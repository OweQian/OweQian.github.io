<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode-005-有效的括号</title>
      <link href="/2020/05/08/leetcode/leetcode-005-you-xiao-de-gua-hao/"/>
      <url>/2020/05/08/leetcode/leetcode-005-you-xiao-de-gua-hao/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组、栈</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="external">https://leetcode-cn.com/problems/valid-parentheses/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例 1:输入: &quot;()&quot;输出: true示例 2:输入: &quot;()[]{}&quot;输出: true示例 3:输入: &quot;(]&quot;输出: false示例 4:输入: &quot;([)]&quot;输出: false示例 5:输入: &quot;{[]}&quot;输出: true</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-栈"><a href="#解法-栈" class="headerlink" title="解法 - 栈"></a>解法 - 栈</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {string} s * @return {boolean} */</span><span class="token keyword">var</span> isValid <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> mapper <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">'('</span><span class="token punctuation">:</span> <span class="token string">')'</span><span class="token punctuation">,</span>        <span class="token string">'{'</span><span class="token punctuation">:</span> <span class="token string">'}'</span><span class="token punctuation">,</span>        <span class="token string">'['</span><span class="token punctuation">:</span> <span class="token string">']'</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> peak <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">!==</span> mapper<span class="token punctuation">[</span>peak<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>&quot;()[]{}&quot;</code></pre><p>输出：</p><pre><code>true</code></pre><p>预期结果：</p><pre><code>true</code></pre><ul><li>解题思路：</li></ul><p>使用栈，遍历输入字符串</p><p>如果当前字符为左半边括号时，则将其压入栈中</p><p>如果遇到右半边括号时，分类讨论：</p><p>1）如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环</p><p>2）若此时栈为空，则直接返回 false</p><p>3）若不为对应的左半边括号，反之返回 false</p><p><img src="https://github.com/azl397985856/leetcode/raw/master/assets/20.validParentheses.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS设计模式-构造器模式</title>
      <link href="/2020/05/01/she-ji-mo-shi/gou-zao-qi-mo-shi/"/>
      <url>/2020/05/01/she-ji-mo-shi/gou-zao-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>使用构造函数初始化对象，抽象了每个实例的变与不变。</p></blockquote><a id="more"></a><p>设计模式的核心操作是去观察你整个逻辑里面的变与不变，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。</p><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：公司员工信息录入系统，每个员工有姓名、年龄、工种，大约有500名员工。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>创建一个 User 构造函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token punctuation">,</span> age<span class="token punctuation">,</span> career<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age    <span class="token keyword">this</span><span class="token punctuation">.</span>career <span class="token operator">=</span> career <span class="token punctuation">}</span></code></pre><p>接下来要做的事情，就是让程序自动地去读取数据库里面一行行的员工信息，然后把拿到的姓名、年龄等字段塞进User函数里，进行一个简单的调用：</p><pre><code>const user = new User(name, age, career)</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在创建一个user过程中，谁变了，谁不变？</p><p>很明显，变的是每个user的姓名、年龄、工种这些值，这是用户的个性，不变的是每个员工都具备姓名、年龄、工种这些属性，这是用户的共性。</p><p>那么构造器做了什么？</p><p>构造器是不是将 name、age、career 赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了共性的不变，同时将 name、age、career 各自的取值操作开放，确保了个性的灵活？</p><p>在使用构造器模式的时候，我们本质上是去抽象了每个对象实例的变与不变。</p><p>参考：</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS设计模式-中介者模式</title>
      <link href="/2020/04/15/she-ji-mo-shi/zhong-jie-zhe-mo-shi/"/>
      <url>/2020/04/15/she-ji-mo-shi/zhong-jie-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>通过一个中介者对象，其它所有相关对象都通过该中介者对象来通信，而不是相互引用，当其中一个对象发生变化时，只需要通知中介者对象即可。通过中介者模式可以解除对象之间的紧耦合关系。</p></blockquote><a id="more"></a><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>先通过一张 loading 图占位，然后通过异步的方式去加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> goods <span class="token operator">=</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//手机库存</span>    <span class="token string">'red|32G'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    <span class="token string">'red|64G'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">'blue|32G'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span>    <span class="token string">'blue|32G'</span><span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//中介者</span><span class="token keyword">const</span> mediator <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> colorSelect <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'colorSelect'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> memorySelect <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'memorySelect'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> numSelect <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'numSelect'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        changed<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">switch</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">case</span> colorSelect<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">//TODO</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> memorySelect<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">//TODO</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> numSelect<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">//TODO</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>colorSelect<span class="token punctuation">.</span>onchange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mediator<span class="token punctuation">.</span><span class="token function">changed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>memorySelect<span class="token punctuation">.</span>onchange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mediator<span class="token punctuation">.</span><span class="token function">changed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>numSelect<span class="token punctuation">.</span>onchange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mediator<span class="token punctuation">.</span><span class="token function">changed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>参考：</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS设计模式-策略模式</title>
      <link href="/2020/04/15/she-ji-mo-shi/ce-lue-mo-shi/"/>
      <url>/2020/04/15/she-ji-mo-shi/ce-lue-mo-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>定义一系列算法，将它们一个个封装起来，并使它们可以相互替换。</p></blockquote><a id="more"></a><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放。例如：绩效为 S 的人年终奖有 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，绩效为 B 的人年终奖有 2 倍工资。假设财务要求我们提供一段代码，来方便他们计算员工的年终奖。</p><h2 id="最初代码实现"><a href="#最初代码实现" class="headerlink" title="最初代码实现"></a>最初代码实现</h2><p>我们可以编写一个 calculateBonus 函数来计算每个人的奖金额数，函数需要接受两个参数：员工的工资数额和他的绩效考核等级。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> calculateBonus <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>performanceLevel<span class="token punctuation">,</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以发现，这段代码十分简单，但存在显而易见的缺点。</p><ul><li><p>函数体庞大，包含很多if-else语句</p></li><li><p>缺乏弹性，如果新增等级 C，要修改函数内部实现</p></li><li><p>复用性差</p></li></ul><h2 id="组合函数实现"><a href="#组合函数实现" class="headerlink" title="组合函数实现"></a>组合函数实现</h2><p>一般我们最容易想到就是使用组合函数来重构代码，把各种算法封装到一个小小的函数里。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> performanceS <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> performanceA <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> performanceB <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> calculateBonus <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>performanceLevel<span class="token punctuation">,</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">performanceS</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">performanceS</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">performanceS</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>目前，我们的程序得到了一定的改善，但这种改善非常有限，我们依然没有解决最重要的问题：calculateBonus函数有可能越来越庞大，而且在系统变化的时候缺乏弹性。</p><h2 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h2><p>策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。</p><p>一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context,Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> strategies <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'S'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> calculateBonus <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>performanceLevel<span class="token punctuation">,</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> strategies<span class="token punctuation">[</span>performanceLevel<span class="token punctuation">]</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>参考：</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS设计模式-代理模式</title>
      <link href="/2020/04/15/she-ji-mo-shi/dai-li-mo-shi/"/>
      <url>/2020/04/15/she-ji-mo-shi/dai-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>为一个对象提供一个代用品或占位符，以便控制对它的访问。</p></blockquote><a id="more"></a><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：虚拟代理实现图片懒加载</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>先通过一张 loading 图占位，然后通过异步的方式去加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> imgFunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> imgNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>imgNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        setSrc<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>            imgNode<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> proxyImg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       imgFunc<span class="token punctuation">.</span><span class="token function">setSrc</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        setSrc<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>            imgFunc<span class="token punctuation">.</span><span class="token function">setSrc</span><span class="token punctuation">(</span><span class="token string">'./loading.gif'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            img<span class="token punctuation">.</span>src <span class="token operator">=</span> src          <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxyImg<span class="token punctuation">.</span><span class="token function">setSrc</span><span class="token punctuation">(</span><span class="token string">'./pic.pmg'</span><span class="token punctuation">)</span></code></pre><p>使用代理模式实现图片懒加载的优点还有符合单一职责原则。减少一个类或方法的粒度和耦合度。</p><p>参考：</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-栈</title>
      <link href="/2020/04/14/shu-ju-jie-gou/shu-ju-jie-gou-zhan/"/>
      <url>/2020/04/14/shu-ju-jie-gou/shu-ju-jie-gou-zhan/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p></blockquote><a id="more"></a><h1 id="基于数组的栈"><a href="#基于数组的栈" class="headerlink" title="基于数组的栈"></a>基于数组的栈</h1><p>我们将创建一个类来表示栈，需要一种数据结构来保存栈里的元素。可以选择数组。数组允许我们在任何位置添加或删除元素。由于栈遵循LIFO原则，需要对元素的插入和删除功能进行限制。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新增元素到栈顶</span>    <span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 移除栈顶元素,同时返回被移除的元素</span>    <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈顶元素</span>    <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 是否为空栈</span>    <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈里的元素个数</span>    <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 清空栈元素</span>    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>创建一个 Stack 类最简单的方式是使用一个数组来存储其元素。在处理大量数据的时候，我们同样需要评估如何操作数据是最高效的。在使用数组时，大部分方法的时间复杂度是O(n)。</p><h1 id="基于对象的栈"><a href="#基于对象的栈" class="headerlink" title="基于对象的栈"></a>基于对象的栈</h1><p>我们将创建一个基于对象来存储栈里的元素的类来表示栈，这里新增一个 count 来表示栈的元素个数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新增元素到栈顶</span>    <span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 移除栈顶元素,同时返回被移除的元素</span>    <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 首先判断是否为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> undefined        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈顶元素</span>    <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> undefined<span class="token punctuation">;</span>        <span class="token punctuation">}</span>           <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 是否为空栈</span>    <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈里的元素个数</span>    <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 清空栈元素</span>    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS设计模式-单例模式</title>
      <link href="/2020/04/14/she-ji-mo-shi/dan-li-mo-shi/"/>
      <url>/2020/04/14/she-ji-mo-shi/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>保证一个类只有一个实例，并提供一个访问它的全局访问点。</p></blockquote><a id="more"></a><h1 id="单例模式的实现思路"><a href="#单例模式的实现思路" class="headerlink" title="单例模式的实现思路"></a>单例模式的实现思路</h1><p>思考：如何才能保证一个类仅有一个实例？</p><p>通常，当我们创建一个类后，可以通过 new 关键字调用构造函数进而生成任意的实例。</p><pre><code>class SingleObj {    show() {        console.log(&#39;我是一个单例对象&#39;)    }}const s1 = new SingleObj()const s2 = new SingleObj()// falseconsole.log(s1 === s2)</code></pre><p>new 一个 s1，new 一个 s2，很明显 s1 和 s2 之间没有任何联系，而单例模式想要做到的是，无论实例化多少次，只返回第一次创建的那个唯一的实例。</p><p>要做到这一点，就需要构造函数具备判断自己是否已经创建过一个实例的能力。</p><ul><li>写一个静态方法判断逻辑</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">SingleObj</span> <span class="token punctuation">{</span>    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是一个单例对象'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断是否已经new过1个实例</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>SingleObj<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 若这个唯一的实例不存在，那么先创建它</span>            SingleObj<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果这个唯一的实例已经存在，则直接返回</span>        <span class="token keyword">return</span> SingleObj<span class="token punctuation">.</span>instance    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> s1 <span class="token operator">=</span> SingleObj<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> s2 <span class="token operator">=</span> SingleObj<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// true</span>s1 <span class="token operator">===</span> s2</code></pre><ul><li>闭包</li></ul><pre class=" language-javascript"><code class="language-javascript">SingleObj<span class="token punctuation">.</span>getInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>可以看出，在 getInstance 方法的判断和拦截下，我们不管调用多少次，SingleObj 都只会给我们返回一个实例，s1 和 s2 现在都指向这个唯一的实例。</p><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><pre><code>实现 Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。</code></pre><p>思路：</p><p>考察单例模式的实现思路，只实例化一次。</p><ul><li>静态方法版</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Storage</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Storage<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Storage<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Storage<span class="token punctuation">.</span>instance      <span class="token punctuation">}</span>    getItem <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    setItem <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>闭包版</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">StorageBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>StorageBase<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getItem <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">}</span>StorageBase<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>setItem <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">const</span> Storage <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StorageBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>实现一个全局唯一的Modal弹框</code></pre><p>万变不离其踪，依然考察单例模式。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;单例模式弹框&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    #modal {        height: 200px;        width: 200px;        line-height: 200px;        position: fixed;        left: 50%;        top: 50%;        transform: translate(-50%, -50%);        border: 1px solid black;        text-align: center;    }&lt;/style&gt;&lt;body&gt;    &lt;button id=&#39;open&#39;&gt;打开弹框&lt;/button&gt;    &lt;button id=&#39;close&#39;&gt;关闭弹框&lt;/button&gt;&lt;/body&gt;&lt;script&gt;    // 核心逻辑，这里采用了闭包思路来实现单例模式    const Modal = (function() {        let modal = null        return function() {            if(!modal) {                modal = document.createElement(&#39;div&#39;)                modal.innerHTML = &#39;我是一个全局唯一的Modal&#39;                modal.style.display = &#39;none&#39;                document.body.appendChild(modal)            }            return modal        }    })()    // 点击打开按钮展示模态框    document.getElementById(&#39;open&#39;).addEventListener(&#39;click&#39;, function() {        // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理        const modal = new Modal()        modal.style.display = &#39;block&#39;    })    // 点击关闭按钮隐藏模态框    document.getElementById(&#39;close&#39;).addEventListener(&#39;click&#39;, function() {        const modal = new Modal()        if(modal) {            modal.style.display = &#39;none&#39;        }    })&lt;/script&gt;&lt;/html&gt;</code></pre><p>参考：</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-01-替换字符串</title>
      <link href="/2020/04/10/jian-zhi-offer/jian-zhi-offer-01-ti-huan-zi-fu-chuan/"/>
      <url>/2020/04/10/jian-zhi-offer/jian-zhi-offer-01-ti-huan-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 剑指offer 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：正则表达式、数组遍历</p></li><li><p>题目内容：</p></li></ul><pre><code>请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。例如输入“We are happy.”，则输出“We%20are%20happy.”。</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-正则表达式"><a href="#解法-正则表达式" class="headerlink" title="解法 - 正则表达式"></a>解法 - 正则表达式</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {String} str */</span><span class="token keyword">function</span> <span class="token function">replaceEmpty</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/ /g</span><span class="token punctuation">,</span> <span class="token string">'%20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>replaceEmpty(&#39;we are family&#39;)</code></pre><p>输出：</p><pre><code>&quot;we%20are%20family&quot;</code></pre><p>预期结果：</p><pre><code>&quot;we%20are%20family&quot;</code></pre><ul><li>解题思路：</li></ul><p>直接使用正则表达式全局替换</p><p>String.prototype.replace: 返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者是一个正则表达式，替换值可以是一个字符串或者是一个每次匹配都要调用的回调函数。</p><pre><code>str.replace(regexp|substr, newSubStr|function)</code></pre><ul><li>regexp (pattern)</li></ul><p>一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。</p><ul><li>substr (pattern)</li></ul><p>一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。</p><ul><li>newSubStr (replacement)</li></ul><p>用于替换掉第一个参数在原字符串中的匹配部分的字符串。</p><ul><li>function (replacement)</li></ul><p>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。</p><p>返回值：</p><p>一个部分或全部匹配由替代模式所取代的新的字符串。</p><p>描述：</p><p>该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。</p><p>在进行全局的搜索替换时，正则表达式需包含 g 标志。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-004-罗马数字转整数</title>
      <link href="/2020/04/10/leetcode/leetcode-004-luo-ma-shu-zi-zhuan-zheng-shu/"/>
      <url>/2020/04/10/leetcode/leetcode-004-luo-ma-shu-zi-zhuan-zheng-shu/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组、数学</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="external">https://leetcode-cn.com/problems/roman-to-integer/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符          数值I             1V             5X             10L             50C             100D             500M             1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-转字符串、数组遍历，区分正常情况与特殊情况"><a href="#解法-转字符串、数组遍历，区分正常情况与特殊情况" class="headerlink" title="解法 - 转字符串、数组遍历，区分正常情况与特殊情况"></a>解法 - 转字符串、数组遍历，区分正常情况与特殊情况</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {string} s * @return {number} */</span><span class="token keyword">var</span> romanToInt <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/**       * 特殊情况       * IV === 4       * IX === 9       * XL === 40       * XC === 90       * CD === 400       * CM === 900       * 正常情况       * I === 1       * V === 5       * X === 10       * L === 50       * C === 100       * D === 500       * M === 1000       */</span>    <span class="token keyword">let</span> arr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">9</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">40</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">90</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">400</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">900</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">5</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">50</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">100</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">500</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1000</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>MCMXCIV</code></pre><p>输出：</p><pre><code>1994</code></pre><p>预期结果：</p><pre><code>1994</code></pre><ul><li><p>解题思路：转换为字符串、数组</p></li><li><p>split(): 字符串分割为数组</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-原型原型链</title>
      <link href="/2020/04/03/javascript/javascript-yuan-xing-yuan-xing-lian/"/>
      <url>/2020/04/03/javascript/javascript-yuan-xing-yuan-xing-lian/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>JavaScript 中的 原型和原型链是面试中常考的点，本文旨在分析原型和原型链是什么。</p></blockquote><a id="more"></a>           <hr><h1 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h1><p>JavaScript 通过 new 一个构造函数生成一个对象实例，但是每个对象实例的属性和方法并不是共享的，为了各个对象实例可以共享一些属性和方法，要设计一个对象专门用来存储对象共享的属性，那么我们叫它「原型对象」。</p><p>在 JS 所有对象中，只要是对象，都会有一个内置属性叫做<em>proto</em>，而且这个属性是系统自动生成的，只要你创建一个对象，这个对象就有这个属性。这个<em>proto</em>属性指向的是原型对象。</p><p>构造函数的 prototype 属性指向原型对象，原型对象的 constructor 属性指回构造函数。</p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>每个对象都一个 <strong>proto</strong> 指向原型对象，原型对象也有一个 <strong>proto</strong> 指向它的原型对象，直到原型链的顶端 null。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/24/16dfb64428ee0ce4?imageslim" alt=""></p><p>总结：</p><ul><li>所有的实例的 <strong>proto</strong> 都指向该构造函数的原型对象（prototype）。</li><li>所有的函数（包括构造函数）是 Function() 的实例，所以所有函数的 <strong>proto</strong> 的都指向 Function() 的原型对象。</li><li>所有的原型对象（包括 Function 的原型对象）都是 Object 的实例，所以 <strong>proto</strong> 都指向 Object （构造函数）的原型对象。而 Object 构造函数的 <strong>proto</strong>  指向 null。</li><li>Function 构造函数本身就是 Function 的实例，所以 <strong>proto</strong> 指向 Function 的原型对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/04/02/http/tcp-si-ci-hui-shou/"/>
      <url>/2020/04/02/http/tcp-si-ci-hui-shou/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP-三次握手</title>
      <link href="/2020/04/01/http/tcp-san-ci-wo-shou/"/>
      <url>/2020/04/01/http/tcp-san-ci-wo-shou/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>建立 TCP 连接前，客户端和服务端需要通过三次握手来确认对方的接受和传送能力是否正常</p></blockquote><a id="more"></a>           <hr><p>客户端向服务器发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，确保双方的接收和发送能力正常。</p><p>起始状态：客户端处于 closed 状态，服务端处于 listen 状态。</p><p>第一次握手：客户端给服务端发送一个 SYN 报文，并指明自己的初始化序列号（ISN） Seq = X，此时客户端处于 SYN_Send 状态。</p><p>第二次握手：服务端收到客户端的 SYN 报文后，会以自己的 SYN 报文作为应答，并且也指定了自己的初始化序列号（ISN） Seq = Y，同时会把客户端的 Seq X + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。</p><p>第三次握手：客户端回传一个 Seq Y + 1 作为 ACK 的值，Seq = Z 的数据包，代表握手结束，此时客户端处于 established 状态。</p><p>服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立起了连接。</p><p>（SYN：代表 TCP 连接 Seq：序列号 ACK：确认号）</p><p><img src="https://segmentfault.com/img/remote/1460000017184707" alt=""></p><h4 id="为什么需要3次握手"><a href="#为什么需要3次握手" class="headerlink" title="为什么需要3次握手"></a>为什么需要3次握手</h4><p>为了防止已经失效的连接请求报文突然又传送到了服务器，因为产生错误。</p><h4 id="ISN-是固定的吗"><a href="#ISN-是固定的吗" class="headerlink" title="ISN 是固定的吗"></a>ISN 是固定的吗</h4><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p><h4 id="什么是半连接队列"><a href="#什么是半连接队列" class="headerlink" title="什么是半连接队列"></a>什么是半连接队列</h4><p>服务器第一次收到客户端的 SYN 之后，此时会处于 SYN_RCVD 状态，此时双方还没有建立起连接，服务器会把这种状态的请求连接放在一个队列里，这种队列称为半连接队列。</p><p>服务器与客户端三次握手完成建立起的连接会放在全连接队列里。</p><p>如果队列满了，就可能会出现丢包现象。</p><pre><code>这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ....</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-基础之this</title>
      <link href="/2020/03/17/liu-lan-qi/browser-liu-lan-qi-xuan-ran-yuan-li/"/>
      <url>/2020/03/17/liu-lan-qi/browser-liu-lan-qi-xuan-ran-yuan-li/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列旨在总结浏览器相关知识，本篇围绕浏览器渲染原理展开。</p></blockquote><a id="more"></a>           <hr><h1 id="浏览器的主要组成部分"><a href="#浏览器的主要组成部分" class="headerlink" title="浏览器的主要组成部分"></a>浏览器的主要组成部分</h1><p>讲解浏览器渲染之前，先主要了解浏览器有哪些组成部分。</p><ul><li><p>用户界面：包括地址栏、前进/后退按钮，书签菜单等。</p></li><li><p>浏览器引擎：在用户界面和渲染引擎之间传送指令。</p></li><li><p>渲染引擎：负责显示请求的内容。如：解析 HTML 和 CSS，并将解析后的内容显示在屏幕上。</p></li><li><p>网络：用于网络调用，比如 HTTP 请求。</p></li><li><p>用户界面后端：用于绘制基本的窗口小部件，如组合框和窗口等。</p></li><li><p>JS 解释器：用于解析和执行 JS 代码。</p></li><li><p>数据存储：这是持久层，用于浏览器在硬盘上保存各种数据。</p></li></ul><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=531622336,2916455443&amp;fm=26&amp;gp=0.jpg" alt=""></p><h1 id="常见的浏览器内核"><a href="#常见的浏览器内核" class="headerlink" title="常见的浏览器内核"></a>常见的浏览器内核</h1><table><thead><tr><th>浏览器</th><th>内核（渲染引擎）</th><th>JS 引擎</th></tr></thead><tbody><tr><td>Chrome</td><td>Blink（28~）<br> Webkit</td><td>V8</td></tr><tr><td>Safari</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>FireFox</td><td>Gecko</td><td>SpiderMonkey</td></tr><tr><td>Edge</td><td>EdgeHTML</td><td>Chakra</td></tr><tr><td>IE</td><td>Trident</td><td>Chakra</td></tr></tbody></table><h1 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h1><p>DOM（Document Object Model 文档对象模型），是对 HTML 文档结构化的表述，允许程序和脚本动态的访问和更新文档的内容、结构和样式。服务器返回给浏览器渲染引擎的HTML的文件字节流是无法直接被浏览器渲染引擎理解的，要转化为浏览器渲染引擎可以理解的内部结构，这个结构就是 DOM。</p><h1 id="浏览器接受-HTML-文件并转换为-DOM-树"><a href="#浏览器接受-HTML-文件并转换为-DOM-树" class="headerlink" title="浏览器接受 HTML 文件并转换为 DOM 树"></a>浏览器接受 HTML 文件并转换为 DOM 树</h1><p>从服务器返回给浏览器渲染引擎的 HTML 文件字节流，第一步要经过渲染引擎中的 HTML 解析器。它实现了将 HTML 字节流转换为 DOM 树结构。HTML 文件字节流返回的过程中，HTML 解析器就一直在解析（边加载边解析）。</p><p>阶段一：在网络中传输的内容都是 0 和 1 这些字节数据，当浏览器接收到这些字节数据后，会将这些字节数据转换为字符串，就是我们平时写的代码。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754281e59587f3?imageslim" alt=""></p><p>阶段二：当数据转换为字符串后，浏览器会先将这些字符串通过分词器转化为 Token(标记)，Token 分为 Tag Token 和文本 TOken。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754288f37a5347?imageslim" alt=""></p><p>标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167540a7b5cef612?imageslim" alt=""></p><p>阶段三：将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。</p><p>HTML 解析器维护了一个 Token 栈，这个栈的目的就是用来计算节点间的父子关系，再上一个阶段生成的 Token 会被顺序压到这个栈中。</p><ul><li><p>HTML 解析器开始工作时，会默认创建一个根为 document 的空 DOM 结构，同时将一个 StartTag document 的 Token 压入栈底。</p></li><li><p>如果压入到栈中的是 StartTagToken，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将这个 DOM 节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的 DOM 节点。</p></li><li><p>如果是文本 Token，那么会生成一个文本节点，然后把这个文本 Dom 节点加入到 DOM 树中（注:文本Token不需入栈），它的 父节点就是当前栈顶 Token 所对应的 DOM 节点。</p></li><li><p>如果分词器解析出来的是 EndTag 标签，比如例子中的 EndTag div，HTML 解析器会查看 Token栈顶的元素是否是 StartTag div，如果是，就将 StartTag div从栈中弹出，边上该 div 元素解析完成。</p></li><li><p>最后按照上面的规则，分词器一路解析下来，就形成了这个简单的 DOM 树。</p></li></ul><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/6ccc9594a0dc0a616804780992d4298d.png" alt=""></p><h1 id="浏览器接受-CSS-文件并转换为-CSSOM-树"><a href="#浏览器接受-CSS-文件并转换为-CSSOM-树" class="headerlink" title="浏览器接受 CSS 文件并转换为 CSSOM 树"></a>浏览器接受 CSS 文件并转换为 CSSOM 树</h1><p>转换 CSS 到 CSSOM 树的过程和上一小节的过程极其相似。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f?imageslim" alt=""></p><h2 id="浏览器如何解析-CSS-选择器"><a href="#浏览器如何解析-CSS-选择器" class="headerlink" title="浏览器如何解析 CSS 选择器"></a>浏览器如何解析 CSS 选择器</h2><p>浏览器会【从右向左】解析 CSS 选择器。</p><p>以下段 CSS 为例：</p><pre><code>.mode-nav h3 span {font-size: 16px;}</code></pre><p>我们对应的DOM Tree如下：</p><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/4fe91032bd748f2509e0f0da3e56dcc1.png" alt=""></p><p>若从左向右匹配：过程是：</p><ol><li><p>从 .mod-nav 开始，遍历子节点 header 和子节点 div</p></li><li><p>然后各自向子节点遍历。在右侧 div 的分支中</p></li><li><p>最后遍历到叶子节点 a ，发现不符合规则，需要回溯到 ul 节点，再遍历下一个 li-a，一颗DOM树的节点动不动上千，这种效率很低</p></li></ol><p>若从右向左匹配：</p><ol><li><p>先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3</p></li><li><p>由 h3再向上寻找 class=mod-nav 的节点</p></li><li><p>最后找到根元素 html 则结束这个分支的遍历</p></li></ol><p>后者匹配性能更好，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）；而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack-简介</title>
      <link href="/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-jian-jie/"/>
      <url>/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-jian-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="Webpack-简介"><a href="#Webpack-简介" class="headerlink" title="Webpack 简介"></a>Webpack 简介</h1><h2 id="Webpack是什么"><a href="#Webpack是什么" class="headerlink" title="Webpack是什么"></a>Webpack是什么</h2><p>Webpack是一个开源的JavaScript模块打包工具，其最核心的功能是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个JS文件（有时会有多个，这里讨论的只是最基本的情况）。</p><h2 id="模块打包工具"><a href="#模块打包工具" class="headerlink" title="模块打包工具"></a>模块打包工具</h2><p>模块打包工具（module bundler）的任务就是解决模块间的依赖，使其打包后的结果能运行在浏览器上。它的工作方式主要分为两种</p><ul><li><p>将存在依赖关系的模块按照特定规则合并为单个JS文件，一次全部加载进页面中。</p></li><li><p>在页面初始时加载一个入口模块，其他模块异步地进行加载。</p></li></ul><h2 id="Webpack-优势"><a href="#Webpack-优势" class="headerlink" title="Webpack 优势"></a>Webpack 优势</h2><ul><li><p>默认支持多种模块标准，包括AMD、CommonJS，以及最新的ES6模块。</p></li><li><p>完备的代码分割（code splitting）解决方案，首屏只加载重要的部分。</p></li><li><p>可以处理各种类型的资源。除了JavaScript以外，Webpack还可以处理样式、模板，甚至图片等。</p></li><li><p>拥有庞大的社区支持。</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用npm或者yarn来安装webpack</p><hr><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><pre><code>$ npm i webpack webpack-cli -gor$ yarn -g add webpack webpack-cli</code></pre><p>等待安装完毕，就可以全局执行webpack命令了。注：webpack-cli在4.x版本之后不再作为webpack的依赖了，我们使用时需要单独安装。</p><hr><h3 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h3><p>在项目中，我们更推荐将webpack作为项目的开发依赖来安装使用，这样可以指定项目中使用的webpack版本。</p><pre><code>$ npm i webpack webpack-cli -Dor$ yarn add webpack webpack-cli -D</code></pre><p>等待安装完毕，webpack会出现在项目的package.json文件中，我们添加一个npm scripts:</p><pre><code>  &quot;scripts&quot;: {    &quot;build&quot;: &quot;webpack --mode production&quot;  },  &quot;devDependencies&quot;: {    &quot;webpack&quot;: &quot;^4.1.1&quot;,    &quot;webpack-cli&quot;: &quot;^2.0.12&quot;,  }</code></pre><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack-dev-server可以看作一个服务者，它的主要工作就是接收浏览器的请求，然后将资源返回。当服务启动时，会先让Webpack进行模块打包并将资源准备好（在示例中就是bundle.js）。当webpack-dev-server接收到浏览器的资源请求时，它会首先进行URL地址校验。如果该地址是资源服务地址（上面配置的publicPath），就会从Webpack的打包结果中寻找该资源并返回给浏览器。反之，如果请求地址不属于资源服务地址，则直接读取硬盘中的源文件并将其返回。</p><pre class=" language-javascript"><code class="language-javascript">$ npm i webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server <span class="token operator">-</span>D</code></pre><p>为了便捷地启动webpack-dev-server，我们在package.json中添加一个dev指令：</p><pre class=" language-json"><code class="language-json"><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"webpack"</span><span class="token punctuation">,</span>  <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"webpack-dev-server"</span><span class="token punctuation">}</span></code></pre><p>最后，我们还需要对webpack-dev-server进行配置。编辑webpack.config.js如下：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">"./src/index.js"</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">"./bundle.js"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">"development"</span><span class="token punctuation">,</span>    devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>        publicPath<span class="token punctuation">:</span> <span class="token string">"/dist"</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p>这里有一点需要注意。直接用Webpack开发和使用webpack-dev-server有一个很大的区别，前者每次都会生成budnle.js，而webpack-dev-server只是将打包结果放在内存中，并不会写入实际的bundle.js，在每次webpack-dev-server接收到请求时都只是将内存中的打包结果返回给浏览器。</p><p>webpack-dev-server还有一项很便捷的特性就是live-reloading（自动刷新）。</p><p>注：关于内容自动更新，webpack-dev-server 与 hot-module-replacement（模块热替换）的区别在于：前者会刷新浏览器，后者不需要刷新浏览器就能获得更新之后的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack-资源输入输出</title>
      <link href="/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-zi-yuan-shu-ru-shu-chu/"/>
      <url>/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-zi-yuan-shu-ru-shu-chu/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="资源输入输出"><a href="#资源输入输出" class="headerlink" title="资源输入输出"></a>资源输入输出</h1><h2 id="资源处理流程"><a href="#资源处理流程" class="headerlink" title="资源处理流程"></a>资源处理流程</h2><p>在一切流程的最开始，我们需要指定一个或多个入口（entry），也就是告诉Webpack具体从源码目录下的哪个文件开始打包。如果把工程中各个模块的依赖关系当作一棵树，那么入口就是这棵依赖树的根，这些存在依赖关系的模块会在打包时被封装为一个chunk。</p><p>chunk字面的意思是代码块，在Webpack中可以理解成被抽象和包装过后的一些模块。它就像一个装着很多文件的文件袋，里面的文件就是各个模块，Webpack在外面加了一层包裹，从而形成了chunk。根据具体配置不同，一个工程打包时可能会产生一个或多个chunk。</p><p>Webpack会从入口文件开始检索，并将具有依赖关系的模块生成一棵依赖树，最终得到一个chunk。由这个chunk得到的打包产物我们一般称之为bundle。</p><h2 id="配置资源入口"><a href="#配置资源入口" class="headerlink" title="配置资源入口"></a>配置资源入口</h2><p>通过context和entry这两个配置项来共同决定入口文件的路径。在配置入口时，实际上做了两件事：</p><ul><li><p>确定入口模块位置，告诉Webpack从哪里开始进行打包。</p></li><li><p>定义chunk name。如果工程只有一个入口，那么默认其chunk name为“main”；如果工程有多个入口，我们需要为每个入口定义chunk name，来作为该chunk的唯一标识。</p></li></ul><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>context可以理解为资源入口的路径前缀，在配置时要求必须使用绝对路径的形式。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    context<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./src/script'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    entry<span class="token punctuation">:</span> <span class="token string">'./index.js'</span><span class="token punctuation">}</span></code></pre><p>配置context的主要目的是让entry的编写更加简洁，尤其是在多入口的情况下。context可以省略，默认值为当前工程的根目录。</p><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>entry的配置可以有多种形式：字符串、数组、对象、函数。可以根据不同的需求场景来选择。</p><ul><li>字符串类型入口</li></ul><p>直接传入文件路径：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token string">'./src/index'</span><span class="token punctuation">}</span></code></pre><ul><li>数组类型入口</li></ul><p>传入一个数组的作用是将多个资源预先合并，在打包时Webpack会将数组中的最后一个元素作为实际的入口路径。如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'babel-polyfill'</span><span class="token punctuation">,</span> <span class="token string">'./src/index'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ul><li>对象类型入口</li></ul><p>如果想要定义多入口，则必须使用对象的形式。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>    foo<span class="token punctuation">:</span> <span class="token string">'./src/foo'</span><span class="token punctuation">,</span>    bar<span class="token punctuation">:</span> <span class="token string">'./src/bar'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>函数类型入口</li></ul><p>用函数定义入口时，只要返回上面介绍的任何配置形式即可。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>                    foo<span class="token punctuation">:</span> <span class="token string">'./src/foo'</span><span class="token punctuation">,</span>                    bar<span class="token punctuation">:</span> <span class="token string">'./src/bar'</span>                  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>所有与出口相关的配置都集中在output对象里。</p><h4 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h4><p>filename的作用是控制输出资源的文件名。</p><ul><li>字符串形式</li></ul><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>在多入口的场景中，我们需要为对应产生的每个bundle指定不同的名字，Webpack支持使用一种类似模板语言的形式动态地生成文件名。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 多个入口生成不同的文件</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>路径中使用hash，每次构建都有一个不同的hash值，避免发布新版本使用浏览器缓存。</li></ul><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist/[hash]'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>path可以指定资源输出的位置，要求值必须为绝对路径。如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><p>publicPath是一个非常重要的配置项，并且容易与path相混淆。从功能上来说，path用来指定资源的输出位置，而publicPath则用来指定资源的请求位置。让我们详细解释这两个定义。</p><ul><li><p>输出位置：打包完成后资源产生的目录，一般将其指定为工程中的dist目录。</p></li><li><p>请求位置：由JS或CSS所请求的间接资源路径。页面中的资源分为两种，一种是由HTML页面直接请求的，比如通过script标签加载的JS；另一种是由JS或CSS请求的，如异步加载的JS、从CSS请求的图片字体等。publicPath的作用就是指定这部分间接资源的请求位置。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack-代码分片</title>
      <link href="/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-dai-ma-fen-pian/"/>
      <url>/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-dai-ma-fen-pian/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="代码分片"><a href="#代码分片" class="headerlink" title="代码分片"></a>代码分片</h1><p>代码分片（code splitting）是Webpack作为打包工具所特有的一项技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用户不必一次全部加载，而是按需加载。</p><p>代码分片可以有效降低首屏加载资源的大小，但同时也会带来新的问题，比如我们应该对哪些模块进行分片、分片后的资源如何管理等，这些也是需要关注的。</p><h2 id="通过入口划分代码"><a href="#通过入口划分代码" class="headerlink" title="通过入口划分代码"></a>通过入口划分代码</h2><p>在Webpack中每个入口（entry）都将生成一个对应的资源文件，通过入口的配置我们可以进行一些简单有效的代码拆分。</p><p>对于Web应用来说通常会有一些库和工具是不常变动的，可以把它们放在一个单独的入口中，由该入口产生的资源不会经常更新，因此可以有效地利用客户端缓存，让用户不必在每次请求页面时都重新加载。如：</p><pre><code>// webpack.config.jsentry: {   app: &#39;./app.js&#39;,   lib: [&#39;lib-a&#39;, &#39;lib-b&#39;, &#39;lib-c&#39;]}// index.html&lt;script src=&quot;dist/lib.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;dist/app.js&quot;&gt;&lt;/script&gt;</code></pre><p>这种拆分方法主要适合于那些将接口绑定在全局对象上的库，因为业务代码中的模块无法直接引用库中的模块，二者属于不同的依赖树。</p><h2 id="CommonsChunkPlugin"><a href="#CommonsChunkPlugin" class="headerlink" title="CommonsChunkPlugin"></a>CommonsChunkPlugin</h2><p>CommonsChunkPlugin是Webpack 4之前内部自带的插件（Webpack 4之后替换为了SplitChunks）。它可以将多个Chunk中公共的部分提取出来。公共模块的提取可以为项目带来几个收益：</p><ul><li><p>开发过程中减少了重复模块打包，可以提升开发速度；</p></li><li><p>减小整体资源体积；</p></li><li><p>合理分片后的代码可以更有效地利用客户端缓存。</p></li></ul><p>更改webpack.config.js，添加CommonsChunkPlugin。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>        foo<span class="token punctuation">:</span> <span class="token string">'./foo.js'</span><span class="token punctuation">,</span>        bar<span class="token punctuation">:</span> <span class="token string">'./bar.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>CommonsChunkOlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'commons'</span><span class="token punctuation">,</span>            filename<span class="token punctuation">:</span> <span class="token string">'commons.js'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ul><li><p>name：用于指定公共chunk的名字。</p></li><li><p>filename：提取后的资源文件名。</p></li></ul><p>最后，记得在页面中添加一个script标签来引入commons.js，并且注意，该JS一定要在其他JS之前引入。</p><h3 id="提取-vendor"><a href="#提取-vendor" class="headerlink" title="提取 vendor"></a>提取 vendor</h3><p>虽然CommonsChunkPlugin主要用于提取多入口之间的公共模块，但这不代表对于单入口的应用就无法使用。我们仍然可以用它来提取第三方类库及业务中不常更新的模块，只需要单独为它们创建一个入口即可。</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        app: &#39;./app.js&#39;,        vendor: [&#39;react&#39;]    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;,            filename: &#39;vendor.js&#39;        })    ]}// app.jsimport React from &#39;react&#39;document.write(&#39;app.js&#39;, React.version)</code></pre><p>为了将react从app.js提取出来，我们在配置中加入了一个入口vendor，并使其只包含react，这样就把react变为了app和vendor这两个chunk所共有的模块</p><h3 id="设置提取范围"><a href="#设置提取范围" class="headerlink" title="设置提取范围"></a>设置提取范围</h3><p>通过CommonsChunkPlugin中的chunks配置项可以规定从哪些入口中提取公共模块。</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        a: &#39;./a.js&#39;,        b: &#39;./b.js&#39;,        c: &#39;./c.js&#39;,    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;common&#39;,            filename: &#39;common.js&#39;,            chunks: [&#39;a&#39;, &#39;b&#39;]        })    ]}</code></pre><p>我们在chunks中配置了a和b，这意味着只会从a.js和b.js中提取公共模块。</p><h3 id="设置提取规则"><a href="#设置提取规则" class="headerlink" title="设置提取规则"></a>设置提取规则</h3><p>CommonsChunkPlugin的默认规则是只要一个模块被两个入口chunk所使用就会被提取出来，比如只要a和b用了react，react就会被提取出来。</p><p>然而现实情况是，有些时候我们不希望所有的公共模块都被提取出来，此时我们可以通过CommonsChunkPlugin的minChunks配置项来设置提取的规则，该配置项非常灵活，支持多种输入形式。</p><ul><li>数字</li></ul><p>minChunks可以接受一个数字，当设置minChunks为n时，只有该模块被n个入口同时引用才会进行提取。另外，这个阈值不会影响通过数组形式入口传入模块的提取。</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        foo: &#39;./foo.js&#39;,        bar: &#39;./bar.js&#39;,        vendor: [&#39;react&#39;],    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;,            filename: &#39;vendor.js&#39;,            minChunks: 3        })    ]}</code></pre><p>我们令foo.js和bar.js共同引用一个util.js。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// foo.js</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token string">'./util'</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'foo.js'</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// foo.js</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token string">'./util'</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'bar.js'</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// util.js</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span></code></pre><p>如果实际打包应该可以发现，由于我们设置minChunks为3，util.js并不会被提取到vendor.js中，然而react并不受这个的影响，仍然会出现在vendor.js中。</p><ul><li>Infinity</li></ul><p>设置为无穷代表提取的阈值无限高，也就是说所有模块都不会被提取。</p><ul><li>函数</li></ul><p>minChunks支持传入一个函数，它可以让我们更细粒度地控制公共模块。Webpack打包过程中的每个模块都会经过这个函数的处理，当函数的返回值是true时进行提取。</p><pre><code>module.exports = {    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;,            filename: &#39;vendor.js&#39;,            minChunks: function(module, count) {              // module.context 模块目录路径              if (module.context &amp;&amp; module.context.include(&#39;node_modules&#39;)) {                return true              }              // module.resource 包含模块名的完整路径              if (module.resource &amp;&amp; module.resource.endsWith(&#39;util.js&#39;)) {                return true              }              // count 为模块被引用的次数              if (count &gt; 5) {                return true              }            }        })    ]}</code></pre><p>借助上面的配置，我们可以分别提取node_modules目录下的模块、名称为util.js的模块，以及被引用5次（不包含5次）以上的模块。</p><h3 id="hash-与-长效缓存"><a href="#hash-与-长效缓存" class="headerlink" title="hash 与 长效缓存"></a>hash 与 长效缓存</h3><p>当我们使用该插件提取公共模块时，提取后的资源内部不仅仅是模块的代码，往往还包含Webpack的运行时（runtime）。Webpack的运行时指的是初始化环境的代码，如创建模块缓存对象、声明模块加载函数等。</p><p>将运行时的代码单独提取出来。请看下面这个例子：</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        app: &#39;./app.js&#39;,        vendor: [&#39;react&#39;],    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;        }),        new webpack.optimize.CommonsChunkOlugin({          name: &#39;manifest&#39;        }),    ]}</code></pre><p>上面的配置中，通过添加了一个name为manifest的CommonsChunkPlugin来提取Webpack的运行时。</p><p>注：manifest的CommonsChunkPlugin必须出现在最后，否则Webpack将无法正常提取模块。</p><h3 id="CommonsChunkPlugin-的不足"><a href="#CommonsChunkPlugin-的不足" class="headerlink" title="CommonsChunkPlugin 的不足"></a>CommonsChunkPlugin 的不足</h3><p>在提取公共模块方面，CommonsChunkPlugin可以满足很多场景的需求，但是它也有一些欠缺的地方。</p><ul><li><p>一个CommonsChunkPlugin只能提取一个vendor，假如我们想提取多个vendor则需要配置多个插件，这会增加很多重复的配置代码。</p></li><li><p>前面我们提到的manifest实际上会使浏览器多加载一个资源，这对于页面渲染速度是不友好的。</p></li><li><p>由于内部设计上的一些缺陷，CommonsChunkPlugin在提取公共模块的时候会破坏掉原有Chunk中模块的依赖关系，导致难以进行更多的优化。</p></li></ul><h2 id="optimization-SplitChunks"><a href="#optimization-SplitChunks" class="headerlink" title="optimization.SplitChunks"></a>optimization.SplitChunks</h2><p>optimization.SplitChunks（简称SplitChunks）是Webpack 4为了改进CommonsChunk-Plugin而重新设计和实现的代码分片特性。</p><p>比如我们前面异步加载的例子，在换成Webpack 4的SplitChunks之后，就可以自动提取出react了。</p><pre><code>module.exports = {    entry: &#39;./foo.js&#39;,    output: {        filename: &#39;foo.js&#39;,        publicPath: &#39;/dist/&#39;    },    mode: &#39;development&#39;,    optimization: {      splitChunks: {        chunks: &#39;all&#39;      }    }}// foo.jsimport React from &#39;react&#39;import(&#39;./bar.js&#39;)document.write(&#39;app.js&#39;, React.version)// bar.jsimport React from &#39;react&#39;document.write(&#39;bar.js&#39;, React.version)</code></pre><p>此处Webpack 4的配置与之前相比有两点不同：</p><ul><li>使用optimization.splitChunks替代了CommonsChunkPlugin，并指定了chunks的值为all，这个配置项的含义是，SplitChunks将会对所有的chunks生效（默认情况下，SplitChunks只对异步chunks生效，并且不需要配置）。</li></ul><p>以下是SplitChunks默认情形下的提取条件：</p><ul><li><p>提取后的chunk可被共享或者来自node_modules目录。</p></li><li><p>提取后的Javascript chunk体积大于30kB（压缩和gzip之前），CSS chunk体积大于50kB。</p></li><li><p>在按需加载过程中，并行请求的资源最大值小于等于5。按需加载指的是，通过动态插入script标签的方式加载脚本。</p></li><li><p>在首次加载时，并行请求的资源数最大值小于等于3。</p></li></ul><h3 id="默认的异步提取"><a href="#默认的异步提取" class="headerlink" title="默认的异步提取"></a>默认的异步提取</h3><p>前面我们对SplitChunks添加了一个chunks：all的配置，这是为了提取foo.js和bar.js的公共模块。实际上SplitChunks不需要配置也能生效，但仅仅针对异步资源。</p><pre><code>module.exports = {    entry: &#39;./foo.js&#39;,    output: {        filename: &#39;foo.js&#39;,        publicPath: &#39;/dist/&#39;    },    mode: &#39;development&#39;}// foo.jsimport(&#39;./bar.js&#39;)document.write(&#39;app.js&#39;, React.version)// bar.jsimport React from &#39;react&#39;document.write(&#39;bar.js&#39;, React.version)</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>为了更好地了解SplitChunks是怎样工作的，我们来看一下它的默认配置。</p><pre><code>        optimization: {       splitChunks: {          chunks: &#39;async&#39;,          minSize: {              javascript: 30000,              style: 50000          },          maxSize: 0,          minChunks: 1,          maxAsyncRequest3: 3,          maxInitialRequests: 2,          automaticNameDelimiter: &#39;~&#39;,          name: true,          cacheGroups: {            vendors: {              test: /[\\/]node_modules[\\/]/            },            default: {              minChunks: 2,              priority: -20,              reuseExistingChunk: true            }          }       }    }</code></pre><ul><li>匹配模式</li></ul><p>通过chunks我们可以配置SplitChunks的工作模式。它有3个可选值，分别为async（默认）、initial和all。async即只提取异步chunk，initial则只对入口chunk生效（如果配置了initial则上面异步的例子将失效），all则是两种模式同时开启。</p><ul><li>匹配条件</li></ul><p>minSize、minChunks、maxAsyncRequests、maxInitialRequests都属于匹配条件。</p><ul><li>命名</li></ul><p>配置项name默认为true，它意味着SplitChunks可以根据cacheGroups和作用范围自动为新生成的chunk命名，并以automaticNameDelimiter分隔。</p><ul><li>cacheGroups</li></ul><p>可以理解成分离chunks时的规则。默认情况下有两种规则——vendors和default。vendors用于提取所有node_modules中符合条件的模块，default则作用于被多次引用的模块。我们可以对这些规则进行增加或者修改，如果想要禁用某种规则，也可以直接将其置为false。当一个模块同时符合多个cacheGroups时，则根据其中的priority配置项确定优先级。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack-预处理器</title>
      <link href="/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yang-shi-chu-li/"/>
      <url>/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yang-shi-chu-li/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h1><h2 id="分离样式文件"><a href="#分离样式文件" class="headerlink" title="分离样式文件"></a>分离样式文件</h2><p>Webpack社区有专门的插件：extract-text-webpack-plugin（适用于Webpack 4之前版本）和mini-css-extract-plugin（适用于Webpack 4及以上版本），它们就是专门用于提取样式到CSS文件的。</p><h3 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h3><pre class=" language-javascript"><code class="language-javascript">npm i extract<span class="token operator">-</span>text<span class="token operator">-</span>webpack<span class="token operator">-</span>plugin</code></pre><p>在 webpack.config.js 中引入：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'bundle.css'</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>内部的fallback属性用于指定当插件无法提取样式时所采用的loader。</p><p>use（extract方法里面的）用于指定在提取样式之前采用哪些loader来预先进行处理。</p><p>除此之外，还要在Webpack的plugins配置中添加该插件，并传入提取后的资源文件名。</p><h3 id="多样式文件处理"><a href="#多样式文件处理" class="headerlink" title="多样式文件处理"></a>多样式文件处理</h3><p>上面我们将bundle.css作为文件名传给了extract-text-webpack-plugin，但当工程有多个入口时就会发生重名问题。就像在前面的章节中我们配置动态的output.filename一样，这里我们也要对插件提取的CSS文件使用类似模板的命名方式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'[name].css'</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>说到mini-css-extract-plugin的特性，最重要的就是它支持按需加载CSS，以前在使用extract-text-webpack-plugin的时候我们是做不到这一点的。</p><p>举个例子，a.js通过import()函数异步加载了b.js，b.js里面加载了style.css，那么style.css最终只能被同步加载（通过HTML的link标签）。但是现在mini-css-extract-plugin会单独打包出一个0.css（假设使用默认配置），这个CSS文件将由a.js通过动态插入link标签的方式加载。</p><p>在配置上mini-css-extract-plugin与extract-text-webpack-plugin有以下几点不同：</p><ul><li><p>loader规则设置的形式不同，并且mini-css-extract-plugin支持配置publicPath，用来指定异步CSS的加载路径。</p></li><li><p>不需要设置fallback。</p></li><li><p>在plugins设置中，除了指定同步加载的CSS资源名（filename），还要指定异步加载的CSS资源名（chunkFilename）</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                loader<span class="token punctuation">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>                options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    publicPath<span class="token punctuation">:</span> <span class="token string">'../'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token string">'css-loader'</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'[name].css'</span><span class="token punctuation">,</span>        chunkFilename<span class="token punctuation">:</span> <span class="token string">'[id].css'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h2 id="样式预处理"><a href="#样式预处理" class="headerlink" title="样式预处理"></a>样式预处理</h2><p>样式预处理指的是在开发中我们经常会使用一些样式预编译语言，如SCSS、Less等，在项目打包过程中再将这些预编译语言转换为CSS。</p><h3 id="Sass-与-Scss"><a href="#Sass-与-Scss" class="headerlink" title="Sass 与 Scss"></a>Sass 与 Scss</h3><p>sass-loader就是将SCSS语法编译为CSS，因此在使用时通常还要搭配css-loader和style-loader。类似于我们装babel-loader时还要安装babel-core，loader本身只是编译核心库与Webpack的连接器，因此这里我们除了sass-loader以外还要安装node-sass，node-sass是真正用来编译SCSS的，而sass-loader只是起到黏合的作用。</p><pre class=" language-javascript"><code class="language-javascript">npm i sass<span class="token operator">-</span>loader node<span class="token operator">-</span>sass</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.scss$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]      }    ]  }}</code></pre><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><pre class=" language-javascript"><code class="language-javascript">npm i less<span class="token operator">-</span>loader less</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.less/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]      }    ]  }}</code></pre><h2 id="PostCss"><a href="#PostCss" class="headerlink" title="PostCss"></a>PostCss</h2><p>PostCSS并不能算是一个CSS的预编译器，它只是一个编译插件的容器。它的工作模式是接收样式源代码并交由编译插件处理，最后输出CSS。</p><h3 id="PostCss-与-Webpack"><a href="#PostCss-与-Webpack" class="headerlink" title="PostCss 与 Webpack"></a>PostCss 与 Webpack</h3><p>使用postcss-loader可以轻松地将PostCSS与Webpack连接起来。使用npm进行安装。</p><pre><code>npm i postcss-loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.css/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;]      }    ]  }}</code></pre><p>postcss-loader可以结合css-loader使用，也可以单独使用，也就是说不配置css-loader也可以达到相同的效果。唯一不同的是，单独使用postcss-loader时不建议使用CSS中的@import语句，否则会产生冗余代码。</p><p>除此之外，PostCSS要求必须有一个单独的配置文件。我们需要在项目的根目录下创建一个postcss.config.js。</p><pre><code>module.exports = {  // ...  module: {}}</code></pre><h3 id="自动前缀"><a href="#自动前缀" class="headerlink" title="自动前缀"></a>自动前缀</h3><p>Autoprefixer是一个样式工具，可以根据caniuse.com上的数据，自动决定是否要为某一特性添加厂商前缀，并且可以由开发者为其指定支持浏览器的范围。</p><pre><code>npm i autoprefixer</code></pre><p>在postcss.config.js中添加autoprefixer。</p><pre><code>const autoprefixer = require(&#39;autoprefixer&#39;)module.exports = {  // ...  plugins: [    autoprefixer({      grid: true,      browsers: [        &#39;&gt; 1%&#39;,        &#39;last 3 versions&#39;,        &#39;android 4.2&#39;,        &#39;ie 8&#39;      ]    })  ]}</code></pre><h3 id="stylelint"><a href="#stylelint" class="headerlink" title="stylelint"></a>stylelint</h3><p>stylelint是一个CSS的质量检测工具，就像eslint一样，我们可以为其添加各种规则，来统一项目的代码风格，确保代码质量。</p><pre><code>npm i stylelint</code></pre><p>在postcss.config.js中添加相应配置。</p><pre><code>const autoprefixer = require(&#39;autoprefixer&#39;)module.exports = {  // ...  plugins: [    stylelint({      config: {        rules: {          &#39;declaration-no-important&#39;: true        }      }    })  ]}</code></pre><p>这里我们添加了declaration-no-important这样一条规则，当我们的代码中出现了“！important”时就会给出警告。</p><p>使用stylelint可以检测出代码中的样式问题（语法错误、重复的属性等），帮助我们写出更加安全并且风格更加一致的代码。</p><h3 id="CssNext"><a href="#CssNext" class="headerlink" title="CssNext"></a>CssNext</h3><p>PostCSS可以与CSSNext结合使用，让我们在应用中使用最新的CSS语法特性。</p><pre><code>npm i postcss-cssnext</code></pre><p>在postcss.config.js中添加相应配置。</p><pre><code>const postcssCssnext = require(&#39;postcss-cssnext&#39;)module.exports = {  // ...  plugins: [    postcssCssnext({      browsers: [        &#39;&gt; 1%&#39;,        &#39;last 2 versions&#39;,      ]    })  ]}</code></pre><p>指定好需要支持的浏览器之后，我们就可以顺畅地使用CSSNext的特性了。</p><h2 id="Css-Modules"><a href="#Css-Modules" class="headerlink" title="Css Modules"></a>Css Modules</h2><p>CSS Modules是近年来比较流行的一种开发模式，其理念就是把CSS模块化，让CSS也拥有模块的特点:</p><ul><li><p>每个CSS文件中的样式都拥有单独的作用域，不会和外界发生命名冲突。</p></li><li><p>对CSS进行依赖管理，可以通过相对路径引入CSS文件。</p></li><li><p>可以通过composes轻松复用其他CSS模块</p></li></ul><p>使用CSS Modules不需要额外安装模块，只要开启css-loader中的modules配置项即可。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token string">'style-loader'</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>           loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>           options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                 modules<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                 localIdentName<span class="token punctuation">:</span> <span class="token string">'[name]__[local]__[hash:base64:5]'</span>              <span class="token punctuation">}</span>           <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>这里比较值得一提的是localIdentName配置项，它用于指明CSS代码中的类名会如何来编译。</p><p>例：</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* style.css */</span><span class="token selector"><span class="token class">.title</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>经过编译后可能将成为.style<strong>title</strong>1CFy6。</p><ul><li><p>[name]指代的是模块名，这里被替换为style。</p></li><li><p>[local]指代的是原本的选择器标识符，这里被替换为title。</p></li><li><p>[hash：base64：5]指代的是一个5位的hash值，这个hash值是根据模块名和标识符计算的，因此不同模块中相同的标识符也不会造成样式冲突。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack-生产环境配置</title>
      <link href="/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-sheng-chan-huan-jing-pei-zhi/"/>
      <url>/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-sheng-chan-huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h1><p>在生产环境中我们关注的是如何让用户更快地加载资源，涉及如何压缩资源、如何添加环境变量优化打包、如何最大限度地利用缓存等。</p><h2 id="环境配置的封装"><a href="#环境配置的封装" class="headerlink" title="环境配置的封装"></a>环境配置的封装</h2><p>生产环境的配置与开发环境有所不同，如何让Webpack可以按照不同环境采用不同的配置呢？一般来说有以下两种方式。</p><ul><li>使用相同的配置文件</li></ul><p>比如令Webpack不管在什么环境下打包都使用webpack.config.js，只是在构建开始前将当前所属环境作为一个变量传进去，然后在webpack.config.js中通过各种判断条件来决定具体使用哪个配置。</p><pre><code>// package.json{    ...    &quot;scripts&quot;: {        &quot;dev&quot;: &quot;ENV=development webpack-dev-server&quot;,        &quot;build&quot;: &quot;ENV=production webpack&quot;    }}// webpack.config.jsconst ENV = process.env.ENVconst isProd = ENV === &#39;production&#39;module.exports = {    output: {        filename: isProd ? &#39;bundle@[chunkhash].js&#39; : &#39;bundle.js&#39;    },    mode: ENV}</code></pre><ul><li>为不同环境创建各自的配置文件</li></ul><p>比如，我们可以单独创建一个webpack.production.config.js，开发环境的则可以叫webpack.development.config.js。</p><pre><code>// package.json{    ...    &quot;scripts&quot;: {        &quot;dev&quot;: &quot;webpack-dev-server --config=webpack.development.config.js&quot;,        &quot;build&quot;: &quot;webpack --config=webpack.production.config.js&quot;    }}</code></pre><p>但这种方法存在一个问题，即webpack.development.config.js和webpack.production.config.js肯定会有重复的部分，一改都要改，不利于维护。在这种情况下，可以将公共的配置提取出来，比如我们单独创建一个webpack.common.config.js。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// development 和 production 共有配置</span><span class="token punctuation">}</span></code></pre><p>然后让另外两个JS分别引用该文件，并添加上自身环境的配置即可。</p><h2 id="开启-production-模式"><a href="#开启-production-模式" class="headerlink" title="开启 production 模式"></a>开启 production 模式</h2><p>Webpack 4中直接加了一个mode配置项，让开发者可以通过它来直接切换打包模式。如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">}</span></code></pre><p>这意味着当前处于生产环境模式，Webpack会自动添加许多适用于生产环境的配置项，减少了人为手动的工作。</p><p>大部分时候仅仅设置mode是不够的，下面我们继续介绍其他与生产环境相关的自定义配置。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>通常我们需要为生产环境和本地环境添加不同的环境变量，在Webpack中可以使用DefinePlugin进行设置。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">'production'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>注：我们在一些值的外面加上了JSON.stringify，这是因为DefinePlugin在替换环境变量时对于字符串类型的值进行的是完全替换。假如不添加JSON.stringify的话，在替换后就会成为变量名，而非字符串值。因此对于字符串环境变量及包含字符串的对象都要加上JSON.stringify才行。</p><h2 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h2><p>source map指的是将编译、打包、压缩后的代码映射回源代码的过程。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Webpack对于工程源代码的每一步处理都有可能会改变代码的位置、结构，甚至是所处文件，因此每一步都需要生成对应的source map。若我们启用了devtool配置项，source map就会跟随源代码一步步被传递，直到生成最后的map文件。这个文件默认就是打包后的文件名加上.map，如bundle.js.map。</p><p>当我们打开了浏览器的开发者工具时，map文件会同时被加载，这时浏览器会使用它来对打包后的bundle文件进行解析，分析出源代码的目录结构和内容。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>JavaScript的source map的配置很简单，只要在webpack.config.js中添加devtool即可。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    devtool<span class="token punctuation">:</span> <span class="token string">'source-map'</span><span class="token punctuation">}</span></code></pre><p>对于CSS、SCSS、Less来说，则需要添加额外的source map配置项。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    devtool<span class="token punctuation">:</span> <span class="token string">'source-map'</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span> <span class="token punctuation">{</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.scss$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> <span class="token punctuation">[</span>                    <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    <span class="token punctuation">{</span>                        loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                        options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                            sourceMap<span class="token punctuation">:</span> <span class="token boolean">true</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                            loader<span class="token punctuation">:</span> <span class="token string">'sass-loader'</span><span class="token punctuation">,</span>                        options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                            sourceMap<span class="token punctuation">:</span> <span class="token boolean">true</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">]</span>            <span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Webpack支持多种source map的形式。除了配置为devtool：’source-map’以外，还可以根据不同的需求选择cheap-source-map、eval-source-map等。通常它们都是source map的一些简略版本，因为生成完整的source map会延长整体构建时间，如果对打包速度需求比较高的话，建议选择一个简化版的sourcemap。比如，在开发环境中，cheap-module-eval-source-map通常是一个不错的选择，属于打包速度和源码信息还原程度的一个良好折中。</p><p>在生产环境中由于我们会对代码进行压缩，而最常见的压缩插件UglifyjsWebpack-Plugin目前只支持完全的source-map，因此没有那么多选择，我们只能使用source-map、hidden-source-map、nosources-source-map这3者之一。下面介绍一下这3种sourcemap在安全性方面的不同。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>有了source map也就意味着任何人通过浏览器的开发者工具都可以看到工程源码，对于安全性来说也是极大的隐患。那么如何才能在保持其功能的同时，防止暴露源码给用户呢？Webpack提供了hidden-source-map及nosources-source-map两种策略来提升source map的安全性。</p><p>hidden-source-map意味着Webpack仍然会产出完整的map文件，只不过不会在bundle文件中添加对于map文件的引用。这样一来，当打开浏览器的开发者工具时，我们是看不到map文件的，浏览器自然也无法对bundle进行解析。如果我们想要追溯源码，则要利用一些第三方服务，将map文件上传到那上面。目前最流行的解决方案是Sentry。</p><p>Sentry是一个错误跟踪平台，开发者接入后可以进行错误的收集和聚类，以便于更好地发现和解决线上问题。Sentry支持JavaScript的source map，我们可以通过它所提供的命令行工具或者Webpack插件来自动上传map文件。同时我们还要在工程代码中添加Sentry对应的工具包，每当JavaScript执行出错时就会上报给Sentry。Sentry在接收到错误后，就会去找对应的map文件进行源码解析，并给出源码中的错误栈。</p><p>另一种配置是nosources-source-map，它对于安全性的保护则没那么强，但是使用方式相对简单。打包部署之后，我们可以在浏览器开发者工具的Sources选项卡中看到源码的目录结构，但是文件的具体内容会被隐藏起来。对于错误来说，我们仍然可以在Console控制台中查看源代码的错误栈，或者console日志的准确行数。它对于追溯错误来说基本足够，并且其安全性相对于可以看到整个源码的source-map配置来说要略高一些。</p><h2 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h2><h3 id="压缩-javascript"><a href="#压缩-javascript" class="headerlink" title="压缩 javascript"></a>压缩 javascript</h3><p>压缩JavaScript大多数时候使用的工具有两个，一个是UglifyJS（Webpack 3已集成），另一个是terser（Webpack 4已集成）。</p><p>在Webpack 3中的话，开启压缩需调用webpack.optimize.UglifyJsPlugin。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// webpack version &lt; 4</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>UglifyJsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>从Webpack 4之后，这项配置被移到了config.optimization.minimize。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// webpack version > 4</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>        minimize<span class="token punctuation">:</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="压缩CSS"><a href="#压缩CSS" class="headerlink" title="压缩CSS"></a>压缩CSS</h3><p>压缩CSS文件的前提是使用extract-text-webpack-plugin或mini-css-extract-plugin将样式提取出来，接着使用optimize-css-assets-webpack-plugin来进行压缩，这个插件本质上使用的是压缩器cssnano，当然我们也可以通过其配置进行切换。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span><span class="token keyword">const</span> OptimizeCssAssetsPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'optimize-css-assets-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    module<span class="token punctuation">:</span> <span class="token punctuation">{</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                    fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'style.css'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>        minimizer<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">OptimizeCssAssetsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                assetNameRegExp<span class="token punctuation">:</span> <span class="token regex">/\.optimize\.css$/g</span><span class="token punctuation">,</span>                cssProcessor<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cssnano'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                cssProcessorOptions<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    discardComments<span class="token punctuation">:</span> <span class="token punctuation">{</span>removeAll<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                    canPrint<span class="token punctuation">:</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是指重复利用浏览器已经获取过的资源。合理地使用缓存是提升客户端性能的一个关键因素。</p><h3 id="资源-hash"><a href="#资源-hash" class="headerlink" title="资源 hash"></a>资源 hash</h3><p>一个常用的方法是在每次打包的过程中对资源的内容计算一次hash，并作为版本号存放在文件名中，如bundle@2e0a691e769edb228e2.js。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle@[chunkhash].js'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">}</span></code></pre><h3 id="输出动态-HTML"><a href="#输出动态-HTML" class="headerlink" title="输出动态 HTML"></a>输出动态 HTML</h3><p>接下来我们面临的问题是，资源名的改变也就意味着HTML中的引用路径的改变。每次更改后都要手动地去维护它是很困难的，理想的情况是在打包结束后自动把最新的资源名同步过去。使用html-webpack-plugin可以帮我们做到这一点。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>html-webpack-plugin会自动地将我们打包出来的资源名放入生成的index.html中，这样我们就不必手动地更新资源URL了。</p><h3 id="bundle-体积监控和分析"><a href="#bundle-体积监控和分析" class="headerlink" title="bundle 体积监控和分析"></a>bundle 体积监控和分析</h3><p>一个很有用的工具是webpack-bundle-analyzer，它能够帮助我们分析一个bundle的构成。使用方法也很简单，只要将其添加进plugins配置即可。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Analyzer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-bundle-analyzer'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>BundleAnalyzerPluginmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">Analyzer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack-预处理器</title>
      <link href="/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yu-chu-li-qi/"/>
      <url>/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yu-chu-li-qi/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="预处理器（loader）"><a href="#预处理器（loader）" class="headerlink" title="预处理器（loader）"></a>预处理器（loader）</h1><p>每个loader本质上都是一个函数。在Webpack 4之前，函数的输入和输出都必须为字符串；在Webpack 4之后，loader也同时支持抽象语法树（AST）的传递，通过这种方法来减少重复的代码解析。用公式表达loader的本质则为以下形式：</p><p>output=loader(input)</p><p>这里的input可能是工程源文件的字符串，也可能是上一个loader转化后的结果，包括转化后的结果（也是字符串类型）、source map，以及AST对象；output同样包含这几种信息，转化后的文件字符串、source map，以及AST。如果这是最后一个loader，结果将直接被送到Webpack进行后续处理，否则将作为下一个loader的输入向后传递。</p><h2 id="loader-的配置"><a href="#loader-的配置" class="headerlink" title="loader 的配置"></a>loader 的配置</h2><p>Webpack本身只认识JavaScript，对于其他类型的资源必须预先定义一个或多个loader对其进行转译，输出为Webpack能够接收的形式再继续进行，因此loader做的实际上是一个预处理的工作。</p><pre><code>module.exports = {  module: {    rules: [      {        test: /\.jsx?/, // 条件        use: &#39;babel-loader&#39; // 规则应用结果      } // 一个Object即一条规则    ]  }}</code></pre><p>与loader相关的配置都在module对象中，其中module.rules代表了模块的处理规则。每条规则内部可以包含很多配置项，这里我们只使用了最重要的两项—test和use。</p><ul><li><p>test可接收一个正则表达式或者一个元素为正则表达式的数组，只有正则匹配上的模块才会使用这条规则。</p></li><li><p>use可接收一个数组，数组包含该规则所使用的loader。</p></li></ul><h3 id="链式-loader"><a href="#链式-loader" class="headerlink" title="链式 loader"></a>链式 loader</h3><p>很多时候，在处理某一类资源时我们都需要使用多个loader。</p><pre><code>module.exports = {  module: {    rules: [      {        test: /\.css?/, // 条件        use: [&#39;style-loader&#39;, &#39;css-loader&#39;] // 规则应用结果      } // 一个Object即一条规则    ]  }}</code></pre><p>把style-loader加到了css-loader前面，这是因为在Webpack打包时是按照数组从后往前的顺序将资源交给loader处理的，因此要把最后生效的放在前面。</p><h3 id="loader-options"><a href="#loader-options" class="headerlink" title="loader options"></a>loader options</h3><p>webpack为loader提供了多种匹配条件的配置方式：</p><ul><li>test: … 匹配特定条件</li><li>include: … 匹配特定路径</li><li>exclude: … 排除特定路径</li><li>and: [] 必须匹配数组中的所有条件</li><li>or: [] 匹配数组中的任意一个条件</li><li>not: [] 排除匹配数组中的所有条件</li></ul><p>条件值类型：</p><ul><li>字符串：必须以提供的字符串开始（绝对路径）</li><li>正则表达式</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件</li><li>函数：返回true表示匹配</li></ul><hr><h5 id="规则应用配置"><a href="#规则应用配置" class="headerlink" title="规则应用配置"></a>规则应用配置</h5><p>匹配规则后的应用，我们可以使用use字段：</p><pre><code>rules: [  {    test: /\.less/,    use: [      &#39;style-loader&#39;,      {        loader: &#39;css-loader&#39;,        options: {          // ...        }      },      {        loader: &#39;less-loader&#39;,        options: {          // ...        }      }    ]  }]</code></pre><p>使用options可以给对应的loader传递一些配置项。</p><p>对于上述的less规则应用配置，一个less模块文件可以经过多个loader的转换处理，执行顺序为从右到左。</p><p>如果多个rule匹配了同一个模块文件，loader的应用顺序应该如何处理？</p><pre><code>rules: [  {    test: /\.js$/,    loader: &quot;eslint-loader&quot;,  },  {    test: /\.js$/,    loader: &quot;babel-loader&quot;,  }]</code></pre><p>eslint-loader用于检查人工编写的代码，babel-loader用于转换代码。所以，eslint-loader应该在babel-loader之前执行，那么该如何保证执行顺序？</p><p>webpack为每一个匹配规则提供了enforce字段来配置当前rule得的loader类型。pre(前置) &gt; 行内 &gt; 普通 &gt; 后置(post)。 我们要确保eslint-loader在babel-loader之前执行，只需给rule规则项添加enforce字段，并设置其值为pre。</p><pre><code>rules: [  {    enforce: &#39;pre&#39;,    test: /\.js$/,    loader: &quot;eslint-loader&quot;,  },  {    test: /\.js$/,    loader: &quot;babel-loader&quot;,  }]</code></pre><h2 id="常用-loader-介绍"><a href="#常用-loader-介绍" class="headerlink" title="常用 loader 介绍"></a>常用 loader 介绍</h2><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p> babel-loader用来处理ES6+并将其编译为ES5。</p><pre class=" language-javascript"><code class="language-javascript">npm i babel<span class="token operator">-</span>loader @babel<span class="token operator">/</span>core @babel<span class="token operator">/</span>preset<span class="token operator">-</span>env</code></pre><p>各个模块的作用如下:</p><ul><li><p>babel-loader：它是使Babel与Webpack协同工作的模块。</p></li><li><p>@babel/core：顾名思义，它是Babel编译器的核心模块。</p></li><li><p>@babel/preset-env：它是Babel官方推荐的预置器，可根据用户设置的目标环境自动添加所需的插件和补丁来编译ES6+代码。</p></li></ul><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.jsx?/,        loader: &#39;babel-loader&#39;      }    ]  }}</code></pre><hr><h3 id="ts-loader"><a href="#ts-loader" class="headerlink" title="ts-loader"></a>ts-loader</h3><p>ts-loader与babel-loader的性质类似，它是用于连接Webpack与Typescript的模块。</p><pre class=" language-javascript"><code class="language-javascript">npm i ts<span class="token operator">-</span>loader typescript</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.ts?/,        loader: &#39;ts-loader&#39;      }    ]  }}</code></pre><hr><h3 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h3><p>html-loader用于将HTML文件转化为字符串并进行格式化，这使得我们可以把一个HTML片段通过JS加载进来。</p><pre class=" language-javascript"><code class="language-javascript">npm i html<span class="token operator">-</span>loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.html?/,        loader: &#39;html-loader&#39;      }    ]  }}</code></pre><h3 id="handlebars-loader"><a href="#handlebars-loader" class="headerlink" title="handlebars-loader"></a>handlebars-loader</h3><p>handlebars-loader用于处理handlebars模板，在安装时要额外安装handlebars。</p><pre class=" language-javascript"><code class="language-javascript">npm i handlebars<span class="token operator">-</span>loader handlebars</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.handlebars?/,        loader: &#39;handlebars-loader&#39;      }    ]  }}</code></pre><p>handlebars文件加载后得到的是一个函数，可以接收一个变量对象并返回最终的字符串。</p><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>file-loader用于打包文件类型的资源，并返回其publicPath。</p><pre class=" language-javascript"><code class="language-javascript">npm i file<span class="token operator">-</span>loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.(png|jpg|gif)$/,        use: &#39;file-loader&#39;      }    ]  }}</code></pre><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>url-loader与file-loader作用类似，唯一的不同在于用户可以设置一个文件大小的阈值，当大于该阈值时与file-loader一样返回publicPath，而小于该阈值时则返回文件base64形式编码。</p><pre class=" language-javascript"><code class="language-javascript">npm i url<span class="token operator">-</span>loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.(png|jpg|gif)$/,        use: {            loader: &#39;file-loader&#39;,            options: {                limit: 10240,                name: &#39;[name].[ext]&#39;,                publicPath: &#39;./assets-path/&#39;            }        }      }    ]  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack-模块打包</title>
      <link href="/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-mo-kuai-da-bao/"/>
      <url>/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-mo-kuai-da-bao/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="模块打包"><a href="#模块打包" class="headerlink" title="模块打包"></a>模块打包</h1><h2 id="多种不同的模块机制"><a href="#多种不同的模块机制" class="headerlink" title="多种不同的模块机制"></a>多种不同的模块机制</h2><h3 id="Commonjs"><a href="#Commonjs" class="headerlink" title="Commonjs"></a>Commonjs</h3><p>CommonJS最初只为服务端而设计，直到有了Browserify——一个运行在Node.js环境下的模块打包工具，它可以将CommonJS模块打包为浏览器可以运行的单个文件。这意味着客户端的代码也可以遵循CommonJS标准来编写了。</p><p>CommonJS中规定每个文件是一个模块，所有的变量及函数只有自己能访问，对外是不可见的。</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>在CommonJS中，通过module.exports可以导出模块中的内容：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"calculate"</span><span class="token punctuation">}</span></code></pre><p>CommonJS模块内部会有一个module对象用于存放当前模块的信息。</p><p>属性。为了书写方便，CommonJS也支持另一种简化的导出方式—直接使用exports:</p><pre class=" language-javascript"><code class="language-javascript">exports<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"caculate"</span></code></pre><p>另外，要注意导出语句不代表模块的末尾，在module.exports或exports后面的代码依旧会照常执行。</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>在CommonJS中使用require进行模块导入：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> calculator <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./caculate.js'</span><span class="token punctuation">)</span><span class="token keyword">const</span> name <span class="token operator">=</span> calculator<span class="token punctuation">.</span>name</code></pre><p>当我们require一个模块时会有两种情况：</p><ul><li><p>require的模块是第一次被加载。这时会首先执行该模块，然后导出内容。</p></li><li><p>require的模块曾被加载过。这时该模块的代码不会再次执行，而是直接导出上次执行后得到的结果。</p></li></ul><p>模块会有一个module对象用来存放其信息，这个对象中有一个属性loaded用于记录该模块是否被加载过。它的值默认为false，当模块第一次被加载和执行过后会置为true，后面再次加载时检查到module.loaded为true，则不会再次执行模块代码。</p><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6 Module也是将每个文件作为一个模块，每个模块拥有自身的作用域，不同的是导入、导出语句。</p><p>ES6 Module会自动采用严格模式 – “use strict”。</p><h4 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h4><p>在ES6 Module中使用export命令来导出模块。</p><p>export有两种形式：</p><ul><li><p>命名导出</p></li><li><p>默认导出</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"calculate"</span><span class="token keyword">export</span> <span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token string">"add"</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"calculate"</span><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token string">"add"</span><span class="token keyword">export</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> add <span class="token punctuation">}</span></code></pre><p>在使用命名导出时，可以通过as关键字对变量重命名。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"calculate"</span><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token string">"add"</span><span class="token keyword">export</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> add <span class="token keyword">as</span> sum <span class="token punctuation">}</span></code></pre><p>将export default 默认导出，我们可以理解为对外输出了一个名为default的变量，因此不需要像命名导出一样进行变量声明，直接导出值即可。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">"calculate"</span><span class="token keyword">export</span> <span class="token keyword">default</span>  <span class="token keyword">class</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token punctuation">}</span></code></pre><h4 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h4><p>ES6 Module中使用import语法导入模块。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span></code></pre><p>与命名导出类似，我们可以通过as关键字可以对导入的变量重命名。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> name <span class="token keyword">as</span> caculate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span></code></pre><p>在导入多个变量时，我们还可以采用整体导入的方式。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> caculate <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span><span class="token keyword">const</span> name <span class="token operator">=</span> caculate<span class="token punctuation">.</span>name</code></pre><p>对于默认导出来说，import后面直接跟变量名，并且这个名字可以自由指定（比如这里是myCalculator）。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> myCalculator <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span></code></pre><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD是英文Asynchronous Module Definition（异步模块定义）的缩写:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'getSum'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'calculate'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>math<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>calculate<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在AMD中使用define函数来定义模块，它可以接受3个参数:</p><p>第1个参数是当前模块的id，相当于模块名；</p><p>第2个参数是当前模块的依赖，比如上面我们定义的getSum模块需要引入calculator模块作为依赖；</p><p>第3个参数用来描述模块的导出值，可以是函数或对象。如果是函数则导出的是函数的返回值；如果是对象则直接导出对象本身。</p><p>和CommonJS类似，AMD也使用require函数来加载模块，只不过采用异步的形式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'getSum'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>getSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>require的第1个参数指定了加载的模块，第2个参数是当加载完成后执行的回调函数。</p><p>通过AMD这种形式定义模块的好处在于其模块加载是非阻塞性的，当执行到require函数时并不会停下来去执行被加载的模块，而是继续执行require后面的代码，这使得模块加载操作并不会阻塞浏览器。</p><h2 id="模块打包原理"><a href="#模块打包原理" class="headerlink" title="模块打包原理"></a>模块打包原理</h2><p>Webpack 将项目中成百上千个有依赖关系的模块组织在一起，打包后将会成为如下的形式：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 立即执行匿名函数</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 模块缓存</span>    <span class="token keyword">var</span> installedModules <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 实现 require</span>    <span class="token keyword">function</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span>moduleId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 执行入口模块的加载</span>    <span class="token keyword">return</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span>__webpack_require__<span class="token punctuation">.</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// modules: 以 key-value 的形式存储所有被打包的模块</span>        <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> __webpack_require__<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 打包入口</span>            module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token string">"3qiv"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token string">"3qiv"</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> __webpack_require__<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 打包入口</span>            module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token string">"3qiv"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>上面的bundle分为以下几个部分：</p><ul><li><p>最外层立即执行匿名函数。它用来包裹整个bundle，并构成自身的作用域。</p></li><li><p>installedModules对象。每个模块只在第一次被加载的时候执行，之后其导出值就被存储到这个对象里面，当再次被加载的时候直接从这里取值，而不会重新执行。</p></li><li><p><strong>webpack_require</strong>函数。对模块加载的实现，在浏览器中可以通过调用<strong>webpack_require</strong>(module_id)来完成模块导入。</p></li><li><p>modules对象。工程中所有产生了依赖关系的模块都会以key-value的形式放在这里。key可以理解为一个模块的id，由数字或者一个很短的hash字符串构成；value则是由一个匿名函数包裹的模块实体，匿名函数的参数则赋予了每个模块导出和导入的能力。</p></li></ul><p>bundle是如何在浏览器中执行的：</p><ul><li><p>在最外层的匿名函数中会初始化浏览器执行环境，包括定义installedModules对象、<strong>webpack_require</strong>函数等，为模块的加载和执行做一些准备工作。</p></li><li><p>加载入口模块。每个bundle都有且只有一个入口模块，例如：index.js是入口模块，在浏览器中会从它开始执行。</p></li><li><p>执行模块代码。如果执行到了module.exports则记录下模块的导出值；如果中间遇到require函数（准确地说是<strong>webpack_require</strong>），则会暂时交出执行权，进入<strong>webpack_require</strong>函数体内进行加载其他模块的逻辑。</p></li><li><p>在<strong>webpack_require</strong>中会判断即将加载的模块是否存在于installedModules中。如果存在则直接取值，否则回到上一步，执行该模块的代码来获取导出值。</p></li><li><p>所有依赖的模块都已执行完毕，最后执行权又回到入口模块。当入口模块的代码执行到结尾，也就意味着整个bundle运行结束。</p></li></ul><p>不难看出，第3步和第4步是一个递归的过程。Webpack为每个模块创造了一个可以导出和导入模块的环境，但本质上并没有修改代码的执行逻辑，因此代码执行的顺序与模块加载的顺序是完全一致的，这就是Webpack模块打包的奥秘。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-闭包</title>
      <link href="/2020/01/08/javascript/javascript-bi-bao/"/>
      <url>/2020/01/08/javascript/javascript-bi-bao/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>闭包，面试中的重难点，要从很多方面讲起。</p></blockquote><a id="more"></a>           <hr><h1 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h1><p>规定函数和变量的可使用范围叫做作用域。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span></code></pre><p>声明一个函数，创建一个私用作用域。其它函数不能直接访问私有作用域 foo 的变量 a。一个函数就是一个作用域。</p><h1 id="什么是作用域链"><a href="#什么是作用域链" class="headerlink" title="什么是作用域链"></a>什么是作用域链</h1><p>每个函数都会有一个作用域，查找变量或函数时，由局部作用域到全局作用域依次查找，这些作用域的集合就称为作用域链。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 执行 fn2</span>        <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 执行 fn1</span>    <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 执行函数</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 fn2 作用域中打印 a，首先在自己所在作用域搜索，如果没有就向上级作用域搜索，直到搜索到全局作用域，a = 1，找到了打印出值。整个搜索的过程，就是基于作用域链搜索的。</p><h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p><p>闭包产生的本职就是当前环境中存在指向父级作用域的引用。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span>  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> bar<span class="token punctuation">}</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2</span></code></pre><h1 id="闭包有哪些表现形式？"><a href="#闭包有哪些表现形式？" class="headerlink" title="闭包有哪些表现形式？"></a>闭包有哪些表现形式？</h1><ul><li><p>返回一个函数，如上例</p></li><li><p>函数作为参数传递</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span>  <span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">bar</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2</span></code></pre><ul><li><p>定时器，ajax 请求，事件监听等，只要使用了回调函数，实际上就是在使用闭包</p></li><li><p>IIFE (立即执行函数表达式) 创建了闭包</p></li></ul><h1 id="如何解决下面的循环输出问题？"><a href="#如何解决下面的循环输出问题？" class="headerlink" title="如何解决下面的循环输出问题？"></a>如何解决下面的循环输出问题？</h1><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>上面全部输出 6，如何输出 1，2，3，4，5？</p><p>解决方法：</p><ul><li>IIFE，传入此时的 i 变量到定时器中</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ul><li>给定时器传入第三个参数</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ul><li>使用 ES6 中的 let</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-this</title>
      <link href="/2020/01/07/javascript/javascript-this/"/>
      <url>/2020/01/07/javascript/javascript-this/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>JavaScript 中的 this 就是一个对象，本文旨在分析各种情况下 this 的指向问题。</p></blockquote><a id="more"></a>           <hr><p>this 就是一个对象，不同情况下，this 的指向不同，主要有以下几种情况：</p><ul><li>直接调用，指向全局对象 window</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// window</span></code></pre><ul><li>对象调用，指向该对象</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span>    foo<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'a'</span></code></pre><ul><li>new 方式，指向新创建的对象</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> wangxiaobai <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token string">'wangxiaobai'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'wangxiaobai'</span></code></pre><ul><li>箭头函数的 this</li></ul><p>由于箭头函数没有单独的 this 值，箭头函数的 this 与其声明所在的上下文相同(取决于包裹箭头函数的第一个普通函数的 this)，并且不会改变。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 对象调用箭头函数</span>obj<span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span></code></pre><h2 id="如何改变-this-的指向"><a href="#如何改变-this-的指向" class="headerlink" title="如何改变 this 的指向"></a>如何改变 this 的指向</h2><p>我们可以通过 call、apply、bind 改变 this 的指向：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>   name<span class="token punctuation">:</span> <span class="token string">'wangxiaobai'</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 通过 call 改变 this 指向</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj</span><span class="token comment" spellcheck="true">// 通过 apply 改变 this 指向</span>foo<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj</span><span class="token comment" spellcheck="true">// 通过 bind 改变 this 指向</span>foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>总结一下三者的共同点和不同点。</p><p>共同点：</p><ul><li><p>三者都能改变 this 的指向，且第一个传递的参数都是 this 指向的对象</p></li><li><p>三者都采用的后续传参的形式</p></li></ul><p>不同点：</p><ul><li><p>call 的传参是单个传递，apply 的传参是数组形式，bind 没有明确规定。</p></li><li><p>call 和 apply 函数的执行是直接执行，bind 函数会返回一个函数，然后想要调用的时候才会执行。</p></li></ul><p>最后，当多个规则同时出现时，根据优先级来决定 this 最终指向哪里。</p><p>new &gt; 显示绑定(call, apply, bind) &gt; 对象绑定 &gt; 隐式绑定</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-new</title>
      <link href="/2020/01/07/javascript/javascript-new/"/>
      <url>/2020/01/07/javascript/javascript-new/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>new 关键字，首先想到的是 new 一个实例对象。</p></blockquote><a id="more"></a>           <hr><h1 id="new-内部发生了什么"><a href="#new-内部发生了什么" class="headerlink" title="new 内部发生了什么"></a>new 内部发生了什么</h1><p>new 的过程包括以下四个阶段：</p><ul><li><p>创建一个新对象</p></li><li><p>这个新对象的 <strong>proto</strong> 属性指向构造函数的 prototype 属性</p></li><li><p>将这个新对象绑定到此函数的 this 上</p></li><li><p>如果这个函数没有返回其它对象，就返回这个新对象</p></li></ul><h1 id="手动实现一个-new-操作符"><a href="#手动实现一个-new-操作符" class="headerlink" title="手动实现一个 new 操作符"></a>手动实现一个 new 操作符</h1><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 创建一个新对象</span><span class="token comment" spellcheck="true">// 链接到原型链</span><span class="token comment" spellcheck="true">// 绑定 this</span><span class="token comment" spellcheck="true">// 返回对象</span><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span>Con<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Con<span class="token punctuation">.</span>prototype  <span class="token keyword">let</span> result <span class="token operator">=</span> Con<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span>  <span class="token keyword">return</span> result <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> result <span class="token punctuation">:</span> obj<span class="token punctuation">}</span></code></pre><h1 id="有几种创建对象的方式"><a href="#有几种创建对象的方式" class="headerlink" title="有几种创建对象的方式"></a>有几种创建对象的方式</h1><p>最常用的常见对象的两种方式：</p><ul><li><p>对象字面量</p></li><li><p>new 构造函数</p></li></ul><p>其它创建对象的方式：</p><ul><li>Object.create</li></ul><p>Object.create(proto, [propertiesObject])</p><ul><li><p>proto: 新创建对象的原型对象</p></li><li><p>为创建的新对象设置属性和值</p></li></ul><h2 id="字面量相对于-new-创建对象有哪些优势"><a href="#字面量相对于-new-创建对象有哪些优势" class="headerlink" title="字面量相对于 new 创建对象有哪些优势"></a>字面量相对于 new 创建对象有哪些优势</h2><ul><li>代码量少，易阅读</li></ul><h2 id="new-字面量-与-Object-create-null-创建对象的区别？"><a href="#new-字面量-与-Object-create-null-创建对象的区别？" class="headerlink" title="new / 字面量 与 Object.create(null)创建对象的区别？"></a>new / 字面量 与 Object.create(null)创建对象的区别？</h2><ul><li><p>new / 字面量创建的对象的原型指向 Object.prototype，会继承 Object 属性和方法</p></li><li><p>Object.create(null) 创建的对象，其原型指向 null，null 作为原型链的顶端，没有继承任何属性和方法。</p></li><li><p>对象字面量运行速度快，可以在解析时被优化。new 一个对象，解析器需要顺着作用域链从当前作用域开始查找，如果在当前作用域找到名为 Object() 的函数就执行，如果一直没找到，就会顺着作用链继续查找，直到找到为止。</p></li><li><p>Object() 构造函数可以接收参数，通过这个参数可以把实例的创建过程委托给其它内置构造函数，并返回另外一个对象实例。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-数据类型转换</title>
      <link href="/2020/01/05/javascript/javascript-shu-ju-lei-xing-zhuan-huan/"/>
      <url>/2020/01/05/javascript/javascript-shu-ju-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>类型转换分为显式类型转换和隐式类型转换，每种转换又分为原始类型转换和对象类型转换。</p></blockquote><a id="more"></a>             <hr><h1 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h1><p>显式类型转换就是我们所说的强制类型转换</p><h2 id="其它数据类型转字符串-对象除外"><a href="#其它数据类型转字符串-对象除外" class="headerlink" title="其它数据类型转字符串(对象除外)"></a>其它数据类型转字符串(对象除外)</h2><table><thead><tr><th>数据类型</th><th>字符串类型</th></tr></thead><tbody><tr><td>数字</td><td>转化为数字对应的字符串</td></tr><tr><td>true</td><td>‘true’</td></tr><tr><td>false</td><td>‘false’</td></tr><tr><td>null</td><td>‘null’</td></tr><tr><td>undefined</td><td>‘undefined’</td></tr><tr><td>[]</td><td>‘’</td></tr><tr><td>[‘Q’, ‘X’]</td><td>‘Q,X’</td></tr><tr><td>function(){}</td><td>‘function(){}’</td></tr></tbody></table><pre class=" language-javascript"><code class="language-javascript"><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// "123"</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// "true"</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// "null"</span><span class="token function">String</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// "undefined"</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// "1,2"</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// "[object Object]"</span></code></pre><h2 id="其它类型转换为数字-对象除外"><a href="#其它类型转换为数字-对象除外" class="headerlink" title="其它类型转换为数字(对象除外)"></a>其它类型转换为数字(对象除外)</h2><table><thead><tr><th>数据类型</th><th>数字类型</th></tr></thead><tbody><tr><td>字符串</td><td>1)数字转换为对应的数字 2）其它转换为 NaN</td></tr><tr><td>‘’</td><td>0</td></tr><tr><td>true</td><td>1</td></tr><tr><td>false</td><td>0</td></tr><tr><td>null</td><td>0</td></tr><tr><td>undefined</td><td>NaN</td></tr><tr><td>[]</td><td>0</td></tr><tr><td>[9]</td><td>9 存在一个元素且为数字转数字；</td></tr><tr><td>[‘a’, ‘b’]</td><td>NaN</td></tr><tr><td>function(){}</td><td>NaN</td></tr></tbody></table><pre class=" language-javascript"><code class="language-javascript"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 10 </span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 10 </span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 0  </span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 0  </span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 1  </span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 0  </span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 0 </span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// NaN</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'20a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// NaN</span><span class="token function">Number</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// NaN</span></code></pre><h2 id="其它数据类型转换为布尔类型-包括对象"><a href="#其它数据类型转换为布尔类型-包括对象" class="headerlink" title="其它数据类型转换为布尔类型(包括对象)"></a>其它数据类型转换为布尔类型(包括对象)</h2><p>除几个特殊值：0、’’、false、null、undefined、NaN转换为 Boolean 为 false，其它类型值均为 true（包括对象）。</p><h2 id="对象转原始类型-字符串和数字"><a href="#对象转原始类型-字符串和数字" class="headerlink" title="对象转原始类型(字符串和数字)"></a>对象转原始类型(字符串和数字)</h2><p>对象到字符串和字符串到对象的转换是通过调用待转对象的一个方法来完成的，一个麻烦的事实是，JavaScript 对象有两个不同的方法来进行转换。</p><p>所有对象继承了两个转换方法：</p><p>1）toString()，它的作用是返回一个反映这个对象的字符串。</p><p>对象类的 toString() 返回一个字符串：’[object, Object]’</p><p>数组类的 toString() 将每个数组元素转换为字符串，并在元素之间添加逗号后合并成字符串</p><p>函数类的 toString() 返回这个函数的实现定义的表示方式</p><p>日期类的 toString() 返回一个可读的日期和时间字符串</p><p>正则表达式的 toString() 返回这个正则表达式直接量的字符串</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// '[object, Object]'</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// '1,2'</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'function() {}'</span><span class="token punctuation">(</span><span class="token regex">/\d+/</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// '/\\d/'</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'Fri Jan 012010 00:00:00 GMT-0800(PST)'</span></code></pre><p>2) valueOf()，如果存在原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的 valueOf() 方法简单的返回对象本身（日期对象除外）。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// {x: 1, y: 2}</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [1, 2]</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// function() {}</span><span class="token punctuation">(</span><span class="token regex">/\d+/</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// /\\d/</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1262275200000</span></code></pre><h3 id="对象转换为字符串"><a href="#对象转换为字符串" class="headerlink" title="对象转换为字符串"></a>对象转换为字符串</h3><p>对象转换为字符串经历了以下步骤：</p><ul><li><p>如果对象具有 toString() 方法，则调用这个方法。如果它返回一个原始值，将这个值转换为字符串并返回。</p></li><li><p>如果对象没有 toString() 方法，或者这个方法不返回一个原始值，则调用 valueOf() 方法，如果它返回一个原始值，将这个值转换为字符串并返回。</p></li><li><p>如果两者都不成功，抛出类型错误。</p></li></ul><h3 id="对象转换为数字"><a href="#对象转换为数字" class="headerlink" title="对象转换为数字"></a>对象转换为数字</h3><p>对象转换为数字经历了以下步骤：</p><ul><li><p>如果对象具有 valueOf() 方法，则调用这个方法。如果它返回一个原始值，将这个值转换为数字并返回。</p></li><li><p>否则，如果对象具有 toString() 方法，则调用 toString() 方法，如果它返回一个原始值，将这个值转换为数字并返回。</p></li><li><p>如果两者都不成功，抛出类型错误。</p></li></ul><h1 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h1><p>隐式类型转化是不需要认为的强制类型转化，javaScript 自动将类型转化为需要的类型，所以称之为隐式类型转换。</p><h2 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h2><p>加法运算符是在运行时决定，到底是执行相加，还是执行连接。</p><p>如果双方都不是字符串：</p><ul><li><p>Boolean + Boolean 会转换为数字相加</p></li><li><p>Boolean + Number 布尔类型会转换为数字相加</p></li><li><p>Object + Number Object型调用 valueOf，如果不是 String、Boolean或者 Number类型，则继续调用 toString()转化为字符串。</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token boolean">true</span> <span class="token operator">+</span> <span class="token boolean">true</span>  <span class="token comment" spellcheck="true">// 2</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token boolean">true</span>     <span class="token comment" spellcheck="true">// 2</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">3</span>      <span class="token comment" spellcheck="true">// '13'</span></code></pre><p>字符串和字符串以及字符串和非字符串相加都会进行拼接。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'b'</span>     <span class="token comment" spellcheck="true">// ‘1b’</span><span class="token boolean">false</span> <span class="token operator">+</span> <span class="token string">'b'</span> <span class="token comment" spellcheck="true">// ‘falseb’</span></code></pre><h2 id="其它运算"><a href="#其它运算" class="headerlink" title="其它运算"></a>其它运算</h2><p>其它算数运算符(减乘除)，所有运算数一律转换为数值，再进行相应的运算。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">1</span> <span class="token operator">*</span> <span class="token string">'2'</span>  <span class="token comment" spellcheck="true">// 2</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">// 0</span></code></pre><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>逻辑运算符包括两种情况：条件判断和赋值操作。</p><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li><p>&amp;&amp;：所有条件为真，整体才为真</p></li><li><p>||：其中任一条件为真，整体就为真</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span>   <span class="token comment" spellcheck="true">// true</span><span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">false</span>  <span class="token comment" spellcheck="true">// false</span><span class="token boolean">true</span> <span class="token operator">||</span> <span class="token boolean">true</span>   <span class="token comment" spellcheck="true">// true</span><span class="token boolean">true</span> <span class="token operator">||</span> <span class="token boolean">false</span>  <span class="token comment" spellcheck="true">// true</span></code></pre><h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><ul><li>A &amp;&amp; B</li></ul><p>首先看 A 的真假，A 为假，返回 A 的值，A 为真则返回 B 的值（不管B是什么）</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2</span></code></pre><ul><li>A || B</li></ul><p>首先看 A 的真假，A 为真，返回 A 的值，A 为假则返回 B 的值（不管B是什么）</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span></code></pre><h1 id="比较远算符"><a href="#比较远算符" class="headerlink" title="比较远算符"></a>比较远算符</h1><p>比较运算符在逻辑语句中使用，以判定变量或值是否相等。</p><pre><code>== 和 === 的区别？</code></pre><p>对于 === 来说，是严格意义上的相等，会比较两个操作符的类型和值。</p><ul><li><p>如果 X 和 Y 类型不同，则返回 false</p></li><li><p>如果 X 和 Y 类型相同，则根据下方表格进一步判断</p></li></ul><table><thead><tr><th>条件</th><th>例子</th><th>返回值</th></tr></thead><tbody><tr><td>undefined === undefined</td><td>undefined === undefined</td><td>true</td></tr><tr><td>null === null</td><td>null === null</td><td>true</td></tr><tr><td>String === String</td><td>‘a’ === ‘a’<br>‘a’ === ‘aa’</td><td>true<br>false</td></tr><tr><td>Boolean === Boolean</td><td>true === true<br>false === false</td><td>true<br>false</td></tr><tr><td>Symbol === Symbol</td><td>相同的 Symbol 返回 true<br>不相同的 Symbol 返回 true</td></tr><tr><td>Number === Number<br>其中一个为 NaN，返回false<br>X 和 Y 值相等，返回 true<br> 0 和 -0，返回 true</td><td>NaN === NaN<br>NaN === 1<br>3===3<br>0 === -0</td><td>false<br>false<br>true<br>true</td></tr></tbody></table><p>对于 ==来说，是非严格意义上的相等，先判断两个操作符的类型是否相等，如果类型不同，则先进行类型转换，然后再判断值是否相等。</p><ul><li><p>如果 X 和 Y 的类型相同，返回 X == Y 的比较结果；</p></li><li><p>如果 X 和 Y 的类型不同，根据下方表格进一步判断;</p></li></ul><table><thead><tr><th>条件</th><th>例子</th><th>返回值</th></tr></thead><tbody><tr><td>null == undefined</td><td>null == undefined</td><td>true</td></tr><tr><td>String == Number，String 转 Number</td><td>‘2’ == 2</td><td>true</td></tr><tr><td>Boolean == Number，Boolean 转 Number</td><td>true == 1</td><td>true</td></tr><tr><td>Object == String,Number,Symbol，将 Object 转化为原始类型再比较值大小n</td><td>[1] == 1<br>[1] == ‘1’</td><td>true<br>true</td></tr><tr><td>其他返回 false</td><td></td><td>false</td></tr></tbody></table><h1 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h1>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-数据类型存储形式</title>
      <link href="/2020/01/05/javascript/javascript-shu-ju-lei-xing-cun-chu-xing-shi/"/>
      <url>/2020/01/05/javascript/javascript-shu-ju-lei-xing-cun-chu-xing-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>JavaScript 数据类型分为原始类型和引用类型（对象类型），两种类型在内存中有不同的存储形式。</p></blockquote><a id="more"></a>               <hr><p>栈（stack）和堆（Heap），是两种基本的数据结构。</p><p>栈在内存中是自动分配内存空间，堆在内存中是动态分配内存空间，不一定会自动释放。</p><p>一般我们在项目中将对象类型手动置为 null，减少无用内存消耗。</p><p>原始类型和对象类型分别在内存中的存在形式如下图：</p><p><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/aVp1YC8UV0fXooDPZouVS6juuGEP1GxibzBmJd1UmVEjEbyNxr7MlAk5jIQkmEjEMDclZgPogN8n940Lb3jwZfA/640?wx_fmt=png" alt=""></p><p>原始类型是按值形式存放在栈中的数据段，内存空间可以自由分配，同时按值直接访问。</p><p>引用类型在栈中保存的是这个对象在堆内存中的引用地址，值保存在堆内存中。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-数据类型</title>
      <link href="/2020/01/04/javascript/javascript-shu-ju-lei-xing/"/>
      <url>/2020/01/04/javascript/javascript-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>JavaScript 数据类型分为原始类型和引用类型（对象类型）。<br><a id="more"></a>               </p><hr></blockquote><h1 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h1><p>在 JavaScript 中，存在 6 种原始类型：</p><ul><li>string</li><li>number</li><li>boolean</li><li>undefined</li><li>symbol</li><li>null</li></ul><p>原始类型存储的都是值，是没有函数可以调用的。</p><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>引用类型统称为 Object 类型，如果细分的话，常用的有以下几个：</p><ul><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>Error</li><li>RegExp</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-003-回文数</title>
      <link href="/2020/01/03/leetcode/leetcode-003-hui-wen-shu/"/>
      <url>/2020/01/03/leetcode/leetcode-003-hui-wen-shu/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：字符串、数组、数学</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="external">https://leetcode-cn.com/problems/roman-to-integer/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例 1:输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶:你能不将整数转为字符串来解决这个问题吗？</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-数组操作"><a href="#解法-数组操作" class="headerlink" title="解法 - 数组操作"></a>解法 - 数组操作</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {number} x * @return {boolean} */</span><span class="token keyword">var</span> isPalindrome <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> Arr <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> j <span class="token operator">=</span> Arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> Arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>121</code></pre><p>输出：</p><pre><code>true</code></pre><p>预期结果：</p><pre><code>true</code></pre><ul><li><p>解题思路：转换为字符串、数组，交叉对比</p></li><li><p>split(): 字符串分割为数组</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-深浅拷贝</title>
      <link href="/2020/01/03/javascript/javascript-shen-qian-kao-bei/"/>
      <url>/2020/01/03/javascript/javascript-shen-qian-kao-bei/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>类型判断在 Web 开发中有非常广泛的作用，简单的有判断数字、字符串，复杂的有判断数组还是对象等。</p></blockquote><h4 id="导语-1"><a href="#导语-1" class="headerlink" title="导语"></a>导语</h4><blockquote><p>当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。</p></blockquote><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>🌰：</p><pre><code>var a = {x: 10, y: 10}var b = ab.x = 100b.y = 100</code></pre><p>打印一下a和b的值：</p><pre><code>console.log(a) // {x: 100, y: 200}console.log(b) // {x: 100, y: 200}</code></pre><p>发现改变b的值，同时也改了a的值。</p><p>🌰：</p><pre><code>var a = 10var b = ab = 20</code></pre><p>打印一下a和b的值：</p><pre><code>console.log(a) // 10console.log(b) // 20</code></pre><p>??? b的值改变并没有引起a的值改变。</p><hr><h3 id="值类型-vs-引用类型"><a href="#值类型-vs-引用类型" class="headerlink" title="值类型 vs 引用类型"></a>值类型 vs 引用类型</h3><p>在JS中，变量传递方式分为值类型和引用类型。值类型包括String，Number，Null，Boolean，Undefined。引用类型包括Object类的所有，如Date，Array，Function。</p><p>在参数传递方式上，值类型是按值传递。引用类型是按共享传递(指向同一个内存地址，两者引用同一个值，当一者改变值，另一者也改变)。</p><p>JS这样设计的原因在于：按值传递的类型，复制一份存入栈内存，这类类型一般不会占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值，保证过大的对象等不会因为不停复制内容而造成内存的浪费。</p><p>深拷贝和浅拷贝最根本的区别在于是否真正获取了一个对象的拷贝实体，而不只是引用。</p><hr><h3 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h3><h4 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h4><p>🌰：</p><pre><code>  let obj = {username: &#39;kobe&#39;, age: 39, sex: {option1: &#39;男&#39;, option2: &#39;女&#39;}}  let obj1 = obj  obj1.sex.option1 = &#39;不男不女&#39; // 修改复制的对象会影响原对象</code></pre><p>打印obj1的值</p><pre><code>  console.log(obj1) // {username: &#39;kobe&#39;, age: 39, sex: {option1: &#39;不男不女&#39;, option2: &#39;女&#39;}}</code></pre><hr><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h4><p>🌰：</p><pre><code>  let obj = {    username: &#39;kobe&#39;  };  let obj1 = Object.assign(obj)  obj1.username = &#39;wang&#39;</code></pre><p>打印obj的值</p><pre><code>  console.log(obj) // { username: &quot;wang&quot; }</code></pre><hr><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat"></a>Array.prototype.concat</h4><p>🌰：</p><pre><code>let arr = [1, 3, {    username: &#39;kobe&#39;}]let arr2=arr.concat()arr2[2].username = &#39;wang&#39;</code></pre><p>打印arr的值</p><pre><code>   console.log(arr) // [1, 3, { username: &quot;wade&quot; }]</code></pre><hr><h4 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice"></a>Array.prototype.slice</h4><p>🌰：</p><pre><code>let arr = [1, 3, {    username: &#39;kobe&#39;}]let arr2=arr.slice()arr2[2].username = &#39;wang&#39;</code></pre><p>打印arr的值</p><pre><code>   console.log(arr) // [1, 3, { username: &quot;wade&quot; }]</code></pre><hr><h4 id="Array-prototype-concat-vs-Array-prototype-slice"><a href="#Array-prototype-concat-vs-Array-prototype-slice" class="headerlink" title="Array.prototype.concat vs Array.prototype.slice"></a>Array.prototype.concat vs Array.prototype.slice</h4><p>关于Array的concat和slice补充说明：Array的concat和slice方法不改变原始数组，只是返回了一个浅复制原数组中的元素的一个新数组。</p><p>原数组中的元素会按照下述规则拷贝：</p><ul><li><p>如果该元素是个引用类型，slice或者concat会拷贝这个引用到新的数组里，两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新数组和原数组中的这个元素都会发生改变。</p></li><li><p>如果该元素是个值类型，slice或者concat会复制一份这些值到新数组里。在别的数组里修改这些值，并不会影响另一个数组。</p></li></ul><p>🌰：</p><pre><code>let arr = [1, 3, {    username: &#39;kobe&#39;}];let arr3 = arr.slice();arr3[1] = 2console.log(arr, arr3)</code></pre><p>打印arr和arr3的值</p><pre><code>console.log(arr, arr3)// ---result// [1, 3, { username: &quot;kobe&quot; }]// [1, 2, { username: &quot;kobe&quot; }]</code></pre><hr><h3 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h3><h4 id="Object-assign-1"><a href="#Object-assign-1" class="headerlink" title="Object.assign"></a>Object.assign</h4><p>Object.assign可以进行一层深度拷贝</p><p>🌰：</p><pre><code>var obj = {        name: &#39;wang&#39;,        test1: null,        test2: undefined,        test3: function(){alert(1)},        test4: {}    };var obj1 = Object.assign({}, obj1)obj1.age = 24console.log(obj, obj1)</code></pre><p>打印obj和obj1的值</p><pre><code>console.log(obj, obj1)// ----result// { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {  } }// { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {  }, age: 24 }</code></pre><p>然而。。。。。</p><p>🌰：</p><pre><code>var obj = {        name: &#39;wang&#39;,        test1: null,        test2: undefined,        test3: function(){alert(1)},        test4: {}    };var obj1 = Object.assign({}, obj1)obj1.test4.age = 24</code></pre><p>打印obj和obj1的值</p><pre><code>console.log(obj, obj1)// ----result// { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { age: 24 } }// { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { age: 24 } }</code></pre><hr><h4 id="JSON-parse-JSON-stringfy-obj"><a href="#JSON-parse-JSON-stringfy-obj" class="headerlink" title="JSON.parse(JSON.stringfy(obj))"></a>JSON.parse(JSON.stringfy(obj))</h4><p>说到深拷贝，你肯定会想到JSON.parse(JSON.stringfy(obj))。</p><p>🌰：</p><pre><code>var obj = {        name: &#39;wang&#39;,        test: {            name: &#39;test&#39;        }    };var obj1 = JSON.parse(JSON.stringify(obj))obj1.test.name = 24</code></pre><p>打印obj和obj1的值</p><pre><code>console.log(obj, obj1)// ----result// { name: &quot;wang&quot;, test: { name: &quot;test&quot; } }// { name: &quot;wang&quot;, test: { name: 24 } }</code></pre><p>然而。。。。</p><p>🌰：</p><pre><code>var obj = {        name: &#39;wang&#39;,        test1: null,        test2: undefined,        test3: function(){alert(1)},        test4: {}    };var obj1 = JSON.parse(JSON.stringify(obj))</code></pre><p>打印obj和obj1的值</p><pre><code>console.log(obj, obj1)// ---result// { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {  } }// { name: &quot;wang&quot;, test1: null, test4: {  } }</code></pre><p>???test2和test3不见了。。。。。</p><p>JSON.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个JSON字符串，不能接受函数。</p><hr><h4 id="手写递归方法"><a href="#手写递归方法" class="headerlink" title="手写递归方法"></a>手写递归方法</h4><pre><code>function deepClone(obj) {    let result    let toString = Object.prototype.toString    if (toString.call(obj) === &#39;[Object Array]&#39;) {        result = []          for (var i =0; i&lt;obj.length; i++) {            result[i] = deepClone(obj[i])        }    } else if (toString.call(obj) === &#39;[Object Object]&#39;) {        result = {}          for (var key in obj) {            if (obj.hasOwnProperty(key)) {                result[key] = deepClone(obj[key])            }        }    } else {        return obj    }  return result}</code></pre><p>🌰：调用函数并打印结果</p><pre><code>var obj = {        name: &#39;wang&#39;,        test1: null,        test2: undefined,        test3: function(){alert(1)},        test4: {}    };var obj1 = deepClone(obj)console.log(obj, obj21)// { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: Object {  } }// { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: Object {  } }</code></pre><hr><h4 id="jQuery实现"><a href="#jQuery实现" class="headerlink" title="jQuery实现"></a>jQuery实现</h4><p>🌰：</p><pre><code>var obj1 = {        name: &#39;wang&#39;,        test1: null,        test2: undefined,        test3: function(){alert(1)},        test4: {}    };var obj2 = $.extend(true, {}, obj1)</code></pre><hr><h4 id="lodash实现"><a href="#lodash实现" class="headerlink" title="lodash实现"></a>lodash实现</h4><p>🌰：</p><pre><code>var obj1 = {        name: &#39;wclimb&#39;,        test1: null,        test2: undefined,        test3: function(){alert(1)},        test4: {}    };var obj2 = _.cloneDeep(obj1)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-002-整数反转</title>
      <link href="/2020/01/02/leetcode/leetcode-002-zheng-shu-fan-zhuan/"/>
      <url>/2020/01/02/leetcode/leetcode-002-zheng-shu-fan-zhuan/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="external">https://leetcode-cn.com/problems/reverse-integer/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-转字符串、数组反转"><a href="#解法-转字符串、数组反转" class="headerlink" title="解法 - 转字符串、数组反转"></a>解法 - 转字符串、数组反转</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {number} x * @return {number} */</span><span class="token keyword">var</span> reverse <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 转换为整数</span>    <span class="token keyword">let</span> num <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 转换为字符串</span>    <span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 字符串反转</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">||</span> result <span class="token operator">></span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>result    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result    <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>123</code></pre><p>输出：</p><pre><code>321</code></pre><p>预期结果：</p><pre><code>321</code></pre><ul><li><p>解题思路：转换为字符串、数组</p></li><li><p>String: 将其他值转换为字符串</p></li><li><p>Number: 将其他值转换为数字值</p></li><li><p>Math: JS 内置对象</p></li><li><p>split(): 字符串分割为数组</p></li><li><p>reverse(): 数组翻转</p></li><li><p>join(): 数组转换为字符串</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-常见面试题系列之CSS基础</title>
      <link href="/2020/01/02/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-css-ji-chu/"/>
      <url>/2020/01/02/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-css-ji-chu/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><p>本系列旨在整理 CSS 考点的非重难点，帮助梳理 HTML 高频面试题。</p><h1 id="CSS选择器的优先级是怎样的？"><a href="#CSS选择器的优先级是怎样的？" class="headerlink" title="CSS选择器的优先级是怎样的？"></a>CSS选择器的优先级是怎样的？</h1><p>CSS 选择器的优先级是：内联选择器 &gt; id 选择器 &gt; 类选择器 &gt; 标签选择器</p><p>到具体的计算层面，优先级是由 A、B、C、D 的值来决定的，其中它们的值计算规则如下：</p><ul><li><p>A 的值等于1的前提是存在内联样式，否则 A = 0</p></li><li><p>B 的值等于 ID 选择器出现的次数</p></li><li><p>C 的值等于类选择器和属性选择器和伪类出现的总次数</p></li><li><p>D 的值等于标签选择器和伪元素出现的总次数</p></li></ul><p>例如下面的选择器，它不存在内联样式，所以 A = 0，不存在 id 选择器，B = 0，存在一个类选择器 C = 1，存在三个标签选择器 D = 3，那么最终结果为：{0, 0, 1, 3}</p><pre><code>ul ol li .red {    ...}</code></pre><h1 id="link-和-import-的区别？"><a href="#link-和-import-的区别？" class="headerlink" title="link 和 @import 的区别？"></a>link 和 @import 的区别？</h1><ul><li><p>link 属于 XHTML 标签，而 @import 是 CSS 提供的。</p></li><li><p>页面被加载时，link 会同时加载。而 @import 会到页面被加载完在加载。</p></li><li><p>link 方式的样式权重高于 @import 的权重。</p></li></ul><h1 id="有哪些方式（CSS）可以隐藏页面元素？"><a href="#有哪些方式（CSS）可以隐藏页面元素？" class="headerlink" title="有哪些方式（CSS）可以隐藏页面元素？"></a>有哪些方式（CSS）可以隐藏页面元素？</h1><ul><li><p>opacity: 0：本质是将元素的透明度降为 0，就看起来隐藏了，但是依然占据空间且可以交互。</p></li><li><p>visibility: hidden：与上一个方法类似的效果，占据空间，但是不可以交互了。</p></li><li><p>overflow: hidden：隐藏元素溢出的部分，占据空间且不可交互。</p></li><li><p>display: none：彻底隐藏元素，元素从文档流中消失，既不占据空间，也不交互，也不影响布局。</p></li><li><p>z-index: -9999：将层级放到底部。</p></li><li><p>transform: scale(0, 0)：平面变换，将元素缩放为 0，但是依然占据空间，不可交互。</p></li></ul><h1 id="em-px-rem-的区别？"><a href="#em-px-rem-的区别？" class="headerlink" title="em/px/rem 的区别？"></a>em/px/rem 的区别？</h1><ul><li><p>px：绝对单位，页面按精确像素展示。</p></li><li><p>em：相对单位，基准点为父元素字体的大小。</p></li><li><p>rem：相对单位，基准点为根节点 html 的字体大小。</p></li></ul><h1 id="块级元素水平居中的方法？"><a href="#块级元素水平居中的方法？" class="headerlink" title="块级元素水平居中的方法？"></a>块级元素水平居中的方法？</h1><ul><li>margin: 0 auto;</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.center</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>flex 布局。</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.center</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>    <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>table 方法。</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.center</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="CSS-有几种定位方式？"><a href="#CSS-有几种定位方式？" class="headerlink" title="CSS 有几种定位方式？"></a>CSS 有几种定位方式？</h1><ul><li><p>static：正常文档流定位。块级元素从上到下纵向排列，行级元素从左到右横向排列。</p></li><li><p>relative：相对布局。相对于正常文档流的位置。</p></li><li><p>absolute：绝对布局。</p></li><li><p>fixed：相对于屏幕视口的位置来指定元素位置。</p></li><li><p>sticky：粘性定位。近似效果就是 ios 通讯录滚动时候的【顶屁股】。</p></li></ul><h1 id="如何理解-z-index？"><a href="#如何理解-z-index？" class="headerlink" title="如何理解 z-index？"></a>如何理解 z-index？</h1><p>控制重叠元素的垂直叠加顺序，默认元素的 z-index 为 0，而 z-index 只能影响设置了 position 值的元素。</p><h1 id="如何理解层叠上下文？"><a href="#如何理解层叠上下文？" class="headerlink" title="如何理解层叠上下文？"></a>如何理解层叠上下文？</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>假定用户正面向网页，而 HTML 元素沿着其相对于用的一条虚构的 Z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。</p><h2 id="如何产生？"><a href="#如何产生？" class="headerlink" title="如何产生？"></a>如何产生？</h2><p>触发以下条件则会产生层叠上下文：</p><ul><li><p>根元素</p></li><li><p>z-index 值不为 ‘auto’ 的相对/绝对定位</p></li><li><p>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex</p></li><li><p>opacity 属性值小于 1 的元素</p></li><li><p>transform 属性值不为 “none”的元素</p></li><li><p>mix-blend-mode 属性值不为 “normal”的元素</p></li><li><p>filter值不为“none”的元素</p></li><li><p>perspective值不为“none”的元素</p></li><li><p>isolation 属性被设置为 “isolate”的元素</p></li><li><p>position: fixed</p></li><li><p>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值</p></li><li><p>-webkit-overflow-scrolling 属性被设置 “touch”的元素</p></li></ul><h1 id="清除浮动有哪些方法？"><a href="#清除浮动有哪些方法？" class="headerlink" title="清除浮动有哪些方法？"></a>清除浮动有哪些方法？</h1><ul><li><p>空 div 方法：<div style="clear: both;"></div></p></li><li><p>Clearfix 方法： clearfix 类方法</p></li><li><p>overflow: hidden; ovrflow: auto; BFC</p></li></ul><h1 id="你对-css-sprites-的理解，好处是什么？"><a href="#你对-css-sprites-的理解，好处是什么？" class="headerlink" title="你对 css sprites 的理解，好处是什么？"></a>你对 css sprites 的理解，好处是什么？</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>css sprites – 雪碧图，css 图像合成技术，开发人员往往将小图标合在一起，通过 background-image、background-position、background-size等属性定位到要使用的小图标。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>提前加载资源</p></li><li><p>减少 HTTP 请求书</p></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>维护成本高</p></li><li><p>加载速度优势在 http2 开启后荡然无存</p></li></ul><h1 id="你对媒体查询的理解？"><a href="#你对媒体查询的理解？" class="headerlink" title="你对媒体查询的理解？"></a>你对媒体查询的理解？</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>媒体查询，添加自 CSS3，允许内容的呈现针对一个特定范围的输出设备而进行裁剪，而不必改变内容自身，非常适合 web 网页应对不同型号的设备而做出对应的响应适配。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>媒体查询包含一个可选的媒体类型和满足 CSS3 规范的条件下，包含零个或多个表达式，这些表达式描述了媒体类型，最终会被解析为 true 或 false。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>example.css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(max-width: 800px)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"><span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>    <span class="token selector"><span class="token class">.fact_sidebar</span> </span><span class="token punctuation">{</span>        <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><h1 id="你对盒模型的理解？"><a href="#你对盒模型的理解？" class="headerlink" title="你对盒模型的理解？"></a>你对盒模型的理解？</h1><p>当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型，将所有元素表示为一个个矩形的盒子，CSS 决定这些盒子的大小，位置及属性等。</p><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/14650bf5fbb24066cea1dc1714d52a5b.png" alt=""></p><p>盒模型由 content、padding、border、margin组成。</p><h2 id="标准盒模型和怪异盒模型有什么区别？"><a href="#标准盒模型和怪异盒模型有什么区别？" class="headerlink" title="标准盒模型和怪异盒模型有什么区别？"></a>标准盒模型和怪异盒模型有什么区别？</h2><p>标准盒模型中，我们定义的元素的 width 为盒模型中 content 的宽度值，定义的 height 为盒模型中 content 的高度值。</p><p>因此，标准盒模型下：</p><p>元素的宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</p><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/232580766e15853d521a4c0bf6a5c794.png" alt=""></p><p>怪异盒模型中，我们定义的元素的 width 并不是 content 的宽度，而是 border-left + padding-left + width + padding-right + border-right 的总和，height 同理。</p><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/e427c6d19ea6be1359bd0177d7a5b7a3.png" alt=""></p><p>虽然现代浏览器默认使用W3C的标准盒模型，但是在不少情况下怪异盒模型更好用，于是W3C在css3中加入box-sizing。</p><h1 id="谈谈对-BFC-的理解？"><a href="#谈谈对-BFC-的理解？" class="headerlink" title="谈谈对 BFC 的理解？"></a>谈谈对 BFC 的理解？</h1><p>块级格式化上下文，一块独立的渲染区域，BFC 内部的元素与外部的元素互相隔离。</p><p>BFC 触发条件：</p><ul><li><p>根元素</p></li><li><p>position: fixed/absolute</p></li><li><p>overflow 不为 visible</p></li><li><p>float 不为 none</p></li><li><p>display 的值为 inline-block、table-cell、table-caption</p></li></ul><p>BFC 的作用：</p><ul><li><p>防止 margin 发生重叠</p></li><li><p>防止元素塌陷</p></li><li><p>两栏布局，防止文字环绕</p></li></ul><h1 id="为什么有时用-translate-来改变位置而不是定位？"><a href="#为什么有时用-translate-来改变位置而不是定位？" class="headerlink" title="为什么有时用 translate 来改变位置而不是定位？"></a>为什么有时用 translate 来改变位置而不是定位？</h1><p>translate 改变位置时，元素依然占据其原始空间，不会触发浏览器重新布局或重绘，只会触发复合。</p><h1 id="伪类和伪元素的区别是什么？"><a href="#伪类和伪元素的区别是什么？" class="headerlink" title="伪类和伪元素的区别是什么？"></a>伪类和伪元素的区别是什么？</h1><p>伪类：以 (:) 为前缀，添加到一个选择器末尾的关键字，当你希望样式在特别状态下才被呈现到指定的元素时，你可以在元素的选择器后加上对应的伪类。</p><p>伪元素：用于创建一些不在文档树中的元素，并为其添加样式。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS-数据类型判断</title>
      <link href="/2020/01/02/javascript/javascript-shu-ju-lei-xing-pan-duan/"/>
      <url>/2020/01/02/javascript/javascript-shu-ju-lei-xing-pan-duan/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>类型判断在 Web 开发中有非常广泛的作用，简单的有判断数字、字符串，复杂的有判断数组还是对象等。</p></blockquote><a id="more"></a><h1 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h1><p>typeof 是一元操作符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。</p><p>除了 null 类型和 object 类型不能准确判断外，其它数据类型都可以返回正确的类型。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">typeof</span> undefined <span class="token comment" spellcheck="true">// 'undefined</span><span class="token keyword">typeof</span> <span class="token string">'10'</span> <span class="token comment" spellcheck="true">// 'string'</span><span class="token keyword">typeof</span> <span class="token number">10</span> <span class="token comment" spellcheck="true">// 'number'</span><span class="token keyword">typeof</span> <span class="token boolean">false</span> <span class="token comment" spellcheck="true">// 'boolean'</span><span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'symbol'</span><span class="token keyword">typeof</span> Function <span class="token comment" spellcheck="true">// 'function'</span><span class="token keyword">typeof</span> <span class="token keyword">null</span> <span class="token comment" spellcheck="true">// 'object'</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 'object'</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 'object'</span></code></pre><h1 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h1><p>当 toString 方法被调用的时候，下面的步骤会被执行：</p><ul><li><p>如果 this 值是 undefined，就返回 [object Undefined]</p></li><li><p>如果 this 的值是 null，就返回 [object Null]</p></li><li><p>让 O 成为 ToObject(this) 的结果</p></li><li><p>让 class 成为 O 的内部属性 [[Class]] 的值</p></li><li><p>最后返回由 “[object “ 和 class 和 “]” 三个部分组成的字符串</p></li></ul><pre class=" language-javascript"><code class="language-javascript">Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Number]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object String]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Boolean]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Undefined]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Null]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Object]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Array]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Date]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Error]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token regex">/a/g</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object RegExp]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Function]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Symbol]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Set]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Map]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Math</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Math]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JSON</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object JSON]"</span></code></pre><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>instanceof 运算符用来判断一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>A <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-数组去重</title>
      <link href="/2020/01/01/javascript/javascript-shu-zu-qu-chong/"/>
      <url>/2020/01/01/javascript/javascript-shu-zu-qu-chong/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>数组去重方法老生常谈，本文主要总结常见的数组去重方法。</p></blockquote><a id="more"></a>               <hr><p>🌰 array = [1, ‘1’, 1, ‘1’]</p><h1 id="双层循环"><a href="#双层循环" class="headerlink" title="双层循环"></a>双层循环</h1><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> arrayLen <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> resultLen <span class="token operator">=</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> resultLen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> result<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">break</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">===</span> resultLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>使用循环嵌套，最外层循环 array，里面循环 result，如果 array[i] 的值跟 result[j] 的值相等，就跳出循环，如果都不等于，说明元素是唯一的，这时候 j 的值就会等于 result 的长度，根据这个特点进行判断，将值添加进 result。</p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>可以使用 indexOf 来简化内层循环：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> arrayLen <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> current <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>可以使用 filter 的方法：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> res <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> index<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Object-键值对"><a href="#Object-键值对" class="headerlink" title="Object 键值对"></a>Object 键值对</h2><p>这种方法是利用一个空的 Object 对象，我们把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2]</span></code></pre><p>我们可以发现，是有问题的，因为 1 和 ‘1’ 是不同的，但是这种方法会判断为同一个值，这是因为对象的键值只能是字符串，所以我们可以使用 typeof item + item 拼成字符串作为 key 值来避免这个问题：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> item <span class="token operator">+</span> item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span><span class="token keyword">typeof</span> item <span class="token operator">+</span> item<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, "1"]</span></code></pre><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, "1"]</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-001-两数之和</title>
      <link href="/2020/01/01/leetcode/leetcode-001-liang-shu-zhi-he/"/>
      <url>/2020/01/01/leetcode/leetcode-001-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组、哈希表</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="external">https://leetcode-cn.com/problems/two-sum/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-for"><a href="#解法-for" class="headerlink" title="解法 - for()"></a>解法 - for()</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {number[]} nums * @param {number} target * @return {number[]} */</span><span class="token keyword">var</span> twoSum <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>[2,7,11,15]9</code></pre><p>输出：</p><pre><code>[0,1]</code></pre><p>预期结果：</p><pre><code>[0,1]</code></pre><ul><li>解题思路：使用双重 for 循环，不过这样时间复杂度为 O(N^2)，空间复杂度为 O(1)，时间复杂度较高，我们要想办法进行优化。</li></ul><h2 id="解法-Map"><a href="#解法-Map" class="headerlink" title="解法 - Map"></a>解法 - Map</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {number[]} nums * @param {number} target * @return {number[]} */</span><span class="token keyword">var</span> twoSum <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> diff <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span>        <span class="token punctuation">}</span>        map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>[2,7,11,15]9</code></pre><p>输出：</p><pre><code>[0,1]</code></pre><p>预期结果：</p><pre><code>[0,1]</code></pre><ul><li>我们可以增加一个 Map 记录已经遍历过的数字及其对应的索引值。这样当遍历一个新数字的时候去 Map 里查询，target 与该数的差值是否已经在前面的数字中出现过。如果出现过，那么已经得出答案，就不必再往下执行了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-常见面试题系列之JS基础</title>
      <link href="/2020/01/01/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-html-ji-chu/"/>
      <url>/2020/01/01/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-html-ji-chu/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><p>本系列旨在整理 HTML 考点的非重难点，帮助梳理 HTML 高频面试题。</p><h1 id="doctype-的作用是什么？"><a href="#doctype-的作用是什么？" class="headerlink" title="doctype 的作用是什么？"></a>doctype 的作用是什么？</h1><p>doctype 是 html5 标准的网页声明，必须声明在 html 文档的第一行。规定了浏览器的解析器以何种渲染模式来解析文档，不同的渲染模式会影响到浏览器对 css 甚至 js 脚本的解析。</p><p>解析模式有：</p><ul><li><p>BackCompat: 怪异模式，浏览器使用自己的怪异模式解析文档（默认值）。</p></li><li><p>CSS1Compat: 标准模式，浏览器使用 W3C 的标准解析文档。</p></li><li><p>近乎标准模式：IE8 有一种介乎于上述两者之间的近乎标准的模式。</p></li></ul><h2 id="这三者的区别是什么？"><a href="#这三者的区别是什么？" class="headerlink" title="这三者的区别是什么？"></a>这三者的区别是什么？</h2><ul><li><p>标准模式：页面会按照 HTML 与 CSS 的定义渲染。</p></li><li><p>怪异模式：页面会模拟更旧的浏览器的行为。</p></li><li><p>近乎标准模式： 会实施一种表单元格尺寸的怪异行为。</p></li></ul><h1 id="HTML、XHTML、XML-有什么区别？"><a href="#HTML、XHTML、XML-有什么区别？" class="headerlink" title="HTML、XHTML、XML 有什么区别？"></a>HTML、XHTML、XML 有什么区别？</h1><ul><li><p>HTML (超文本标记语言)：在 html4 之前，HTML 先有实现再有标准，导致 html 非常混乱。</p></li><li><p>XML (可扩展标记语言)：主要用于存储数据和结构，可扩展。</p></li><li><p>XHTML (可扩展超文本标记语言)：基于上面两者而来，W3C 为了解决 html 混乱问题而生，并基于此诞生了 HTML5。</p></li></ul><h1 id="什么是-data-属性？"><a href="#什么是-data-属性？" class="headerlink" title="什么是 data- 属性？"></a>什么是 data- 属性？</h1><p>html 的数据属性，用于将数据存储在标准的 html 元素中作为额为信息，可以用 js 访问并操作它。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span>    <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>electriccars<span class="token punctuation">"</span></span>    <span class="token attr-name">data-columns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span>    <span class="token attr-name">data-index-number</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>12321<span class="token punctuation">"</span></span>    <span class="token attr-name">data-parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cars<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span></code></pre><pre><code>前端框架出现后，这种方法已经不流行了</code></pre><h1 id="你对-HTML-语义化的理解？"><a href="#你对-HTML-语义化的理解？" class="headerlink" title="你对 HTML 语义化的理解？"></a>你对 HTML 语义化的理解？</h1><p>语义化指运用恰当语义的 html 标签，使页面具有良好的结构与定义。</p><p>语义化的好处：</p><ul><li><p>开发者友好：增强了可读性，开发者可以清晰地看出网页的结构。</p></li><li><p>机器友好：便于搜索引擎的爬虫爬取有效的信息。</p></li></ul><h1 id="HTML4-与-HTML5-的不同之处？"><a href="#HTML4-与-HTML5-的不同之处？" class="headerlink" title="HTML4 与 HTML5 的不同之处？"></a>HTML4 与 HTML5 的不同之处？</h1><ul><li><p>文档类型声明 (&lt;!DOCTYPE&gt;) 仅有一型：&lt;!DOCTYPE HTML&gt;。</p></li><li><p>新的解析顺序：不再基于 SGML。</p></li><li><p>新的元素：section、video、progress、nav、meter、time、footer、header、summary、source等。</p></li><li><p>input 元素的新类型：date、email、url等。</p></li><li><p>全域属性：id、tabindex、repeat 等。</p></li><li><p>新的全域属性：contenteditable, contextmenu, draggable, dropzone, hidden, spellcheck。</p></li><li><p>移除元素：acronym, applet, basefont, big, center, dir, font, frame, frameset, isindex, noframes, strike。</p></li></ul><h1 id="有哪些常用的-meta-标签？"><a href="#有哪些常用的-meta-标签？" class="headerlink" title="有哪些常用的 meta 标签？"></a>有哪些常用的 meta 标签？</h1><p>meta 标签用于描述一个 html 文档的元信息，如：作者、日期和时间等。</p><ul><li>charset：用于描述 html 文档的编码形式。</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ul><li>viewport：控制视口的大小和比例。</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1, maximum-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ul><li>http-equiv：相当于 http 的文件头作用。</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>expires<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Web, 20 Jun 2020 22:28:00 GMT<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ul><li>app-mobile-web-app-status-bar-style：自定义苹果工具栏的颜色。</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app-mobile-web-app-status-bar-style<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>black-translucent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h1 id="href-和-src-的区别？"><a href="#href-和-src-的区别？" class="headerlink" title="href 和 src 的区别？"></a>href 和 src 的区别？</h1><ul><li><p>src：指向外部资源，指向的内容会下载并嵌入到文档中当前标签所在的位置。当浏览器解析到该元素时，会暂停其它资源的下载和处理，直到当前资源加载、编译、执行完毕。</p></li><li><p>href：指向网络资源所在位置，用来建立和当前元素或文档之间的连接，当浏览器识别到它所指向的文件时，则会并行下载资源。</p></li></ul><h2 id="img-的-srcset-作用是什么？"><a href="#img-的-srcset-作用是什么？" class="headerlink" title="img 的 srcset 作用是什么？"></a>img 的 srcset 作用是什么？</h2><p>使用 img 的 两个新属性 srcset 和 sizes 来提供更多额外的资源图像和提示，帮助浏览器选择一个正确的资源。</p><p>srcset 定义了我们允许浏览器选择的图像集以及每个图像的大小。</p><p>sizes 定义了一组媒体条件，并指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。</p><p>有了这些属性，浏览器会：</p><ul><li><p>查看设备宽度</p></li><li><p>检查 sizes 哪个媒体条件为真</p></li><li><p>查看给予该媒体查询的槽大小</p></li><li><p>加载 srcset 中引用的最接近所选的槽的大小的图像</p></li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clock-demo-thumb-200.png<span class="token punctuation">"</span></span>     <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Clock<span class="token punctuation">"</span></span>     <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clock-demo-thumb-200.png 200w,             clock-demo-thumb-400.png 400w<span class="token punctuation">"</span></span>     <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(min-width: 600px) 200px, 50vw<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h2 id="还有哪一个标签能起到和-srcset-类似作用？"><a href="#还有哪一个标签能起到和-srcset-类似作用？" class="headerlink" title="还有哪一个标签能起到和 srcset 类似作用？"></a>还有哪一个标签能起到和 srcset 类似作用？</h2><p><picture> 元素通过包含零个或多个 <source> 元素和一个 <img> 元素来为不同的显示、设备场景提供图像版本。浏览器会选择最匹配的子 <source> 元素，如果没有匹配的，就会选择 <img> 元素的 src 属性中的 url。</picture></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/media/examples/surfer-240-200.jpg<span class="token punctuation">"</span></span>            <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(min-width: 800px)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/media/examples/painted-hand-298-332.jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span></code></pre><h1 id="script-标签中-defer-和-async-的区别？"><a href="#script-标签中-defer-和-async-的区别？" class="headerlink" title="script 标签中 defer 和 async 的区别？"></a>script 标签中 defer 和 async 的区别？</h1><ul><li><p>defer：异步加载脚本，等待文档被解析完毕后执行。</p></li><li><p>async：异步加载脚本，加载完毕后立即执行。</p></li></ul><h1 id="有几种前端存储方式？"><a href="#有几种前端存储方式？" class="headerlink" title="有几种前端存储方式？"></a>有几种前端存储方式？</h1><p>cookie、localStorage、sessionStorage、indexedDB</p><h2 id="这些方式的区别？"><a href="#这些方式的区别？" class="headerlink" title="这些方式的区别？"></a>这些方式的区别？</h2><ul><li><p>cookie：优点是兼容性好，请求头自带 cookie 方便。缺点是大小只有4k，自动请求头加入 cookie 浪费流量，每个 domain 限制20 个 cookie。</p></li><li><p>localStorage：优点是操作方便，永久性存储，大小为 5M，缺点是只能手动删除。</p></li><li><p>sessionStorage：与 localStorage 基本类似。区别是当页面关闭后会清理。不能在所有同源窗口中被共享。</p></li><li><p>indexedDB：标准的数据库存储方案，是 NoSQL 数据库，用键值对进行存储，可快速读取。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-常见面试题系列之JS基础</title>
      <link href="/2019/11/25/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-js-ji-chu/"/>
      <url>/2019/11/25/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-js-ji-chu/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><p>本系列旨在整理 JS 常见面试题，帮助梳理 JS 基础知识点。</p><h3 id="🌰-‘1’-‘2’-‘3’-map-parseInt-输出结果"><a href="#🌰-‘1’-‘2’-‘3’-map-parseInt-输出结果" class="headerlink" title="🌰 [‘1’, ‘2’, ‘3’].map(parseInt) 输出结果"></a>🌰 [‘1’, ‘2’, ‘3’].map(parseInt) 输出结果</h3><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h4><p>解析一个字符串参数，返回一个指定基数的整数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> intValue <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>string<span class="token punctuation">[</span><span class="token punctuation">,</span> radix<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串。字符串开头的空白符会被忽略。</p><p>radix 一个介于 2~36之间的整数，表示上述字符串的基数，默认值为 10。</p><p>parseInt 返回一个整数或 NaN。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 100</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1*10*10 + 0*10*1 + 0*10*0 = 100</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1*2*2 + 0*2*1 + 0*2*0 = 4</span></code></pre><p>在 radix 为 undefined ，或 radix 为 0 或没有指定的情况下，JS 作如下处理：</p><ul><li><p>string 以 ‘0x’ 或 ‘0X’ 开头，则 radix 为 16。</p></li><li><p>string 以 ‘0’ 开头，radix 为 8 或者 10，具体哪个基数由实现环境决定。</p></li><li><p>string 以其它任何值开头，则 radix 为 10。</p></li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> new_array <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span>currentValue<span class="token punctuation">[</span><span class="token punctuation">,</span>index<span class="token punctuation">[</span><span class="token punctuation">,</span> array<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Return element for new_array</span> <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">,</span> thisArg<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>callback 回调函数需要三个参数，分别为 currentValue(数组中当前正在处理的元素的值)、index(数组中当前正在处理的元素的索引)、array(map 方法中被调用的数组)。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>num <span class="token operator">=</span><span class="token operator">></span> num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [2, 4, 6]</span></code></pre><h4 id="‘1’-‘2’-‘3’-map-parseInt-输出"><a href="#‘1’-‘2’-‘3’-map-parseInt-输出" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt) 输出"></a>[‘1’, ‘2’, ‘3’].map(parseInt) 输出</h4><p>对于每个迭代 map，parseInt() 传递两个参数：字符串和基数。所以实际执行的代码为：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">parseInt</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>执行步骤为：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 (10 进制)</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// NaN radix(2-36)</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// NaN 不符合2进制位数取值(0-1)</span></code></pre><p>所以：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [1, NaN, NaN]</span></code></pre><h3 id="🌰-什么是节流和防抖？区别？如何实现？"><a href="#🌰-什么是节流和防抖？区别？如何实现？" class="headerlink" title="🌰 什么是节流和防抖？区别？如何实现？"></a>🌰 什么是节流和防抖？区别？如何实现？</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>动作绑定事件，动作发生后一定时间内触发时间，在这段时间内如果该动作又发生，则重新等待一定时间再触发事件。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * 防抖 debounce 定时器 * @param fn {function} 回调函数 * @param wait {number} 时间间隔 * @author wangxiaobai */</span><span class="token keyword">export</span> <span class="token keyword">function</span> debounce <span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 清除上次执行得定时器</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 设立新定时器</span>    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>动作绑定事件，动作发生后一定时间内触发事件，在这段时间内如果该动作又发生，则无视该动作，直到事件执行完后，才能重新触发。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * 节流 throttle 定时器 * @param fn {function} 回调函数 * @param wait {number} 时间间隔 * @author wangxiaobai */</span><span class="token keyword">export</span> <span class="token keyword">function</span> throttle <span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 上一次函数的执行时间  </span>  <span class="token keyword">let</span> activeTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> currentTime <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTime <span class="token operator">-</span> activeTime <span class="token operator">></span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>          fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>          activeTime <span class="token operator">=</span> currentTime<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="🌰-Set、Map、WeakSet、WeakMap"><a href="#🌰-Set、Map、WeakSet、WeakMap" class="headerlink" title="🌰 Set、Map、WeakSet、WeakMap"></a>🌰 Set、Map、WeakSet、WeakMap</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>一种叫做集合的数据结构，类似于数组，成员唯一且无序。</p><pre class=" language-text"><code class="language-text">new Set([iterable])</code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1 2 3 4</span><span class="token punctuation">}</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token operator">...</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3]</span></code></pre><p>Set 允许你存储任何类型的唯一值，无论是原始值还是对象引用。</p><p>向 Set 加入值的时候，不会发生类型转换，所以 5 和 ‘5’ 是两个不同的值。</p><p>在 Set 中，NaN 等于自身。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {NaN} </span><span class="token keyword">let</span> set1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {5, '5'}</span></code></pre><ul><li>Set 实例属性</li></ul><p>constructor: 构造函数</p><p>size: 元素数量</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span></code></pre><ul><li>Set 实例方法</li></ul><p>操作方法：</p><p>add(value) 新增</p><p>delete(value) 存在即删除集合中的 value</p><p>has(value) 判断集合中是否存在 value</p><p>clear() 清空集合</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0</span></code></pre><p>Array.from 可以将 Set 结构转化为数组    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> array <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3]</span><span class="token comment" spellcheck="true">// 或</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>items<span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3]</span></code></pre><p>遍历方法：</p><p>keys() 返回一个包含集合中所有键的迭代器</p><p>values() 返回一个包含集合中所有值的迭代器</p><p>entries() 返回一个包含集合中所有键值对的迭代器</p><p>forEach(callbackFn, thisArg)</p><p>map(callbackFn, thisArg)</p><p>filter(callbackFn, thisArg)</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SetIterator {1, 2, 3}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SetIterator {1, 2, 3}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SetIterator {1 => 1, 2 => 2, 3 => 3}</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">' : '</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1:1 2:2 3:3</span><span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">set</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// {2, 4, 6}</span><span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">set</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>item <span class="token operator">>=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// {4, 6}</span></code></pre><p>因此，Set 很容易实现两个数组的交集、并集、差集</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> set1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> set2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> intersect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>set1<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> set2<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> union <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>set1<span class="token punctuation">,</span> <span class="token operator">...</span>set2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> difference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>set1<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">!</span>set2<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>intersect<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {2, 3}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>union<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {1, 2, 3, 4}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>difference<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {1}</span></code></pre><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>允许你将弱引用对象储存在一个集合中。</p><p>WeakSet 与 Set 的区别：</p><ul><li><p>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</p></li><li><p>WeakSet 中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的引用，如果没有其它的变量或属性引用这个对象值，则这个对象或被垃圾回收掉</p></li></ul><p>属性：</p><p>constructor: 构造函数</p><p>方法：</p><p>add(value) 添加元素 value</p><p>has(value) 判断是否包含 value</p><p>delete(value) 删除 value</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>ws<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>ws<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>ws<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span></code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>一种叫做字典的数据结构，以 [key, value] 的形式存储</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>    p<span class="token punctuation">:</span> <span class="token string">'haha'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'content'</span>m<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>m<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span></code></pre><p>任何具有 Iterator 接口，每个成员都是一个双元素的数组的数据结构都可以当做 Map 构造函数的参数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'Author'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "张三"</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "Author"</span><span class="token keyword">const</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m1<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'baz'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> m3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span><span class="token punctuation">;</span>m3<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'baz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span></code></pre><p>如果读取一个未知的键，则返回undefined。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'asfddfsasadf'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined</span></code></pre><p>只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined</span></code></pre><p>Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'true'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span></code></pre><p>属性：</p><p>constructor：构造函数</p><p>size: 字典中所包含的元素个数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'An'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">'des'</span><span class="token punctuation">,</span> <span class="token string">'JS'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span></code></pre><p>操作方法：</p><p>set(key, value) 添加新元素</p><p>get(key) 通过键查找特定的数值并返回</p><p>has(key) 判断字典中是否存在 key</p><p>delete(key) 通过键 key 从字典中移除对应的数据</p><p>clear() 字典中所有元素删除</p><p>遍历方法：</p><p>keys() 将字典中包含的所有键名以迭代器形式返回</p><p>values() 将字典中包含的所有数值以迭代器形式返回</p><p>entries() 返回所有成员的迭代器</p><p>forEach() 遍历字典的所有成员</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>            <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'An'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">[</span><span class="token string">'des'</span><span class="token punctuation">,</span> <span class="token string">'JS'</span><span class="token punctuation">]</span>        <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// MapIterator {"name" => "An", "des" => "JS"}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// MapIterator {"name", "des"}</span></code></pre><p>与其它数据结构相互转换</p><ol><li>Map 转 Array</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>map<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [[1, 1], [2, 2], [3, 3]]</span></code></pre><ol><li>Array 转 map</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Map {1 => 1, 2 => 2, 3 => 3}</span></code></pre><ol><li>Map 转 Object</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">mapToObj</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>        obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> obj<span class="token punctuation">}</span><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'An'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'des'</span><span class="token punctuation">,</span> <span class="token string">'JS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mapToObj</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// {name: "An", des: "JS"}</span></code></pre><ol><li>Object 转 Map</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">objToMap</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> obj<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> map<span class="token punctuation">}</span><span class="token function">objToMap</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'An'</span><span class="token punctuation">,</span> <span class="token string">'des'</span><span class="token punctuation">:</span> <span class="token string">'JS'</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Map {"name" => "An", "des" => "JS"}</span></code></pre><ol><li>Map 转 JSON</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">mapToJson</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>map<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'An'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'des'</span><span class="token punctuation">,</span> <span class="token string">'JS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mapToJson</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// [["name","An"],["des","JS"]]</span></code></pre><ol><li>JSON 转 Map</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">jsonToStrMap</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">objToMap</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">jsonToStrMap</span><span class="token punctuation">(</span><span class="token string">'{"name": "An", "des": "JS"}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Map {"name" => "An", "des" => "JS"}</span></code></pre><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap 对象是一组键值对的集合，其中键是弱引用对象，而值可以是任意。</p><p>每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收。</p><p>属性：</p><p>constructor: 构造函数</p><p>方法：</p><p>has(key)：判断是否有 key 关联对象</p><p>get(key)：返回key关联对象（没有则则返回 undefined）</p><p>set(key)：设置一组key关联对象</p><p>delete(key)：移除 key 的关联对象</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>Set</li></ul><p>成员唯一、无序</p><p>可以遍历</p><ul><li>WeakSet</li></ul><p>成员都是对象</p><p>成员都是弱引用，可以被垃圾回收机制回收</p><p>不能遍历</p><ul><li>Map</li></ul><p>本质是键值对的集合</p><p>可以遍历</p><ul><li>WeakMap</li></ul><p>只接受对象作为键名</p><p>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收机制回收</p><p>不能遍历</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-源码系列随读笔记之Array变化侦测</title>
      <link href="/2019/08/18/vue/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-array-bian-hua-zhen-ce/"/>
      <url>/2019/08/18/vue/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-array-bian-hua-zhen-ce/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档</p></blockquote><a id="more"></a><h3 id="什么是变化侦测"><a href="#什么是变化侦测" class="headerlink" title="什么是变化侦测"></a>什么是变化侦测</h3><p>从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。</p><p>简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。</p><p>Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。</p><hr><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> defineReactive <span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>     enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> val     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span>         <span class="token punctuation">}</span>        val <span class="token operator">=</span> newVal     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。</p><p>由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。</p><hr><h3 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h3><p>思考以下问题：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> globalObj <span class="token operator">=</span> <span class="token punctuation">{</span>  text1<span class="token punctuation">:</span> <span class="token string">'text1'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  template<span class="token punctuation">:</span>    <span class="token template-string"><span class="token string">`&lt;div>       &lt;span>{{text1}}&lt;/span>     &lt;div>`</span></span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> globalObj<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  template<span class="token punctuation">:</span>     <span class="token template-string"><span class="token string">`&lt;div>        &lt;span>{{text1}}&lt;/span>      &lt;div>`</span></span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> globalObj<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？</p><p>对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。</p><p>即：在 getter 中收集依赖，在 setter 中触发依赖。</p><hr><h3 id="依赖收集到哪里（Dep）"><a href="#依赖收集到哪里（Dep）" class="headerlink" title="依赖收集到哪里（Dep）"></a>依赖收集到哪里（Dep）</h3><p> 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>  constructor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 观察者集合</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 添加观察者</span>  addSub <span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 移除观察者</span>  removeSub <span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">,</span> sub<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  depend <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果存在 Dep.target，则进行依赖收集操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  notify <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 避免污染原来的集合</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 更新</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">remove</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>改造 defineReactive</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> defineReactive <span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>     enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> val     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span>         <span class="token punctuation">}</span>        val <span class="token operator">=</span> newVal        dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><hr><h3 id="什么是依赖"><a href="#什么是依赖" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。</p><p>然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。</p><p>收集谁？Watcher!</p><hr><h3 id="什么是-Watcher"><a href="#什么是-Watcher" class="headerlink" title="什么是 Watcher"></a>什么是 Watcher</h3><p>Watcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。</p><pre class=" language-javascript"><code class="language-javascript">vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'a.b.c'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// do something</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。</p><p>把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  constructor <span class="token punctuation">(</span>    vm<span class="token punctuation">:</span> Component<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 组件实例</span>    expOrFn<span class="token punctuation">:</span> string <span class="token operator">|</span> Function<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 要观察的表达式，函数，或者字符串，只要能触发取值操作</span>    cb<span class="token punctuation">:</span> Function <span class="token comment" spellcheck="true">// 被观察者发生变化后的回调</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm <span class="token comment" spellcheck="true">// Watcher有一个 vm 属性，表明它是属于哪个组件的</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb <span class="token comment" spellcheck="true">// 回调</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>expOrFn<span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 触发取值操作，进而触发属性的getter</span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>getter<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">)</span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">return</span> value  <span class="token punctuation">}</span>  update <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 更新</span>    <span class="token keyword">const</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cb<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。</p><p>在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。</p><p>只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。</p><p>依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。</p><p>不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。</p><p>parsePath函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> bailRE <span class="token operator">=</span> <span class="token regex">/[^\w.$]/</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bailRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> segments <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">)</span> <span class="token keyword">return</span>          obj <span class="token operator">=</span> obj<span class="token punctuation">[</span>segments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> obj    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="递归侦测所有Key"><a href="#递归侦测所有Key" class="headerlink" title="递归侦测所有Key"></a>递归侦测所有Key</h3><p>前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    constructor <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    walk <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            defineReactive <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> obj<span class="token punctuation">[</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>       enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>       configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>       <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> val       <span class="token punctuation">}</span><span class="token punctuation">,</span>       <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span>           <span class="token punctuation">}</span>          val <span class="token operator">=</span> newVal          dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>Observer 类，用于将一个正常的 object 转换成被侦测的 object。</p><p>判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。</p><p>最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。</p><p>当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。</p><p>Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。</p><p>我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。</p><p>收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。</p><p>所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。</p><p>Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。</p><p>由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。</p><p>在 Vue 中，对象新增属性或删除属性都无法被侦测到。</p><p><img src="https://screenshot.net/zh/qv9nwto" alt=""></p><p>Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。</p><p>当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。</p><p>当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。</p><p>Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node-NodeJS核心基础知识</title>
      <link href="/2019/06/26/node/node-nodejs-he-xin-ji-chu-zhi-shi/"/>
      <url>/2019/06/26/node/node-nodejs-he-xin-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…</p></blockquote><a id="more"></a><h3 id="Nodejs-概述"><a href="#Nodejs-概述" class="headerlink" title="Nodejs 概述"></a>Nodejs 概述</h3><p>Nodejs 是基于 Chrome V8 引擎构建的，由事件循环分布 I/O 任务，最终工作线程会将任务放到线程池中执行，而事件循环等待执行结果就可以了。</p><ul><li><p>Nodejs 是 Javascript 的运行时环境。</p></li><li><p>Nodejs 构建在 Chrome V8 这个著名的 Javascript 引擎上。</p></li><li><p>Nodejs 每个函数都是同步的，而 I/O 操作是异步的。</p></li><li><p>Nodejs 使用 npm 作为包管理器。</p></li></ul><h3 id="Nodejs-安装"><a href="#Nodejs-安装" class="headerlink" title="Nodejs 安装"></a>Nodejs 安装</h3><p>Nodejs 支持 macOS、Linux 以及 Windows 等多个主流操作系统。</p><h4 id="3m-安装法"><a href="#3m-安装法" class="headerlink" title="3m 安装法"></a>3m 安装法</h4><ul><li><p>nvm 开源的 Nodejs 版本管理器</p></li><li><p>npm Nodejs 包管理端</p></li><li><p>nrm 解决 npm 镜像访问慢的问题。</p></li></ul><h5 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h5><h6 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h6><p>首先，在终端执行如下命令：</p><pre class=" language-javascript"><code class="language-javascript">$ curl <span class="token operator">-</span>o<span class="token operator">-</span> https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span>creationix<span class="token operator">/</span>nvm<span class="token operator">/</span>v0<span class="token number">.33</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">/</span>install<span class="token punctuation">.</span>sh <span class="token operator">|</span> bash</code></pre><p>意思是通过 curl 命令下载 install.sh 脚本并执行。执行完成后，重新打开终端窗口，执行</p><pre class=" language-javascript"><code class="language-javascript">vi <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>zshrc</code></pre><p>把 nvm 命令的执行路径放到 ~/.zshrc 文件下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> NVM_DIR<span class="token operator">=</span><span class="token string">"$HOME/.nvm"</span><span class="token punctuation">[</span> <span class="token operator">-</span>s <span class="token string">"$NVM_DIR/nvm.sh"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span> <span class="token string">"$NVM_DIR/nvm.sh"</span></code></pre><p>执行 source 命令，使系统环境变量生效：</p><pre class=" language-javascript"><code class="language-javascript">source <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>zshrc</code></pre><p>输入：</p><pre class=" language-javascript"><code class="language-javascript">nvm <span class="token operator">--</span>version<span class="token number">0.33</span><span class="token punctuation">.</span><span class="token number">1</span></code></pre><h6 id="查看可安装的-Nodejs-版本"><a href="#查看可安装的-Nodejs-版本" class="headerlink" title="查看可安装的 Nodejs 版本"></a>查看可安装的 Nodejs 版本</h6><p>安装 Node 之前，需要了解通过 nvm 可以安装哪些版本的 Node。</p><pre class=" language-javascript"><code class="language-javascript">nvm ls<span class="token operator">-</span>remote</code></pre><ul><li><p>LTS 版本是指长期支持版本，推荐给大部分用户使用，一般在生产环境中使用。</p></li><li><p>Current 版本是指当前正在开发的尝鲜版本，不完全版本，需要经过一段时间的测试、开发和修复 bug 等才能变为 LTS 版本，一般供开发者学习。</p></li></ul><h6 id="安装-Node"><a href="#安装-Node" class="headerlink" title="安装 Node"></a>安装 Node</h6><pre class=" language-javascript"><code class="language-javascript">nvm install <span class="token number">10.15</span><span class="token punctuation">.</span><span class="token number">3</span></code></pre><p>通过 nvm 安装的 Node 位于用户目录下，而非系统目录下。</p><pre class=" language-javascript"><code class="language-javascript">which node<span class="token operator">/</span>Users<span class="token regex">/wangqian/</span><span class="token punctuation">.</span>nvm<span class="token operator">/</span>versions<span class="token operator">/</span>node<span class="token operator">/</span>v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token operator">/</span>bin<span class="token operator">/</span>node</code></pre><p>默认使用某个 Node 版本来编译代码，需要手动指定一个 default 别名。</p><pre class=" language-javascript"><code class="language-javascript">nvm alias <span class="token keyword">default</span> node<span class="token keyword">default</span> <span class="token operator">-</span><span class="token operator">></span> node <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre><p>此时，输入 node -v，以后在终端的任何地方使用的默认版本都会是你设置的版本。</p><pre class=" language-javascript"><code class="language-javascript">node <span class="token operator">-</span>vv10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span></code></pre><p>如何使用 nvm 切换 Node 版本？首先安装 Node 8.x</p><pre class=" language-javascript"><code class="language-javascript">nvm install <span class="token number">8</span></code></pre><p>切换到 8.x 版本：</p><pre class=" language-javascript"><code class="language-javascript">nvm use <span class="token number">8</span>Now using node v8<span class="token number">.16</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">(</span>npm v6<span class="token number">.4</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">)</span>node <span class="token operator">-</span>vv8<span class="token number">.16</span><span class="token punctuation">.</span><span class="token number">0</span></code></pre><p>如何知道本机通过 nvm 安装了哪些 Node 版本呢？</p><pre class=" language-javascript"><code class="language-javascript">nvm ls<span class="token operator">-</span><span class="token operator">></span>      v8<span class="token number">.16</span><span class="token punctuation">.</span><span class="token number">0</span>       v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token keyword">default</span> <span class="token operator">-</span><span class="token operator">></span> node <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span>node <span class="token operator">-</span><span class="token operator">></span> stable <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span>stable <span class="token operator">-</span><span class="token operator">></span> <span class="token number">10.15</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span>iojs <span class="token operator">-</span><span class="token operator">></span> N<span class="token operator">/</span>A <span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span>lts<span class="token operator">/</span><span class="token operator">*</span> <span class="token operator">-</span><span class="token operator">></span> lts<span class="token operator">/</span>dubnium <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> N<span class="token operator">/</span>A<span class="token punctuation">)</span>lts<span class="token operator">/</span>argon <span class="token operator">-</span><span class="token operator">></span> v4<span class="token number">.9</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> N<span class="token operator">/</span>A<span class="token punctuation">)</span>lts<span class="token operator">/</span>boron <span class="token operator">-</span><span class="token operator">></span> v6<span class="token number">.17</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> N<span class="token operator">/</span>A<span class="token punctuation">)</span>lts<span class="token operator">/</span>carbon <span class="token operator">-</span><span class="token operator">></span> v8<span class="token number">.16</span><span class="token punctuation">.</span><span class="token number">0</span>lts<span class="token operator">/</span>dubnium <span class="token operator">-</span><span class="token operator">></span> v10<span class="token number">.16</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> N<span class="token operator">/</span>A<span class="token punctuation">)</span></code></pre><p>若要经常切换 Node 版本，最痛苦的莫过于全局模块需要重新安装。针对这种情况，nvm 提供了一个很贴心的一键安装全局模块的 nvm reinstall-packages命令。</p><pre class=" language-javascript"><code class="language-javascript">nvm reinstall<span class="token operator">-</span>packages <span class="token number">6</span></code></pre><p>nvm 默认远端下载地址是 <a href="https://nodejs.org/dist，如果想安装自定义的" target="_blank" rel="external">https://nodejs.org/dist，如果想安装自定义的</a> Node 版本，可以指定 nvm 的远端下载地址。</p><pre class=" language-javascript"><code class="language-javascript">NVM_NODEJS_ORG_MIRROR<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>nodejs<span class="token punctuation">.</span>org<span class="token operator">/</span>download<span class="token operator">/</span>chakracore<span class="token operator">-</span>nightly</code></pre><p>对于一些正在测试的尝鲜版本，可以在下面的地址下载。</p><pre class=" language-javascript"><code class="language-javascript">NVM_NODEJS_ORG_MIRROR<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>nodejs<span class="token punctuation">.</span>org<span class="token operator">/</span>download<span class="token operator">/</span>test</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-源码系列随读笔记之Object变化侦测</title>
      <link href="/2019/05/16/vue/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-object-bian-hua-zhen-ce/"/>
      <url>/2019/05/16/vue/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-object-bian-hua-zhen-ce/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档</p></blockquote><a id="more"></a><h3 id="什么是变化侦测"><a href="#什么是变化侦测" class="headerlink" title="什么是变化侦测"></a>什么是变化侦测</h3><p>从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。</p><p>简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。</p><p>Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。</p><hr><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> defineReactive <span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>     enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> val     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span>         <span class="token punctuation">}</span>        val <span class="token operator">=</span> newVal     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。</p><p>由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。</p><hr><h3 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h3><p>思考以下问题：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> globalObj <span class="token operator">=</span> <span class="token punctuation">{</span>  text1<span class="token punctuation">:</span> <span class="token string">'text1'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  template<span class="token punctuation">:</span>    <span class="token template-string"><span class="token string">`&lt;div>       &lt;span>{{text1}}&lt;/span>     &lt;div>`</span></span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> globalObj<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  template<span class="token punctuation">:</span>     <span class="token template-string"><span class="token string">`&lt;div>        &lt;span>{{text1}}&lt;/span>      &lt;div>`</span></span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> globalObj<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？</p><p>对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。</p><p>即：在 getter 中收集依赖，在 setter 中触发依赖。</p><hr><h3 id="依赖收集到哪里（Dep）"><a href="#依赖收集到哪里（Dep）" class="headerlink" title="依赖收集到哪里（Dep）"></a>依赖收集到哪里（Dep）</h3><p> 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>  constructor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 观察者集合</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 添加观察者</span>  addSub <span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 移除观察者</span>  removeSub <span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">,</span> sub<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  depend <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果存在 Dep.target，则进行依赖收集操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  notify <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 避免污染原来的集合</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 更新</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">remove</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>改造 defineReactive</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> defineReactive <span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>     enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> val     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span>         <span class="token punctuation">}</span>        val <span class="token operator">=</span> newVal        dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><hr><h3 id="什么是依赖"><a href="#什么是依赖" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。</p><p>然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。</p><p>收集谁？Watcher!</p><hr><h3 id="什么是-Watcher"><a href="#什么是-Watcher" class="headerlink" title="什么是 Watcher"></a>什么是 Watcher</h3><p>Watcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。</p><pre class=" language-javascript"><code class="language-javascript">vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'a.b.c'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// do something</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。</p><p>把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  constructor <span class="token punctuation">(</span>    vm<span class="token punctuation">:</span> Component<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 组件实例</span>    expOrFn<span class="token punctuation">:</span> string <span class="token operator">|</span> Function<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 要观察的表达式，函数，或者字符串，只要能触发取值操作</span>    cb<span class="token punctuation">:</span> Function <span class="token comment" spellcheck="true">// 被观察者发生变化后的回调</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm <span class="token comment" spellcheck="true">// Watcher有一个 vm 属性，表明它是属于哪个组件的</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb <span class="token comment" spellcheck="true">// 回调</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>expOrFn<span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 触发取值操作，进而触发属性的getter</span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>getter<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">)</span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">return</span> value  <span class="token punctuation">}</span>  update <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 更新</span>    <span class="token keyword">const</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cb<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。</p><p>在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。</p><p>只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。</p><p>依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。</p><p>不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。</p><p>parsePath函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> bailRE <span class="token operator">=</span> <span class="token regex">/[^\w.$]/</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bailRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> segments <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">)</span> <span class="token keyword">return</span>          obj <span class="token operator">=</span> obj<span class="token punctuation">[</span>segments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> obj    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="递归侦测所有Key"><a href="#递归侦测所有Key" class="headerlink" title="递归侦测所有Key"></a>递归侦测所有Key</h3><p>前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    constructor <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    walk <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            defineReactive <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> obj<span class="token punctuation">[</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>       enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>       configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>       <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> val       <span class="token punctuation">}</span><span class="token punctuation">,</span>       <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span>           <span class="token punctuation">}</span>          val <span class="token operator">=</span> newVal          dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>Observer 类，用于将一个正常的 object 转换成被侦测的 object。</p><p>判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。</p><p>最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。</p><p>当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。</p><p>Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。</p><p>我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。</p><p>收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。</p><p>所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。</p><p>Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。</p><p>由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。</p><p>在 Vue 中，对象新增属性或删除属性都无法被侦测到。</p><p><img src="https://screenshot.net/zh/qv9nwto" alt=""></p><p>Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。</p><p>当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。</p><p>当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。</p><p>Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node-阿里云ECS部署</title>
      <link href="/2018/11/27/node/node-a-li-yun-ecs-bu-shu/"/>
      <url>/2018/11/27/node/node-a-li-yun-ecs-bu-shu/</url>
      
        <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？</p></blockquote><a id="more"></a><p>此教程仅供新手借鉴，多少有些缺陷，有问题还望各位大佬指正。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>一个域名</li><li>阿里云ECS(实例镜像：CentOS7.4)</li><li>如果使用Windows，推荐xshell。如果是Mac，推荐iTerm2</li></ul><p>(注：因本人使用Mac，以下均已Mac为主)</p><hr><h3 id="终端连接服务器"><a href="#终端连接服务器" class="headerlink" title="终端连接服务器"></a>终端连接服务器</h3><ul><li>打开iTerm2，输入连接命令ssh username@ip公网地址，回车，输入你在购买服务器时设置的密码。</li></ul><p><img src="http://images.gitbook.cn/fb945240-f68e-11e7-b8d1-49d5de1a2fe1" alt=""></p><ul><li>密码输入正确，进入服务器。</li></ul><p><img src="http://images.gitbook.cn/8a21b2f0-f68f-11e7-b8d1-49d5de1a2fe1" alt=""></p><p>cd / 进入根目录，创建一个空目录 mkdir soft，用来放我们的安装包。</p><hr><h3 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h3><p>下载node包。</p><pre><code>wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz</code></pre><p>下载完成后，进行压缩包解压。</p><pre><code>tar -zxvf v8.9.4.tar.gz</code></pre><p>进入解压好的目录并执行config配置命令。</p><pre><code>cd node-v8.9.4 &amp;&amp; ./configure</code></pre><p>执行编译及安装命令。</p><pre><code>make &amp;&amp; make install</code></pre><p>经过漫长的等待之后，一个node环境就安装好了。可以通过node -v 或者 npm -v来检查当前node/npm是否安装成功。</p><p><img src="http://images.gitbook.cn/aa87c390-f6e4-11e7-b0db-b9b8a7444865" alt=""></p><p>如果你需要升级node和npm版本，执行以下命令即可。</p><pre><code>npm i -g nn stable</code></pre><hr><h3 id="安装nrm和pm2"><a href="#安装nrm和pm2" class="headerlink" title="安装nrm和pm2"></a>安装nrm和pm2</h3><p>nrm是一个管理npm源的插件，方便切换国内外以及私人npm库。</p><p>pm2是node服务器的守护进程，方便管理当前服务器上的所有服务。</p><p>这里说一下cnpm，如果安装依赖包很慢或者根本没进度，输入命令</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>然后使用cnpm代替npm安装。</p><p>回到我们熟悉的soft目录。</p><hr><h4 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h4><p>安装nrm。</p><pre><code>npm install -g nrm</code></pre><p>常用命令：</p><ul><li>nrm add name address 添加新的源</li><li>nrm use name 切换到源</li><li>nrm ls 查看所有可用的源</li></ul><p><img src="http://images.gitbook.cn/ef923690-f6e5-11e7-b28d-519a9998aa5b" alt=""></p><hr><h4 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h4><p>安装pm2。</p><pre><code>npm install -g pm2</code></pre><p>常用命令：</p><ul><li>pm2 list 查看pm2守护服务</li><li>pm2 start index.js 启动一个pm2守护进程命令</li><li>pm2 restart id/name 重启一个pm2守护进程命令</li><li>pm2 delete id/name 删除一个正在使用的进程</li><li>pm2 delete all 删除所有正在使用的进程</li><li>pm2 monit 查看pm2的消耗</li></ul><p><img src="http://images.gitbook.cn/24e04d00-f6e6-11e7-b0db-b9b8a7444865" alt=""></p><hr><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>卸载已有的mysql。</p><pre><code>rpm -qa|grep -i mysqlyum remove &#39;mysql&#39;</code></pre><p>下载mysql源。</p><pre><code>// 5.7.24wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm</code></pre><p>安装下载的源。</p><pre><code>rpm -ivh mysql57-community-release-el7-7.noarch.rpm</code></pre><p>下载安装mysql。</p><pre><code>yum install mysql-serveryum install mysql-develyum install mysql</code></pre><p>启动mysql。</p><pre><code>service mysqld start</code></pre><p>常用命令：</p><ul><li>service mysqld status 查看mysql当前的状态</li><li>service mysqld stop 停止mysql</li><li>service mysqld restart 重启mysql</li><li>service mysqld start 启动mysql</li></ul><p>如果遇到错误：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket /var/lib/mysql/mysql.sock’，请在tmp下创建一个软连接：</p><pre><code>ln -s /tmp/mysql.sock /var/lib/mysql</code></pre><p>打开my.cnf并修改。</p><pre><code>vi /etc/my.cnf</code></pre><p><img src="http://images.gitbook.cn/4d980cc0-f6ea-11e7-9a49-93c72a04fa82" alt=""></p><p>重启数据库。</p><pre><code>service mysqld restart</code></pre><p>登录(默认root是没有密码的)。</p><pre><code>mysql -u root</code></pre><p>这时出现ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)，登录root帐号需要密码，现在我们没有设置密码，哪来的密码。</p><p>于是我们开始忘记密码的操作</p><p>第一步，在/etc/my.cnf文件中添加skip-grant-tables<br>第二步，重启mysql，service mysqld restart<br>第三步，登录mysql，mysql -u root<br>第四步，修改密码：</p><pre><code>mysql&gt;use mysql;mysql&gt;update mysql.user set authentication_string=password(&#39;your password&#39;) where user=&#39;root&#39;;mysql&gt;flush privileges;mysql&gt;exit;</code></pre><p>第五步，恢复/etc/my.cnf，将skip-grant-tables删除或者注释掉<br>第六步，重启mysql，service mysqld restart</p><p>分配用户</p><p>host指定该用户在哪个主机上可以登陆，此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录;也可以指定某台机器可以远程登录。</p><pre><code>CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;CREATE USER &#39;test&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39;;</code></pre><p>给创建的用户权限</p><ul><li>privileges 用户的操作权限,如SELECT，INSERT，UPDATE等.如果要授予所的权限则使用ALL</li><li>databasename 数据库名</li><li>tablename 表名,如果要授予该用户对所有数据库和表的相应操作权限则可用表示, 如.*.</li></ul><pre><code>GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;</code></pre><hr><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><p>Redis是一个非常好用的数据仓库，既可以做nosql数据库，也可以做缓存数据库。</p><p>下载安装包。</p><pre><code>wget http://download.redis.io/releases/redis-4.0.6.tar.gz</code></pre><p>解压并进入解压之后的文件夹。</p><pre><code>tar -zxvf redis-4.0.6.tar.gz &amp;&amp;cd redis-4.0.6</code></pre><p>编译并安装。</p><pre><code>make &amp;&amp; make install</code></pre><p>启动redis服务。</p><pre><code>redis-server redis.conf</code></pre><p><img src="http://images.gitbook.cn/9ab114d0-f82e-11e7-b753-f548c55dc4dd" alt=""></p><p>此时我们发现，不能再输入任何命令，因为redis-server已经占用了这个命令行客户端。我们需要再打开一个命令行工具并连接服务器。</p><p>使用redis客户端连接Redis服务，执行Redis文件夹下的redis-cli文件redis-cli，输入几个命令测试一下简单的set/get：</p><p><img src="http://images.gitbook.cn/c4d479e0-f82f-11e7-bec2-d1185e7bb6e2" alt=""></p><p>关掉客户端，redis服务也会停止。这时，我们就需要修改redis.conf文件，将daemonizede的值改为yes。</p><p><img src="http://images.gitbook.cn/afb6f050-f830-11e7-b753-f548c55dc4dd" alt=""></p><p>再次运行Redis的启动命令redis-server redis.conf，这次就不会占用命令行了，可以继续操作其他的，Redis服务也不会停止。</p><hr><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>nginx在转发请求，负载均衡等方面非常有用。它可以将几个不同的服务集中在一个80端口下，根据域名或者请求路径来区分。</p><p>在安装nginx之前，先要安装几个依赖插件。</p><pre><code>yum install -y pcre pcre-develyum install -y zlib zlib-devel</code></pre><p>安装openssl。</p><pre><code>yum install -y openssl openssl-devel</code></pre><p>下载nginx包。</p><pre><code>wget https://nginx.org/download/nginx-1.15.6.tar.gz</code></pre><p>解压并进入解压好的目录。</p><pre><code>tar -zxvf nginx-1.15.6.tar.gz &amp;&amp; cd nginx-1.15.6</code></pre><p>执行配置命令。</p><pre><code>./configure</code></pre><p>编译并安装。</p><pre><code>make &amp;&amp; make install</code></pre><p>查看安装结果。</p><pre><code>whereis nginx</code></pre><p><img src="http://images.gitbook.cn/d892e470-f835-11e7-b753-f548c55dc4dd" alt=""></p><p>跳转到安装好的nginx目录下，进入sbin目录。</p><pre><code>cd /usr/local/nginx/sbin</code></pre><p>启动nginx。</p><pre><code>./nginx</code></pre><p>常用命令：</p><ul><li>./nginx 启动nginx</li><li>./nginx -s stop 停止nginx</li><li>./nginx -s quit 退出nginx</li><li>./nginx -s reload 重启nginx</li></ul><hr><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>centOS上没有安装git，有需要的话，我们可以自己手动安装一下。</p><pre><code>yum install gitgit --version</code></pre><hr><h3 id="使用pm2启动项目"><a href="#使用pm2启动项目" class="headerlink" title="使用pm2启动项目"></a>使用pm2启动项目</h3><p>在本地搭建并测试好node项目，上传到GitHub。然后git clone一下。</p><p>配置ECS安全组规则，暴露3000接口。</p><p>如果项目中使用数据库，运行之前要先建立好数据库，然后再运行项目，登录数据库执行create database dabasename;</p><pre><code>git clone https://github.com/***cd ***cnpm ipm2 start index.js</code></pre><p>注：项目监听3000端口，如果顺利的话，项目已经运行起来了。<br>   可以使用pm2 list查看进程列表，使用pm2 log打印日志。</p><hr><h3 id="Linux常用操作指令列表"><a href="#Linux常用操作指令列表" class="headerlink" title="Linux常用操作指令列表"></a>Linux常用操作指令列表</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ssh username@ip</td><td>连接服务器</td></tr><tr><td>cd path</td><td>跳转到路径对应的目录下</td></tr><tr><td>rm filename</td><td>删除文件</td></tr><tr><td>rm -rf path</td><td>删除目录及目录下的所有文件</td></tr><tr><td>ls [-a]</td><td>查看当前目录下的文件和目录(-a：查看所有文件，包括隐藏文件)</td></tr><tr><td>ll</td><td>查看当前目录下的文件详情(文件权限)</td></tr><tr><td>pwd</td><td>查看当前路径的完整路径</td></tr><tr><td>which name</td><td>默认位置查找该名字</td></tr><tr><td>mkdir dirname</td><td>创建空目录</td></tr><tr><td>cat path</td><td>查看文件内容</td></tr><tr><td>cp origin target</td><td>复制一个文件到另一个地方</td></tr><tr><td>mv origin target</td><td>移动一个文件到另一个地方</td></tr><tr><td>ps -aux</td><td>显示当前进程</td></tr><tr><td>kill -9 processid</td><td>结束进程</td></tr><tr><td>tar -zxvf filename</td><td>解压文件</td></tr><tr><td>tar -zcvf filename</td><td>压缩文件</td></tr><tr><td>vi path</td><td>进入文件编辑模式</td></tr><tr><td>vi编辑文件，按下i进入编辑模式</td></tr><tr><td>vi退出文件，esc+:wq或esc+:x保存退出</td></tr><tr><td>vi退出文件，esc+:q或esc+:q!强制退出</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
