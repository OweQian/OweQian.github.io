<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>W | 个人博客 | web前端</title>
  
  <subtitle>wangxiaobai</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qiandream.cn/"/>
  <updated>2020-02-17T10:46:18.801Z</updated>
  <id>http://qiandream.cn/</id>
  
  <author>
    <name>wangxiaobai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://qiandream.cn/2020/02/17/js-lei-xing-pan-duan/"/>
    <id>http://qiandream.cn/2020/02/17/js-lei-xing-pan-duan/</id>
    <published>2020-02-17T10:46:18.801Z</published>
    <updated>2020-02-17T10:46:18.801Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://qiandream.cn/2020/02/11/leetcode-004-luo-ma-shu-zi-zhuan-zheng-shu/"/>
    <id>http://qiandream.cn/2020/02/11/leetcode-004-luo-ma-shu-zi-zhuan-zheng-shu/</id>
    <published>2020-02-11T15:00:49.737Z</published>
    <updated>2020-02-11T15:00:49.737Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之生产环境配置</title>
    <link href="http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-sheng-chan-huan-jing-pei-zhi/"/>
    <id>http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-sheng-chan-huan-jing-pei-zhi/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-09T09:58:39.267Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h1><p>在生产环境中我们关注的是如何让用户更快地加载资源，涉及如何压缩资源、如何添加环境变量优化打包、如何最大限度地利用缓存等。</p><h2 id="环境配置的封装"><a href="#环境配置的封装" class="headerlink" title="环境配置的封装"></a>环境配置的封装</h2><p>生产环境的配置与开发环境有所不同，如何让Webpack可以按照不同环境采用不同的配置呢？一般来说有以下两种方式。</p><ul><li>使用相同的配置文件</li></ul><p>比如令Webpack不管在什么环境下打包都使用webpack.config.js，只是在构建开始前将当前所属环境作为一个变量传进去，然后在webpack.config.js中通过各种判断条件来决定具体使用哪个配置。</p><pre><code>// package.json{    ...    &quot;scripts&quot;: {        &quot;dev&quot;: &quot;ENV=development webpack-dev-server&quot;,        &quot;build&quot;: &quot;ENV=production webpack&quot;    }}// webpack.config.jsconst ENV = process.env.ENVconst isProd = ENV === &#39;production&#39;module.exports = {    output: {        filename: isProd ? &#39;bundle@[chunkhash].js&#39; : &#39;bundle.js&#39;    },    mode: ENV}</code></pre><ul><li>为不同环境创建各自的配置文件</li></ul><p>比如，我们可以单独创建一个webpack.production.config.js，开发环境的则可以叫webpack.development.config.js。</p><pre><code>// package.json{    ...    &quot;scripts&quot;: {        &quot;dev&quot;: &quot;webpack-dev-server --config=webpack.development.config.js&quot;,        &quot;build&quot;: &quot;webpack --config=webpack.production.config.js&quot;    }}</code></pre><p>但这种方法存在一个问题，即webpack.development.config.js和webpack.production.config.js肯定会有重复的部分，一改都要改，不利于维护。在这种情况下，可以将公共的配置提取出来，比如我们单独创建一个webpack.common.config.js。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// development 和 production 共有配置</span><span class="token punctuation">}</span></code></pre><p>然后让另外两个JS分别引用该文件，并添加上自身环境的配置即可。</p><h2 id="开启-production-模式"><a href="#开启-production-模式" class="headerlink" title="开启 production 模式"></a>开启 production 模式</h2><p>Webpack 4中直接加了一个mode配置项，让开发者可以通过它来直接切换打包模式。如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">}</span></code></pre><p>这意味着当前处于生产环境模式，Webpack会自动添加许多适用于生产环境的配置项，减少了人为手动的工作。</p><p>大部分时候仅仅设置mode是不够的，下面我们继续介绍其他与生产环境相关的自定义配置。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>通常我们需要为生产环境和本地环境添加不同的环境变量，在Webpack中可以使用DefinePlugin进行设置。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">'production'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>注：我们在一些值的外面加上了JSON.stringify，这是因为DefinePlugin在替换环境变量时对于字符串类型的值进行的是完全替换。假如不添加JSON.stringify的话，在替换后就会成为变量名，而非字符串值。因此对于字符串环境变量及包含字符串的对象都要加上JSON.stringify才行。</p><h2 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h2><p>source map指的是将编译、打包、压缩后的代码映射回源代码的过程。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Webpack对于工程源代码的每一步处理都有可能会改变代码的位置、结构，甚至是所处文件，因此每一步都需要生成对应的source map。若我们启用了devtool配置项，source map就会跟随源代码一步步被传递，直到生成最后的map文件。这个文件默认就是打包后的文件名加上.map，如bundle.js.map。</p><p>当我们打开了浏览器的开发者工具时，map文件会同时被加载，这时浏览器会使用它来对打包后的bundle文件进行解析，分析出源代码的目录结构和内容。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>JavaScript的source map的配置很简单，只要在webpack.config.js中添加devtool即可。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    devtool<span class="token punctuation">:</span> <span class="token string">'source-map'</span><span class="token punctuation">}</span></code></pre><p>对于CSS、SCSS、Less来说，则需要添加额外的source map配置项。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    devtool<span class="token punctuation">:</span> <span class="token string">'source-map'</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span> <span class="token punctuation">{</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.scss$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> <span class="token punctuation">[</span>                    <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    <span class="token punctuation">{</span>                        loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                        options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                            sourceMap<span class="token punctuation">:</span> <span class="token boolean">true</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                            loader<span class="token punctuation">:</span> <span class="token string">'sass-loader'</span><span class="token punctuation">,</span>                        options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                            sourceMap<span class="token punctuation">:</span> <span class="token boolean">true</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">]</span>            <span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Webpack支持多种source map的形式。除了配置为devtool：’source-map’以外，还可以根据不同的需求选择cheap-source-map、eval-source-map等。通常它们都是source map的一些简略版本，因为生成完整的source map会延长整体构建时间，如果对打包速度需求比较高的话，建议选择一个简化版的sourcemap。比如，在开发环境中，cheap-module-eval-source-map通常是一个不错的选择，属于打包速度和源码信息还原程度的一个良好折中。</p><p>在生产环境中由于我们会对代码进行压缩，而最常见的压缩插件UglifyjsWebpack-Plugin目前只支持完全的source-map，因此没有那么多选择，我们只能使用source-map、hidden-source-map、nosources-source-map这3者之一。下面介绍一下这3种sourcemap在安全性方面的不同。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>有了source map也就意味着任何人通过浏览器的开发者工具都可以看到工程源码，对于安全性来说也是极大的隐患。那么如何才能在保持其功能的同时，防止暴露源码给用户呢？Webpack提供了hidden-source-map及nosources-source-map两种策略来提升source map的安全性。</p><p>hidden-source-map意味着Webpack仍然会产出完整的map文件，只不过不会在bundle文件中添加对于map文件的引用。这样一来，当打开浏览器的开发者工具时，我们是看不到map文件的，浏览器自然也无法对bundle进行解析。如果我们想要追溯源码，则要利用一些第三方服务，将map文件上传到那上面。目前最流行的解决方案是Sentry。</p><p>Sentry是一个错误跟踪平台，开发者接入后可以进行错误的收集和聚类，以便于更好地发现和解决线上问题。Sentry支持JavaScript的source map，我们可以通过它所提供的命令行工具或者Webpack插件来自动上传map文件。同时我们还要在工程代码中添加Sentry对应的工具包，每当JavaScript执行出错时就会上报给Sentry。Sentry在接收到错误后，就会去找对应的map文件进行源码解析，并给出源码中的错误栈。</p><p>另一种配置是nosources-source-map，它对于安全性的保护则没那么强，但是使用方式相对简单。打包部署之后，我们可以在浏览器开发者工具的Sources选项卡中看到源码的目录结构，但是文件的具体内容会被隐藏起来。对于错误来说，我们仍然可以在Console控制台中查看源代码的错误栈，或者console日志的准确行数。它对于追溯错误来说基本足够，并且其安全性相对于可以看到整个源码的source-map配置来说要略高一些。</p><h2 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h2><h3 id="压缩-javascript"><a href="#压缩-javascript" class="headerlink" title="压缩 javascript"></a>压缩 javascript</h3><p>压缩JavaScript大多数时候使用的工具有两个，一个是UglifyJS（Webpack 3已集成），另一个是terser（Webpack 4已集成）。</p><p>在Webpack 3中的话，开启压缩需调用webpack.optimize.UglifyJsPlugin。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// webpack version &lt; 4</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>UglifyJsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>从Webpack 4之后，这项配置被移到了config.optimization.minimize。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// webpack version > 4</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>        minimize<span class="token punctuation">:</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="压缩CSS"><a href="#压缩CSS" class="headerlink" title="压缩CSS"></a>压缩CSS</h3><p>压缩CSS文件的前提是使用extract-text-webpack-plugin或mini-css-extract-plugin将样式提取出来，接着使用optimize-css-assets-webpack-plugin来进行压缩，这个插件本质上使用的是压缩器cssnano，当然我们也可以通过其配置进行切换。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span><span class="token keyword">const</span> OptimizeCssAssetsPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'optimize-css-assets-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    module<span class="token punctuation">:</span> <span class="token punctuation">{</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                    fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'style.css'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>        minimizer<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">OptimizeCssAssetsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                assetNameRegExp<span class="token punctuation">:</span> <span class="token regex">/\.optimize\.css$/g</span><span class="token punctuation">,</span>                cssProcessor<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cssnano'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                cssProcessorOptions<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    discardComments<span class="token punctuation">:</span> <span class="token punctuation">{</span>removeAll<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                    canPrint<span class="token punctuation">:</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是指重复利用浏览器已经获取过的资源。合理地使用缓存是提升客户端性能的一个关键因素。</p><h3 id="资源-hash"><a href="#资源-hash" class="headerlink" title="资源 hash"></a>资源 hash</h3><p>一个常用的方法是在每次打包的过程中对资源的内容计算一次hash，并作为版本号存放在文件名中，如bundle@2e0a691e769edb228e2.js。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle@[chunkhash].js'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">}</span></code></pre><h3 id="输出动态-HTML"><a href="#输出动态-HTML" class="headerlink" title="输出动态 HTML"></a>输出动态 HTML</h3><p>接下来我们面临的问题是，资源名的改变也就意味着HTML中的引用路径的改变。每次更改后都要手动地去维护它是很困难的，理想的情况是在打包结束后自动把最新的资源名同步过去。使用html-webpack-plugin可以帮我们做到这一点。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>html-webpack-plugin会自动地将我们打包出来的资源名放入生成的index.html中，这样我们就不必手动地更新资源URL了。</p><h3 id="bundle-体积监控和分析"><a href="#bundle-体积监控和分析" class="headerlink" title="bundle 体积监控和分析"></a>bundle 体积监控和分析</h3><p>一个很有用的工具是webpack-bundle-analyzer，它能够帮助我们分析一个bundle的构成。使用方法也很简单，只要将其添加进plugins配置即可。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Analyzer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-bundle-analyzer'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>BundleAnalyzerPluginmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">Analyzer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之代码分片</title>
    <link href="http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-dai-ma-fen-pian/"/>
    <id>http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-dai-ma-fen-pian/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-08T14:40:41.145Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="代码分片"><a href="#代码分片" class="headerlink" title="代码分片"></a>代码分片</h1><p>代码分片（code splitting）是Webpack作为打包工具所特有的一项技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用户不必一次全部加载，而是按需加载。</p><p>代码分片可以有效降低首屏加载资源的大小，但同时也会带来新的问题，比如我们应该对哪些模块进行分片、分片后的资源如何管理等，这些也是需要关注的。</p><h2 id="通过入口划分代码"><a href="#通过入口划分代码" class="headerlink" title="通过入口划分代码"></a>通过入口划分代码</h2><p>在Webpack中每个入口（entry）都将生成一个对应的资源文件，通过入口的配置我们可以进行一些简单有效的代码拆分。</p><p>对于Web应用来说通常会有一些库和工具是不常变动的，可以把它们放在一个单独的入口中，由该入口产生的资源不会经常更新，因此可以有效地利用客户端缓存，让用户不必在每次请求页面时都重新加载。如：</p><pre><code>// webpack.config.jsentry: {   app: &#39;./app.js&#39;,   lib: [&#39;lib-a&#39;, &#39;lib-b&#39;, &#39;lib-c&#39;]}// index.html&lt;script src=&quot;dist/lib.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;dist/app.js&quot;&gt;&lt;/script&gt;</code></pre><p>这种拆分方法主要适合于那些将接口绑定在全局对象上的库，因为业务代码中的模块无法直接引用库中的模块，二者属于不同的依赖树。</p><h2 id="CommonsChunkPlugin"><a href="#CommonsChunkPlugin" class="headerlink" title="CommonsChunkPlugin"></a>CommonsChunkPlugin</h2><p>CommonsChunkPlugin是Webpack 4之前内部自带的插件（Webpack 4之后替换为了SplitChunks）。它可以将多个Chunk中公共的部分提取出来。公共模块的提取可以为项目带来几个收益：</p><ul><li><p>开发过程中减少了重复模块打包，可以提升开发速度；</p></li><li><p>减小整体资源体积；</p></li><li><p>合理分片后的代码可以更有效地利用客户端缓存。</p></li></ul><p>更改webpack.config.js，添加CommonsChunkPlugin。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>        foo<span class="token punctuation">:</span> <span class="token string">'./foo.js'</span><span class="token punctuation">,</span>        bar<span class="token punctuation">:</span> <span class="token string">'./bar.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>CommonsChunkOlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'commons'</span><span class="token punctuation">,</span>            filename<span class="token punctuation">:</span> <span class="token string">'commons.js'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ul><li><p>name：用于指定公共chunk的名字。</p></li><li><p>filename：提取后的资源文件名。</p></li></ul><p>最后，记得在页面中添加一个script标签来引入commons.js，并且注意，该JS一定要在其他JS之前引入。</p><h3 id="提取-vendor"><a href="#提取-vendor" class="headerlink" title="提取 vendor"></a>提取 vendor</h3><p>虽然CommonsChunkPlugin主要用于提取多入口之间的公共模块，但这不代表对于单入口的应用就无法使用。我们仍然可以用它来提取第三方类库及业务中不常更新的模块，只需要单独为它们创建一个入口即可。</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        app: &#39;./app.js&#39;,        vendor: [&#39;react&#39;]    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;,            filename: &#39;vendor.js&#39;        })    ]}// app.jsimport React from &#39;react&#39;document.write(&#39;app.js&#39;, React.version)</code></pre><p>为了将react从app.js提取出来，我们在配置中加入了一个入口vendor，并使其只包含react，这样就把react变为了app和vendor这两个chunk所共有的模块</p><h3 id="设置提取范围"><a href="#设置提取范围" class="headerlink" title="设置提取范围"></a>设置提取范围</h3><p>通过CommonsChunkPlugin中的chunks配置项可以规定从哪些入口中提取公共模块。</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        a: &#39;./a.js&#39;,        b: &#39;./b.js&#39;,        c: &#39;./c.js&#39;,    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;common&#39;,            filename: &#39;common.js&#39;,            chunks: [&#39;a&#39;, &#39;b&#39;]        })    ]}</code></pre><p>我们在chunks中配置了a和b，这意味着只会从a.js和b.js中提取公共模块。</p><h3 id="设置提取规则"><a href="#设置提取规则" class="headerlink" title="设置提取规则"></a>设置提取规则</h3><p>CommonsChunkPlugin的默认规则是只要一个模块被两个入口chunk所使用就会被提取出来，比如只要a和b用了react，react就会被提取出来。</p><p>然而现实情况是，有些时候我们不希望所有的公共模块都被提取出来，此时我们可以通过CommonsChunkPlugin的minChunks配置项来设置提取的规则，该配置项非常灵活，支持多种输入形式。</p><ul><li>数字</li></ul><p>minChunks可以接受一个数字，当设置minChunks为n时，只有该模块被n个入口同时引用才会进行提取。另外，这个阈值不会影响通过数组形式入口传入模块的提取。</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        foo: &#39;./foo.js&#39;,        bar: &#39;./bar.js&#39;,        vendor: [&#39;react&#39;],    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;,            filename: &#39;vendor.js&#39;,            minChunks: 3        })    ]}</code></pre><p>我们令foo.js和bar.js共同引用一个util.js。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// foo.js</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token string">'./util'</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'foo.js'</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// foo.js</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token string">'./util'</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'bar.js'</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// util.js</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span></code></pre><p>如果实际打包应该可以发现，由于我们设置minChunks为3，util.js并不会被提取到vendor.js中，然而react并不受这个的影响，仍然会出现在vendor.js中。</p><ul><li>Infinity</li></ul><p>设置为无穷代表提取的阈值无限高，也就是说所有模块都不会被提取。</p><ul><li>函数</li></ul><p>minChunks支持传入一个函数，它可以让我们更细粒度地控制公共模块。Webpack打包过程中的每个模块都会经过这个函数的处理，当函数的返回值是true时进行提取。</p><pre><code>module.exports = {    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;,            filename: &#39;vendor.js&#39;,            minChunks: function(module, count) {              // module.context 模块目录路径              if (module.context &amp;&amp; module.context.include(&#39;node_modules&#39;)) {                return true              }              // module.resource 包含模块名的完整路径              if (module.resource &amp;&amp; module.resource.endsWith(&#39;util.js&#39;)) {                return true              }              // count 为模块被引用的次数              if (count &gt; 5) {                return true              }            }        })    ]}</code></pre><p>借助上面的配置，我们可以分别提取node_modules目录下的模块、名称为util.js的模块，以及被引用5次（不包含5次）以上的模块。</p><h3 id="hash-与-长效缓存"><a href="#hash-与-长效缓存" class="headerlink" title="hash 与 长效缓存"></a>hash 与 长效缓存</h3><p>当我们使用该插件提取公共模块时，提取后的资源内部不仅仅是模块的代码，往往还包含Webpack的运行时（runtime）。Webpack的运行时指的是初始化环境的代码，如创建模块缓存对象、声明模块加载函数等。</p><p>将运行时的代码单独提取出来。请看下面这个例子：</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        app: &#39;./app.js&#39;,        vendor: [&#39;react&#39;],    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;        }),        new webpack.optimize.CommonsChunkOlugin({          name: &#39;manifest&#39;        }),    ]}</code></pre><p>上面的配置中，通过添加了一个name为manifest的CommonsChunkPlugin来提取Webpack的运行时。</p><p>注：manifest的CommonsChunkPlugin必须出现在最后，否则Webpack将无法正常提取模块。</p><h3 id="CommonsChunkPlugin-的不足"><a href="#CommonsChunkPlugin-的不足" class="headerlink" title="CommonsChunkPlugin 的不足"></a>CommonsChunkPlugin 的不足</h3><p>在提取公共模块方面，CommonsChunkPlugin可以满足很多场景的需求，但是它也有一些欠缺的地方。</p><ul><li><p>一个CommonsChunkPlugin只能提取一个vendor，假如我们想提取多个vendor则需要配置多个插件，这会增加很多重复的配置代码。</p></li><li><p>前面我们提到的manifest实际上会使浏览器多加载一个资源，这对于页面渲染速度是不友好的。</p></li><li><p>由于内部设计上的一些缺陷，CommonsChunkPlugin在提取公共模块的时候会破坏掉原有Chunk中模块的依赖关系，导致难以进行更多的优化。</p></li></ul><h2 id="optimization-SplitChunks"><a href="#optimization-SplitChunks" class="headerlink" title="optimization.SplitChunks"></a>optimization.SplitChunks</h2><p>optimization.SplitChunks（简称SplitChunks）是Webpack 4为了改进CommonsChunk-Plugin而重新设计和实现的代码分片特性。</p><p>比如我们前面异步加载的例子，在换成Webpack 4的SplitChunks之后，就可以自动提取出react了。</p><pre><code>module.exports = {    entry: &#39;./foo.js&#39;,    output: {        filename: &#39;foo.js&#39;,        publicPath: &#39;/dist/&#39;    },    mode: &#39;development&#39;,    optimization: {      splitChunks: {        chunks: &#39;all&#39;      }    }}// foo.jsimport React from &#39;react&#39;import(&#39;./bar.js&#39;)document.write(&#39;app.js&#39;, React.version)// bar.jsimport React from &#39;react&#39;document.write(&#39;bar.js&#39;, React.version)</code></pre><p>此处Webpack 4的配置与之前相比有两点不同：</p><ul><li>使用optimization.splitChunks替代了CommonsChunkPlugin，并指定了chunks的值为all，这个配置项的含义是，SplitChunks将会对所有的chunks生效（默认情况下，SplitChunks只对异步chunks生效，并且不需要配置）。</li></ul><p>以下是SplitChunks默认情形下的提取条件：</p><ul><li><p>提取后的chunk可被共享或者来自node_modules目录。</p></li><li><p>提取后的Javascript chunk体积大于30kB（压缩和gzip之前），CSS chunk体积大于50kB。</p></li><li><p>在按需加载过程中，并行请求的资源最大值小于等于5。按需加载指的是，通过动态插入script标签的方式加载脚本。</p></li><li><p>在首次加载时，并行请求的资源数最大值小于等于3。</p></li></ul><h3 id="默认的异步提取"><a href="#默认的异步提取" class="headerlink" title="默认的异步提取"></a>默认的异步提取</h3><p>前面我们对SplitChunks添加了一个chunks：all的配置，这是为了提取foo.js和bar.js的公共模块。实际上SplitChunks不需要配置也能生效，但仅仅针对异步资源。</p><pre><code>module.exports = {    entry: &#39;./foo.js&#39;,    output: {        filename: &#39;foo.js&#39;,        publicPath: &#39;/dist/&#39;    },    mode: &#39;development&#39;}// foo.jsimport(&#39;./bar.js&#39;)document.write(&#39;app.js&#39;, React.version)// bar.jsimport React from &#39;react&#39;document.write(&#39;bar.js&#39;, React.version)</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>为了更好地了解SplitChunks是怎样工作的，我们来看一下它的默认配置。</p><pre><code>        optimization: {       splitChunks: {          chunks: &#39;async&#39;,          minSize: {              javascript: 30000,              style: 50000          },          maxSize: 0,          minChunks: 1,          maxAsyncRequest3: 3,          maxInitialRequests: 2,          automaticNameDelimiter: &#39;~&#39;,          name: true,          cacheGroups: {            vendors: {              test: /[\\/]node_modules[\\/]/            },            default: {              minChunks: 2,              priority: -20,              reuseExistingChunk: true            }          }       }    }</code></pre><ul><li>匹配模式</li></ul><p>通过chunks我们可以配置SplitChunks的工作模式。它有3个可选值，分别为async（默认）、initial和all。async即只提取异步chunk，initial则只对入口chunk生效（如果配置了initial则上面异步的例子将失效），all则是两种模式同时开启。</p><ul><li>匹配条件</li></ul><p>minSize、minChunks、maxAsyncRequests、maxInitialRequests都属于匹配条件。</p><ul><li>命名</li></ul><p>配置项name默认为true，它意味着SplitChunks可以根据cacheGroups和作用范围自动为新生成的chunk命名，并以automaticNameDelimiter分隔。</p><ul><li>cacheGroups</li></ul><p>可以理解成分离chunks时的规则。默认情况下有两种规则——vendors和default。vendors用于提取所有node_modules中符合条件的模块，default则作用于被多次引用的模块。我们可以对这些规则进行增加或者修改，如果想要禁用某种规则，也可以直接将其置为false。当一个模块同时符合多个cacheGroups时，则根据其中的priority配置项确定优先级。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之预处理器</title>
    <link href="http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-yang-shi-chu-li/"/>
    <id>http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-yang-shi-chu-li/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-07T13:50:51.364Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h1><h2 id="分离样式文件"><a href="#分离样式文件" class="headerlink" title="分离样式文件"></a>分离样式文件</h2><p>Webpack社区有专门的插件：extract-text-webpack-plugin（适用于Webpack 4之前版本）和mini-css-extract-plugin（适用于Webpack 4及以上版本），它们就是专门用于提取样式到CSS文件的。</p><h3 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h3><pre class=" language-javascript"><code class="language-javascript">npm i extract<span class="token operator">-</span>text<span class="token operator">-</span>webpack<span class="token operator">-</span>plugin</code></pre><p>在 webpack.config.js 中引入：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'bundle.css'</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>内部的fallback属性用于指定当插件无法提取样式时所采用的loader。</p><p>use（extract方法里面的）用于指定在提取样式之前采用哪些loader来预先进行处理。</p><p>除此之外，还要在Webpack的plugins配置中添加该插件，并传入提取后的资源文件名。</p><h3 id="多样式文件处理"><a href="#多样式文件处理" class="headerlink" title="多样式文件处理"></a>多样式文件处理</h3><p>上面我们将bundle.css作为文件名传给了extract-text-webpack-plugin，但当工程有多个入口时就会发生重名问题。就像在前面的章节中我们配置动态的output.filename一样，这里我们也要对插件提取的CSS文件使用类似模板的命名方式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'[name].css'</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>说到mini-css-extract-plugin的特性，最重要的就是它支持按需加载CSS，以前在使用extract-text-webpack-plugin的时候我们是做不到这一点的。</p><p>举个例子，a.js通过import()函数异步加载了b.js，b.js里面加载了style.css，那么style.css最终只能被同步加载（通过HTML的link标签）。但是现在mini-css-extract-plugin会单独打包出一个0.css（假设使用默认配置），这个CSS文件将由a.js通过动态插入link标签的方式加载。</p><p>在配置上mini-css-extract-plugin与extract-text-webpack-plugin有以下几点不同：</p><ul><li><p>loader规则设置的形式不同，并且mini-css-extract-plugin支持配置publicPath，用来指定异步CSS的加载路径。</p></li><li><p>不需要设置fallback。</p></li><li><p>在plugins设置中，除了指定同步加载的CSS资源名（filename），还要指定异步加载的CSS资源名（chunkFilename）</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                loader<span class="token punctuation">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>                options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    publicPath<span class="token punctuation">:</span> <span class="token string">'../'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token string">'css-loader'</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'[name].css'</span><span class="token punctuation">,</span>        chunkFilename<span class="token punctuation">:</span> <span class="token string">'[id].css'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h2 id="样式预处理"><a href="#样式预处理" class="headerlink" title="样式预处理"></a>样式预处理</h2><p>样式预处理指的是在开发中我们经常会使用一些样式预编译语言，如SCSS、Less等，在项目打包过程中再将这些预编译语言转换为CSS。</p><h3 id="Sass-与-Scss"><a href="#Sass-与-Scss" class="headerlink" title="Sass 与 Scss"></a>Sass 与 Scss</h3><p>sass-loader就是将SCSS语法编译为CSS，因此在使用时通常还要搭配css-loader和style-loader。类似于我们装babel-loader时还要安装babel-core，loader本身只是编译核心库与Webpack的连接器，因此这里我们除了sass-loader以外还要安装node-sass，node-sass是真正用来编译SCSS的，而sass-loader只是起到黏合的作用。</p><pre class=" language-javascript"><code class="language-javascript">npm i sass<span class="token operator">-</span>loader node<span class="token operator">-</span>sass</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.scss$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]      }    ]  }}</code></pre><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><pre class=" language-javascript"><code class="language-javascript">npm i less<span class="token operator">-</span>loader less</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.less/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]      }    ]  }}</code></pre><h2 id="PostCss"><a href="#PostCss" class="headerlink" title="PostCss"></a>PostCss</h2><p>PostCSS并不能算是一个CSS的预编译器，它只是一个编译插件的容器。它的工作模式是接收样式源代码并交由编译插件处理，最后输出CSS。</p><h3 id="PostCss-与-Webpack"><a href="#PostCss-与-Webpack" class="headerlink" title="PostCss 与 Webpack"></a>PostCss 与 Webpack</h3><p>使用postcss-loader可以轻松地将PostCSS与Webpack连接起来。使用npm进行安装。</p><pre><code>npm i postcss-loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.css/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;]      }    ]  }}</code></pre><p>postcss-loader可以结合css-loader使用，也可以单独使用，也就是说不配置css-loader也可以达到相同的效果。唯一不同的是，单独使用postcss-loader时不建议使用CSS中的@import语句，否则会产生冗余代码。</p><p>除此之外，PostCSS要求必须有一个单独的配置文件。我们需要在项目的根目录下创建一个postcss.config.js。</p><pre><code>module.exports = {  // ...  module: {}}</code></pre><h3 id="自动前缀"><a href="#自动前缀" class="headerlink" title="自动前缀"></a>自动前缀</h3><p>Autoprefixer是一个样式工具，可以根据caniuse.com上的数据，自动决定是否要为某一特性添加厂商前缀，并且可以由开发者为其指定支持浏览器的范围。</p><pre><code>npm i autoprefixer</code></pre><p>在postcss.config.js中添加autoprefixer。</p><pre><code>const autoprefixer = require(&#39;autoprefixer&#39;)module.exports = {  // ...  plugins: [    autoprefixer({      grid: true,      browsers: [        &#39;&gt; 1%&#39;,        &#39;last 3 versions&#39;,        &#39;android 4.2&#39;,        &#39;ie 8&#39;      ]    })  ]}</code></pre><h3 id="stylelint"><a href="#stylelint" class="headerlink" title="stylelint"></a>stylelint</h3><p>stylelint是一个CSS的质量检测工具，就像eslint一样，我们可以为其添加各种规则，来统一项目的代码风格，确保代码质量。</p><pre><code>npm i stylelint</code></pre><p>在postcss.config.js中添加相应配置。</p><pre><code>const autoprefixer = require(&#39;autoprefixer&#39;)module.exports = {  // ...  plugins: [    stylelint({      config: {        rules: {          &#39;declaration-no-important&#39;: true        }      }    })  ]}</code></pre><p>这里我们添加了declaration-no-important这样一条规则，当我们的代码中出现了“！important”时就会给出警告。</p><p>使用stylelint可以检测出代码中的样式问题（语法错误、重复的属性等），帮助我们写出更加安全并且风格更加一致的代码。</p><h3 id="CssNext"><a href="#CssNext" class="headerlink" title="CssNext"></a>CssNext</h3><p>PostCSS可以与CSSNext结合使用，让我们在应用中使用最新的CSS语法特性。</p><pre><code>npm i postcss-cssnext</code></pre><p>在postcss.config.js中添加相应配置。</p><pre><code>const postcssCssnext = require(&#39;postcss-cssnext&#39;)module.exports = {  // ...  plugins: [    postcssCssnext({      browsers: [        &#39;&gt; 1%&#39;,        &#39;last 2 versions&#39;,      ]    })  ]}</code></pre><p>指定好需要支持的浏览器之后，我们就可以顺畅地使用CSSNext的特性了。</p><h2 id="Css-Modules"><a href="#Css-Modules" class="headerlink" title="Css Modules"></a>Css Modules</h2><p>CSS Modules是近年来比较流行的一种开发模式，其理念就是把CSS模块化，让CSS也拥有模块的特点:</p><ul><li><p>每个CSS文件中的样式都拥有单独的作用域，不会和外界发生命名冲突。</p></li><li><p>对CSS进行依赖管理，可以通过相对路径引入CSS文件。</p></li><li><p>可以通过composes轻松复用其他CSS模块</p></li></ul><p>使用CSS Modules不需要额外安装模块，只要开启css-loader中的modules配置项即可。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token string">'style-loader'</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>           loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>           options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                 modules<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                 localIdentName<span class="token punctuation">:</span> <span class="token string">'[name]__[local]__[hash:base64:5]'</span>              <span class="token punctuation">}</span>           <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>这里比较值得一提的是localIdentName配置项，它用于指明CSS代码中的类名会如何来编译。</p><p>例：</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* style.css */</span><span class="token selector"><span class="token class">.title</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>经过编译后可能将成为.style<strong>title</strong>1CFy6。</p><ul><li><p>[name]指代的是模块名，这里被替换为style。</p></li><li><p>[local]指代的是原本的选择器标识符，这里被替换为title。</p></li><li><p>[hash：base64：5]指代的是一个5位的hash值，这个hash值是根据模块名和标识符计算的，因此不同模块中相同的标识符也不会造成样式冲突。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之预处理器</title>
    <link href="http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-yu-chu-li-qi/"/>
    <id>http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-yu-chu-li-qi/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-07T04:01:19.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="预处理器（loader）"><a href="#预处理器（loader）" class="headerlink" title="预处理器（loader）"></a>预处理器（loader）</h1><p>每个loader本质上都是一个函数。在Webpack 4之前，函数的输入和输出都必须为字符串；在Webpack 4之后，loader也同时支持抽象语法树（AST）的传递，通过这种方法来减少重复的代码解析。用公式表达loader的本质则为以下形式：</p><p>output=loader(input)</p><p>这里的input可能是工程源文件的字符串，也可能是上一个loader转化后的结果，包括转化后的结果（也是字符串类型）、source map，以及AST对象；output同样包含这几种信息，转化后的文件字符串、source map，以及AST。如果这是最后一个loader，结果将直接被送到Webpack进行后续处理，否则将作为下一个loader的输入向后传递。</p><h2 id="loader-的配置"><a href="#loader-的配置" class="headerlink" title="loader 的配置"></a>loader 的配置</h2><p>Webpack本身只认识JavaScript，对于其他类型的资源必须预先定义一个或多个loader对其进行转译，输出为Webpack能够接收的形式再继续进行，因此loader做的实际上是一个预处理的工作。</p><pre><code>module.exports = {  module: {    rules: [      {        test: /\.jsx?/, // 条件        use: &#39;babel-loader&#39; // 规则应用结果      } // 一个Object即一条规则    ]  }}</code></pre><p>与loader相关的配置都在module对象中，其中module.rules代表了模块的处理规则。每条规则内部可以包含很多配置项，这里我们只使用了最重要的两项—test和use。</p><ul><li><p>test可接收一个正则表达式或者一个元素为正则表达式的数组，只有正则匹配上的模块才会使用这条规则。</p></li><li><p>use可接收一个数组，数组包含该规则所使用的loader。</p></li></ul><h3 id="链式-loader"><a href="#链式-loader" class="headerlink" title="链式 loader"></a>链式 loader</h3><p>很多时候，在处理某一类资源时我们都需要使用多个loader。</p><pre><code>module.exports = {  module: {    rules: [      {        test: /\.css?/, // 条件        use: [&#39;style-loader&#39;, &#39;css-loader&#39;] // 规则应用结果      } // 一个Object即一条规则    ]  }}</code></pre><p>把style-loader加到了css-loader前面，这是因为在Webpack打包时是按照数组从后往前的顺序将资源交给loader处理的，因此要把最后生效的放在前面。</p><h3 id="loader-options"><a href="#loader-options" class="headerlink" title="loader options"></a>loader options</h3><p>webpack为loader提供了多种匹配条件的配置方式：</p><ul><li>test: … 匹配特定条件</li><li>include: … 匹配特定路径</li><li>exclude: … 排除特定路径</li><li>and: [] 必须匹配数组中的所有条件</li><li>or: [] 匹配数组中的任意一个条件</li><li>not: [] 排除匹配数组中的所有条件</li></ul><p>条件值类型：</p><ul><li>字符串：必须以提供的字符串开始（绝对路径）</li><li>正则表达式</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件</li><li>函数：返回true表示匹配</li></ul><hr><h5 id="规则应用配置"><a href="#规则应用配置" class="headerlink" title="规则应用配置"></a>规则应用配置</h5><p>匹配规则后的应用，我们可以使用use字段：</p><pre><code>rules: [  {    test: /\.less/,    use: [      &#39;style-loader&#39;,      {        loader: &#39;css-loader&#39;,        options: {          // ...        }      },      {        loader: &#39;less-loader&#39;,        options: {          // ...        }      }    ]  }]</code></pre><p>使用options可以给对应的loader传递一些配置项。</p><p>对于上述的less规则应用配置，一个less模块文件可以经过多个loader的转换处理，执行顺序为从右到左。</p><p>如果多个rule匹配了同一个模块文件，loader的应用顺序应该如何处理？</p><pre><code>rules: [  {    test: /\.js$/,    loader: &quot;eslint-loader&quot;,  },  {    test: /\.js$/,    loader: &quot;babel-loader&quot;,  }]</code></pre><p>eslint-loader用于检查人工编写的代码，babel-loader用于转换代码。所以，eslint-loader应该在babel-loader之前执行，那么该如何保证执行顺序？</p><p>webpack为每一个匹配规则提供了enforce字段来配置当前rule得的loader类型。pre(前置) &gt; 行内 &gt; 普通 &gt; 后置(post)。 我们要确保eslint-loader在babel-loader之前执行，只需给rule规则项添加enforce字段，并设置其值为pre。</p><pre><code>rules: [  {    enforce: &#39;pre&#39;,    test: /\.js$/,    loader: &quot;eslint-loader&quot;,  },  {    test: /\.js$/,    loader: &quot;babel-loader&quot;,  }]</code></pre><h2 id="常用-loader-介绍"><a href="#常用-loader-介绍" class="headerlink" title="常用 loader 介绍"></a>常用 loader 介绍</h2><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p> babel-loader用来处理ES6+并将其编译为ES5。</p><pre class=" language-javascript"><code class="language-javascript">npm i babel<span class="token operator">-</span>loader @babel<span class="token operator">/</span>core @babel<span class="token operator">/</span>preset<span class="token operator">-</span>env</code></pre><p>各个模块的作用如下:</p><ul><li><p>babel-loader：它是使Babel与Webpack协同工作的模块。</p></li><li><p>@babel/core：顾名思义，它是Babel编译器的核心模块。</p></li><li><p>@babel/preset-env：它是Babel官方推荐的预置器，可根据用户设置的目标环境自动添加所需的插件和补丁来编译ES6+代码。</p></li></ul><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.jsx?/,        loader: &#39;babel-loader&#39;      }    ]  }}</code></pre><hr><h3 id="ts-loader"><a href="#ts-loader" class="headerlink" title="ts-loader"></a>ts-loader</h3><p>ts-loader与babel-loader的性质类似，它是用于连接Webpack与Typescript的模块。</p><pre class=" language-javascript"><code class="language-javascript">npm i ts<span class="token operator">-</span>loader typescript</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.ts?/,        loader: &#39;ts-loader&#39;      }    ]  }}</code></pre><hr><h3 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h3><p>html-loader用于将HTML文件转化为字符串并进行格式化，这使得我们可以把一个HTML片段通过JS加载进来。</p><pre class=" language-javascript"><code class="language-javascript">npm i html<span class="token operator">-</span>loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.html?/,        loader: &#39;html-loader&#39;      }    ]  }}</code></pre><h3 id="handlebars-loader"><a href="#handlebars-loader" class="headerlink" title="handlebars-loader"></a>handlebars-loader</h3><p>handlebars-loader用于处理handlebars模板，在安装时要额外安装handlebars。</p><pre class=" language-javascript"><code class="language-javascript">npm i handlebars<span class="token operator">-</span>loader handlebars</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.handlebars?/,        loader: &#39;handlebars-loader&#39;      }    ]  }}</code></pre><p>handlebars文件加载后得到的是一个函数，可以接收一个变量对象并返回最终的字符串。</p><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>file-loader用于打包文件类型的资源，并返回其publicPath。</p><pre class=" language-javascript"><code class="language-javascript">npm i file<span class="token operator">-</span>loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.(png|jpg|gif)$/,        use: &#39;file-loader&#39;      }    ]  }}</code></pre><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>url-loader与file-loader作用类似，唯一的不同在于用户可以设置一个文件大小的阈值，当大于该阈值时与file-loader一样返回publicPath，而小于该阈值时则返回文件base64形式编码。</p><pre class=" language-javascript"><code class="language-javascript">npm i url<span class="token operator">-</span>loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.(png|jpg|gif)$/,        use: {            loader: &#39;file-loader&#39;,            options: {                limit: 10240,                name: &#39;[name].[ext]&#39;,                publicPath: &#39;./assets-path/&#39;            }        }      }    ]  }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之资源输入输出</title>
    <link href="http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-zi-yuan-shu-ru-shu-chu/"/>
    <id>http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-zi-yuan-shu-ru-shu-chu/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-07T04:00:14.591Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="资源输入输出"><a href="#资源输入输出" class="headerlink" title="资源输入输出"></a>资源输入输出</h1><h2 id="资源处理流程"><a href="#资源处理流程" class="headerlink" title="资源处理流程"></a>资源处理流程</h2><p>在一切流程的最开始，我们需要指定一个或多个入口（entry），也就是告诉Webpack具体从源码目录下的哪个文件开始打包。如果把工程中各个模块的依赖关系当作一棵树，那么入口就是这棵依赖树的根，这些存在依赖关系的模块会在打包时被封装为一个chunk。</p><p>chunk字面的意思是代码块，在Webpack中可以理解成被抽象和包装过后的一些模块。它就像一个装着很多文件的文件袋，里面的文件就是各个模块，Webpack在外面加了一层包裹，从而形成了chunk。根据具体配置不同，一个工程打包时可能会产生一个或多个chunk。</p><p>Webpack会从入口文件开始检索，并将具有依赖关系的模块生成一棵依赖树，最终得到一个chunk。由这个chunk得到的打包产物我们一般称之为bundle。</p><h2 id="配置资源入口"><a href="#配置资源入口" class="headerlink" title="配置资源入口"></a>配置资源入口</h2><p>通过context和entry这两个配置项来共同决定入口文件的路径。在配置入口时，实际上做了两件事：</p><ul><li><p>确定入口模块位置，告诉Webpack从哪里开始进行打包。</p></li><li><p>定义chunk name。如果工程只有一个入口，那么默认其chunk name为“main”；如果工程有多个入口，我们需要为每个入口定义chunk name，来作为该chunk的唯一标识。</p></li></ul><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>context可以理解为资源入口的路径前缀，在配置时要求必须使用绝对路径的形式。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    context<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./src/script'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    entry<span class="token punctuation">:</span> <span class="token string">'./index.js'</span><span class="token punctuation">}</span></code></pre><p>配置context的主要目的是让entry的编写更加简洁，尤其是在多入口的情况下。context可以省略，默认值为当前工程的根目录。</p><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>entry的配置可以有多种形式：字符串、数组、对象、函数。可以根据不同的需求场景来选择。</p><ul><li>字符串类型入口</li></ul><p>直接传入文件路径：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token string">'./src/index'</span><span class="token punctuation">}</span></code></pre><ul><li>数组类型入口</li></ul><p>传入一个数组的作用是将多个资源预先合并，在打包时Webpack会将数组中的最后一个元素作为实际的入口路径。如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'babel-polyfill'</span><span class="token punctuation">,</span> <span class="token string">'./src/index'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ul><li>对象类型入口</li></ul><p>如果想要定义多入口，则必须使用对象的形式。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>    foo<span class="token punctuation">:</span> <span class="token string">'./src/foo'</span><span class="token punctuation">,</span>    bar<span class="token punctuation">:</span> <span class="token string">'./src/bar'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>函数类型入口</li></ul><p>用函数定义入口时，只要返回上面介绍的任何配置形式即可。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>                    foo<span class="token punctuation">:</span> <span class="token string">'./src/foo'</span><span class="token punctuation">,</span>                    bar<span class="token punctuation">:</span> <span class="token string">'./src/bar'</span>                  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>所有与出口相关的配置都集中在output对象里。</p><h4 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h4><p>filename的作用是控制输出资源的文件名。</p><ul><li>字符串形式</li></ul><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>在多入口的场景中，我们需要为对应产生的每个bundle指定不同的名字，Webpack支持使用一种类似模板语言的形式动态地生成文件名。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 多个入口生成不同的文件</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>路径中使用hash，每次构建都有一个不同的hash值，避免发布新版本使用浏览器缓存。</li></ul><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist/[hash]'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>path可以指定资源输出的位置，要求值必须为绝对路径。如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><p>publicPath是一个非常重要的配置项，并且容易与path相混淆。从功能上来说，path用来指定资源的输出位置，而publicPath则用来指定资源的请求位置。让我们详细解释这两个定义。</p><ul><li><p>输出位置：打包完成后资源产生的目录，一般将其指定为工程中的dist目录。</p></li><li><p>请求位置：由JS或CSS所请求的间接资源路径。页面中的资源分为两种，一种是由HTML页面直接请求的，比如通过script标签加载的JS；另一种是由JS或CSS请求的，如异步加载的JS、从CSS请求的图片字体等。publicPath的作用就是指定这部分间接资源的请求位置。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之简介</title>
    <link href="http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-jian-jie/"/>
    <id>http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-jian-jie/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-07T03:56:32.065Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="Webpack-简介"><a href="#Webpack-简介" class="headerlink" title="Webpack 简介"></a>Webpack 简介</h1><h2 id="Webpack是什么"><a href="#Webpack是什么" class="headerlink" title="Webpack是什么"></a>Webpack是什么</h2><p>Webpack是一个开源的JavaScript模块打包工具，其最核心的功能是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个JS文件（有时会有多个，这里讨论的只是最基本的情况）。</p><h2 id="模块打包工具"><a href="#模块打包工具" class="headerlink" title="模块打包工具"></a>模块打包工具</h2><p>模块打包工具（module bundler）的任务就是解决模块间的依赖，使其打包后的结果能运行在浏览器上。它的工作方式主要分为两种</p><ul><li><p>将存在依赖关系的模块按照特定规则合并为单个JS文件，一次全部加载进页面中。</p></li><li><p>在页面初始时加载一个入口模块，其他模块异步地进行加载。</p></li></ul><h2 id="Webpack-优势"><a href="#Webpack-优势" class="headerlink" title="Webpack 优势"></a>Webpack 优势</h2><ul><li><p>默认支持多种模块标准，包括AMD、CommonJS，以及最新的ES6模块。</p></li><li><p>完备的代码分割（code splitting）解决方案，首屏只加载重要的部分。</p></li><li><p>可以处理各种类型的资源。除了JavaScript以外，Webpack还可以处理样式、模板，甚至图片等。</p></li><li><p>拥有庞大的社区支持。</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用npm或者yarn来安装webpack</p><hr><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><pre><code>$ npm i webpack webpack-cli -gor$ yarn -g add webpack webpack-cli</code></pre><p>等待安装完毕，就可以全局执行webpack命令了。注：webpack-cli在4.x版本之后不再作为webpack的依赖了，我们使用时需要单独安装。</p><hr><h3 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h3><p>在项目中，我们更推荐将webpack作为项目的开发依赖来安装使用，这样可以指定项目中使用的webpack版本。</p><pre><code>$ npm i webpack webpack-cli -Dor$ yarn add webpack webpack-cli -D</code></pre><p>等待安装完毕，webpack会出现在项目的package.json文件中，我们添加一个npm scripts:</p><pre><code>  &quot;scripts&quot;: {    &quot;build&quot;: &quot;webpack --mode production&quot;  },  &quot;devDependencies&quot;: {    &quot;webpack&quot;: &quot;^4.1.1&quot;,    &quot;webpack-cli&quot;: &quot;^2.0.12&quot;,  }</code></pre><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack-dev-server可以看作一个服务者，它的主要工作就是接收浏览器的请求，然后将资源返回。当服务启动时，会先让Webpack进行模块打包并将资源准备好（在示例中就是bundle.js）。当webpack-dev-server接收到浏览器的资源请求时，它会首先进行URL地址校验。如果该地址是资源服务地址（上面配置的publicPath），就会从Webpack的打包结果中寻找该资源并返回给浏览器。反之，如果请求地址不属于资源服务地址，则直接读取硬盘中的源文件并将其返回。</p><pre class=" language-javascript"><code class="language-javascript">$ npm i webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server <span class="token operator">-</span>D</code></pre><p>为了便捷地启动webpack-dev-server，我们在package.json中添加一个dev指令：</p><pre class=" language-json"><code class="language-json"><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"webpack"</span><span class="token punctuation">,</span>  <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"webpack-dev-server"</span><span class="token punctuation">}</span></code></pre><p>最后，我们还需要对webpack-dev-server进行配置。编辑webpack.config.js如下：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">"./src/index.js"</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">"./bundle.js"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">"development"</span><span class="token punctuation">,</span>    devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>        publicPath<span class="token punctuation">:</span> <span class="token string">"/dist"</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p>这里有一点需要注意。直接用Webpack开发和使用webpack-dev-server有一个很大的区别，前者每次都会生成budnle.js，而webpack-dev-server只是将打包结果放在内存中，并不会写入实际的bundle.js，在每次webpack-dev-server接收到请求时都只是将内存中的打包结果返回给浏览器。</p><p>webpack-dev-server还有一项很便捷的特性就是live-reloading（自动刷新）。</p><p>注：关于内容自动更新，webpack-dev-server 与 hot-module-replacement（模块热替换）的区别在于：前者会刷新浏览器，后者不需要刷新浏览器就能获得更新之后的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之模块打包</title>
    <link href="http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-mo-kuai-da-bao/"/>
    <id>http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-mo-kuai-da-bao/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-07T03:57:52.343Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="模块打包"><a href="#模块打包" class="headerlink" title="模块打包"></a>模块打包</h1><h2 id="多种不同的模块机制"><a href="#多种不同的模块机制" class="headerlink" title="多种不同的模块机制"></a>多种不同的模块机制</h2><h3 id="Commonjs"><a href="#Commonjs" class="headerlink" title="Commonjs"></a>Commonjs</h3><p>CommonJS最初只为服务端而设计，直到有了Browserify——一个运行在Node.js环境下的模块打包工具，它可以将CommonJS模块打包为浏览器可以运行的单个文件。这意味着客户端的代码也可以遵循CommonJS标准来编写了。</p><p>CommonJS中规定每个文件是一个模块，所有的变量及函数只有自己能访问，对外是不可见的。</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>在CommonJS中，通过module.exports可以导出模块中的内容：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"calculate"</span><span class="token punctuation">}</span></code></pre><p>CommonJS模块内部会有一个module对象用于存放当前模块的信息。</p><p>属性。为了书写方便，CommonJS也支持另一种简化的导出方式—直接使用exports:</p><pre class=" language-javascript"><code class="language-javascript">exports<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"caculate"</span></code></pre><p>另外，要注意导出语句不代表模块的末尾，在module.exports或exports后面的代码依旧会照常执行。</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>在CommonJS中使用require进行模块导入：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> calculator <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./caculate.js'</span><span class="token punctuation">)</span><span class="token keyword">const</span> name <span class="token operator">=</span> calculator<span class="token punctuation">.</span>name</code></pre><p>当我们require一个模块时会有两种情况：</p><ul><li><p>require的模块是第一次被加载。这时会首先执行该模块，然后导出内容。</p></li><li><p>require的模块曾被加载过。这时该模块的代码不会再次执行，而是直接导出上次执行后得到的结果。</p></li></ul><p>模块会有一个module对象用来存放其信息，这个对象中有一个属性loaded用于记录该模块是否被加载过。它的值默认为false，当模块第一次被加载和执行过后会置为true，后面再次加载时检查到module.loaded为true，则不会再次执行模块代码。</p><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6 Module也是将每个文件作为一个模块，每个模块拥有自身的作用域，不同的是导入、导出语句。</p><p>ES6 Module会自动采用严格模式 – “use strict”。</p><h4 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h4><p>在ES6 Module中使用export命令来导出模块。</p><p>export有两种形式：</p><ul><li><p>命名导出</p></li><li><p>默认导出</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"calculate"</span><span class="token keyword">export</span> <span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token string">"add"</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"calculate"</span><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token string">"add"</span><span class="token keyword">export</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> add <span class="token punctuation">}</span></code></pre><p>在使用命名导出时，可以通过as关键字对变量重命名。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"calculate"</span><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token string">"add"</span><span class="token keyword">export</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> add <span class="token keyword">as</span> sum <span class="token punctuation">}</span></code></pre><p>将export default 默认导出，我们可以理解为对外输出了一个名为default的变量，因此不需要像命名导出一样进行变量声明，直接导出值即可。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">"calculate"</span><span class="token keyword">export</span> <span class="token keyword">default</span>  <span class="token keyword">class</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token punctuation">}</span></code></pre><h4 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h4><p>ES6 Module中使用import语法导入模块。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span></code></pre><p>与命名导出类似，我们可以通过as关键字可以对导入的变量重命名。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> name <span class="token keyword">as</span> caculate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span></code></pre><p>在导入多个变量时，我们还可以采用整体导入的方式。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> caculate <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span><span class="token keyword">const</span> name <span class="token operator">=</span> caculate<span class="token punctuation">.</span>name</code></pre><p>对于默认导出来说，import后面直接跟变量名，并且这个名字可以自由指定（比如这里是myCalculator）。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> myCalculator <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span></code></pre><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD是英文Asynchronous Module Definition（异步模块定义）的缩写:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'getSum'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'calculate'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>math<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>calculate<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在AMD中使用define函数来定义模块，它可以接受3个参数:</p><p>第1个参数是当前模块的id，相当于模块名；</p><p>第2个参数是当前模块的依赖，比如上面我们定义的getSum模块需要引入calculator模块作为依赖；</p><p>第3个参数用来描述模块的导出值，可以是函数或对象。如果是函数则导出的是函数的返回值；如果是对象则直接导出对象本身。</p><p>和CommonJS类似，AMD也使用require函数来加载模块，只不过采用异步的形式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'getSum'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>getSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>require的第1个参数指定了加载的模块，第2个参数是当加载完成后执行的回调函数。</p><p>通过AMD这种形式定义模块的好处在于其模块加载是非阻塞性的，当执行到require函数时并不会停下来去执行被加载的模块，而是继续执行require后面的代码，这使得模块加载操作并不会阻塞浏览器。</p><h2 id="模块打包原理"><a href="#模块打包原理" class="headerlink" title="模块打包原理"></a>模块打包原理</h2><p>Webpack 将项目中成百上千个有依赖关系的模块组织在一起，打包后将会成为如下的形式：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 立即执行匿名函数</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 模块缓存</span>    <span class="token keyword">var</span> installedModules <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 实现 require</span>    <span class="token keyword">function</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span>moduleId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 执行入口模块的加载</span>    <span class="token keyword">return</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span>__webpack_require__<span class="token punctuation">.</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// modules: 以 key-value 的形式存储所有被打包的模块</span>        <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> __webpack_require__<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 打包入口</span>            module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token string">"3qiv"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token string">"3qiv"</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> __webpack_require__<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 打包入口</span>            module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token string">"3qiv"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>上面的bundle分为以下几个部分：</p><ul><li><p>最外层立即执行匿名函数。它用来包裹整个bundle，并构成自身的作用域。</p></li><li><p>installedModules对象。每个模块只在第一次被加载的时候执行，之后其导出值就被存储到这个对象里面，当再次被加载的时候直接从这里取值，而不会重新执行。</p></li><li><p><strong>webpack_require</strong>函数。对模块加载的实现，在浏览器中可以通过调用<strong>webpack_require</strong>(module_id)来完成模块导入。</p></li><li><p>modules对象。工程中所有产生了依赖关系的模块都会以key-value的形式放在这里。key可以理解为一个模块的id，由数字或者一个很短的hash字符串构成；value则是由一个匿名函数包裹的模块实体，匿名函数的参数则赋予了每个模块导出和导入的能力。</p></li></ul><p>bundle是如何在浏览器中执行的：</p><ul><li><p>在最外层的匿名函数中会初始化浏览器执行环境，包括定义installedModules对象、<strong>webpack_require</strong>函数等，为模块的加载和执行做一些准备工作。</p></li><li><p>加载入口模块。每个bundle都有且只有一个入口模块，例如：index.js是入口模块，在浏览器中会从它开始执行。</p></li><li><p>执行模块代码。如果执行到了module.exports则记录下模块的导出值；如果中间遇到require函数（准确地说是<strong>webpack_require</strong>），则会暂时交出执行权，进入<strong>webpack_require</strong>函数体内进行加载其他模块的逻辑。</p></li><li><p>在<strong>webpack_require</strong>中会判断即将加载的模块是否存在于installedModules中。如果存在则直接取值，否则回到上一步，执行该模块的代码来获取导出值。</p></li><li><p>所有依赖的模块都已执行完毕，最后执行权又回到入口模块。当入口模块的代码执行到结尾，也就意味着整个bundle运行结束。</p></li></ul><p>不难看出，第3步和第4步是一个递归的过程。Webpack为每个模块创造了一个可以导出和导入模块的环境，但本质上并没有修改代码的执行逻辑，因此代码执行的顺序与模块加载的顺序是完全一致的，这就是Webpack模块打包的奥秘。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-003-回文数</title>
    <link href="http://qiandream.cn/2020/01/03/leetcode-003-hui-wen-shu/"/>
    <id>http://qiandream.cn/2020/01/03/leetcode-003-hui-wen-shu/</id>
    <published>2020-01-03T10:11:52.000Z</published>
    <updated>2020-02-11T15:00:49.736Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：字符串、数组、数学</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="external">https://leetcode-cn.com/problems/roman-to-integer/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符          数值I             1V             5X             10L             50C             100D             500M             1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-转字符串、数组遍历，区分正常情况与特殊情况"><a href="#解法-转字符串、数组遍历，区分正常情况与特殊情况" class="headerlink" title="解法 - 转字符串、数组遍历，区分正常情况与特殊情况"></a>解法 - 转字符串、数组遍历，区分正常情况与特殊情况</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {string} s * @return {number} */</span><span class="token keyword">var</span> romanToInt <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/**       * 特殊情况       * IV === 4       * IX === 9       * XL === 40       * XC === 90       * CD === 400       * CM === 900       * 正常情况       * I === 1       * V === 5       * X === 10       * L === 50       * C === 100       * D === 500       * M === 1000       */</span>    <span class="token keyword">let</span> arr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">9</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">40</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">90</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">400</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">900</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">5</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">50</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">100</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">500</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1000</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>MCMXCIV</code></pre><p>输出：</p><pre><code>1994</code></pre><p>预期结果：</p><pre><code>1994</code></pre><ul><li><p>解题思路：转换为字符串、数组</p></li><li><p>split(): 字符串分割为数组</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-002-整数反转</title>
    <link href="http://qiandream.cn/2020/01/02/leetcode-002-zheng-shu-fan-zhuan/"/>
    <id>http://qiandream.cn/2020/01/02/leetcode-002-zheng-shu-fan-zhuan/</id>
    <published>2020-01-02T10:11:52.000Z</published>
    <updated>2020-02-10T08:21:03.443Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="external">https://leetcode-cn.com/problems/reverse-integer/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-转字符串、数组反转"><a href="#解法-转字符串、数组反转" class="headerlink" title="解法 - 转字符串、数组反转"></a>解法 - 转字符串、数组反转</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {number} x * @return {number} */</span><span class="token keyword">var</span> reverse <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 转换为整数</span>    <span class="token keyword">let</span> num <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 转换为字符串</span>    <span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 字符串反转</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">||</span> result <span class="token operator">></span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>result    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result    <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>123</code></pre><p>输出：</p><pre><code>321</code></pre><p>预期结果：</p><pre><code>321</code></pre><ul><li><p>解题思路：转换为字符串、数组</p></li><li><p>String: 将其他值转换为字符串</p></li><li><p>Number: 将其他值转换为数字值</p></li><li><p>Math: JS 内置对象</p></li><li><p>split(): 字符串分割为数组</p></li><li><p>reverse(): 数组翻转</p></li><li><p>join(): 数组转换为字符串</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>面试题-常见面试题系列之CSS基础</title>
    <link href="http://qiandream.cn/2020/01/02/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-css-ji-chu/"/>
    <id>http://qiandream.cn/2020/01/02/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-css-ji-chu/</id>
    <published>2020-01-02T06:46:52.000Z</published>
    <updated>2020-02-17T06:09:49.694Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><p>本系列旨在整理 CSS 考点的非重难点，帮助梳理 HTML 高频面试题。</p><h1 id="CSS选择器的优先级是怎样的？"><a href="#CSS选择器的优先级是怎样的？" class="headerlink" title="CSS选择器的优先级是怎样的？"></a>CSS选择器的优先级是怎样的？</h1><p>CSS 选择器的优先级是：内联选择器 &gt; id 选择器 &gt; 类选择器 &gt; 标签选择器</p><p>到具体的计算层面，优先级是由 A、B、C、D 的值来决定的，其中它们的值计算规则如下：</p><ul><li><p>A 的值等于1的前提是存在内联样式，否则 A = 0</p></li><li><p>B 的值等于 ID 选择器出现的次数</p></li><li><p>C 的值等于类选择器和属性选择器和伪类出现的总次数</p></li><li><p>D 的值等于标签选择器和伪元素出现的总次数</p></li></ul><p>例如下面的选择器，它不存在内联样式，所以 A = 0，不存在 id 选择器，B = 0，存在一个类选择器 C = 1，存在三个标签选择器 D = 3，那么最终结果为：{0, 0, 1, 3}</p><pre><code>ul ol li .red {    ...}</code></pre><h1 id="link-和-import-的区别？"><a href="#link-和-import-的区别？" class="headerlink" title="link 和 @import 的区别？"></a>link 和 @import 的区别？</h1><ul><li><p>link 属于 XHTML 标签，而 @import 是 CSS 提供的。</p></li><li><p>页面被加载时，link 会同时加载。而 @import 会到页面被加载完在加载。</p></li><li><p>link 方式的样式权重高于 @import 的权重。</p></li></ul><h1 id="有哪些方式（CSS）可以隐藏页面元素？"><a href="#有哪些方式（CSS）可以隐藏页面元素？" class="headerlink" title="有哪些方式（CSS）可以隐藏页面元素？"></a>有哪些方式（CSS）可以隐藏页面元素？</h1><ul><li><p>opacity: 0：本质是将元素的透明度降为 0，就看起来隐藏了，但是依然占据空间且可以交互。</p></li><li><p>visibility: hidden：与上一个方法类似的效果，占据空间，但是不可以交互了。</p></li><li><p>overflow: hidden：隐藏元素溢出的部分，占据空间且不可交互。</p></li><li><p>display: none：彻底隐藏元素，元素从文档流中消失，既不占据空间，也不交互，也不影响布局。</p></li><li><p>z-index: -9999：将层级放到底部。</p></li><li><p>transform: scale(0, 0)：平面变换，将元素缩放为 0，但是依然占据空间，不可交互。</p></li></ul><h1 id="em-px-rem-的区别？"><a href="#em-px-rem-的区别？" class="headerlink" title="em/px/rem 的区别？"></a>em/px/rem 的区别？</h1><ul><li><p>px：绝对单位，页面按精确像素展示。</p></li><li><p>em：相对单位，基准点为父元素字体的大小。</p></li><li><p>rem：相对单位，基准点为根节点 html 的字体大小。</p></li></ul><h1 id="块级元素水平居中的方法？"><a href="#块级元素水平居中的方法？" class="headerlink" title="块级元素水平居中的方法？"></a>块级元素水平居中的方法？</h1><ul><li>margin: 0 auto;</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.center</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>flex 布局。</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.center</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>    <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>table 方法。</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.center</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="CSS-有几种定位方式？"><a href="#CSS-有几种定位方式？" class="headerlink" title="CSS 有几种定位方式？"></a>CSS 有几种定位方式？</h1><ul><li><p>static：正常文档流定位。块级元素从上到下纵向排列，行级元素从左到右横向排列。</p></li><li><p>relative：相对布局。相对于正常文档流的位置。</p></li><li><p>absolute：绝对布局。</p></li><li><p>fixed：相对于屏幕视口的位置来指定元素位置。</p></li><li><p>sticky：粘性定位。近似效果就是 ios 通讯录滚动时候的【顶屁股】。</p></li></ul><h1 id="如何理解-z-index？"><a href="#如何理解-z-index？" class="headerlink" title="如何理解 z-index？"></a>如何理解 z-index？</h1><p>控制重叠元素的垂直叠加顺序，默认元素的 z-index 为 0，而 z-index 只能影响设置了 position 值的元素。</p><h1 id="如何理解层叠上下文？"><a href="#如何理解层叠上下文？" class="headerlink" title="如何理解层叠上下文？"></a>如何理解层叠上下文？</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>假定用户正面向网页，而 HTML 元素沿着其相对于用的一条虚构的 Z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。</p><h2 id="如何产生？"><a href="#如何产生？" class="headerlink" title="如何产生？"></a>如何产生？</h2><p>触发以下条件则会产生层叠上下文：</p><ul><li><p>根元素</p></li><li><p>z-index 值不为 ‘auto’ 的相对/绝对定位</p></li><li><p>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex</p></li><li><p>opacity 属性值小于 1 的元素</p></li><li><p>transform 属性值不为 “none”的元素</p></li><li><p>mix-blend-mode 属性值不为 “normal”的元素</p></li><li><p>filter值不为“none”的元素</p></li><li><p>perspective值不为“none”的元素</p></li><li><p>isolation 属性被设置为 “isolate”的元素</p></li><li><p>position: fixed</p></li><li><p>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值</p></li><li><p>-webkit-overflow-scrolling 属性被设置 “touch”的元素</p></li></ul><h1 id="清除浮动有哪些方法？"><a href="#清除浮动有哪些方法？" class="headerlink" title="清除浮动有哪些方法？"></a>清除浮动有哪些方法？</h1><ul><li><p>空 div 方法：<div style="clear: both;"></div></p></li><li><p>Clearfix 方法： clearfix 类方法</p></li><li><p>overflow: hidden; ovrflow: auto; BFC</p></li></ul><h1 id="你对-css-sprites-的理解，好处是什么？"><a href="#你对-css-sprites-的理解，好处是什么？" class="headerlink" title="你对 css sprites 的理解，好处是什么？"></a>你对 css sprites 的理解，好处是什么？</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>css sprites – 雪碧图，css 图像合成技术，开发人员往往将小图标合在一起，通过 background-image、background-position、background-size等属性定位到要使用的小图标。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>提前加载资源</p></li><li><p>减少 HTTP 请求书</p></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>维护成本高</p></li><li><p>加载速度优势在 http2 开启后荡然无存</p></li></ul><h1 id="你对媒体查询的理解？"><a href="#你对媒体查询的理解？" class="headerlink" title="你对媒体查询的理解？"></a>你对媒体查询的理解？</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>媒体查询，添加自 CSS3，允许内容的呈现针对一个特定范围的输出设备而进行裁剪，而不必改变内容自身，非常适合 web 网页应对不同型号的设备而做出对应的响应适配。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>媒体查询包含一个可选的媒体类型和满足 CSS3 规范的条件下，包含零个或多个表达式，这些表达式描述了媒体类型，最终会被解析为 true 或 false。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>example.css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(max-width: 800px)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"><span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>    <span class="token selector"><span class="token class">.fact_sidebar</span> </span><span class="token punctuation">{</span>        <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><h1 id="你对盒模型的理解？"><a href="#你对盒模型的理解？" class="headerlink" title="你对盒模型的理解？"></a>你对盒模型的理解？</h1><p>当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型，将所有元素表示为一个个矩形的盒子，CSS 决定这些盒子的大小，位置及属性等。</p><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/14650bf5fbb24066cea1dc1714d52a5b.png" alt=""></p><p>盒模型由 content、padding、border、margin组成。</p><h2 id="标准盒模型和怪异盒模型有什么区别？"><a href="#标准盒模型和怪异盒模型有什么区别？" class="headerlink" title="标准盒模型和怪异盒模型有什么区别？"></a>标准盒模型和怪异盒模型有什么区别？</h2><p>标准盒模型中，我们定义的元素的 width 为盒模型中 content 的宽度值，定义的 height 为盒模型中 content 的高度值。</p><p>因此，标准盒模型下：</p><p>元素的宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</p><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/232580766e15853d521a4c0bf6a5c794.png" alt=""></p><p>怪异盒模型中，我们定义的元素的 width 并不是 content 的宽度，而是 border-left + padding-left + width + padding-right + border-right 的总和，height 同理。</p><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/e427c6d19ea6be1359bd0177d7a5b7a3.png" alt=""></p><p>虽然现代浏览器默认使用W3C的标准盒模型，但是在不少情况下怪异盒模型更好用，于是W3C在css3中加入box-sizing。</p><h1 id="谈谈对-BFC-的理解？"><a href="#谈谈对-BFC-的理解？" class="headerlink" title="谈谈对 BFC 的理解？"></a>谈谈对 BFC 的理解？</h1><p>块级格式化上下文，一块独立的渲染区域，BFC 内部的元素与外部的元素互相隔离。</p><p>BFC 触发条件：</p><ul><li><p>根元素</p></li><li><p>position: fixed/absolute</p></li><li><p>overflow 不为 visible</p></li><li><p>float 不为 none</p></li><li><p>display 的值为 inline-block、table-cell、table-caption</p></li></ul><p>BFC 的作用：</p><ul><li><p>防止 margin 发生重叠</p></li><li><p>防止元素塌陷</p></li><li><p>两栏布局，防止文字环绕</p></li></ul><h1 id="为什么有时用-translate-来改变位置而不是定位？"><a href="#为什么有时用-translate-来改变位置而不是定位？" class="headerlink" title="为什么有时用 translate 来改变位置而不是定位？"></a>为什么有时用 translate 来改变位置而不是定位？</h1><p>translate 改变位置时，元素依然占据其原始空间，不会触发浏览器重新布局或重绘，只会触发复合。</p><h1 id="伪类和伪元素的区别是什么？"><a href="#伪类和伪元素的区别是什么？" class="headerlink" title="伪类和伪元素的区别是什么？"></a>伪类和伪元素的区别是什么？</h1><p>伪类：以 (:) 为前缀，添加到一个选择器末尾的关键字，当你希望样式在特别状态下才被呈现到指定的元素时，你可以在元素的选择器后加上对应的伪类。</p><p>伪元素：用于创建一些不在文档树中的元素，并为其添加样式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;p&gt;本系列旨在整理 CSS 考点的非重难点，帮助梳理 HTML 高频面试题。&lt;/p&gt;
&lt;h1 id=&quot;CSS选择器的优先级是怎样的？&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="面试题" scheme="http://qiandream.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JS-数组去重</title>
    <link href="http://qiandream.cn/2020/01/01/js-shu-zu-qu-chong/"/>
    <id>http://qiandream.cn/2020/01/01/js-shu-zu-qu-chong/</id>
    <published>2020-01-01T12:57:52.000Z</published>
    <updated>2020-02-17T09:37:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>数组去重方法老生常谈，本文主要总结常见的数组去重方法。</p></blockquote><a id="more"></a>               <hr><p>🌰 array = [1, ‘1’, 1, ‘1’]</p><h1 id="双层循环"><a href="#双层循环" class="headerlink" title="双层循环"></a>双层循环</h1><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> arrayLen <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> resultLen <span class="token operator">=</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> resultLen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> result<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">break</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">===</span> resultLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>使用循环嵌套，最外层循环 array，里面循环 result，如果 array[i] 的值跟 result[j] 的值相等，就跳出循环，如果都不等于，说明元素是唯一的，这时候 j 的值就会等于 result 的长度，根据这个特点进行判断，将值添加进 result。</p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>可以使用 indexOf 来简化内层循环：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> arrayLen <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> current <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>可以使用 filter 的方法：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> res <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> index<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Object-键值对"><a href="#Object-键值对" class="headerlink" title="Object 键值对"></a>Object 键值对</h2><p>这种方法是利用一个空的 Object 对象，我们把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2]</span></code></pre><p>我们可以发现，是有问题的，因为 1 和 ‘1’ 是不同的，但是这种方法会判断为同一个值，这是因为对象的键值只能是字符串，所以我们可以使用 typeof item + item 拼成字符串作为 key 值来避免这个问题：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> item <span class="token operator">+</span> item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span><span class="token keyword">typeof</span> item <span class="token operator">+</span> item<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, "1"]</span></code></pre><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, "1"]</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">unique</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;数组去重方法老生常谈，本文主要总结常见的数组去重方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://qiandream.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-001-两数之和</title>
    <link href="http://qiandream.cn/2020/01/01/leetcode-001-liang-shu-zhi-he/"/>
    <id>http://qiandream.cn/2020/01/01/leetcode-001-liang-shu-zhi-he/</id>
    <published>2020-01-01T10:11:52.000Z</published>
    <updated>2020-02-10T07:56:42.619Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组、哈希表</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="external">https://leetcode-cn.com/problems/two-sum/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-for"><a href="#解法-for" class="headerlink" title="解法 - for()"></a>解法 - for()</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {number[]} nums * @param {number} target * @return {number[]} */</span><span class="token keyword">var</span> twoSum <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>[2,7,11,15]9</code></pre><p>输出：</p><pre><code>[0,1]</code></pre><p>预期结果：</p><pre><code>[0,1]</code></pre><ul><li>解题思路：使用双重 for 循环</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>面试题-常见面试题系列之JS基础</title>
    <link href="http://qiandream.cn/2020/01/01/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-html-ji-chu/"/>
    <id>http://qiandream.cn/2020/01/01/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-html-ji-chu/</id>
    <published>2020-01-01T01:46:52.000Z</published>
    <updated>2020-02-13T06:44:06.238Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><p>本系列旨在整理 HTML 考点的非重难点，帮助梳理 HTML 高频面试题。</p><h1 id="doctype-的作用是什么？"><a href="#doctype-的作用是什么？" class="headerlink" title="doctype 的作用是什么？"></a>doctype 的作用是什么？</h1><p>doctype 是 html5 标准的网页声明，必须声明在 html 文档的第一行。规定了浏览器的解析器以何种渲染模式来解析文档，不同的渲染模式会影响到浏览器对 css 甚至 js 脚本的解析。</p><p>解析模式有：</p><ul><li><p>BackCompat: 怪异模式，浏览器使用自己的怪异模式解析文档（默认值）。</p></li><li><p>CSS1Compat: 标准模式，浏览器使用 W3C 的标准解析文档。</p></li><li><p>近乎标准模式：IE8 有一种介乎于上述两者之间的近乎标准的模式。</p></li></ul><h2 id="这三者的区别是什么？"><a href="#这三者的区别是什么？" class="headerlink" title="这三者的区别是什么？"></a>这三者的区别是什么？</h2><ul><li><p>标准模式：页面会按照 HTML 与 CSS 的定义渲染。</p></li><li><p>怪异模式：页面会模拟更旧的浏览器的行为。</p></li><li><p>近乎标准模式： 会实施一种表单元格尺寸的怪异行为。</p></li></ul><h1 id="HTML、XHTML、XML-有什么区别？"><a href="#HTML、XHTML、XML-有什么区别？" class="headerlink" title="HTML、XHTML、XML 有什么区别？"></a>HTML、XHTML、XML 有什么区别？</h1><ul><li><p>HTML (超文本标记语言)：在 html4 之前，HTML 先有实现再有标准，导致 html 非常混乱。</p></li><li><p>XML (可扩展标记语言)：主要用于存储数据和结构，可扩展。</p></li><li><p>XHTML (可扩展超文本标记语言)：基于上面两者而来，W3C 为了解决 html 混乱问题而生，并基于此诞生了 HTML5。</p></li></ul><h1 id="什么是-data-属性？"><a href="#什么是-data-属性？" class="headerlink" title="什么是 data- 属性？"></a>什么是 data- 属性？</h1><p>html 的数据属性，用于将数据存储在标准的 html 元素中作为额为信息，可以用 js 访问并操作它。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span>    <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>electriccars<span class="token punctuation">"</span></span>    <span class="token attr-name">data-columns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span>    <span class="token attr-name">data-index-number</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>12321<span class="token punctuation">"</span></span>    <span class="token attr-name">data-parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cars<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span></code></pre><pre><code>前端框架出现后，这种方法已经不流行了</code></pre><h1 id="你对-HTML-语义化的理解？"><a href="#你对-HTML-语义化的理解？" class="headerlink" title="你对 HTML 语义化的理解？"></a>你对 HTML 语义化的理解？</h1><p>语义化指运用恰当语义的 html 标签，使页面具有良好的结构与定义。</p><p>语义化的好处：</p><ul><li><p>开发者友好：增强了可读性，开发者可以清晰地看出网页的结构。</p></li><li><p>机器友好：便于搜索引擎的爬虫爬取有效的信息。</p></li></ul><h1 id="HTML4-与-HTML5-的不同之处？"><a href="#HTML4-与-HTML5-的不同之处？" class="headerlink" title="HTML4 与 HTML5 的不同之处？"></a>HTML4 与 HTML5 的不同之处？</h1><ul><li><p>文档类型声明 (&lt;!DOCTYPE&gt;) 仅有一型：&lt;!DOCTYPE HTML&gt;。</p></li><li><p>新的解析顺序：不再基于 SGML。</p></li><li><p>新的元素：section、video、progress、nav、meter、time、footer、header、summary、source等。</p></li><li><p>input 元素的新类型：date、email、url等。</p></li><li><p>全域属性：id、tabindex、repeat 等。</p></li><li><p>新的全域属性：contenteditable, contextmenu, draggable, dropzone, hidden, spellcheck。</p></li><li><p>移除元素：acronym, applet, basefont, big, center, dir, font, frame, frameset, isindex, noframes, strike。</p></li></ul><h1 id="有哪些常用的-meta-标签？"><a href="#有哪些常用的-meta-标签？" class="headerlink" title="有哪些常用的 meta 标签？"></a>有哪些常用的 meta 标签？</h1><p>meta 标签用于描述一个 html 文档的元信息，如：作者、日期和时间等。</p><ul><li>charset：用于描述 html 文档的编码形式。</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ul><li>viewport：控制视口的大小和比例。</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1, maximum-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ul><li>http-equiv：相当于 http 的文件头作用。</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>expires<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Web, 20 Jun 2020 22:28:00 GMT<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ul><li>app-mobile-web-app-status-bar-style：自定义苹果工具栏的颜色。</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app-mobile-web-app-status-bar-style<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>black-translucent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h1 id="href-和-src-的区别？"><a href="#href-和-src-的区别？" class="headerlink" title="href 和 src 的区别？"></a>href 和 src 的区别？</h1><ul><li><p>src：指向外部资源，指向的内容会下载并嵌入到文档中当前标签所在的位置。当浏览器解析到该元素时，会暂停其它资源的下载和处理，直到当前资源加载、编译、执行完毕。</p></li><li><p>href：指向网络资源所在位置，用来建立和当前元素或文档之间的连接，当浏览器识别到它所指向的文件时，则会并行下载资源。</p></li></ul><h2 id="img-的-srcset-作用是什么？"><a href="#img-的-srcset-作用是什么？" class="headerlink" title="img 的 srcset 作用是什么？"></a>img 的 srcset 作用是什么？</h2><p>使用 img 的 两个新属性 srcset 和 sizes 来提供更多额外的资源图像和提示，帮助浏览器选择一个正确的资源。</p><p>srcset 定义了我们允许浏览器选择的图像集以及每个图像的大小。</p><p>sizes 定义了一组媒体条件，并指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。</p><p>有了这些属性，浏览器会：</p><ul><li><p>查看设备宽度</p></li><li><p>检查 sizes 哪个媒体条件为真</p></li><li><p>查看给予该媒体查询的槽大小</p></li><li><p>加载 srcset 中引用的最接近所选的槽的大小的图像</p></li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clock-demo-thumb-200.png<span class="token punctuation">"</span></span>     <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Clock<span class="token punctuation">"</span></span>     <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clock-demo-thumb-200.png 200w,             clock-demo-thumb-400.png 400w<span class="token punctuation">"</span></span>     <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(min-width: 600px) 200px, 50vw<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h2 id="还有哪一个标签能起到和-srcset-类似作用？"><a href="#还有哪一个标签能起到和-srcset-类似作用？" class="headerlink" title="还有哪一个标签能起到和 srcset 类似作用？"></a>还有哪一个标签能起到和 srcset 类似作用？</h2><p><picture> 元素通过包含零个或多个 <source> 元素和一个 <img> 元素来为不同的显示、设备场景提供图像版本。浏览器会选择最匹配的子 <source> 元素，如果没有匹配的，就会选择 <img> 元素的 src 属性中的 url。</picture></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/media/examples/surfer-240-200.jpg<span class="token punctuation">"</span></span>            <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(min-width: 800px)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/media/examples/painted-hand-298-332.jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span></code></pre><h1 id="script-标签中-defer-和-async-的区别？"><a href="#script-标签中-defer-和-async-的区别？" class="headerlink" title="script 标签中 defer 和 async 的区别？"></a>script 标签中 defer 和 async 的区别？</h1><ul><li><p>defer：异步加载脚本，等待文档被解析完毕后执行。</p></li><li><p>async：异步加载脚本，加载完毕后立即执行。</p></li></ul><h1 id="有几种前端存储方式？"><a href="#有几种前端存储方式？" class="headerlink" title="有几种前端存储方式？"></a>有几种前端存储方式？</h1><p>cookie、localStorage、sessionStorage、indexedDB</p><h2 id="这些方式的区别？"><a href="#这些方式的区别？" class="headerlink" title="这些方式的区别？"></a>这些方式的区别？</h2><ul><li><p>cookie：优点是兼容性好，请求头自带 cookie 方便。缺点是大小只有4k，自动请求头加入 cookie 浪费流量，每个 domain 限制20 个 cookie。</p></li><li><p>localStorage：优点是操作方便，永久性存储，大小为 5M，缺点是只能手动删除。</p></li><li><p>sessionStorage：与 localStorage 基本类似。区别是当页面关闭后会清理。不能在所有同源窗口中被共享。</p></li><li><p>indexedDB：标准的数据库存储方案，是 NoSQL 数据库，用键值对进行存储，可快速读取。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;p&gt;本系列旨在整理 HTML 考点的非重难点，帮助梳理 HTML 高频面试题。&lt;/p&gt;
&lt;h1 id=&quot;doctype-的作用是什么？&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="面试题" scheme="http://qiandream.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题-常见面试题系列之JS基础</title>
    <link href="http://qiandream.cn/2019/11/25/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-js-ji-chu/"/>
    <id>http://qiandream.cn/2019/11/25/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-js-ji-chu/</id>
    <published>2019-11-25T01:46:52.000Z</published>
    <updated>2019-11-25T20:02:59.098Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><p>本系列旨在整理 JS 常见面试题，帮助梳理 JS 基础知识点。</p><h3 id="🌰-‘1’-‘2’-‘3’-map-parseInt-输出结果"><a href="#🌰-‘1’-‘2’-‘3’-map-parseInt-输出结果" class="headerlink" title="🌰 [‘1’, ‘2’, ‘3’].map(parseInt) 输出结果"></a>🌰 [‘1’, ‘2’, ‘3’].map(parseInt) 输出结果</h3><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h4><p>解析一个字符串参数，返回一个指定基数的整数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> intValue <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>string<span class="token punctuation">[</span><span class="token punctuation">,</span> radix<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串。字符串开头的空白符会被忽略。</p><p>radix 一个介于 2~36之间的整数，表示上述字符串的基数，默认值为 10。</p><p>parseInt 返回一个整数或 NaN。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 100</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1*10*10 + 0*10*1 + 0*10*0 = 100</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1*2*2 + 0*2*1 + 0*2*0 = 4</span></code></pre><p>在 radix 为 undefined ，或 radix 为 0 或没有指定的情况下，JS 作如下处理：</p><ul><li><p>string 以 ‘0x’ 或 ‘0X’ 开头，则 radix 为 16。</p></li><li><p>string 以 ‘0’ 开头，radix 为 8 或者 10，具体哪个基数由实现环境决定。</p></li><li><p>string 以其它任何值开头，则 radix 为 10。</p></li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> new_array <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span>currentValue<span class="token punctuation">[</span><span class="token punctuation">,</span>index<span class="token punctuation">[</span><span class="token punctuation">,</span> array<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Return element for new_array</span> <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">,</span> thisArg<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>callback 回调函数需要三个参数，分别为 currentValue(数组中当前正在处理的元素的值)、index(数组中当前正在处理的元素的索引)、array(map 方法中被调用的数组)。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>num <span class="token operator">=</span><span class="token operator">></span> num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [2, 4, 6]</span></code></pre><h4 id="‘1’-‘2’-‘3’-map-parseInt-输出"><a href="#‘1’-‘2’-‘3’-map-parseInt-输出" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt) 输出"></a>[‘1’, ‘2’, ‘3’].map(parseInt) 输出</h4><p>对于每个迭代 map，parseInt() 传递两个参数：字符串和基数。所以实际执行的代码为：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">parseInt</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>执行步骤为：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 (10 进制)</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// NaN radix(2-36)</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// NaN 不符合2进制位数取值(0-1)</span></code></pre><p>所以：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [1, NaN, NaN]</span></code></pre><h3 id="🌰-什么是节流和防抖？区别？如何实现？"><a href="#🌰-什么是节流和防抖？区别？如何实现？" class="headerlink" title="🌰 什么是节流和防抖？区别？如何实现？"></a>🌰 什么是节流和防抖？区别？如何实现？</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>动作绑定事件，动作发生后一定时间内触发时间，在这段时间内如果该动作又发生，则重新等待一定时间再触发事件。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * 防抖 debounce 定时器 * @param fn {function} 回调函数 * @param wait {number} 时间间隔 * @author wangxiaobai */</span><span class="token keyword">export</span> <span class="token keyword">function</span> debounce <span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 清除上次执行得定时器</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 设立新定时器</span>    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>动作绑定事件，动作发生后一定时间内触发事件，在这段时间内如果该动作又发生，则无视该动作，直到事件执行完后，才能重新触发。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * 节流 throttle 定时器 * @param fn {function} 回调函数 * @param wait {number} 时间间隔 * @author wangxiaobai */</span><span class="token keyword">export</span> <span class="token keyword">function</span> throttle <span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 上一次函数的执行时间  </span>  <span class="token keyword">let</span> activeTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> currentTime <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTime <span class="token operator">-</span> activeTime <span class="token operator">></span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>          fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>          activeTime <span class="token operator">=</span> currentTime<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="🌰-Set、Map、WeakSet、WeakMap"><a href="#🌰-Set、Map、WeakSet、WeakMap" class="headerlink" title="🌰 Set、Map、WeakSet、WeakMap"></a>🌰 Set、Map、WeakSet、WeakMap</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>一种叫做集合的数据结构，类似于数组，成员唯一且无序。</p><pre class=" language-text"><code class="language-text">new Set([iterable])</code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1 2 3 4</span><span class="token punctuation">}</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token operator">...</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3]</span></code></pre><p>Set 允许你存储任何类型的唯一值，无论是原始值还是对象引用。</p><p>向 Set 加入值的时候，不会发生类型转换，所以 5 和 ‘5’ 是两个不同的值。</p><p>在 Set 中，NaN 等于自身。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {NaN} </span><span class="token keyword">let</span> set1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {5, '5'}</span></code></pre><ul><li>Set 实例属性</li></ul><p>constructor: 构造函数</p><p>size: 元素数量</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span></code></pre><ul><li>Set 实例方法</li></ul><p>操作方法：</p><p>add(value) 新增</p><p>delete(value) 存在即删除集合中的 value</p><p>has(value) 判断集合中是否存在 value</p><p>clear() 清空集合</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0</span></code></pre><p>Array.from 可以将 Set 结构转化为数组    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> array <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3]</span><span class="token comment" spellcheck="true">// 或</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>items<span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3]</span></code></pre><p>遍历方法：</p><p>keys() 返回一个包含集合中所有键的迭代器</p><p>values() 返回一个包含集合中所有值的迭代器</p><p>entries() 返回一个包含集合中所有键值对的迭代器</p><p>forEach(callbackFn, thisArg)</p><p>map(callbackFn, thisArg)</p><p>filter(callbackFn, thisArg)</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SetIterator {1, 2, 3}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SetIterator {1, 2, 3}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SetIterator {1 => 1, 2 => 2, 3 => 3}</span><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">' : '</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1:1 2:2 3:3</span><span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">set</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> item <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// {2, 4, 6}</span><span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">set</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>item <span class="token operator">>=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// {4, 6}</span></code></pre><p>因此，Set 很容易实现两个数组的交集、并集、差集</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> set1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> set2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> intersect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>set1<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> set2<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> union <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>set1<span class="token punctuation">,</span> <span class="token operator">...</span>set2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> difference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>set1<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">!</span>set2<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>intersect<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {2, 3}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>union<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {1, 2, 3, 4}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>difference<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {1}</span></code></pre><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>允许你将弱引用对象储存在一个集合中。</p><p>WeakSet 与 Set 的区别：</p><ul><li><p>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</p></li><li><p>WeakSet 中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的引用，如果没有其它的变量或属性引用这个对象值，则这个对象或被垃圾回收掉</p></li></ul><p>属性：</p><p>constructor: 构造函数</p><p>方法：</p><p>add(value) 添加元素 value</p><p>has(value) 判断是否包含 value</p><p>delete(value) 删除 value</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>ws<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>ws<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>ws<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span></code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>一种叫做字典的数据结构，以 [key, value] 的形式存储</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>    p<span class="token punctuation">:</span> <span class="token string">'haha'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'content'</span>m<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>m<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span></code></pre><p>任何具有 Iterator 接口，每个成员都是一个双元素的数组的数据结构都可以当做 Map 构造函数的参数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'Author'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "张三"</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "Author"</span><span class="token keyword">const</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m1<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'baz'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> m3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span><span class="token punctuation">;</span>m3<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'baz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span></code></pre><p>如果读取一个未知的键，则返回undefined。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'asfddfsasadf'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined</span></code></pre><p>只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined</span></code></pre><p>Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'true'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span></code></pre><p>属性：</p><p>constructor：构造函数</p><p>size: 字典中所包含的元素个数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'An'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">[</span><span class="token string">'des'</span><span class="token punctuation">,</span> <span class="token string">'JS'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span></code></pre><p>操作方法：</p><p>set(key, value) 添加新元素</p><p>get(key) 通过键查找特定的数值并返回</p><p>has(key) 判断字典中是否存在 key</p><p>delete(key) 通过键 key 从字典中移除对应的数据</p><p>clear() 字典中所有元素删除</p><p>遍历方法：</p><p>keys() 将字典中包含的所有键名以迭代器形式返回</p><p>values() 将字典中包含的所有数值以迭代器形式返回</p><p>entries() 返回所有成员的迭代器</p><p>forEach() 遍历字典的所有成员</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>            <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'An'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">[</span><span class="token string">'des'</span><span class="token punctuation">,</span> <span class="token string">'JS'</span><span class="token punctuation">]</span>        <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// MapIterator {"name" => "An", "des" => "JS"}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// MapIterator {"name", "des"}</span></code></pre><p>与其它数据结构相互转换</p><ol><li>Map 转 Array</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>map<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [[1, 1], [2, 2], [3, 3]]</span></code></pre><ol><li>Array 转 map</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Map {1 => 1, 2 => 2, 3 => 3}</span></code></pre><ol><li>Map 转 Object</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">mapToObj</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>        obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> obj<span class="token punctuation">}</span><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'An'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'des'</span><span class="token punctuation">,</span> <span class="token string">'JS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mapToObj</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// {name: "An", des: "JS"}</span></code></pre><ol><li>Object 转 Map</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">objToMap</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> obj<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> map<span class="token punctuation">}</span><span class="token function">objToMap</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'An'</span><span class="token punctuation">,</span> <span class="token string">'des'</span><span class="token punctuation">:</span> <span class="token string">'JS'</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Map {"name" => "An", "des" => "JS"}</span></code></pre><ol><li>Map 转 JSON</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">mapToJson</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>map<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'An'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'des'</span><span class="token punctuation">,</span> <span class="token string">'JS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mapToJson</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// [["name","An"],["des","JS"]]</span></code></pre><ol><li>JSON 转 Map</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">jsonToStrMap</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">objToMap</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>jsonStr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">jsonToStrMap</span><span class="token punctuation">(</span><span class="token string">'{"name": "An", "des": "JS"}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Map {"name" => "An", "des" => "JS"}</span></code></pre><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap 对象是一组键值对的集合，其中键是弱引用对象，而值可以是任意。</p><p>每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收。</p><p>属性：</p><p>constructor: 构造函数</p><p>方法：</p><p>has(key)：判断是否有 key 关联对象</p><p>get(key)：返回key关联对象（没有则则返回 undefined）</p><p>set(key)：设置一组key关联对象</p><p>delete(key)：移除 key 的关联对象</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>Set</li></ul><p>成员唯一、无序</p><p>可以遍历</p><ul><li>WeakSet</li></ul><p>成员都是对象</p><p>成员都是弱引用，可以被垃圾回收机制回收</p><p>不能遍历</p><ul><li>Map</li></ul><p>本质是键值对的集合</p><p>可以遍历</p><ul><li>WeakMap</li></ul><p>只接受对象作为键名</p><p>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收机制回收</p><p>不能遍历</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;p&gt;本系列旨在整理 JS 常见面试题，帮助梳理 JS 基础知识点。&lt;/p&gt;
&lt;h3 id=&quot;🌰-‘1’-‘2’-‘3’-map-parseIn
      
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="面试题" scheme="http://qiandream.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Vue-源码系列随读笔记之Array变化侦测</title>
    <link href="http://qiandream.cn/2019/08/18/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-array-bian-hua-zhen-ce/"/>
    <id>http://qiandream.cn/2019/08/18/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-array-bian-hua-zhen-ce/</id>
    <published>2019-08-18T10:34:52.000Z</published>
    <updated>2019-08-17T17:13:30.468Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档</p></blockquote><a id="more"></a><h3 id="什么是变化侦测"><a href="#什么是变化侦测" class="headerlink" title="什么是变化侦测"></a>什么是变化侦测</h3><p>从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。</p><p>简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。</p><p>Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。</p><hr><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> defineReactive <span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>     enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> val     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span>         <span class="token punctuation">}</span>        val <span class="token operator">=</span> newVal     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。</p><p>由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。</p><hr><h3 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h3><p>思考以下问题：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> globalObj <span class="token operator">=</span> <span class="token punctuation">{</span>  text1<span class="token punctuation">:</span> <span class="token string">'text1'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  template<span class="token punctuation">:</span>    <span class="token template-string"><span class="token string">`&lt;div>       &lt;span>{{text1}}&lt;/span>     &lt;div>`</span></span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> globalObj<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  template<span class="token punctuation">:</span>     <span class="token template-string"><span class="token string">`&lt;div>        &lt;span>{{text1}}&lt;/span>      &lt;div>`</span></span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> globalObj<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？</p><p>对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。</p><p>即：在 getter 中收集依赖，在 setter 中触发依赖。</p><hr><h3 id="依赖收集到哪里（Dep）"><a href="#依赖收集到哪里（Dep）" class="headerlink" title="依赖收集到哪里（Dep）"></a>依赖收集到哪里（Dep）</h3><p> 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>  constructor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 观察者集合</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 添加观察者</span>  addSub <span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 移除观察者</span>  removeSub <span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">,</span> sub<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  depend <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果存在 Dep.target，则进行依赖收集操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  notify <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 避免污染原来的集合</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 更新</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">remove</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>改造 defineReactive</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> defineReactive <span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>     enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> val     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span>         <span class="token punctuation">}</span>        val <span class="token operator">=</span> newVal        dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><hr><h3 id="什么是依赖"><a href="#什么是依赖" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。</p><p>然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。</p><p>收集谁？Watcher!</p><hr><h3 id="什么是-Watcher"><a href="#什么是-Watcher" class="headerlink" title="什么是 Watcher"></a>什么是 Watcher</h3><p>Watcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。</p><pre class=" language-javascript"><code class="language-javascript">vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'a.b.c'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// do something</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。</p><p>把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  constructor <span class="token punctuation">(</span>    vm<span class="token punctuation">:</span> Component<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 组件实例</span>    expOrFn<span class="token punctuation">:</span> string <span class="token operator">|</span> Function<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 要观察的表达式，函数，或者字符串，只要能触发取值操作</span>    cb<span class="token punctuation">:</span> Function <span class="token comment" spellcheck="true">// 被观察者发生变化后的回调</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm <span class="token comment" spellcheck="true">// Watcher有一个 vm 属性，表明它是属于哪个组件的</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb <span class="token comment" spellcheck="true">// 回调</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>expOrFn<span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 触发取值操作，进而触发属性的getter</span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>getter<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">)</span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">return</span> value  <span class="token punctuation">}</span>  update <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 更新</span>    <span class="token keyword">const</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cb<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。</p><p>在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。</p><p>只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。</p><p>依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。</p><p>不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。</p><p>parsePath函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> bailRE <span class="token operator">=</span> <span class="token regex">/[^\w.$]/</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>bailRE<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> segments <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">)</span> <span class="token keyword">return</span>          obj <span class="token operator">=</span> obj<span class="token punctuation">[</span>segments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> obj    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h3 id="递归侦测所有Key"><a href="#递归侦测所有Key" class="headerlink" title="递归侦测所有Key"></a>递归侦测所有Key</h3><p>前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    constructor <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    walk <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            defineReactive <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> obj<span class="token punctuation">[</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>       enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>       configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>       <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> val       <span class="token punctuation">}</span><span class="token punctuation">,</span>       <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span>           <span class="token punctuation">}</span>          val <span class="token operator">=</span> newVal          dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>Observer 类，用于将一个正常的 object 转换成被侦测的 object。</p><p>判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。</p><p>最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。</p><p>当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。</p><p>Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。</p><p>我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。</p><p>收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。</p><p>所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。</p><p>Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。</p><p>由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。</p><p>在 Vue 中，对象新增属性或删除属性都无法被侦测到。</p><p><img src="https://screenshot.net/zh/qv9nwto" alt=""></p><p>Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。</p><p>当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。</p><p>当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。</p><p>Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://qiandream.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JS-执行上下文和执行上下文栈</title>
    <link href="http://qiandream.cn/2019/07/26/js-zhi-xing-shang-xia-wen-he-zhi-xing-zhan/"/>
    <id>http://qiandream.cn/2019/07/26/js-zhi-xing-shang-xia-wen-he-zhi-xing-zhan/</id>
    <published>2019-07-26T07:18:52.000Z</published>
    <updated>2019-07-26T07:28:37.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文栈用于存储在代码执行期间创建的所有执行上下文。</p></blockquote><a id="more"></a><h2 id="理解执行上下文和执行上下文栈"><a href="#理解执行上下文和执行上下文栈" class="headerlink" title="理解执行上下文和执行上下文栈"></a>理解执行上下文和执行上下文栈</h2><h3 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h3><p>执行上下文总共有三种类型：</p><ul><li><p>全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 会指向这个全局对象。</p></li><li><p>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p></li><li><p>Eval 函数执行上下文：运行在 Eval 函数中的代码。</p></li></ul><hr><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>接下来问题来了，我们写了那么多函数，如何管理创建的那么多执行上下文呢？</p><p>Javascript 创建了执行上下文栈，也叫调用栈，来管理在代码执行期间创建的所有执行上下文。</p><p>首次运行 Javascript 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。</p><p>根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从栈中 Pop 出，上下文控制权将会移到当前执行栈的下一个执行上下文。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'Hello World!'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside first function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Again inside first function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside second function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside Global Execution Context'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="&#39;https://user-gold-cdn.xitu.io/2018/11/5/166e258e1d0281a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#39;" alt=""></p><hr><h3 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h3><p>执行上下文分为两个阶段创建：1） 创建阶段 2）执行阶段</p><h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><ul><li><p>确定 this 的值，也被称为 This Binding</p></li><li><p>LexicalEnvironment-词法环境组件被创建</p></li><li><p>VariableEnvironment-变量环境组件被创建</p></li></ul><pre class=" language-javascript"><code class="language-javascript">ExecutionContext <span class="token operator">=</span> <span class="token punctuation">{</span>    ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">this</span> value<span class="token operator">></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 确定 this</span>    LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 词法环境</span>    VariableEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 变量环境</span><span class="token punctuation">}</span></code></pre><h5 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h5><ul><li><p>全局执行上下文中，this 指向全局对象，在浏览器中 this 的值指向 window 对象，而在 nodejs 中指向这个文件的 module 对象。</p></li><li><p>函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显示绑定、new 绑定等。</p></li></ul><h5 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h5><p>词法环境有两个组成部分：</p><ul><li><p>环境记录：存储变量和函数声明的实际位置</p></li><li><p>对外部环境的引用：可以访问其外部词法环境</p></li></ul><p>词法环境有两种类型：</p><ul><li><p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window）及其关联的方法和属性以及任何用户自定义的全局变量， this 的值指向这个全局对象。</p></li><li><p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境，</p></li></ul><pre class=" language-javascript"><code class="language-javascript">GlobalExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 全局执行上下文</span>  LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 词法环境</span>    EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 环境记录</span>      Type<span class="token punctuation">:</span> <span class="token string">"Object"</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">// 全局环境</span>      <span class="token comment" spellcheck="true">// 标识符绑定在这里 </span>      outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span>                 <span class="token comment" spellcheck="true">// 对外部环境的引用</span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span>FunctionExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 函数执行上下文</span>  LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 词法环境</span>      EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 环境记录</span>        Type<span class="token punctuation">:</span> <span class="token string">"Declarative"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 函数环境</span>        <span class="token comment" spellcheck="true">// 标识符绑定在这里          // 对外部环境的引用</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global or outer <span class="token keyword">function</span> environment reference<span class="token operator">></span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h5 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h5><p>  变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>  在ES6中，词法环境和变量环境的区别在于前者用于存储函数声明和变量(let const)绑定，后者仅用于存储变量(var)绑定。</p><pre class=" language-javascript"><code class="language-javascript">  GlobalExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>    ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">></span><span class="token punctuation">,</span>    LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>          Type<span class="token punctuation">:</span> <span class="token string">"Object"</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 标识符绑定在这里  </span>        a<span class="token punctuation">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">></span><span class="token punctuation">,</span>          b<span class="token punctuation">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">></span><span class="token punctuation">,</span>          multiply<span class="token punctuation">:</span> <span class="token operator">&lt;</span> func <span class="token operator">></span>        <span class="token punctuation">}</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    VariableEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>          Type<span class="token punctuation">:</span> <span class="token string">"Object"</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 标识符绑定在这里  </span>        c<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>        <span class="token punctuation">}</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  FunctionExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>      ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">></span><span class="token punctuation">,</span>    LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>          Type<span class="token punctuation">:</span> <span class="token string">"Declarative"</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 标识符绑定在这里  </span>        Arguments<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span>GlobalLexicalEnvironment<span class="token operator">></span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    VariableEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>          Type<span class="token punctuation">:</span> <span class="token string">"Declarative"</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 标识符绑定在这里  </span>        g<span class="token punctuation">:</span> undefined        <span class="token punctuation">}</span><span class="token punctuation">,</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span>GlobalLexicalEnvironment<span class="token operator">></span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>  变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined (var 情况下) 或保持未初始化 (let、const 情况下)。所以这就是为什么可以在声明之前访问 var 定义的变量，如果在声明之前访问 let 和 const 定义的变量会提示引用错误的原因。这就是所谓的变量提升。</p><h5 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h5><p>  执行上下文的代码分为两个阶段进行处理：</p><ul><li><p>进入执行上下文</p></li><li><p>代码执行</p><h6 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h6><p>此时的变量对象包括（如下顺序初始化）：</p></li><li><p>函数所有的形参：没有实参，属性值设为 undefined。</p></li><li><p>函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li><li><p>变量声明：如果变量名称与已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。</p><p>```javascript<br>function foo(a) {<br>var b = 2;<br>function c() {}<br>var d = function() {};</p><p>b = 3;<br>}</p></li></ul><p>foo(1);</p><pre><code>  ```javascript    AO = {        arguments: {            0: 1,            length: 1        },        a: 1,        b: undefined,        c: reference to function c(){},        d: undefined    }</code></pre><p>  形参 arguments 已经有值了，但是变量还是 undefined，只是初始化的值。</p><h6 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h6><p>  这个阶段会顺序执行代码，并修改变量的值。</p><pre class=" language-javascript"><code class="language-javascript">AO <span class="token operator">=</span> <span class="token punctuation">{</span>    arguments<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        length<span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    b<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    c<span class="token punctuation">:</span> reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    d<span class="token punctuation">:</span> reference to FunctionExpression <span class="token string">"d"</span><span class="token punctuation">}</span></code></pre><p>  总结如下：</p><ul><li><p>全局上下文的变量对象初始化是全局对象。</p></li><li><p>函数上下文的变量对象初始化只包括 arguments 对象。</p></li><li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值。</p></li><li><p>在代码执行阶段，会再次修改变量对象的属性值。</p></li></ul><h2 id="深入执行上下文和执行上下文栈"><a href="#深入执行上下文和执行上下文栈" class="headerlink" title="深入执行上下文和执行上下文栈"></a>深入执行上下文和执行上下文栈</h2><p>JS 是单线程的语言，执行顺序是顺序执行，但是 JS 引擎并不是一行一行地分析和执行代码，而是一段一段地分析和执行，先进行编译然后才是执行。</p><p>有如下两段代码，执行结果是一样的，但是两段代码究竟有什么不同？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> scope<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> scope<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>答案是执行上下文栈的变化不一样。</p><p>第一段代码：</p><pre class=" language-javascript"><code class="language-javascript">ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>checkscope<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>f<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第二段代码：</p><pre class=" language-javascript"><code class="language-javascript">ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>checkscope<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>f<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h3><p>在函数执行上下文中，用活动对象来表示变量对象。</p><p>活动对象和变量对象的区别在于：</p><ul><li><p>变量对象是规范上或 JS 引擎上实现的，并不能在 JS 环境中直接访问。</p></li><li><p>当进入到一个执行上下文后，这个变量对象会被激活，所以叫活动对象，这时活动对象上的各种属性才能被访问。</p></li></ul><p>调用函数时，会自动为其创建一个 arguments 对象，并初始化局部变量 arguments。所有作为参数传入的值都会成为 arguments 对象的数组元素。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5bf3d20ff265da61776b95da" target="_blank" rel="external">理解JavaScript 中的执行上下文和执行栈</a></li><li><a href="https://juejin.im/post/5bf3d20ff265da61776b95da" target="_blank" rel="external">JavaScript深入之执行上下文栈和变量对象</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文栈用于存储在代码执行期间创建的所有执行上下文。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://qiandream.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Node-NodeJS核心基础知识</title>
    <link href="http://qiandream.cn/2019/06/26/node-nodejs-he-xin-ji-chu-zhi-shi/"/>
    <id>http://qiandream.cn/2019/06/26/node-nodejs-he-xin-ji-chu-zhi-shi/</id>
    <published>2019-06-26T15:11:52.000Z</published>
    <updated>2019-07-07T11:26:33.333Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…</p></blockquote><a id="more"></a><h3 id="Nodejs-概述"><a href="#Nodejs-概述" class="headerlink" title="Nodejs 概述"></a>Nodejs 概述</h3><p>Nodejs 是基于 Chrome V8 引擎构建的，由事件循环分布 I/O 任务，最终工作线程会将任务放到线程池中执行，而事件循环等待执行结果就可以了。</p><ul><li><p>Nodejs 是 Javascript 的运行时环境。</p></li><li><p>Nodejs 构建在 Chrome V8 这个著名的 Javascript 引擎上。</p></li><li><p>Nodejs 每个函数都是同步的，而 I/O 操作是异步的。</p></li><li><p>Nodejs 使用 npm 作为包管理器。</p></li></ul><h3 id="Nodejs-安装"><a href="#Nodejs-安装" class="headerlink" title="Nodejs 安装"></a>Nodejs 安装</h3><p>Nodejs 支持 macOS、Linux 以及 Windows 等多个主流操作系统。</p><h4 id="3m-安装法"><a href="#3m-安装法" class="headerlink" title="3m 安装法"></a>3m 安装法</h4><ul><li><p>nvm 开源的 Nodejs 版本管理器</p></li><li><p>npm Nodejs 包管理端</p></li><li><p>nrm 解决 npm 镜像访问慢的问题。</p></li></ul><h5 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h5><h6 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h6><p>首先，在终端执行如下命令：</p><pre class=" language-javascript"><code class="language-javascript">$ curl <span class="token operator">-</span>o<span class="token operator">-</span> https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span>creationix<span class="token operator">/</span>nvm<span class="token operator">/</span>v0<span class="token number">.33</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">/</span>install<span class="token punctuation">.</span>sh <span class="token operator">|</span> bash</code></pre><p>意思是通过 curl 命令下载 install.sh 脚本并执行。执行完成后，重新打开终端窗口，执行</p><pre class=" language-javascript"><code class="language-javascript">vi <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>zshrc</code></pre><p>把 nvm 命令的执行路径放到 ~/.zshrc 文件下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> NVM_DIR<span class="token operator">=</span><span class="token string">"$HOME/.nvm"</span><span class="token punctuation">[</span> <span class="token operator">-</span>s <span class="token string">"$NVM_DIR/nvm.sh"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span> <span class="token string">"$NVM_DIR/nvm.sh"</span></code></pre><p>执行 source 命令，使系统环境变量生效：</p><pre class=" language-javascript"><code class="language-javascript">source <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>zshrc</code></pre><p>输入：</p><pre class=" language-javascript"><code class="language-javascript">nvm <span class="token operator">--</span>version<span class="token number">0.33</span><span class="token punctuation">.</span><span class="token number">1</span></code></pre><h6 id="查看可安装的-Nodejs-版本"><a href="#查看可安装的-Nodejs-版本" class="headerlink" title="查看可安装的 Nodejs 版本"></a>查看可安装的 Nodejs 版本</h6><p>安装 Node 之前，需要了解通过 nvm 可以安装哪些版本的 Node。</p><pre class=" language-javascript"><code class="language-javascript">nvm ls<span class="token operator">-</span>remote</code></pre><ul><li><p>LTS 版本是指长期支持版本，推荐给大部分用户使用，一般在生产环境中使用。</p></li><li><p>Current 版本是指当前正在开发的尝鲜版本，不完全版本，需要经过一段时间的测试、开发和修复 bug 等才能变为 LTS 版本，一般供开发者学习。</p></li></ul><h6 id="安装-Node"><a href="#安装-Node" class="headerlink" title="安装 Node"></a>安装 Node</h6><pre class=" language-javascript"><code class="language-javascript">nvm install <span class="token number">10.15</span><span class="token punctuation">.</span><span class="token number">3</span></code></pre><p>通过 nvm 安装的 Node 位于用户目录下，而非系统目录下。</p><pre class=" language-javascript"><code class="language-javascript">which node<span class="token operator">/</span>Users<span class="token regex">/wangqian/</span><span class="token punctuation">.</span>nvm<span class="token operator">/</span>versions<span class="token operator">/</span>node<span class="token operator">/</span>v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token operator">/</span>bin<span class="token operator">/</span>node</code></pre><p>默认使用某个 Node 版本来编译代码，需要手动指定一个 default 别名。</p><pre class=" language-javascript"><code class="language-javascript">nvm alias <span class="token keyword">default</span> node<span class="token keyword">default</span> <span class="token operator">-</span><span class="token operator">></span> node <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre><p>此时，输入 node -v，以后在终端的任何地方使用的默认版本都会是你设置的版本。</p><pre class=" language-javascript"><code class="language-javascript">node <span class="token operator">-</span>vv10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span></code></pre><p>如何使用 nvm 切换 Node 版本？首先安装 Node 8.x</p><pre class=" language-javascript"><code class="language-javascript">nvm install <span class="token number">8</span></code></pre><p>切换到 8.x 版本：</p><pre class=" language-javascript"><code class="language-javascript">nvm use <span class="token number">8</span>Now using node v8<span class="token number">.16</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">(</span>npm v6<span class="token number">.4</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">)</span>node <span class="token operator">-</span>vv8<span class="token number">.16</span><span class="token punctuation">.</span><span class="token number">0</span></code></pre><p>如何知道本机通过 nvm 安装了哪些 Node 版本呢？</p><pre class=" language-javascript"><code class="language-javascript">nvm ls<span class="token operator">-</span><span class="token operator">></span>      v8<span class="token number">.16</span><span class="token punctuation">.</span><span class="token number">0</span>       v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token keyword">default</span> <span class="token operator">-</span><span class="token operator">></span> node <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span>node <span class="token operator">-</span><span class="token operator">></span> stable <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span>stable <span class="token operator">-</span><span class="token operator">></span> <span class="token number">10.15</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> v10<span class="token number">.15</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span>iojs <span class="token operator">-</span><span class="token operator">></span> N<span class="token operator">/</span>A <span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span>lts<span class="token operator">/</span><span class="token operator">*</span> <span class="token operator">-</span><span class="token operator">></span> lts<span class="token operator">/</span>dubnium <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> N<span class="token operator">/</span>A<span class="token punctuation">)</span>lts<span class="token operator">/</span>argon <span class="token operator">-</span><span class="token operator">></span> v4<span class="token number">.9</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> N<span class="token operator">/</span>A<span class="token punctuation">)</span>lts<span class="token operator">/</span>boron <span class="token operator">-</span><span class="token operator">></span> v6<span class="token number">.17</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> N<span class="token operator">/</span>A<span class="token punctuation">)</span>lts<span class="token operator">/</span>carbon <span class="token operator">-</span><span class="token operator">></span> v8<span class="token number">.16</span><span class="token punctuation">.</span><span class="token number">0</span>lts<span class="token operator">/</span>dubnium <span class="token operator">-</span><span class="token operator">></span> v10<span class="token number">.16</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">></span> N<span class="token operator">/</span>A<span class="token punctuation">)</span></code></pre><p>若要经常切换 Node 版本，最痛苦的莫过于全局模块需要重新安装。针对这种情况，nvm 提供了一个很贴心的一键安装全局模块的 nvm reinstall-packages命令。</p><pre class=" language-javascript"><code class="language-javascript">nvm reinstall<span class="token operator">-</span>packages <span class="token number">6</span></code></pre><p>nvm 默认远端下载地址是 <a href="https://nodejs.org/dist，如果想安装自定义的" target="_blank" rel="external">https://nodejs.org/dist，如果想安装自定义的</a> Node 版本，可以指定 nvm 的远端下载地址。</p><pre class=" language-javascript"><code class="language-javascript">NVM_NODEJS_ORG_MIRROR<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>nodejs<span class="token punctuation">.</span>org<span class="token operator">/</span>download<span class="token operator">/</span>chakracore<span class="token operator">-</span>nightly</code></pre><p>对于一些正在测试的尝鲜版本，可以在下面的地址下载。</p><pre class=" language-javascript"><code class="language-javascript">NVM_NODEJS_ORG_MIRROR<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>nodejs<span class="token punctuation">.</span>org<span class="token operator">/</span>download<span class="token operator">/</span>test</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node" scheme="http://qiandream.cn/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>JS-this、call、apply</title>
    <link href="http://qiandream.cn/2019/06/13/js-this-call-apply/"/>
    <id>http://qiandream.cn/2019/06/13/js-this-call-apply/</id>
    <published>2019-06-13T05:00:52.000Z</published>
    <updated>2019-06-16T09:51:28.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。</p></blockquote><a id="more"></a><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>Javascript 中的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的。</p><h4 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h4><p>在具体实际应用中，this 的指向通常可分为以下4种:</p><ul><li><p>作为对象的方法调用</p></li><li><p>作为普通函数调用</p></li><li><p>作为构造器调用</p></li><li><p>Function.prototype.call、Function.prototype.apply</p></li></ul><h5 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h5><p>当函数作为对象的方法调用时，this 指向该对象：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  getA<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>obj<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1</span></code></pre><h5 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h5><p>函数作为普通函数调用，此时的 this 总是指向全局对象。在浏览器中，这个全局对象是 window 对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">var</span> getName <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1</span></code></pre><h5 id="作为构造器调用"><a href="#作为构造器调用" class="headerlink" title="作为构造器调用"></a>作为构造器调用</h5><p>当用 new 运算符调用函数时，该函数会返回一个对象。通常情况下，构造器里的 this 就指向返回的这个对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> MyClass <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'sven'</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 'sven'</span></code></pre><p>如果构造器显式地返回了一个对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> MyClass <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'sven'</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'wang'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// wang</span></code></pre><p>如果构造器不显式地返回任何数据，或者返回一个非对象类型的数据，就不会造成上述问题。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> MyClass <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'sven'</span>  <span class="token keyword">return</span> <span class="token string">'wang'</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 'sven'</span></code></pre><h5 id="Function-prototype-call、Function-prototype-apply"><a href="#Function-prototype-call、Function-prototype-apply" class="headerlink" title="Function.prototype.call、Function.prototype.apply"></a>Function.prototype.call、Function.prototype.apply</h5><p>用 Function.prototype.call、Function.prototype.apply 可以动态改变传入函数的 this。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'wang'</span><span class="token punctuation">,</span>  getName<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'zhang'</span><span class="token punctuation">}</span>obj1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>obj1<span class="token punctuation">.</span>getName<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 'wang'</span><span class="token comment" spellcheck="true">// 'zhang'</span></code></pre><hr><h4 id="丢失的-this"><a href="#丢失的-this" class="headerlink" title="丢失的 this"></a>丢失的 this</h4><p>举个例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'wang'</span><span class="token punctuation">,</span>  getName<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>obj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>getName <span class="token operator">=</span> obj<span class="token punctuation">.</span>getName<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 'wang'</span><span class="token comment" spellcheck="true">// undefined</span></code></pre><p>当调用 obj.getName 时，此时 this 指向 obj 对象，所以输出 ‘wang’。</p><p>当用另外一个变量 getName 来引用 obj.getName，并且调用时，它是被当作普通函数来调用，此时 this 指向 window 对象，所以输出 undefined。</p><hr><h4 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h4><p>在实际开发中，特别是在一些函数式风格的代码编写中，call 和 apply 方法尤为重要。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>call 和 apply 作用一模一样，区别在于传入参数形式的不同。</p><p>apply 接受两个参数，第一个参数指定了函数体内的 this 对象的指向，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。</p><p>call 传入的参数数量不固定，跟 apply 不同的是，第一个参数也是代表函数体内 this 对象的指向，从第二个参数开始，每个参数依此传入函数。</p><p>当使用 call 或者 apply 时，如果我们传入的第一个参数为 null，则函数体内的 this 会指向默认的宿主对象。</p><p>但如果在严格模式下，函数体内的 this 还是为 null。</p><h5 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h5><p>下面将详细介绍 call 和 apply 在实际开发中的用途。</p><h6 id="改变-this-指向"><a href="#改变-this-指向" class="headerlink" title="改变 this 指向"></a>改变 this 指向</h6><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'wang'</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'zhang'</span><span class="token punctuation">}</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'qian'</span><span class="token keyword">var</span> getName <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span>getName <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'qian'</span>getName<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 'wang'</span>getName<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'zhang'</span></code></pre><h6 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h6><p>大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向。即使没有原生的 Function.prototype.bind ，我们也可以自己来模拟：</p><pre class=" language-javascript"><code class="language-javascript">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>bind <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment" spellcheck="true">// 保存原函数</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 返回一个新的函数</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行新的函数时，会把之前传入的 context 当作新函数体内的 this</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'seven'</span><span class="token punctuation">}</span><span class="token keyword">var</span> func <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>上述为一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一些，使得可以在 func 函数中预先填入一些参数：</p><pre class=" language-javascript"><code class="language-javascript">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>bind <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>  <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 保存原函数</span>      context <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 需要绑定的 this 上下文</span>      args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 剩余的参数转化为数组</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 返回一个新韩淑</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 执行新的函数时，把之前传入的 context 当作新函数体内的 this，并且组合两次分别传入的参数，作为新函数的参数</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'seven'</span><span class="token punctuation">}</span><span class="token keyword">var</span> func <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span></code></pre><h6 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h6><p>借用方法的第一种场景是”借用构造函数“，通过这种技术，可以实现一些类似继承的效果：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> A <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span><span class="token keyword">var</span> B <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  A<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">}</span>B<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token string">'wang'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'wang'</span></code></pre><p>附：</p><p>函数的参数列表 arguments 是一个类数组对象，并不是真正的数组。</p><p>如果想在 arguments 中添加一个元素，通常会借用 Array.prototype.push</p><p>如果想把 arguments 转换为真正的数组，通常会借用 Array.prototype.slice</p><p>如果想截取 arguments 中的第一个元素，通常会借用 Array.prototype.shift</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://qiandream.cn/tags/JavaScript/"/>
    
  </entry>
  
</feed>
