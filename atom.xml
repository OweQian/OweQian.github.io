<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>W | 个人博客 | web前端</title>
  
  <subtitle>wangxiaobai</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qiandream.cn/"/>
  <updated>2020-05-11T16:59:17.993Z</updated>
  <id>http://qiandream.cn/</id>
  
  <author>
    <name>wangxiaobai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-006-合并两个有序链表</title>
    <link href="http://qiandream.cn/2020/05/09/leetcode/leetcode-007-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/"/>
    <id>http://qiandream.cn/2020/05/09/leetcode/leetcode-007-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/</id>
    <published>2020-05-09T12:01:52.000Z</published>
    <updated>2020-05-11T16:59:17.993Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="external">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。示例 1:给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-遍历、splice"><a href="#解法-遍历、splice" class="headerlink" title="解法 - 遍历、splice"></a>解法 - 遍历、splice</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {number[]} nums * @return {number} */</span><span class="token keyword">var</span> removeDuplicates <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token operator">--</span>i        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>[1,1,2]</code></pre><p>输出：</p><pre><code>2</code></pre><p>预期结果：</p><pre><code>2</code></pre><ul><li>解题思路：</li></ul><p>遍历数组，比较当前元素和下一个元素，如果两个元素相等，则移除元素，并处理当前索引(因为元素移除，当前索引值需要减一个值)，继续遍历，直到结束，返回数组长度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-006-合并两个有序链表</title>
    <link href="http://qiandream.cn/2020/05/09/leetcode/leetcode-006-he-bing-liang-ge-you-xu-lian-biao/"/>
    <id>http://qiandream.cn/2020/05/09/leetcode/leetcode-006-he-bing-liang-ge-you-xu-lian-biao/</id>
    <published>2020-05-09T12:01:52.000Z</published>
    <updated>2020-05-11T16:59:24.801Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：链表</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="external">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p></li><li><p>题目内容：</p></li></ul><pre><code>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-递归（链表数据结构、边界）"><a href="#解法-递归（链表数据结构、边界）" class="headerlink" title="解法 - 递归（链表数据结构、边界）"></a>解法 - 递归（链表数据结构、边界）</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } */</span><span class="token comment" spellcheck="true">/** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */</span><span class="token keyword">const</span> mergeTwoLists <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> l2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> l2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>[1,2,4][1,3,4]</code></pre><p>输出：</p><pre><code>[1,1,2,3,4,4]</code></pre><p>预期结果：</p><pre><code>[1,1,2,3,4,4]</code></pre><ul><li>解题思路：</li></ul><p>使用递归来解题，将两个链表头部较小的一个与剩下的元素合并，并返回排好序的链表头，当两条链表中的一条为空时终止递归。</p><ul><li><p>时间复杂度：O(M+N)</p></li><li><p>空间复杂度：O(M+N)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-005-有效的括号</title>
    <link href="http://qiandream.cn/2020/05/08/leetcode/leetcode-005-you-xiao-de-gua-hao/"/>
    <id>http://qiandream.cn/2020/05/08/leetcode/leetcode-005-you-xiao-de-gua-hao/</id>
    <published>2020-05-08T12:01:52.000Z</published>
    <updated>2020-05-08T14:45:44.585Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组、栈</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="external">https://leetcode-cn.com/problems/valid-parentheses/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例 1:输入: &quot;()&quot;输出: true示例 2:输入: &quot;()[]{}&quot;输出: true示例 3:输入: &quot;(]&quot;输出: false示例 4:输入: &quot;([)]&quot;输出: false示例 5:输入: &quot;{[]}&quot;输出: true</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-栈"><a href="#解法-栈" class="headerlink" title="解法 - 栈"></a>解法 - 栈</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {string} s * @return {boolean} */</span><span class="token keyword">var</span> isValid <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> mapper <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">'('</span><span class="token punctuation">:</span> <span class="token string">')'</span><span class="token punctuation">,</span>        <span class="token string">'{'</span><span class="token punctuation">:</span> <span class="token string">'}'</span><span class="token punctuation">,</span>        <span class="token string">'['</span><span class="token punctuation">:</span> <span class="token string">']'</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> peak <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">!==</span> mapper<span class="token punctuation">[</span>peak<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>&quot;()[]{}&quot;</code></pre><p>输出：</p><pre><code>true</code></pre><p>预期结果：</p><pre><code>true</code></pre><ul><li>解题思路：</li></ul><p>使用栈，遍历输入字符串</p><p>如果当前字符为左半边括号时，则将其压入栈中</p><p>如果遇到右半边括号时，分类讨论：</p><p>1）如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环</p><p>2）若此时栈为空，则直接返回 false</p><p>3）若不为对应的左半边括号，反之返回 false</p><p><img src="https://github.com/azl397985856/leetcode/raw/master/assets/20.validParentheses.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-构造器模式</title>
    <link href="http://qiandream.cn/2020/05/01/she-ji-mo-shi/gou-zao-qi-mo-shi/"/>
    <id>http://qiandream.cn/2020/05/01/she-ji-mo-shi/gou-zao-qi-mo-shi/</id>
    <published>2020-05-01T03:54:52.000Z</published>
    <updated>2020-05-08T17:10:33.667Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>使用构造函数初始化对象，抽象了每个实例的变与不变。</p></blockquote><a id="more"></a><p>设计模式的核心操作是去观察你整个逻辑里面的变与不变，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。</p><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：公司员工信息录入系统，每个员工有姓名、年龄、工种，大约有500名员工。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>创建一个 User 构造函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token punctuation">,</span> age<span class="token punctuation">,</span> career<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age    <span class="token keyword">this</span><span class="token punctuation">.</span>career <span class="token operator">=</span> career <span class="token punctuation">}</span></code></pre><p>接下来要做的事情，就是让程序自动地去读取数据库里面一行行的员工信息，然后把拿到的姓名、年龄等字段塞进User函数里，进行一个简单的调用：</p><pre><code>const user = new User(name, age, career)</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在创建一个user过程中，谁变了，谁不变？</p><p>很明显，变的是每个user的姓名、年龄、工种这些值，这是用户的个性，不变的是每个员工都具备姓名、年龄、工种这些属性，这是用户的共性。</p><p>那么构造器做了什么？</p><p>构造器是不是将 name、age、career 赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了共性的不变，同时将 name、age、career 各自的取值操作开放，确保了个性的灵活？</p><p>在使用构造器模式的时候，我们本质上是去抽象了每个对象实例的变与不变。</p><p>参考：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;使用构造函数初始化对象，抽象了每个实例的变与不变。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://qiandream.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://qiandream.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-中介者模式</title>
    <link href="http://qiandream.cn/2020/04/15/she-ji-mo-shi/zhong-jie-zhe-mo-shi/"/>
    <id>http://qiandream.cn/2020/04/15/she-ji-mo-shi/zhong-jie-zhe-mo-shi/</id>
    <published>2020-04-15T03:54:52.000Z</published>
    <updated>2020-04-23T06:51:50.749Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>通过一个中介者对象，其它所有相关对象都通过该中介者对象来通信，而不是相互引用，当其中一个对象发生变化时，只需要通知中介者对象即可。通过中介者模式可以解除对象之间的紧耦合关系。</p></blockquote><a id="more"></a><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>先通过一张 loading 图占位，然后通过异步的方式去加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> goods <span class="token operator">=</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//手机库存</span>    <span class="token string">'red|32G'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    <span class="token string">'red|64G'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">'blue|32G'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span>    <span class="token string">'blue|32G'</span><span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//中介者</span><span class="token keyword">const</span> mediator <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> colorSelect <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'colorSelect'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> memorySelect <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'memorySelect'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> numSelect <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'numSelect'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        changed<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">switch</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">case</span> colorSelect<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">//TODO</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> memorySelect<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">//TODO</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> numSelect<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">//TODO</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>colorSelect<span class="token punctuation">.</span>onchange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mediator<span class="token punctuation">.</span><span class="token function">changed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>memorySelect<span class="token punctuation">.</span>onchange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mediator<span class="token punctuation">.</span><span class="token function">changed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>numSelect<span class="token punctuation">.</span>onchange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mediator<span class="token punctuation">.</span><span class="token function">changed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>参考：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;通过一个中介者对象，其它所有相关对象都通过该中介者对象来通信，而不是相互引用，当其中一个对象发生变化时，只需要通知中介者对象即可。通过中介者模式可以解除对象之间的紧耦合关系。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://qiandream.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://qiandream.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-策略模式</title>
    <link href="http://qiandream.cn/2020/04/15/she-ji-mo-shi/ce-lue-mo-shi/"/>
    <id>http://qiandream.cn/2020/04/15/she-ji-mo-shi/ce-lue-mo-shi/</id>
    <published>2020-04-15T03:54:52.000Z</published>
    <updated>2020-04-17T04:13:28.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>定义一系列算法，将它们一个个封装起来，并使它们可以相互替换。</p></blockquote><a id="more"></a><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放。例如：绩效为 S 的人年终奖有 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，绩效为 B 的人年终奖有 2 倍工资。假设财务要求我们提供一段代码，来方便他们计算员工的年终奖。</p><h2 id="最初代码实现"><a href="#最初代码实现" class="headerlink" title="最初代码实现"></a>最初代码实现</h2><p>我们可以编写一个 calculateBonus 函数来计算每个人的奖金额数，函数需要接受两个参数：员工的工资数额和他的绩效考核等级。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> calculateBonus <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>performanceLevel<span class="token punctuation">,</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以发现，这段代码十分简单，但存在显而易见的缺点。</p><ul><li><p>函数体庞大，包含很多if-else语句</p></li><li><p>缺乏弹性，如果新增等级 C，要修改函数内部实现</p></li><li><p>复用性差</p></li></ul><h2 id="组合函数实现"><a href="#组合函数实现" class="headerlink" title="组合函数实现"></a>组合函数实现</h2><p>一般我们最容易想到就是使用组合函数来重构代码，把各种算法封装到一个小小的函数里。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> performanceS <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> performanceA <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> performanceB <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> calculateBonus <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>performanceLevel<span class="token punctuation">,</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">performanceS</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">performanceS</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">performanceS</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>目前，我们的程序得到了一定的改善，但这种改善非常有限，我们依然没有解决最重要的问题：calculateBonus函数有可能越来越庞大，而且在系统变化的时候缺乏弹性。</p><h2 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h2><p>策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。</p><p>一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context,Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> strategies <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'S'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> calculateBonus <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>performanceLevel<span class="token punctuation">,</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> strategies<span class="token punctuation">[</span>performanceLevel<span class="token punctuation">]</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>参考：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;定义一系列算法，将它们一个个封装起来，并使它们可以相互替换。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://qiandream.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://qiandream.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-代理模式</title>
    <link href="http://qiandream.cn/2020/04/15/she-ji-mo-shi/dai-li-mo-shi/"/>
    <id>http://qiandream.cn/2020/04/15/she-ji-mo-shi/dai-li-mo-shi/</id>
    <published>2020-04-15T03:54:52.000Z</published>
    <updated>2020-04-23T06:40:31.990Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>为一个对象提供一个代用品或占位符，以便控制对它的访问。</p></blockquote><a id="more"></a><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：虚拟代理实现图片懒加载</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>先通过一张 loading 图占位，然后通过异步的方式去加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> imgFunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> imgNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>imgNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        setSrc<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>            imgNode<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> proxyImg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       imgFunc<span class="token punctuation">.</span><span class="token function">setSrc</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        setSrc<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>            imgFunc<span class="token punctuation">.</span><span class="token function">setSrc</span><span class="token punctuation">(</span><span class="token string">'./loading.gif'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            img<span class="token punctuation">.</span>src <span class="token operator">=</span> src          <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxyImg<span class="token punctuation">.</span><span class="token function">setSrc</span><span class="token punctuation">(</span><span class="token string">'./pic.pmg'</span><span class="token punctuation">)</span></code></pre><p>使用代理模式实现图片懒加载的优点还有符合单一职责原则。减少一个类或方法的粒度和耦合度。</p><p>参考：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;为一个对象提供一个代用品或占位符，以便控制对它的访问。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://qiandream.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://qiandream.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="http://qiandream.cn/2020/04/14/shu-ju-jie-gou/shu-ju-jie-gou-zhan/"/>
    <id>http://qiandream.cn/2020/04/14/shu-ju-jie-gou/shu-ju-jie-gou-zhan/</id>
    <published>2020-04-14T10:44:52.000Z</published>
    <updated>2020-04-14T14:22:07.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p></blockquote><a id="more"></a><h1 id="基于数组的栈"><a href="#基于数组的栈" class="headerlink" title="基于数组的栈"></a>基于数组的栈</h1><p>我们将创建一个类来表示栈，需要一种数据结构来保存栈里的元素。可以选择数组。数组允许我们在任何位置添加或删除元素。由于栈遵循LIFO原则，需要对元素的插入和删除功能进行限制。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新增元素到栈顶</span>    <span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 移除栈顶元素,同时返回被移除的元素</span>    <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈顶元素</span>    <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 是否为空栈</span>    <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈里的元素个数</span>    <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 清空栈元素</span>    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>创建一个 Stack 类最简单的方式是使用一个数组来存储其元素。在处理大量数据的时候，我们同样需要评估如何操作数据是最高效的。在使用数组时，大部分方法的时间复杂度是O(n)。</p><h1 id="基于对象的栈"><a href="#基于对象的栈" class="headerlink" title="基于对象的栈"></a>基于对象的栈</h1><p>我们将创建一个基于对象来存储栈里的元素的类来表示栈，这里新增一个 count 来表示栈的元素个数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新增元素到栈顶</span>    <span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 移除栈顶元素,同时返回被移除的元素</span>    <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 首先判断是否为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> undefined        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈顶元素</span>    <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> undefined<span class="token punctuation">;</span>        <span class="token punctuation">}</span>           <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 是否为空栈</span>    <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈里的元素个数</span>    <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 清空栈元素</span>    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://qiandream.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-单例模式</title>
    <link href="http://qiandream.cn/2020/04/14/she-ji-mo-shi/dan-li-mo-shi/"/>
    <id>http://qiandream.cn/2020/04/14/she-ji-mo-shi/dan-li-mo-shi/</id>
    <published>2020-04-14T03:54:52.000Z</published>
    <updated>2020-04-14T04:46:25.202Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>保证一个类只有一个实例，并提供一个访问它的全局访问点。</p></blockquote><a id="more"></a><h1 id="单例模式的实现思路"><a href="#单例模式的实现思路" class="headerlink" title="单例模式的实现思路"></a>单例模式的实现思路</h1><p>思考：如何才能保证一个类仅有一个实例？</p><p>通常，当我们创建一个类后，可以通过 new 关键字调用构造函数进而生成任意的实例。</p><pre><code>class SingleObj {    show() {        console.log(&#39;我是一个单例对象&#39;)    }}const s1 = new SingleObj()const s2 = new SingleObj()// falseconsole.log(s1 === s2)</code></pre><p>new 一个 s1，new 一个 s2，很明显 s1 和 s2 之间没有任何联系，而单例模式想要做到的是，无论实例化多少次，只返回第一次创建的那个唯一的实例。</p><p>要做到这一点，就需要构造函数具备判断自己是否已经创建过一个实例的能力。</p><ul><li>写一个静态方法判断逻辑</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">SingleObj</span> <span class="token punctuation">{</span>    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是一个单例对象'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断是否已经new过1个实例</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>SingleObj<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 若这个唯一的实例不存在，那么先创建它</span>            SingleObj<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果这个唯一的实例已经存在，则直接返回</span>        <span class="token keyword">return</span> SingleObj<span class="token punctuation">.</span>instance    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> s1 <span class="token operator">=</span> SingleObj<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> s2 <span class="token operator">=</span> SingleObj<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// true</span>s1 <span class="token operator">===</span> s2</code></pre><ul><li>闭包</li></ul><pre class=" language-javascript"><code class="language-javascript">SingleObj<span class="token punctuation">.</span>getInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>可以看出，在 getInstance 方法的判断和拦截下，我们不管调用多少次，SingleObj 都只会给我们返回一个实例，s1 和 s2 现在都指向这个唯一的实例。</p><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><pre><code>实现 Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。</code></pre><p>思路：</p><p>考察单例模式的实现思路，只实例化一次。</p><ul><li>静态方法版</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Storage</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Storage<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Storage<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Storage<span class="token punctuation">.</span>instance      <span class="token punctuation">}</span>    getItem <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    setItem <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>闭包版</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">StorageBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>StorageBase<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getItem <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">}</span>StorageBase<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>setItem <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">const</span> Storage <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StorageBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>实现一个全局唯一的Modal弹框</code></pre><p>万变不离其踪，依然考察单例模式。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;单例模式弹框&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    #modal {        height: 200px;        width: 200px;        line-height: 200px;        position: fixed;        left: 50%;        top: 50%;        transform: translate(-50%, -50%);        border: 1px solid black;        text-align: center;    }&lt;/style&gt;&lt;body&gt;    &lt;button id=&#39;open&#39;&gt;打开弹框&lt;/button&gt;    &lt;button id=&#39;close&#39;&gt;关闭弹框&lt;/button&gt;&lt;/body&gt;&lt;script&gt;    // 核心逻辑，这里采用了闭包思路来实现单例模式    const Modal = (function() {        let modal = null        return function() {            if(!modal) {                modal = document.createElement(&#39;div&#39;)                modal.innerHTML = &#39;我是一个全局唯一的Modal&#39;                modal.style.display = &#39;none&#39;                document.body.appendChild(modal)            }            return modal        }    })()    // 点击打开按钮展示模态框    document.getElementById(&#39;open&#39;).addEventListener(&#39;click&#39;, function() {        // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理        const modal = new Modal()        modal.style.display = &#39;block&#39;    })    // 点击关闭按钮隐藏模态框    document.getElementById(&#39;close&#39;).addEventListener(&#39;click&#39;, function() {        const modal = new Modal()        if(modal) {            modal.style.display = &#39;none&#39;        }    })&lt;/script&gt;&lt;/html&gt;</code></pre><p>参考：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;保证一个类只有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://qiandream.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://qiandream.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-01-替换字符串</title>
    <link href="http://qiandream.cn/2020/04/10/jian-zhi-offer/jian-zhi-offer-01-ti-huan-zi-fu-chuan/"/>
    <id>http://qiandream.cn/2020/04/10/jian-zhi-offer/jian-zhi-offer-01-ti-huan-zi-fu-chuan/</id>
    <published>2020-04-10T10:44:52.000Z</published>
    <updated>2020-04-10T10:55:52.790Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 剑指offer 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：正则表达式、数组遍历</p></li><li><p>题目内容：</p></li></ul><pre><code>请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。例如输入“We are happy.”，则输出“We%20are%20happy.”。</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-正则表达式"><a href="#解法-正则表达式" class="headerlink" title="解法 - 正则表达式"></a>解法 - 正则表达式</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {String} str */</span><span class="token keyword">function</span> <span class="token function">replaceEmpty</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/ /g</span><span class="token punctuation">,</span> <span class="token string">'%20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>replaceEmpty(&#39;we are family&#39;)</code></pre><p>输出：</p><pre><code>&quot;we%20are%20family&quot;</code></pre><p>预期结果：</p><pre><code>&quot;we%20are%20family&quot;</code></pre><ul><li>解题思路：</li></ul><p>直接使用正则表达式全局替换</p><p>String.prototype.replace: 返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者是一个正则表达式，替换值可以是一个字符串或者是一个每次匹配都要调用的回调函数。</p><pre><code>str.replace(regexp|substr, newSubStr|function)</code></pre><ul><li>regexp (pattern)</li></ul><p>一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。</p><ul><li>substr (pattern)</li></ul><p>一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。</p><ul><li>newSubStr (replacement)</li></ul><p>用于替换掉第一个参数在原字符串中的匹配部分的字符串。</p><ul><li>function (replacement)</li></ul><p>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。</p><p>返回值：</p><p>一个部分或全部匹配由替代模式所取代的新的字符串。</p><p>描述：</p><p>该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。</p><p>在进行全局的搜索替换时，正则表达式需包含 g 标志。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 剑指offer 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指offer" scheme="http://qiandream.cn/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-004-罗马数字转整数</title>
    <link href="http://qiandream.cn/2020/04/10/leetcode/leetcode-004-luo-ma-shu-zi-zhuan-zheng-shu/"/>
    <id>http://qiandream.cn/2020/04/10/leetcode/leetcode-004-luo-ma-shu-zi-zhuan-zheng-shu/</id>
    <published>2020-04-10T10:11:52.000Z</published>
    <updated>2020-04-10T09:53:28.189Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组、数学</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="external">https://leetcode-cn.com/problems/roman-to-integer/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符          数值I             1V             5X             10L             50C             100D             500M             1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-转字符串、数组遍历，区分正常情况与特殊情况"><a href="#解法-转字符串、数组遍历，区分正常情况与特殊情况" class="headerlink" title="解法 - 转字符串、数组遍历，区分正常情况与特殊情况"></a>解法 - 转字符串、数组遍历，区分正常情况与特殊情况</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {string} s * @return {number} */</span><span class="token keyword">var</span> romanToInt <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/**       * 特殊情况       * IV === 4       * IX === 9       * XL === 40       * XC === 90       * CD === 400       * CM === 900       * 正常情况       * I === 1       * V === 5       * X === 10       * L === 50       * C === 100       * D === 500       * M === 1000       */</span>    <span class="token keyword">let</span> arr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">9</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">40</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">90</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">400</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">900</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">5</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">50</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">100</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">500</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1000</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>MCMXCIV</code></pre><p>输出：</p><pre><code>1994</code></pre><p>预期结果：</p><pre><code>1994</code></pre><ul><li><p>解题思路：转换为字符串、数组</p></li><li><p>split(): 字符串分割为数组</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-原型原型链</title>
    <link href="http://qiandream.cn/2020/04/03/javascript/javascript-yuan-xing-yuan-xing-lian/"/>
    <id>http://qiandream.cn/2020/04/03/javascript/javascript-yuan-xing-yuan-xing-lian/</id>
    <published>2020-04-03T09:10:52.000Z</published>
    <updated>2020-04-03T09:20:11.886Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>JavaScript 中的 原型和原型链是面试中常考的点，本文旨在分析原型和原型链是什么。</p></blockquote><a id="more"></a>           <hr><h1 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h1><p>JavaScript 通过 new 一个构造函数生成一个对象实例，但是每个对象实例的属性和方法并不是共享的，为了各个对象实例可以共享一些属性和方法，要设计一个对象专门用来存储对象共享的属性，那么我们叫它「原型对象」。</p><p>在 JS 所有对象中，只要是对象，都会有一个内置属性叫做<em>proto</em>，而且这个属性是系统自动生成的，只要你创建一个对象，这个对象就有这个属性。这个<em>proto</em>属性指向的是原型对象。</p><p>构造函数的 prototype 属性指向原型对象，原型对象的 constructor 属性指回构造函数。</p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>每个对象都一个 <strong>proto</strong> 指向原型对象，原型对象也有一个 <strong>proto</strong> 指向它的原型对象，直到原型链的顶端 null。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/24/16dfb64428ee0ce4?imageslim" alt=""></p><p>总结：</p><ul><li>所有的实例的 <strong>proto</strong> 都指向该构造函数的原型对象（prototype）。</li><li>所有的函数（包括构造函数）是 Function() 的实例，所以所有函数的 <strong>proto</strong> 的都指向 Function() 的原型对象。</li><li>所有的原型对象（包括 Function 的原型对象）都是 Object 的实例，所以 <strong>proto</strong> 都指向 Object （构造函数）的原型对象。而 Object 构造函数的 <strong>proto</strong>  指向 null。</li><li>Function 构造函数本身就是 Function 的实例，所以 <strong>proto</strong> 指向 Function 的原型对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;JavaScript 中的 原型和原型链是面试中常考的点，本文旨在分析原型和原型链是什么。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://qiandream.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://qiandream.cn/2020/04/02/http/tcp-si-ci-hui-shou/"/>
    <id>http://qiandream.cn/2020/04/02/http/tcp-si-ci-hui-shou/</id>
    <published>2020-04-02T08:24:30.882Z</published>
    <updated>2020-04-02T08:24:30.882Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP-三次握手</title>
    <link href="http://qiandream.cn/2020/04/01/http/tcp-san-ci-wo-shou/"/>
    <id>http://qiandream.cn/2020/04/01/http/tcp-san-ci-wo-shou/</id>
    <published>2020-04-01T10:10:52.000Z</published>
    <updated>2020-04-02T08:24:54.857Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>建立 TCP 连接前，客户端和服务端需要通过三次握手来确认对方的接受和传送能力是否正常</p></blockquote><a id="more"></a>           <hr><p>客户端向服务器发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，确保双方的接收和发送能力正常。</p><p>起始状态：客户端处于 closed 状态，服务端处于 listen 状态。</p><p>第一次握手：客户端给服务端发送一个 SYN 报文，并指明自己的初始化序列号（ISN） Seq = X，此时客户端处于 SYN_Send 状态。</p><p>第二次握手：服务端收到客户端的 SYN 报文后，会以自己的 SYN 报文作为应答，并且也指定了自己的初始化序列号（ISN） Seq = Y，同时会把客户端的 Seq X + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。</p><p>第三次握手：客户端回传一个 Seq Y + 1 作为 ACK 的值，Seq = Z 的数据包，代表握手结束，此时客户端处于 established 状态。</p><p>服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立起了连接。</p><p>（SYN：代表 TCP 连接 Seq：序列号 ACK：确认号）</p><p><img src="https://segmentfault.com/img/remote/1460000017184707" alt=""></p><h4 id="为什么需要3次握手"><a href="#为什么需要3次握手" class="headerlink" title="为什么需要3次握手"></a>为什么需要3次握手</h4><p>为了防止已经失效的连接请求报文突然又传送到了服务器，因为产生错误。</p><h4 id="ISN-是固定的吗"><a href="#ISN-是固定的吗" class="headerlink" title="ISN 是固定的吗"></a>ISN 是固定的吗</h4><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p><h4 id="什么是半连接队列"><a href="#什么是半连接队列" class="headerlink" title="什么是半连接队列"></a>什么是半连接队列</h4><p>服务器第一次收到客户端的 SYN 之后，此时会处于 SYN_RCVD 状态，此时双方还没有建立起连接，服务器会把这种状态的请求连接放在一个队列里，这种队列称为半连接队列。</p><p>服务器与客户端三次握手完成建立起的连接会放在全连接队列里。</p><p>如果队列满了，就可能会出现丢包现象。</p><pre><code>这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ....</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;建立 TCP 连接前，客户端和服务端需要通过三次握手来确认对方的接受和传送能力是否正常&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://qiandream.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-基础之this</title>
    <link href="http://qiandream.cn/2020/03/17/liu-lan-qi/browser-liu-lan-qi-xuan-ran-yuan-li/"/>
    <id>http://qiandream.cn/2020/03/17/liu-lan-qi/browser-liu-lan-qi-xuan-ran-yuan-li/</id>
    <published>2020-03-17T03:10:52.000Z</published>
    <updated>2020-04-02T07:30:12.718Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列旨在总结浏览器相关知识，本篇围绕浏览器渲染原理展开。</p></blockquote><a id="more"></a>           <hr><h1 id="浏览器的主要组成部分"><a href="#浏览器的主要组成部分" class="headerlink" title="浏览器的主要组成部分"></a>浏览器的主要组成部分</h1><p>讲解浏览器渲染之前，先主要了解浏览器有哪些组成部分。</p><ul><li><p>用户界面：包括地址栏、前进/后退按钮，书签菜单等。</p></li><li><p>浏览器引擎：在用户界面和渲染引擎之间传送指令。</p></li><li><p>渲染引擎：负责显示请求的内容。如：解析 HTML 和 CSS，并将解析后的内容显示在屏幕上。</p></li><li><p>网络：用于网络调用，比如 HTTP 请求。</p></li><li><p>用户界面后端：用于绘制基本的窗口小部件，如组合框和窗口等。</p></li><li><p>JS 解释器：用于解析和执行 JS 代码。</p></li><li><p>数据存储：这是持久层，用于浏览器在硬盘上保存各种数据。</p></li></ul><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=531622336,2916455443&amp;fm=26&amp;gp=0.jpg" alt=""></p><h1 id="常见的浏览器内核"><a href="#常见的浏览器内核" class="headerlink" title="常见的浏览器内核"></a>常见的浏览器内核</h1><table><thead><tr><th>浏览器</th><th>内核（渲染引擎）</th><th>JS 引擎</th></tr></thead><tbody><tr><td>Chrome</td><td>Blink（28~）<br> Webkit</td><td>V8</td></tr><tr><td>Safari</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>FireFox</td><td>Gecko</td><td>SpiderMonkey</td></tr><tr><td>Edge</td><td>EdgeHTML</td><td>Chakra</td></tr><tr><td>IE</td><td>Trident</td><td>Chakra</td></tr></tbody></table><h1 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h1><p>DOM（Document Object Model 文档对象模型），是对 HTML 文档结构化的表述，允许程序和脚本动态的访问和更新文档的内容、结构和样式。服务器返回给浏览器渲染引擎的HTML的文件字节流是无法直接被浏览器渲染引擎理解的，要转化为浏览器渲染引擎可以理解的内部结构，这个结构就是 DOM。</p><h1 id="浏览器接受-HTML-文件并转换为-DOM-树"><a href="#浏览器接受-HTML-文件并转换为-DOM-树" class="headerlink" title="浏览器接受 HTML 文件并转换为 DOM 树"></a>浏览器接受 HTML 文件并转换为 DOM 树</h1><p>从服务器返回给浏览器渲染引擎的 HTML 文件字节流，第一步要经过渲染引擎中的 HTML 解析器。它实现了将 HTML 字节流转换为 DOM 树结构。HTML 文件字节流返回的过程中，HTML 解析器就一直在解析（边加载边解析）。</p><p>阶段一：在网络中传输的内容都是 0 和 1 这些字节数据，当浏览器接收到这些字节数据后，会将这些字节数据转换为字符串，就是我们平时写的代码。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754281e59587f3?imageslim" alt=""></p><p>阶段二：当数据转换为字符串后，浏览器会先将这些字符串通过分词器转化为 Token(标记)，Token 分为 Tag Token 和文本 TOken。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754288f37a5347?imageslim" alt=""></p><p>标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167540a7b5cef612?imageslim" alt=""></p><p>阶段三：将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。</p><p>HTML 解析器维护了一个 Token 栈，这个栈的目的就是用来计算节点间的父子关系，再上一个阶段生成的 Token 会被顺序压到这个栈中。</p><ul><li><p>HTML 解析器开始工作时，会默认创建一个根为 document 的空 DOM 结构，同时将一个 StartTag document 的 Token 压入栈底。</p></li><li><p>如果压入到栈中的是 StartTagToken，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将这个 DOM 节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的 DOM 节点。</p></li><li><p>如果是文本 Token，那么会生成一个文本节点，然后把这个文本 Dom 节点加入到 DOM 树中（注:文本Token不需入栈），它的 父节点就是当前栈顶 Token 所对应的 DOM 节点。</p></li><li><p>如果分词器解析出来的是 EndTag 标签，比如例子中的 EndTag div，HTML 解析器会查看 Token栈顶的元素是否是 StartTag div，如果是，就将 StartTag div从栈中弹出，边上该 div 元素解析完成。</p></li><li><p>最后按照上面的规则，分词器一路解析下来，就形成了这个简单的 DOM 树。</p></li></ul><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/6ccc9594a0dc0a616804780992d4298d.png" alt=""></p><h1 id="浏览器接受-CSS-文件并转换为-CSSOM-树"><a href="#浏览器接受-CSS-文件并转换为-CSSOM-树" class="headerlink" title="浏览器接受 CSS 文件并转换为 CSSOM 树"></a>浏览器接受 CSS 文件并转换为 CSSOM 树</h1><p>转换 CSS 到 CSSOM 树的过程和上一小节的过程极其相似。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f?imageslim" alt=""></p><h2 id="浏览器如何解析-CSS-选择器"><a href="#浏览器如何解析-CSS-选择器" class="headerlink" title="浏览器如何解析 CSS 选择器"></a>浏览器如何解析 CSS 选择器</h2><p>浏览器会【从右向左】解析 CSS 选择器。</p><p>以下段 CSS 为例：</p><pre><code>.mode-nav h3 span {font-size: 16px;}</code></pre><p>我们对应的DOM Tree如下：</p><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/4fe91032bd748f2509e0f0da3e56dcc1.png" alt=""></p><p>若从左向右匹配：过程是：</p><ol><li><p>从 .mod-nav 开始，遍历子节点 header 和子节点 div</p></li><li><p>然后各自向子节点遍历。在右侧 div 的分支中</p></li><li><p>最后遍历到叶子节点 a ，发现不符合规则，需要回溯到 ul 节点，再遍历下一个 li-a，一颗DOM树的节点动不动上千，这种效率很低</p></li></ol><p>若从右向左匹配：</p><ol><li><p>先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3</p></li><li><p>由 h3再向上寻找 class=mod-nav 的节点</p></li><li><p>最后找到根元素 html 则结束这个分支的遍历</p></li></ol><p>后者匹配性能更好，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）；而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列旨在总结浏览器相关知识，本篇围绕浏览器渲染原理展开。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://qiandream.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-生产环境配置</title>
    <link href="http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-sheng-chan-huan-jing-pei-zhi/"/>
    <id>http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-sheng-chan-huan-jing-pei-zhi/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-04-02T08:04:25.338Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h1><p>在生产环境中我们关注的是如何让用户更快地加载资源，涉及如何压缩资源、如何添加环境变量优化打包、如何最大限度地利用缓存等。</p><h2 id="环境配置的封装"><a href="#环境配置的封装" class="headerlink" title="环境配置的封装"></a>环境配置的封装</h2><p>生产环境的配置与开发环境有所不同，如何让Webpack可以按照不同环境采用不同的配置呢？一般来说有以下两种方式。</p><ul><li>使用相同的配置文件</li></ul><p>比如令Webpack不管在什么环境下打包都使用webpack.config.js，只是在构建开始前将当前所属环境作为一个变量传进去，然后在webpack.config.js中通过各种判断条件来决定具体使用哪个配置。</p><pre><code>// package.json{    ...    &quot;scripts&quot;: {        &quot;dev&quot;: &quot;ENV=development webpack-dev-server&quot;,        &quot;build&quot;: &quot;ENV=production webpack&quot;    }}// webpack.config.jsconst ENV = process.env.ENVconst isProd = ENV === &#39;production&#39;module.exports = {    output: {        filename: isProd ? &#39;bundle@[chunkhash].js&#39; : &#39;bundle.js&#39;    },    mode: ENV}</code></pre><ul><li>为不同环境创建各自的配置文件</li></ul><p>比如，我们可以单独创建一个webpack.production.config.js，开发环境的则可以叫webpack.development.config.js。</p><pre><code>// package.json{    ...    &quot;scripts&quot;: {        &quot;dev&quot;: &quot;webpack-dev-server --config=webpack.development.config.js&quot;,        &quot;build&quot;: &quot;webpack --config=webpack.production.config.js&quot;    }}</code></pre><p>但这种方法存在一个问题，即webpack.development.config.js和webpack.production.config.js肯定会有重复的部分，一改都要改，不利于维护。在这种情况下，可以将公共的配置提取出来，比如我们单独创建一个webpack.common.config.js。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// development 和 production 共有配置</span><span class="token punctuation">}</span></code></pre><p>然后让另外两个JS分别引用该文件，并添加上自身环境的配置即可。</p><h2 id="开启-production-模式"><a href="#开启-production-模式" class="headerlink" title="开启 production 模式"></a>开启 production 模式</h2><p>Webpack 4中直接加了一个mode配置项，让开发者可以通过它来直接切换打包模式。如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">}</span></code></pre><p>这意味着当前处于生产环境模式，Webpack会自动添加许多适用于生产环境的配置项，减少了人为手动的工作。</p><p>大部分时候仅仅设置mode是不够的，下面我们继续介绍其他与生产环境相关的自定义配置。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>通常我们需要为生产环境和本地环境添加不同的环境变量，在Webpack中可以使用DefinePlugin进行设置。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">'production'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>注：我们在一些值的外面加上了JSON.stringify，这是因为DefinePlugin在替换环境变量时对于字符串类型的值进行的是完全替换。假如不添加JSON.stringify的话，在替换后就会成为变量名，而非字符串值。因此对于字符串环境变量及包含字符串的对象都要加上JSON.stringify才行。</p><h2 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h2><p>source map指的是将编译、打包、压缩后的代码映射回源代码的过程。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Webpack对于工程源代码的每一步处理都有可能会改变代码的位置、结构，甚至是所处文件，因此每一步都需要生成对应的source map。若我们启用了devtool配置项，source map就会跟随源代码一步步被传递，直到生成最后的map文件。这个文件默认就是打包后的文件名加上.map，如bundle.js.map。</p><p>当我们打开了浏览器的开发者工具时，map文件会同时被加载，这时浏览器会使用它来对打包后的bundle文件进行解析，分析出源代码的目录结构和内容。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>JavaScript的source map的配置很简单，只要在webpack.config.js中添加devtool即可。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    devtool<span class="token punctuation">:</span> <span class="token string">'source-map'</span><span class="token punctuation">}</span></code></pre><p>对于CSS、SCSS、Less来说，则需要添加额外的source map配置项。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    devtool<span class="token punctuation">:</span> <span class="token string">'source-map'</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span> <span class="token punctuation">{</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.scss$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> <span class="token punctuation">[</span>                    <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    <span class="token punctuation">{</span>                        loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                        options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                            sourceMap<span class="token punctuation">:</span> <span class="token boolean">true</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                            loader<span class="token punctuation">:</span> <span class="token string">'sass-loader'</span><span class="token punctuation">,</span>                        options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                            sourceMap<span class="token punctuation">:</span> <span class="token boolean">true</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">]</span>            <span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Webpack支持多种source map的形式。除了配置为devtool：’source-map’以外，还可以根据不同的需求选择cheap-source-map、eval-source-map等。通常它们都是source map的一些简略版本，因为生成完整的source map会延长整体构建时间，如果对打包速度需求比较高的话，建议选择一个简化版的sourcemap。比如，在开发环境中，cheap-module-eval-source-map通常是一个不错的选择，属于打包速度和源码信息还原程度的一个良好折中。</p><p>在生产环境中由于我们会对代码进行压缩，而最常见的压缩插件UglifyjsWebpack-Plugin目前只支持完全的source-map，因此没有那么多选择，我们只能使用source-map、hidden-source-map、nosources-source-map这3者之一。下面介绍一下这3种sourcemap在安全性方面的不同。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>有了source map也就意味着任何人通过浏览器的开发者工具都可以看到工程源码，对于安全性来说也是极大的隐患。那么如何才能在保持其功能的同时，防止暴露源码给用户呢？Webpack提供了hidden-source-map及nosources-source-map两种策略来提升source map的安全性。</p><p>hidden-source-map意味着Webpack仍然会产出完整的map文件，只不过不会在bundle文件中添加对于map文件的引用。这样一来，当打开浏览器的开发者工具时，我们是看不到map文件的，浏览器自然也无法对bundle进行解析。如果我们想要追溯源码，则要利用一些第三方服务，将map文件上传到那上面。目前最流行的解决方案是Sentry。</p><p>Sentry是一个错误跟踪平台，开发者接入后可以进行错误的收集和聚类，以便于更好地发现和解决线上问题。Sentry支持JavaScript的source map，我们可以通过它所提供的命令行工具或者Webpack插件来自动上传map文件。同时我们还要在工程代码中添加Sentry对应的工具包，每当JavaScript执行出错时就会上报给Sentry。Sentry在接收到错误后，就会去找对应的map文件进行源码解析，并给出源码中的错误栈。</p><p>另一种配置是nosources-source-map，它对于安全性的保护则没那么强，但是使用方式相对简单。打包部署之后，我们可以在浏览器开发者工具的Sources选项卡中看到源码的目录结构，但是文件的具体内容会被隐藏起来。对于错误来说，我们仍然可以在Console控制台中查看源代码的错误栈，或者console日志的准确行数。它对于追溯错误来说基本足够，并且其安全性相对于可以看到整个源码的source-map配置来说要略高一些。</p><h2 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h2><h3 id="压缩-javascript"><a href="#压缩-javascript" class="headerlink" title="压缩 javascript"></a>压缩 javascript</h3><p>压缩JavaScript大多数时候使用的工具有两个，一个是UglifyJS（Webpack 3已集成），另一个是terser（Webpack 4已集成）。</p><p>在Webpack 3中的话，开启压缩需调用webpack.optimize.UglifyJsPlugin。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// webpack version &lt; 4</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>UglifyJsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>从Webpack 4之后，这项配置被移到了config.optimization.minimize。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// webpack version > 4</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>        minimize<span class="token punctuation">:</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="压缩CSS"><a href="#压缩CSS" class="headerlink" title="压缩CSS"></a>压缩CSS</h3><p>压缩CSS文件的前提是使用extract-text-webpack-plugin或mini-css-extract-plugin将样式提取出来，接着使用optimize-css-assets-webpack-plugin来进行压缩，这个插件本质上使用的是压缩器cssnano，当然我们也可以通过其配置进行切换。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span><span class="token keyword">const</span> OptimizeCssAssetsPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'optimize-css-assets-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    module<span class="token punctuation">:</span> <span class="token punctuation">{</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                    fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'style.css'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>        minimizer<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">OptimizeCssAssetsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                assetNameRegExp<span class="token punctuation">:</span> <span class="token regex">/\.optimize\.css$/g</span><span class="token punctuation">,</span>                cssProcessor<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cssnano'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                cssProcessorOptions<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    discardComments<span class="token punctuation">:</span> <span class="token punctuation">{</span>removeAll<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                    canPrint<span class="token punctuation">:</span> <span class="token boolean">true</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是指重复利用浏览器已经获取过的资源。合理地使用缓存是提升客户端性能的一个关键因素。</p><h3 id="资源-hash"><a href="#资源-hash" class="headerlink" title="资源 hash"></a>资源 hash</h3><p>一个常用的方法是在每次打包的过程中对资源的内容计算一次hash，并作为版本号存放在文件名中，如bundle@2e0a691e769edb228e2.js。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle@[chunkhash].js'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">}</span></code></pre><h3 id="输出动态-HTML"><a href="#输出动态-HTML" class="headerlink" title="输出动态 HTML"></a>输出动态 HTML</h3><p>接下来我们面临的问题是，资源名的改变也就意味着HTML中的引用路径的改变。每次更改后都要手动地去维护它是很困难的，理想的情况是在打包结束后自动把最新的资源名同步过去。使用html-webpack-plugin可以帮我们做到这一点。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>html-webpack-plugin会自动地将我们打包出来的资源名放入生成的index.html中，这样我们就不必手动地更新资源URL了。</p><h3 id="bundle-体积监控和分析"><a href="#bundle-体积监控和分析" class="headerlink" title="bundle 体积监控和分析"></a>bundle 体积监控和分析</h3><p>一个很有用的工具是webpack-bundle-analyzer，它能够帮助我们分析一个bundle的构成。使用方法也很简单，只要将其添加进plugins配置即可。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Analyzer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-bundle-analyzer'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>BundleAnalyzerPluginmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">Analyzer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-模块打包</title>
    <link href="http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-mo-kuai-da-bao/"/>
    <id>http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-mo-kuai-da-bao/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-04-02T08:04:17.094Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="模块打包"><a href="#模块打包" class="headerlink" title="模块打包"></a>模块打包</h1><h2 id="多种不同的模块机制"><a href="#多种不同的模块机制" class="headerlink" title="多种不同的模块机制"></a>多种不同的模块机制</h2><h3 id="Commonjs"><a href="#Commonjs" class="headerlink" title="Commonjs"></a>Commonjs</h3><p>CommonJS最初只为服务端而设计，直到有了Browserify——一个运行在Node.js环境下的模块打包工具，它可以将CommonJS模块打包为浏览器可以运行的单个文件。这意味着客户端的代码也可以遵循CommonJS标准来编写了。</p><p>CommonJS中规定每个文件是一个模块，所有的变量及函数只有自己能访问，对外是不可见的。</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>在CommonJS中，通过module.exports可以导出模块中的内容：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"calculate"</span><span class="token punctuation">}</span></code></pre><p>CommonJS模块内部会有一个module对象用于存放当前模块的信息。</p><p>属性。为了书写方便，CommonJS也支持另一种简化的导出方式—直接使用exports:</p><pre class=" language-javascript"><code class="language-javascript">exports<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"caculate"</span></code></pre><p>另外，要注意导出语句不代表模块的末尾，在module.exports或exports后面的代码依旧会照常执行。</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>在CommonJS中使用require进行模块导入：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> calculator <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./caculate.js'</span><span class="token punctuation">)</span><span class="token keyword">const</span> name <span class="token operator">=</span> calculator<span class="token punctuation">.</span>name</code></pre><p>当我们require一个模块时会有两种情况：</p><ul><li><p>require的模块是第一次被加载。这时会首先执行该模块，然后导出内容。</p></li><li><p>require的模块曾被加载过。这时该模块的代码不会再次执行，而是直接导出上次执行后得到的结果。</p></li></ul><p>模块会有一个module对象用来存放其信息，这个对象中有一个属性loaded用于记录该模块是否被加载过。它的值默认为false，当模块第一次被加载和执行过后会置为true，后面再次加载时检查到module.loaded为true，则不会再次执行模块代码。</p><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6 Module也是将每个文件作为一个模块，每个模块拥有自身的作用域，不同的是导入、导出语句。</p><p>ES6 Module会自动采用严格模式 – “use strict”。</p><h4 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h4><p>在ES6 Module中使用export命令来导出模块。</p><p>export有两种形式：</p><ul><li><p>命名导出</p></li><li><p>默认导出</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"calculate"</span><span class="token keyword">export</span> <span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token string">"add"</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"calculate"</span><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token string">"add"</span><span class="token keyword">export</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> add <span class="token punctuation">}</span></code></pre><p>在使用命名导出时，可以通过as关键字对变量重命名。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"calculate"</span><span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token string">"add"</span><span class="token keyword">export</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> add <span class="token keyword">as</span> sum <span class="token punctuation">}</span></code></pre><p>将export default 默认导出，我们可以理解为对外输出了一个名为default的变量，因此不需要像命名导出一样进行变量声明，直接导出值即可。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">"calculate"</span><span class="token keyword">export</span> <span class="token keyword">default</span>  <span class="token keyword">class</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token punctuation">}</span></code></pre><h4 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h4><p>ES6 Module中使用import语法导入模块。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span></code></pre><p>与命名导出类似，我们可以通过as关键字可以对导入的变量重命名。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> name <span class="token keyword">as</span> caculate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span></code></pre><p>在导入多个变量时，我们还可以采用整体导入的方式。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> caculate <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span><span class="token keyword">const</span> name <span class="token operator">=</span> caculate<span class="token punctuation">.</span>name</code></pre><p>对于默认导出来说，import后面直接跟变量名，并且这个名字可以自由指定（比如这里是myCalculator）。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> myCalculator <span class="token keyword">from</span> <span class="token string">'./caculate.js'</span></code></pre><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD是英文Asynchronous Module Definition（异步模块定义）的缩写:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'getSum'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'calculate'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>math<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>calculate<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在AMD中使用define函数来定义模块，它可以接受3个参数:</p><p>第1个参数是当前模块的id，相当于模块名；</p><p>第2个参数是当前模块的依赖，比如上面我们定义的getSum模块需要引入calculator模块作为依赖；</p><p>第3个参数用来描述模块的导出值，可以是函数或对象。如果是函数则导出的是函数的返回值；如果是对象则直接导出对象本身。</p><p>和CommonJS类似，AMD也使用require函数来加载模块，只不过采用异步的形式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'getSum'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>getSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>require的第1个参数指定了加载的模块，第2个参数是当加载完成后执行的回调函数。</p><p>通过AMD这种形式定义模块的好处在于其模块加载是非阻塞性的，当执行到require函数时并不会停下来去执行被加载的模块，而是继续执行require后面的代码，这使得模块加载操作并不会阻塞浏览器。</p><h2 id="模块打包原理"><a href="#模块打包原理" class="headerlink" title="模块打包原理"></a>模块打包原理</h2><p>Webpack 将项目中成百上千个有依赖关系的模块组织在一起，打包后将会成为如下的形式：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 立即执行匿名函数</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 模块缓存</span>    <span class="token keyword">var</span> installedModules <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 实现 require</span>    <span class="token keyword">function</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span>moduleId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 执行入口模块的加载</span>    <span class="token keyword">return</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span>__webpack_require__<span class="token punctuation">.</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// modules: 以 key-value 的形式存储所有被打包的模块</span>        <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> __webpack_require__<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 打包入口</span>            module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token string">"3qiv"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token string">"3qiv"</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> __webpack_require__<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 打包入口</span>            module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token string">"3qiv"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>上面的bundle分为以下几个部分：</p><ul><li><p>最外层立即执行匿名函数。它用来包裹整个bundle，并构成自身的作用域。</p></li><li><p>installedModules对象。每个模块只在第一次被加载的时候执行，之后其导出值就被存储到这个对象里面，当再次被加载的时候直接从这里取值，而不会重新执行。</p></li><li><p><strong>webpack_require</strong>函数。对模块加载的实现，在浏览器中可以通过调用<strong>webpack_require</strong>(module_id)来完成模块导入。</p></li><li><p>modules对象。工程中所有产生了依赖关系的模块都会以key-value的形式放在这里。key可以理解为一个模块的id，由数字或者一个很短的hash字符串构成；value则是由一个匿名函数包裹的模块实体，匿名函数的参数则赋予了每个模块导出和导入的能力。</p></li></ul><p>bundle是如何在浏览器中执行的：</p><ul><li><p>在最外层的匿名函数中会初始化浏览器执行环境，包括定义installedModules对象、<strong>webpack_require</strong>函数等，为模块的加载和执行做一些准备工作。</p></li><li><p>加载入口模块。每个bundle都有且只有一个入口模块，例如：index.js是入口模块，在浏览器中会从它开始执行。</p></li><li><p>执行模块代码。如果执行到了module.exports则记录下模块的导出值；如果中间遇到require函数（准确地说是<strong>webpack_require</strong>），则会暂时交出执行权，进入<strong>webpack_require</strong>函数体内进行加载其他模块的逻辑。</p></li><li><p>在<strong>webpack_require</strong>中会判断即将加载的模块是否存在于installedModules中。如果存在则直接取值，否则回到上一步，执行该模块的代码来获取导出值。</p></li><li><p>所有依赖的模块都已执行完毕，最后执行权又回到入口模块。当入口模块的代码执行到结尾，也就意味着整个bundle运行结束。</p></li></ul><p>不难看出，第3步和第4步是一个递归的过程。Webpack为每个模块创造了一个可以导出和导入模块的环境，但本质上并没有修改代码的执行逻辑，因此代码执行的顺序与模块加载的顺序是完全一致的，这就是Webpack模块打包的奥秘。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-预处理器</title>
    <link href="http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yang-shi-chu-li/"/>
    <id>http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yang-shi-chu-li/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-04-02T08:04:11.365Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h1><h2 id="分离样式文件"><a href="#分离样式文件" class="headerlink" title="分离样式文件"></a>分离样式文件</h2><p>Webpack社区有专门的插件：extract-text-webpack-plugin（适用于Webpack 4之前版本）和mini-css-extract-plugin（适用于Webpack 4及以上版本），它们就是专门用于提取样式到CSS文件的。</p><h3 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h3><pre class=" language-javascript"><code class="language-javascript">npm i extract<span class="token operator">-</span>text<span class="token operator">-</span>webpack<span class="token operator">-</span>plugin</code></pre><p>在 webpack.config.js 中引入：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'bundle.css'</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>内部的fallback属性用于指定当插件无法提取样式时所采用的loader。</p><p>use（extract方法里面的）用于指定在提取样式之前采用哪些loader来预先进行处理。</p><p>除此之外，还要在Webpack的plugins配置中添加该插件，并传入提取后的资源文件名。</p><h3 id="多样式文件处理"><a href="#多样式文件处理" class="headerlink" title="多样式文件处理"></a>多样式文件处理</h3><p>上面我们将bundle.css作为文件名传给了extract-text-webpack-plugin，但当工程有多个入口时就会发生重名问题。就像在前面的章节中我们配置动态的output.filename一样，这里我们也要对插件提取的CSS文件使用类似模板的命名方式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'[name].css'</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>说到mini-css-extract-plugin的特性，最重要的就是它支持按需加载CSS，以前在使用extract-text-webpack-plugin的时候我们是做不到这一点的。</p><p>举个例子，a.js通过import()函数异步加载了b.js，b.js里面加载了style.css，那么style.css最终只能被同步加载（通过HTML的link标签）。但是现在mini-css-extract-plugin会单独打包出一个0.css（假设使用默认配置），这个CSS文件将由a.js通过动态插入link标签的方式加载。</p><p>在配置上mini-css-extract-plugin与extract-text-webpack-plugin有以下几点不同：</p><ul><li><p>loader规则设置的形式不同，并且mini-css-extract-plugin支持配置publicPath，用来指定异步CSS的加载路径。</p></li><li><p>不需要设置fallback。</p></li><li><p>在plugins设置中，除了指定同步加载的CSS资源名（filename），还要指定异步加载的CSS资源名（chunkFilename）</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                loader<span class="token punctuation">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>                options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    publicPath<span class="token punctuation">:</span> <span class="token string">'../'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token string">'css-loader'</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'[name].css'</span><span class="token punctuation">,</span>        chunkFilename<span class="token punctuation">:</span> <span class="token string">'[id].css'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h2 id="样式预处理"><a href="#样式预处理" class="headerlink" title="样式预处理"></a>样式预处理</h2><p>样式预处理指的是在开发中我们经常会使用一些样式预编译语言，如SCSS、Less等，在项目打包过程中再将这些预编译语言转换为CSS。</p><h3 id="Sass-与-Scss"><a href="#Sass-与-Scss" class="headerlink" title="Sass 与 Scss"></a>Sass 与 Scss</h3><p>sass-loader就是将SCSS语法编译为CSS，因此在使用时通常还要搭配css-loader和style-loader。类似于我们装babel-loader时还要安装babel-core，loader本身只是编译核心库与Webpack的连接器，因此这里我们除了sass-loader以外还要安装node-sass，node-sass是真正用来编译SCSS的，而sass-loader只是起到黏合的作用。</p><pre class=" language-javascript"><code class="language-javascript">npm i sass<span class="token operator">-</span>loader node<span class="token operator">-</span>sass</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.scss$/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]      }    ]  }}</code></pre><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><pre class=" language-javascript"><code class="language-javascript">npm i less<span class="token operator">-</span>loader less</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.less/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]      }    ]  }}</code></pre><h2 id="PostCss"><a href="#PostCss" class="headerlink" title="PostCss"></a>PostCss</h2><p>PostCSS并不能算是一个CSS的预编译器，它只是一个编译插件的容器。它的工作模式是接收样式源代码并交由编译插件处理，最后输出CSS。</p><h3 id="PostCss-与-Webpack"><a href="#PostCss-与-Webpack" class="headerlink" title="PostCss 与 Webpack"></a>PostCss 与 Webpack</h3><p>使用postcss-loader可以轻松地将PostCSS与Webpack连接起来。使用npm进行安装。</p><pre><code>npm i postcss-loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.css/,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;]      }    ]  }}</code></pre><p>postcss-loader可以结合css-loader使用，也可以单独使用，也就是说不配置css-loader也可以达到相同的效果。唯一不同的是，单独使用postcss-loader时不建议使用CSS中的@import语句，否则会产生冗余代码。</p><p>除此之外，PostCSS要求必须有一个单独的配置文件。我们需要在项目的根目录下创建一个postcss.config.js。</p><pre><code>module.exports = {  // ...  module: {}}</code></pre><h3 id="自动前缀"><a href="#自动前缀" class="headerlink" title="自动前缀"></a>自动前缀</h3><p>Autoprefixer是一个样式工具，可以根据caniuse.com上的数据，自动决定是否要为某一特性添加厂商前缀，并且可以由开发者为其指定支持浏览器的范围。</p><pre><code>npm i autoprefixer</code></pre><p>在postcss.config.js中添加autoprefixer。</p><pre><code>const autoprefixer = require(&#39;autoprefixer&#39;)module.exports = {  // ...  plugins: [    autoprefixer({      grid: true,      browsers: [        &#39;&gt; 1%&#39;,        &#39;last 3 versions&#39;,        &#39;android 4.2&#39;,        &#39;ie 8&#39;      ]    })  ]}</code></pre><h3 id="stylelint"><a href="#stylelint" class="headerlink" title="stylelint"></a>stylelint</h3><p>stylelint是一个CSS的质量检测工具，就像eslint一样，我们可以为其添加各种规则，来统一项目的代码风格，确保代码质量。</p><pre><code>npm i stylelint</code></pre><p>在postcss.config.js中添加相应配置。</p><pre><code>const autoprefixer = require(&#39;autoprefixer&#39;)module.exports = {  // ...  plugins: [    stylelint({      config: {        rules: {          &#39;declaration-no-important&#39;: true        }      }    })  ]}</code></pre><p>这里我们添加了declaration-no-important这样一条规则，当我们的代码中出现了“！important”时就会给出警告。</p><p>使用stylelint可以检测出代码中的样式问题（语法错误、重复的属性等），帮助我们写出更加安全并且风格更加一致的代码。</p><h3 id="CssNext"><a href="#CssNext" class="headerlink" title="CssNext"></a>CssNext</h3><p>PostCSS可以与CSSNext结合使用，让我们在应用中使用最新的CSS语法特性。</p><pre><code>npm i postcss-cssnext</code></pre><p>在postcss.config.js中添加相应配置。</p><pre><code>const postcssCssnext = require(&#39;postcss-cssnext&#39;)module.exports = {  // ...  plugins: [    postcssCssnext({      browsers: [        &#39;&gt; 1%&#39;,        &#39;last 2 versions&#39;,      ]    })  ]}</code></pre><p>指定好需要支持的浏览器之后，我们就可以顺畅地使用CSSNext的特性了。</p><h2 id="Css-Modules"><a href="#Css-Modules" class="headerlink" title="Css Modules"></a>Css Modules</h2><p>CSS Modules是近年来比较流行的一种开发模式，其理念就是把CSS模块化，让CSS也拥有模块的特点:</p><ul><li><p>每个CSS文件中的样式都拥有单独的作用域，不会和外界发生命名冲突。</p></li><li><p>对CSS进行依赖管理，可以通过相对路径引入CSS文件。</p></li><li><p>可以通过composes轻松复用其他CSS模块</p></li></ul><p>使用CSS Modules不需要额外安装模块，只要开启css-loader中的modules配置项即可。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token string">'style-loader'</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>           loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>           options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                 modules<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                 localIdentName<span class="token punctuation">:</span> <span class="token string">'[name]__[local]__[hash:base64:5]'</span>              <span class="token punctuation">}</span>           <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>这里比较值得一提的是localIdentName配置项，它用于指明CSS代码中的类名会如何来编译。</p><p>例：</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* style.css */</span><span class="token selector"><span class="token class">.title</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>经过编译后可能将成为.style<strong>title</strong>1CFy6。</p><ul><li><p>[name]指代的是模块名，这里被替换为style。</p></li><li><p>[local]指代的是原本的选择器标识符，这里被替换为title。</p></li><li><p>[hash：base64：5]指代的是一个5位的hash值，这个hash值是根据模块名和标识符计算的，因此不同模块中相同的标识符也不会造成样式冲突。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-代码分片</title>
    <link href="http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-dai-ma-fen-pian/"/>
    <id>http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-dai-ma-fen-pian/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-04-02T08:04:05.975Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="代码分片"><a href="#代码分片" class="headerlink" title="代码分片"></a>代码分片</h1><p>代码分片（code splitting）是Webpack作为打包工具所特有的一项技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用户不必一次全部加载，而是按需加载。</p><p>代码分片可以有效降低首屏加载资源的大小，但同时也会带来新的问题，比如我们应该对哪些模块进行分片、分片后的资源如何管理等，这些也是需要关注的。</p><h2 id="通过入口划分代码"><a href="#通过入口划分代码" class="headerlink" title="通过入口划分代码"></a>通过入口划分代码</h2><p>在Webpack中每个入口（entry）都将生成一个对应的资源文件，通过入口的配置我们可以进行一些简单有效的代码拆分。</p><p>对于Web应用来说通常会有一些库和工具是不常变动的，可以把它们放在一个单独的入口中，由该入口产生的资源不会经常更新，因此可以有效地利用客户端缓存，让用户不必在每次请求页面时都重新加载。如：</p><pre><code>// webpack.config.jsentry: {   app: &#39;./app.js&#39;,   lib: [&#39;lib-a&#39;, &#39;lib-b&#39;, &#39;lib-c&#39;]}// index.html&lt;script src=&quot;dist/lib.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;dist/app.js&quot;&gt;&lt;/script&gt;</code></pre><p>这种拆分方法主要适合于那些将接口绑定在全局对象上的库，因为业务代码中的模块无法直接引用库中的模块，二者属于不同的依赖树。</p><h2 id="CommonsChunkPlugin"><a href="#CommonsChunkPlugin" class="headerlink" title="CommonsChunkPlugin"></a>CommonsChunkPlugin</h2><p>CommonsChunkPlugin是Webpack 4之前内部自带的插件（Webpack 4之后替换为了SplitChunks）。它可以将多个Chunk中公共的部分提取出来。公共模块的提取可以为项目带来几个收益：</p><ul><li><p>开发过程中减少了重复模块打包，可以提升开发速度；</p></li><li><p>减小整体资源体积；</p></li><li><p>合理分片后的代码可以更有效地利用客户端缓存。</p></li></ul><p>更改webpack.config.js，添加CommonsChunkPlugin。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>        foo<span class="token punctuation">:</span> <span class="token string">'./foo.js'</span><span class="token punctuation">,</span>        bar<span class="token punctuation">:</span> <span class="token string">'./bar.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>CommonsChunkOlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'commons'</span><span class="token punctuation">,</span>            filename<span class="token punctuation">:</span> <span class="token string">'commons.js'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ul><li><p>name：用于指定公共chunk的名字。</p></li><li><p>filename：提取后的资源文件名。</p></li></ul><p>最后，记得在页面中添加一个script标签来引入commons.js，并且注意，该JS一定要在其他JS之前引入。</p><h3 id="提取-vendor"><a href="#提取-vendor" class="headerlink" title="提取 vendor"></a>提取 vendor</h3><p>虽然CommonsChunkPlugin主要用于提取多入口之间的公共模块，但这不代表对于单入口的应用就无法使用。我们仍然可以用它来提取第三方类库及业务中不常更新的模块，只需要单独为它们创建一个入口即可。</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        app: &#39;./app.js&#39;,        vendor: [&#39;react&#39;]    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;,            filename: &#39;vendor.js&#39;        })    ]}// app.jsimport React from &#39;react&#39;document.write(&#39;app.js&#39;, React.version)</code></pre><p>为了将react从app.js提取出来，我们在配置中加入了一个入口vendor，并使其只包含react，这样就把react变为了app和vendor这两个chunk所共有的模块</p><h3 id="设置提取范围"><a href="#设置提取范围" class="headerlink" title="设置提取范围"></a>设置提取范围</h3><p>通过CommonsChunkPlugin中的chunks配置项可以规定从哪些入口中提取公共模块。</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        a: &#39;./a.js&#39;,        b: &#39;./b.js&#39;,        c: &#39;./c.js&#39;,    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;common&#39;,            filename: &#39;common.js&#39;,            chunks: [&#39;a&#39;, &#39;b&#39;]        })    ]}</code></pre><p>我们在chunks中配置了a和b，这意味着只会从a.js和b.js中提取公共模块。</p><h3 id="设置提取规则"><a href="#设置提取规则" class="headerlink" title="设置提取规则"></a>设置提取规则</h3><p>CommonsChunkPlugin的默认规则是只要一个模块被两个入口chunk所使用就会被提取出来，比如只要a和b用了react，react就会被提取出来。</p><p>然而现实情况是，有些时候我们不希望所有的公共模块都被提取出来，此时我们可以通过CommonsChunkPlugin的minChunks配置项来设置提取的规则，该配置项非常灵活，支持多种输入形式。</p><ul><li>数字</li></ul><p>minChunks可以接受一个数字，当设置minChunks为n时，只有该模块被n个入口同时引用才会进行提取。另外，这个阈值不会影响通过数组形式入口传入模块的提取。</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        foo: &#39;./foo.js&#39;,        bar: &#39;./bar.js&#39;,        vendor: [&#39;react&#39;],    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;,            filename: &#39;vendor.js&#39;,            minChunks: 3        })    ]}</code></pre><p>我们令foo.js和bar.js共同引用一个util.js。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// foo.js</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token string">'./util'</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'foo.js'</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// foo.js</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> <span class="token string">'./util'</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'bar.js'</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// util.js</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span></code></pre><p>如果实际打包应该可以发现，由于我们设置minChunks为3，util.js并不会被提取到vendor.js中，然而react并不受这个的影响，仍然会出现在vendor.js中。</p><ul><li>Infinity</li></ul><p>设置为无穷代表提取的阈值无限高，也就是说所有模块都不会被提取。</p><ul><li>函数</li></ul><p>minChunks支持传入一个函数，它可以让我们更细粒度地控制公共模块。Webpack打包过程中的每个模块都会经过这个函数的处理，当函数的返回值是true时进行提取。</p><pre><code>module.exports = {    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;,            filename: &#39;vendor.js&#39;,            minChunks: function(module, count) {              // module.context 模块目录路径              if (module.context &amp;&amp; module.context.include(&#39;node_modules&#39;)) {                return true              }              // module.resource 包含模块名的完整路径              if (module.resource &amp;&amp; module.resource.endsWith(&#39;util.js&#39;)) {                return true              }              // count 为模块被引用的次数              if (count &gt; 5) {                return true              }            }        })    ]}</code></pre><p>借助上面的配置，我们可以分别提取node_modules目录下的模块、名称为util.js的模块，以及被引用5次（不包含5次）以上的模块。</p><h3 id="hash-与-长效缓存"><a href="#hash-与-长效缓存" class="headerlink" title="hash 与 长效缓存"></a>hash 与 长效缓存</h3><p>当我们使用该插件提取公共模块时，提取后的资源内部不仅仅是模块的代码，往往还包含Webpack的运行时（runtime）。Webpack的运行时指的是初始化环境的代码，如创建模块缓存对象、声明模块加载函数等。</p><p>将运行时的代码单独提取出来。请看下面这个例子：</p><pre><code>const webpack = require(&#39;webpack&#39;)module.exports = {    entry: {        app: &#39;./app.js&#39;,        vendor: [&#39;react&#39;],    },    output: {        filename: &#39;[name].js&#39;    },    plugins: [        new webpack.optimize.CommonsChunkOlugin({            name: &#39;vendor&#39;        }),        new webpack.optimize.CommonsChunkOlugin({          name: &#39;manifest&#39;        }),    ]}</code></pre><p>上面的配置中，通过添加了一个name为manifest的CommonsChunkPlugin来提取Webpack的运行时。</p><p>注：manifest的CommonsChunkPlugin必须出现在最后，否则Webpack将无法正常提取模块。</p><h3 id="CommonsChunkPlugin-的不足"><a href="#CommonsChunkPlugin-的不足" class="headerlink" title="CommonsChunkPlugin 的不足"></a>CommonsChunkPlugin 的不足</h3><p>在提取公共模块方面，CommonsChunkPlugin可以满足很多场景的需求，但是它也有一些欠缺的地方。</p><ul><li><p>一个CommonsChunkPlugin只能提取一个vendor，假如我们想提取多个vendor则需要配置多个插件，这会增加很多重复的配置代码。</p></li><li><p>前面我们提到的manifest实际上会使浏览器多加载一个资源，这对于页面渲染速度是不友好的。</p></li><li><p>由于内部设计上的一些缺陷，CommonsChunkPlugin在提取公共模块的时候会破坏掉原有Chunk中模块的依赖关系，导致难以进行更多的优化。</p></li></ul><h2 id="optimization-SplitChunks"><a href="#optimization-SplitChunks" class="headerlink" title="optimization.SplitChunks"></a>optimization.SplitChunks</h2><p>optimization.SplitChunks（简称SplitChunks）是Webpack 4为了改进CommonsChunk-Plugin而重新设计和实现的代码分片特性。</p><p>比如我们前面异步加载的例子，在换成Webpack 4的SplitChunks之后，就可以自动提取出react了。</p><pre><code>module.exports = {    entry: &#39;./foo.js&#39;,    output: {        filename: &#39;foo.js&#39;,        publicPath: &#39;/dist/&#39;    },    mode: &#39;development&#39;,    optimization: {      splitChunks: {        chunks: &#39;all&#39;      }    }}// foo.jsimport React from &#39;react&#39;import(&#39;./bar.js&#39;)document.write(&#39;app.js&#39;, React.version)// bar.jsimport React from &#39;react&#39;document.write(&#39;bar.js&#39;, React.version)</code></pre><p>此处Webpack 4的配置与之前相比有两点不同：</p><ul><li>使用optimization.splitChunks替代了CommonsChunkPlugin，并指定了chunks的值为all，这个配置项的含义是，SplitChunks将会对所有的chunks生效（默认情况下，SplitChunks只对异步chunks生效，并且不需要配置）。</li></ul><p>以下是SplitChunks默认情形下的提取条件：</p><ul><li><p>提取后的chunk可被共享或者来自node_modules目录。</p></li><li><p>提取后的Javascript chunk体积大于30kB（压缩和gzip之前），CSS chunk体积大于50kB。</p></li><li><p>在按需加载过程中，并行请求的资源最大值小于等于5。按需加载指的是，通过动态插入script标签的方式加载脚本。</p></li><li><p>在首次加载时，并行请求的资源数最大值小于等于3。</p></li></ul><h3 id="默认的异步提取"><a href="#默认的异步提取" class="headerlink" title="默认的异步提取"></a>默认的异步提取</h3><p>前面我们对SplitChunks添加了一个chunks：all的配置，这是为了提取foo.js和bar.js的公共模块。实际上SplitChunks不需要配置也能生效，但仅仅针对异步资源。</p><pre><code>module.exports = {    entry: &#39;./foo.js&#39;,    output: {        filename: &#39;foo.js&#39;,        publicPath: &#39;/dist/&#39;    },    mode: &#39;development&#39;}// foo.jsimport(&#39;./bar.js&#39;)document.write(&#39;app.js&#39;, React.version)// bar.jsimport React from &#39;react&#39;document.write(&#39;bar.js&#39;, React.version)</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>为了更好地了解SplitChunks是怎样工作的，我们来看一下它的默认配置。</p><pre><code>        optimization: {       splitChunks: {          chunks: &#39;async&#39;,          minSize: {              javascript: 30000,              style: 50000          },          maxSize: 0,          minChunks: 1,          maxAsyncRequest3: 3,          maxInitialRequests: 2,          automaticNameDelimiter: &#39;~&#39;,          name: true,          cacheGroups: {            vendors: {              test: /[\\/]node_modules[\\/]/            },            default: {              minChunks: 2,              priority: -20,              reuseExistingChunk: true            }          }       }    }</code></pre><ul><li>匹配模式</li></ul><p>通过chunks我们可以配置SplitChunks的工作模式。它有3个可选值，分别为async（默认）、initial和all。async即只提取异步chunk，initial则只对入口chunk生效（如果配置了initial则上面异步的例子将失效），all则是两种模式同时开启。</p><ul><li>匹配条件</li></ul><p>minSize、minChunks、maxAsyncRequests、maxInitialRequests都属于匹配条件。</p><ul><li>命名</li></ul><p>配置项name默认为true，它意味着SplitChunks可以根据cacheGroups和作用范围自动为新生成的chunk命名，并以automaticNameDelimiter分隔。</p><ul><li>cacheGroups</li></ul><p>可以理解成分离chunks时的规则。默认情况下有两种规则——vendors和default。vendors用于提取所有node_modules中符合条件的模块，default则作用于被多次引用的模块。我们可以对这些规则进行增加或者修改，如果想要禁用某种规则，也可以直接将其置为false。当一个模块同时符合多个cacheGroups时，则根据其中的priority配置项确定优先级。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-预处理器</title>
    <link href="http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yu-chu-li-qi/"/>
    <id>http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yu-chu-li-qi/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-04-02T08:04:41.965Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="预处理器（loader）"><a href="#预处理器（loader）" class="headerlink" title="预处理器（loader）"></a>预处理器（loader）</h1><p>每个loader本质上都是一个函数。在Webpack 4之前，函数的输入和输出都必须为字符串；在Webpack 4之后，loader也同时支持抽象语法树（AST）的传递，通过这种方法来减少重复的代码解析。用公式表达loader的本质则为以下形式：</p><p>output=loader(input)</p><p>这里的input可能是工程源文件的字符串，也可能是上一个loader转化后的结果，包括转化后的结果（也是字符串类型）、source map，以及AST对象；output同样包含这几种信息，转化后的文件字符串、source map，以及AST。如果这是最后一个loader，结果将直接被送到Webpack进行后续处理，否则将作为下一个loader的输入向后传递。</p><h2 id="loader-的配置"><a href="#loader-的配置" class="headerlink" title="loader 的配置"></a>loader 的配置</h2><p>Webpack本身只认识JavaScript，对于其他类型的资源必须预先定义一个或多个loader对其进行转译，输出为Webpack能够接收的形式再继续进行，因此loader做的实际上是一个预处理的工作。</p><pre><code>module.exports = {  module: {    rules: [      {        test: /\.jsx?/, // 条件        use: &#39;babel-loader&#39; // 规则应用结果      } // 一个Object即一条规则    ]  }}</code></pre><p>与loader相关的配置都在module对象中，其中module.rules代表了模块的处理规则。每条规则内部可以包含很多配置项，这里我们只使用了最重要的两项—test和use。</p><ul><li><p>test可接收一个正则表达式或者一个元素为正则表达式的数组，只有正则匹配上的模块才会使用这条规则。</p></li><li><p>use可接收一个数组，数组包含该规则所使用的loader。</p></li></ul><h3 id="链式-loader"><a href="#链式-loader" class="headerlink" title="链式 loader"></a>链式 loader</h3><p>很多时候，在处理某一类资源时我们都需要使用多个loader。</p><pre><code>module.exports = {  module: {    rules: [      {        test: /\.css?/, // 条件        use: [&#39;style-loader&#39;, &#39;css-loader&#39;] // 规则应用结果      } // 一个Object即一条规则    ]  }}</code></pre><p>把style-loader加到了css-loader前面，这是因为在Webpack打包时是按照数组从后往前的顺序将资源交给loader处理的，因此要把最后生效的放在前面。</p><h3 id="loader-options"><a href="#loader-options" class="headerlink" title="loader options"></a>loader options</h3><p>webpack为loader提供了多种匹配条件的配置方式：</p><ul><li>test: … 匹配特定条件</li><li>include: … 匹配特定路径</li><li>exclude: … 排除特定路径</li><li>and: [] 必须匹配数组中的所有条件</li><li>or: [] 匹配数组中的任意一个条件</li><li>not: [] 排除匹配数组中的所有条件</li></ul><p>条件值类型：</p><ul><li>字符串：必须以提供的字符串开始（绝对路径）</li><li>正则表达式</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件</li><li>函数：返回true表示匹配</li></ul><hr><h5 id="规则应用配置"><a href="#规则应用配置" class="headerlink" title="规则应用配置"></a>规则应用配置</h5><p>匹配规则后的应用，我们可以使用use字段：</p><pre><code>rules: [  {    test: /\.less/,    use: [      &#39;style-loader&#39;,      {        loader: &#39;css-loader&#39;,        options: {          // ...        }      },      {        loader: &#39;less-loader&#39;,        options: {          // ...        }      }    ]  }]</code></pre><p>使用options可以给对应的loader传递一些配置项。</p><p>对于上述的less规则应用配置，一个less模块文件可以经过多个loader的转换处理，执行顺序为从右到左。</p><p>如果多个rule匹配了同一个模块文件，loader的应用顺序应该如何处理？</p><pre><code>rules: [  {    test: /\.js$/,    loader: &quot;eslint-loader&quot;,  },  {    test: /\.js$/,    loader: &quot;babel-loader&quot;,  }]</code></pre><p>eslint-loader用于检查人工编写的代码，babel-loader用于转换代码。所以，eslint-loader应该在babel-loader之前执行，那么该如何保证执行顺序？</p><p>webpack为每一个匹配规则提供了enforce字段来配置当前rule得的loader类型。pre(前置) &gt; 行内 &gt; 普通 &gt; 后置(post)。 我们要确保eslint-loader在babel-loader之前执行，只需给rule规则项添加enforce字段，并设置其值为pre。</p><pre><code>rules: [  {    enforce: &#39;pre&#39;,    test: /\.js$/,    loader: &quot;eslint-loader&quot;,  },  {    test: /\.js$/,    loader: &quot;babel-loader&quot;,  }]</code></pre><h2 id="常用-loader-介绍"><a href="#常用-loader-介绍" class="headerlink" title="常用 loader 介绍"></a>常用 loader 介绍</h2><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p> babel-loader用来处理ES6+并将其编译为ES5。</p><pre class=" language-javascript"><code class="language-javascript">npm i babel<span class="token operator">-</span>loader @babel<span class="token operator">/</span>core @babel<span class="token operator">/</span>preset<span class="token operator">-</span>env</code></pre><p>各个模块的作用如下:</p><ul><li><p>babel-loader：它是使Babel与Webpack协同工作的模块。</p></li><li><p>@babel/core：顾名思义，它是Babel编译器的核心模块。</p></li><li><p>@babel/preset-env：它是Babel官方推荐的预置器，可根据用户设置的目标环境自动添加所需的插件和补丁来编译ES6+代码。</p></li></ul><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.jsx?/,        loader: &#39;babel-loader&#39;      }    ]  }}</code></pre><hr><h3 id="ts-loader"><a href="#ts-loader" class="headerlink" title="ts-loader"></a>ts-loader</h3><p>ts-loader与babel-loader的性质类似，它是用于连接Webpack与Typescript的模块。</p><pre class=" language-javascript"><code class="language-javascript">npm i ts<span class="token operator">-</span>loader typescript</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.ts?/,        loader: &#39;ts-loader&#39;      }    ]  }}</code></pre><hr><h3 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h3><p>html-loader用于将HTML文件转化为字符串并进行格式化，这使得我们可以把一个HTML片段通过JS加载进来。</p><pre class=" language-javascript"><code class="language-javascript">npm i html<span class="token operator">-</span>loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.html?/,        loader: &#39;html-loader&#39;      }    ]  }}</code></pre><h3 id="handlebars-loader"><a href="#handlebars-loader" class="headerlink" title="handlebars-loader"></a>handlebars-loader</h3><p>handlebars-loader用于处理handlebars模板，在安装时要额外安装handlebars。</p><pre class=" language-javascript"><code class="language-javascript">npm i handlebars<span class="token operator">-</span>loader handlebars</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.handlebars?/,        loader: &#39;handlebars-loader&#39;      }    ]  }}</code></pre><p>handlebars文件加载后得到的是一个函数，可以接收一个变量对象并返回最终的字符串。</p><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>file-loader用于打包文件类型的资源，并返回其publicPath。</p><pre class=" language-javascript"><code class="language-javascript">npm i file<span class="token operator">-</span>loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.(png|jpg|gif)$/,        use: &#39;file-loader&#39;      }    ]  }}</code></pre><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>url-loader与file-loader作用类似，唯一的不同在于用户可以设置一个文件大小的阈值，当大于该阈值时与file-loader一样返回publicPath，而小于该阈值时则返回文件base64形式编码。</p><pre class=" language-javascript"><code class="language-javascript">npm i url<span class="token operator">-</span>loader</code></pre><pre><code>module.exports = {  // ...  module: {    rules: [      {        test: /\.(png|jpg|gif)$/,        use: {            loader: &#39;file-loader&#39;,            options: {                limit: 10240,                name: &#39;[name].[ext]&#39;,                publicPath: &#39;./assets-path/&#39;            }        }      }    ]  }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
</feed>
