<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>W | 个人博客 | web前端</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-25T08:08:23.863Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wangxiaobai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题-常见面试题系列之JS基础</title>
    <link href="http://yoursite.com/2019/11/25/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97%E4%B9%8BJS%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/11/25/面试题-常见面试题系列之JS基础/</id>
    <published>2019-11-25T01:46:52.000Z</published>
    <updated>2019-11-25T08:08:23.863Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><p>本系列旨在整理 JS 常见面试题，帮助梳理 JS 基础知识点。</p><h3 id="🌰-‘1’-‘2’-‘3’-map-parseInt-输出结果"><a href="#🌰-‘1’-‘2’-‘3’-map-parseInt-输出结果" class="headerlink" title="🌰 [‘1’, ‘2’, ‘3’].map(parseInt) 输出结果"></a>🌰 [‘1’, ‘2’, ‘3’].map(parseInt) 输出结果</h3><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h4><p>解析一个字符串参数，返回一个指定基数的整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> intValue = <span class="built_in">parseInt</span>(string[, radix]);</div></pre></td></tr></table></figure><p>string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串。字符串开头的空白符会被忽略。</p><p>radix 一个介于 2~36之间的整数，表示上述字符串的基数，默认值为 10。</p><p>parseInt 返回一个整数或 NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>); <span class="comment">// 100</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>, <span class="number">10</span>); <span class="comment">// 1*10*10 + 0*10*1 + 0*10*0 = 100</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>, <span class="number">2</span>); <span class="comment">// 1*2*2 + 0*2*1 + 0*2*0 = 4</span></div></pre></td></tr></table></figure><p>在 radix 为 undefined ，或 radix 为 0 或没有指定的情况下，JS 作如下处理：</p><ul><li><p>string 以 ‘0x’ 或 ‘0X’ 开头，则 radix 为 16。</p></li><li><p>string 以 ‘0’ 开头，radix 为 8 或者 10，具体哪个基数由实现环境决定。</p></li><li><p>string 以其它任何值开头，则 radix 为 10。</p></li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[,index[, array]]</span>) </span>&#123;</div><div class="line"> <span class="comment">// Return element for new_array</span></div><div class="line"> &#125;[, thisArg])</div></pre></td></tr></table></figure><p>callback 回调函数需要三个参数，分别为 currentValue(数组中当前正在处理的元素的值)、index(数组中当前正在处理的元素的索引)、array(map 方法中被调用的数组)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">arr.map(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>) <span class="comment">// [2, 4, 6]</span></div></pre></td></tr></table></figure><h4 id="‘1’-‘2’-‘3’-map-parseInt-输出"><a href="#‘1’-‘2’-‘3’-map-parseInt-输出" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt) 输出"></a>[‘1’, ‘2’, ‘3’].map(parseInt) 输出</h4><p>对于每个迭代 map，parseInt() 传递两个参数：字符串和基数。所以实际执行的代码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">parseInt</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> <span class="built_in">parseInt</span>(item, index))</div></pre></td></tr></table></figure><p>执行步骤为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>); <span class="comment">// 1 (10 进制)</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>); <span class="comment">// NaN radix(2-36)</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>); <span class="comment">// NaN 不符合2进制位数取值(0-1)</span></div></pre></td></tr></table></figure><p>所以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">parseInt</span>) <span class="comment">// [1, NaN, NaN]</span></div></pre></td></tr></table></figure><h3 id="🌰-什么是节流和防抖？区别？如何实现？"><a href="#🌰-什么是节流和防抖？区别？如何实现？" class="headerlink" title="🌰 什么是节流和防抖？区别？如何实现？"></a>🌰 什么是节流和防抖？区别？如何实现？</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>动作绑定事件，动作发生后一定时间内触发时间，在这段时间内如果该动作又发生，则重新等待一定时间再触发事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 防抖 debounce 定时器</span></div><div class="line"><span class="comment"> * @param fn &#123;function&#125; 回调函数</span></div><div class="line"><span class="comment"> * @param wait &#123;number&#125; 时间间隔</span></div><div class="line"><span class="comment"> * @author wangxiaobai</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, wait</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 清除上次执行得定时器</span></div><div class="line">    <span class="keyword">if</span> (timer) &#123;</div><div class="line">      clearTimeout(timer)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设立新定时器</span></div><div class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">    &#125;, wait)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>动作绑定事件，动作发生后一定时间内触发事件，在这段时间内如果该动作又发生，则无视该动作，直到事件执行完后，才能重新触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 节流 throttle 定时器</span></div><div class="line"><span class="comment"> * @param fn &#123;function&#125; 回调函数</span></div><div class="line"><span class="comment"> * @param wait &#123;number&#125; 时间间隔</span></div><div class="line"><span class="comment"> * @author wangxiaobai</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, wait</span>) </span>&#123;</div><div class="line">  <span class="comment">// 上一次函数的执行时间  </span></div><div class="line">  <span class="keyword">let</span> activeTime = <span class="number">0</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">let</span> currentTime = +<span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">      <span class="keyword">if</span> (currentTime - activeTime &gt; wait) &#123;</div><div class="line">          fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">          activeTime = currentTime</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;p&gt;本系列旨在整理 JS 常见面试题，帮助梳理 JS 基础知识点。&lt;/p&gt;
&lt;h3 id=&quot;🌰-‘1’-‘2’-‘3’-map-parseIn
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CSS-常见面试题系列之BFC</title>
    <link href="http://yoursite.com/2019/08/26/CSS-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97%E4%B9%8BBFC/"/>
    <id>http://yoursite.com/2019/08/26/CSS-常见面试题系列之BFC/</id>
    <published>2019-08-26T08:24:52.000Z</published>
    <updated>2019-08-29T08:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>BFC (Block Formatting Context) 块级格式化上下文，页面的可视化 CSS 渲染的一部分，是一个独立的渲染区域，块内的子元素布局与块外的元素互不干扰。</p></blockquote><h3 id="BFC-解决的问题"><a href="#BFC-解决的问题" class="headerlink" title="BFC 解决的问题"></a>BFC 解决的问题</h3><ul><li>浮动定位</li><li>消除外边距折叠</li><li>清除浮动</li><li>自适应多栏布局<br>…</li></ul><hr><h3 id="BFC-的创建"><a href="#BFC-的创建" class="headerlink" title="BFC 的创建"></a>BFC 的创建</h3><ul><li>body根元素</li><li>浮动: float 除 none 以外的值</li><li>绝对定位: position (absolute, fixed)</li><li>overflow 值不为 visible</li><li>弹性布局或网格布局</li></ul><hr><h3 id="BFC-的约束规则"><a href="#BFC-的约束规则" class="headerlink" title="BFC 的约束规则"></a>BFC 的约束规则</h3><ul><li>属于同一个 BFC 中的两个相邻的 Box 的 margin 会发生折叠。</li><li>每个元素的左外边距与包含块的左边界相接触，即使浮动元素也是如此。</li><li>BFC 的区域不会与 float 的元素区域重叠</li><li>计算 BFC 的高度时，浮动子元素也参与计算</li></ul><hr><h3 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h3><h4 id="防止-margin-重叠"><a href="#防止-margin-重叠" class="headerlink" title="防止 margin 重叠"></a>防止 margin 重叠</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>top<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>bottom<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">  p &#123;</span></div><div class="line"><span class="undefined">    width: 100px;</span></div><div class="line"><span class="undefined">    height: 100px;</span></div><div class="line"><span class="undefined">    background: yellow;</span></div><div class="line"><span class="undefined">    line-height: 100px;</span></div><div class="line"><span class="undefined">    margin: 10px;</span></div><div class="line"><span class="undefined">    text-align: center</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/css-bfc.png&#39;" alt=""></p><p>两个 box 中间的间距为 10px，而不是 20px，因为它们处于同一个 BFC 中(body)。</p><p>解决方案为给第二个 box 包一层 div，设置其 overflow 属性，使它们处于不同的 BFC。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>top<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>bottom<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">  p &#123;</span></div><div class="line"><span class="undefined">    width: 100px;</span></div><div class="line"><span class="undefined">    height: 100px;</span></div><div class="line"><span class="undefined">    background: yellow;</span></div><div class="line"><span class="undefined">    line-height: 100px;</span></div><div class="line"><span class="undefined">    margin: 10px;</span></div><div class="line"><span class="undefined">    text-align: center</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined">  div &#123;</span></div><div class="line"><span class="undefined">    overflow: hidden;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/css-bfc-margin.png&#39;" alt=""></p><h4 id="让浮动内容与周围内容等高"><a href="#让浮动内容与周围内容等高" class="headerlink" title="让浮动内容与周围内容等高"></a>让浮动内容与周围内容等高</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>浮动元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>未浮动元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">.box &#123;</span></div><div class="line"><span class="undefined">    background-color: rgb(224, 206, 247);</span></div><div class="line"><span class="undefined">    border: 5px solid rebeccapurple;</span></div><div class="line"><span class="undefined">&#125;</span></div><div class="line"><span class="undefined">.float &#123;</span></div><div class="line"><span class="undefined">    float: left;</span></div><div class="line"><span class="undefined">    width: 200px;</span></div><div class="line"><span class="undefined">    height: 150px;</span></div><div class="line"><span class="undefined">    background-color: white;</span></div><div class="line"><span class="undefined">    border:1px solid black;</span></div><div class="line"><span class="undefined">    padding: 10px;</span></div><div class="line"><span class="undefined">&#125;      </span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/float-bfc-margin.png&#39;" alt=""></p><p>由于浮动，使得浮动元素的高度高于旁边的元素，解决方式为使父 box 生成一个 BFC，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>浮动元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>未浮动元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">.box &#123;</span></div><div class="line"><span class="undefined">    background-color: rgb(224, 206, 247);</span></div><div class="line"><span class="undefined">    border: 5px solid rebeccapurple;</span></div><div class="line"><span class="undefined">    overflow: auto;</span></div><div class="line"><span class="undefined">&#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="undefined">.float &#123;</span></div><div class="line"><span class="undefined">    float: left;</span></div><div class="line"><span class="undefined">    width: 200px;</span></div><div class="line"><span class="undefined">    height: 150px;</span></div><div class="line"><span class="undefined">    background-color: white;</span></div><div class="line"><span class="undefined">    border:1px solid black;</span></div><div class="line"><span class="undefined">    padding: 10px;</span></div><div class="line"><span class="undefined">&#125;      </span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/float-bfc.png&#39;" alt=""></p><h4 id="阻止元素被浮动元素覆盖"><a href="#阻止元素被浮动元素覆盖" class="headerlink" title="阻止元素被浮动元素覆盖"></a>阻止元素被浮动元素覆盖</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>我是一个没有设置浮动, 也没有触发 BFC 元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">.float &#123;</span></div><div class="line"><span class="undefined">  width: 100px;</span></div><div class="line"><span class="undefined">  height: 100px;</span></div><div class="line"><span class="undefined">  background: #eee;</span></div><div class="line"><span class="undefined">  float: left;</span></div><div class="line"><span class="undefined">&#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="undefined">.box &#123;</span></div><div class="line"><span class="undefined">  width: 200px;</span></div><div class="line"><span class="undefined">  height: 200px;</span></div><div class="line"><span class="undefined">  background: yellow;</span></div><div class="line"><span class="undefined">&#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/column-css.png&#39;" alt=""></p><p>第二个元素有部分被浮动元素覆盖，此时可触发第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>我是一个没有设置浮动, 也没有触发 BFC 元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">    .float &#123;</span></div><div class="line"><span class="undefined">      width: 100px;</span></div><div class="line"><span class="undefined">      height: 100px;</span></div><div class="line"><span class="undefined">      background: #eee;</span></div><div class="line"><span class="undefined">      float: left;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined">    </span></div><div class="line"><span class="undefined">    .box &#123;</span></div><div class="line"><span class="undefined">      overflow: hidden;</span></div><div class="line"><span class="undefined">      width: 200px;</span></div><div class="line"><span class="undefined">      height: 200px;</span></div><div class="line"><span class="undefined">      background: yellow;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/columb-css-bfc.png&#39;" alt=""></p><p>此方法可用来实现两列自适应布局</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/louzhedong/blog/issues/145" target="_blank" rel="external">BFC原理解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="external">10 分钟理解 BFC 原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;BFC (Block Formatting Context) 块级格式化上下文，页面的可视化 CSS 渲染的一部分
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue-源码系列随读笔记之Array变化侦测</title>
    <link href="http://yoursite.com/2019/08/18/Vue-%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E9%9A%8F%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8BArray%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/08/18/Vue-源码系列随读笔记之Array变化侦测/</id>
    <published>2019-08-18T10:34:52.000Z</published>
    <updated>2019-08-17T17:13:30.468Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档</p></blockquote><a id="more"></a><h3 id="什么是变化侦测"><a href="#什么是变化侦测" class="headerlink" title="什么是变化侦测"></a>什么是变化侦测</h3><p>从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。</p><p>简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。</p><p>Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。</p><hr><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">     enumerable: <span class="literal">true</span>,</div><div class="line">     configurable: <span class="literal">true</span>,</div><div class="line">     get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> val</div><div class="line">     &#125;,</div><div class="line">     set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">           <span class="keyword">return</span> </div><div class="line">        &#125;</div><div class="line">        val = newVal</div><div class="line">     &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。</p><p>由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。</p><hr><h3 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h3><p>思考以下问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> globalObj = &#123;</div><div class="line">  text1: <span class="string">'text1'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  template:</div><div class="line">    <span class="string">`&lt;div&gt;</span></div><div class="line"><span class="string">       &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></div><div class="line"><span class="string">    &lt;div&gt;`</span>,</div><div class="line">  data: globalObj</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  template:</div><div class="line">     <span class="string">`&lt;div&gt;</span></div><div class="line"><span class="string">        &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></div><div class="line"><span class="string">     &lt;div&gt;`</span>,</div><div class="line">  data: globalObj</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？</p><p>对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。</p><p>即：在 getter 中收集依赖，在 setter 中触发依赖。</p><hr><h3 id="依赖收集到哪里（Dep）"><a href="#依赖收集到哪里（Dep）" class="headerlink" title="依赖收集到哪里（Dep）"></a>依赖收集到哪里（Dep）</h3><p> 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">constructor</span> () &#123;</div><div class="line">    <span class="keyword">this</span>.subs = [] <span class="comment">// 观察者集合</span></div><div class="line">  &#125;</div><div class="line"> <span class="comment">// 添加观察者</span></div><div class="line">  addSub (sub) &#123;</div><div class="line">    <span class="keyword">this</span>.subs.push(sub)</div><div class="line">  &#125;</div><div class="line"> <span class="comment">// 移除观察者</span></div><div class="line">  removeSub (sub) &#123;</div><div class="line">    remove(<span class="keyword">this</span>.subs, sub)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  depend () &#123; <span class="comment">// 如果存在 Dep.target，则进行依赖收集操作</span></div><div class="line">    <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">      <span class="keyword">this</span>.addSub(Dep.target)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  notify () &#123;</div><div class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice() <span class="comment">// 避免污染原来的集合</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</div><div class="line">      subs[i].update() <span class="comment">// 更新</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arr.length) &#123;</div><div class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</div><div class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>改造 defineReactive</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">     enumerable: <span class="literal">true</span>,</div><div class="line">     configurable: <span class="literal">true</span>,</div><div class="line">     get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        dep.depend()</div><div class="line">           <span class="keyword">return</span> val</div><div class="line">     &#125;,</div><div class="line">     set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">           <span class="keyword">return</span> </div><div class="line">        &#125;</div><div class="line">        val = newVal</div><div class="line">        dep.notify()</div><div class="line">     &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="什么是依赖"><a href="#什么是依赖" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。</p><p>然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。</p><p>收集谁？Watcher!</p><hr><h3 id="什么是-Watcher"><a href="#什么是-Watcher" class="headerlink" title="什么是 Watcher"></a>什么是 Watcher</h3><p>Watcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm.$watch(<span class="string">'a.b.c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。</p><p>把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">constructor</span> (</div><div class="line">    vm: Component, // 组件实例</div><div class="line">    expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作</div><div class="line">    cb: Function // 被观察者发生变化后的回调</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">this</span>.vm = vm <span class="comment">// Watcher有一个 vm 属性，表明它是属于哪个组件的</span></div><div class="line">    <span class="keyword">this</span>.cb = cb <span class="comment">// 回调</span></div><div class="line">    <span class="keyword">this</span>.getter = parsePath(expOrFn)</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get () &#123; <span class="comment">// 触发取值操作，进而触发属性的getter</span></div><div class="line">    Dep.target = <span class="keyword">this</span></div><div class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm)</div><div class="line">    Dep.target = <span class="literal">null</span></div><div class="line">    <span class="keyword">return</span> value</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  update () &#123; <span class="comment">// 更新</span></div><div class="line">    <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</div><div class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.value, oldValue)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。</p><p>在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。</p><p>只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。</p><p>依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。</p><p>不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。</p><p>parsePath函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">'.'</span>)</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></div><div class="line">      obj = obj[segments[i]]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="递归侦测所有Key"><a href="#递归侦测所有Key" class="headerlink" title="递归侦测所有Key"></a>递归侦测所有Key</h3><p>前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value</div><div class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">            <span class="keyword">this</span>.walk(value)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    walk (obj) &#123;</div><div class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">            defineReactive (obj, keys[i], obj[keys[i]])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'object'</span>) &#123;</div><div class="line">      <span class="keyword">new</span> Observer(val)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">       enumerable: <span class="literal">true</span>,</div><div class="line">       configurable: <span class="literal">true</span>,</div><div class="line">       get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          dep.depend()</div><div class="line">             <span class="keyword">return</span> val</div><div class="line">       &#125;,</div><div class="line">       set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">          <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">             <span class="keyword">return</span> </div><div class="line">          &#125;</div><div class="line">          val = newVal</div><div class="line">          dep.notify()</div><div class="line">       &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Observer 类，用于将一个正常的 object 转换成被侦测的 object。</p><p>判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。</p><p>最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。</p><p>当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。</p><p>Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。</p><p>我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。</p><p>收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。</p><p>所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。</p><p>Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。</p><p>由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。</p><p>在 Vue 中，对象新增属性或删除属性都无法被侦测到。</p><p><img src="https://screenshot.net/zh/qv9nwto" alt=""></p><p>Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。</p><p>当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。</p><p>当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。</p><p>Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JS-执行上下文和执行上下文栈</title>
    <link href="http://yoursite.com/2019/07/26/JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <id>http://yoursite.com/2019/07/26/JS-执行上下文和执行栈/</id>
    <published>2019-07-26T07:18:52.000Z</published>
    <updated>2019-07-26T07:28:37.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文栈用于存储在代码执行期间创建的所有执行上下文。</p></blockquote><a id="more"></a><h2 id="理解执行上下文和执行上下文栈"><a href="#理解执行上下文和执行上下文栈" class="headerlink" title="理解执行上下文和执行上下文栈"></a>理解执行上下文和执行上下文栈</h2><h3 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h3><p>执行上下文总共有三种类型：</p><ul><li><p>全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 会指向这个全局对象。</p></li><li><p>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p></li><li><p>Eval 函数执行上下文：运行在 Eval 函数中的代码。</p></li></ul><hr><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>接下来问题来了，我们写了那么多函数，如何管理创建的那么多执行上下文呢？</p><p>Javascript 创建了执行上下文栈，也叫调用栈，来管理在代码执行期间创建的所有执行上下文。</p><p>首次运行 Javascript 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。</p><p>根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从栈中 Pop 出，上下文控制权将会移到当前执行栈的下一个执行上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'Hello World!'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Inside first function'</span>);  </div><div class="line">  second();  </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Again inside first function'</span>);  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Inside second function'</span>);  </div><div class="line">&#125;</div><div class="line"></div><div class="line">first();  </div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Inside Global Execution Context'</span>);</div></pre></td></tr></table></figure><p><img src="&#39;https://user-gold-cdn.xitu.io/2018/11/5/166e258e1d0281a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#39;" alt=""></p><hr><h3 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h3><p>执行上下文分为两个阶段创建：1） 创建阶段 2）执行阶段</p><h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><ul><li><p>确定 this 的值，也被称为 This Binding</p></li><li><p>LexicalEnvironment-词法环境组件被创建</p></li><li><p>VariableEnvironment-变量环境组件被创建</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutionContext = &#123;</div><div class="line">    ThisBinding: <span class="xml"><span class="tag">&lt;<span class="name">this</span> <span class="attr">value</span>&gt;</span>, // 确定 this</span></div><div class="line"><span class="xml">    LexicalEnvironment: &#123;...&#125;, // 词法环境</span></div><div class="line"><span class="xml">    VariableEnvironment: &#123;...&#125; // 变量环境</span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure><h5 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h5><ul><li><p>全局执行上下文中，this 指向全局对象，在浏览器中 this 的值指向 window 对象，而在 nodejs 中指向这个文件的 module 对象。</p></li><li><p>函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显示绑定、new 绑定等。</p></li></ul><h5 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h5><p>词法环境有两个组成部分：</p><ul><li><p>环境记录：存储变量和函数声明的实际位置</p></li><li><p>对外部环境的引用：可以访问其外部词法环境</p></li></ul><p>词法环境有两种类型：</p><ul><li><p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window）及其关联的方法和属性以及任何用户自定义的全局变量， this 的值指向这个全局对象。</p></li><li><p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境，</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">GlobalExectionContext = &#123;  <span class="comment">// 全局执行上下文</span></div><div class="line">  LexicalEnvironment: &#123;          <span class="comment">// 词法环境</span></div><div class="line">    EnvironmentRecord: &#123;          <span class="comment">// 环境记录</span></div><div class="line">      Type: <span class="string">"Object"</span>,                <span class="comment">// 全局环境</span></div><div class="line">      <span class="comment">// 标识符绑定在这里 </span></div><div class="line">      outer: <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span>                 // 对外部环境的引用</span></div><div class="line"><span class="xml">  &#125;  </span></div><div class="line"><span class="xml">&#125;</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">FunctionExectionContext = &#123; // 函数执行上下文</span></div><div class="line"><span class="xml">  LexicalEnvironment: &#123;     // 词法环境</span></div><div class="line"><span class="xml">      EnvironmentRecord: &#123;      // 环境记录</span></div><div class="line"><span class="xml">        Type: "Declarative",        // 函数环境</span></div><div class="line"><span class="xml">        // 标识符绑定在这里          // 对外部环境的引用</span></div><div class="line">        outer: &lt;Global or outer function environment reference&gt;  </div><div class="line">    &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure><h5 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h5><p>  变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>  在ES6中，词法环境和变量环境的区别在于前者用于存储函数声明和变量(let const)绑定，后者仅用于存储变量(var)绑定。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">GlobalExectionContext = &#123;</div><div class="line"></div><div class="line">  ThisBinding: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">  LexicalEnvironment: &#123;  </span></div><div class="line"><span class="xml">    EnvironmentRecord: &#123;  </span></div><div class="line"><span class="xml">      Type: "Object",  </span></div><div class="line"><span class="xml">      // 标识符绑定在这里  </span></div><div class="line"><span class="xml">      a: <span class="tag">&lt; <span class="attr">uninitialized</span> &gt;</span>,  </span></div><div class="line"><span class="xml">      b: <span class="tag">&lt; <span class="attr">uninitialized</span> &gt;</span>,  </span></div><div class="line"><span class="xml">      multiply: <span class="tag">&lt; <span class="attr">func</span> &gt;</span>  </span></div><div class="line"><span class="xml">    &#125;  </span></div><div class="line">    outer: &lt;null&gt;  </div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  VariableEnvironment: &#123;  </div><div class="line">    EnvironmentRecord: &#123;  </div><div class="line">      Type: "Object",  </div><div class="line">      // 标识符绑定在这里  </div><div class="line">      c: undefined,  </div><div class="line">    &#125;  </div><div class="line">    outer: &lt;null&gt;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">FunctionExectionContext = &#123;  </div><div class="line">   </div><div class="line">  ThisBinding: &lt;Global Object&gt;,</div><div class="line">  </div><div class="line">  LexicalEnvironment: &#123;  </div><div class="line">    EnvironmentRecord: &#123;  </div><div class="line">      Type: "Declarative",  </div><div class="line">      // 标识符绑定在这里  </div><div class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,  </div><div class="line">    &#125;,  </div><div class="line">    outer: &lt;GlobalLexicalEnvironment&gt;  </div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  VariableEnvironment: &#123;  </div><div class="line">    EnvironmentRecord: &#123;  </div><div class="line">      Type: "Declarative",  </div><div class="line">      // 标识符绑定在这里  </div><div class="line">      g: undefined  </div><div class="line">    &#125;,  </div><div class="line">    outer: &lt;GlobalLexicalEnvironment&gt;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined (var 情况下) 或保持未初始化 (let、const 情况下)。所以这就是为什么可以在声明之前访问 var 定义的变量，如果在声明之前访问 let 和 const 定义的变量会提示引用错误的原因。这就是所谓的变量提升。</p><h5 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h5><p>  执行上下文的代码分为两个阶段进行处理：</p><ul><li><p>进入执行上下文</p></li><li><p>代码执行</p><h6 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h6><p>此时的变量对象包括（如下顺序初始化）：</p></li><li><p>函数所有的形参：没有实参，属性值设为 undefined。</p></li><li><p>函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li><li><p>变量声明：如果变量名称与已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">  b = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>);</div></pre></td></tr></table></figure></li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AO = &#123;</div><div class="line">    <span class="built_in">arguments</span>: &#123;</div><div class="line">        <span class="number">0</span>: <span class="number">1</span>,</div><div class="line">        length: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    b: <span class="literal">undefined</span>,</div><div class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">    d: <span class="literal">undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  形参 arguments 已经有值了，但是变量还是 undefined，只是初始化的值。</p><h6 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h6><p>  这个阶段会顺序执行代码，并修改变量的值。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AO = &#123;</div><div class="line">    <span class="built_in">arguments</span>: &#123;</div><div class="line">        <span class="number">0</span>: <span class="number">1</span>,</div><div class="line">        length: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    b: <span class="number">3</span>,</div><div class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">    d: reference to FunctionExpression <span class="string">"d"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  总结如下：</p><ul><li><p>全局上下文的变量对象初始化是全局对象。</p></li><li><p>函数上下文的变量对象初始化只包括 arguments 对象。</p></li><li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值。</p></li><li><p>在代码执行阶段，会再次修改变量对象的属性值。</p></li></ul><h2 id="深入执行上下文和执行上下文栈"><a href="#深入执行上下文和执行上下文栈" class="headerlink" title="深入执行上下文和执行上下文栈"></a>深入执行上下文和执行上下文栈</h2><p>JS 是单线程的语言，执行顺序是顺序执行，但是 JS 引擎并不是一行一行地分析和执行代码，而是一段一段地分析和执行，先进行编译然后才是执行。</p><p>有如下两段代码，执行结果是一样的，但是两段代码究竟有什么不同？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> scope;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> f();</div><div class="line">&#125;</div><div class="line">checkscope();</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> scope;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> f;</div><div class="line">&#125;</div><div class="line">checkscope()();</div></pre></td></tr></table></figure><p>答案是执行上下文栈的变化不一样。</p><p>第一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ECStack.push(<span class="xml"><span class="tag">&lt;<span class="name">checkscope</span>&gt;</span> functionContext);</span></div><div class="line">ECStack.push(&lt;f&gt; functionContext);</div><div class="line">ECStack.pop();</div><div class="line">ECStack.pop();</div></pre></td></tr></table></figure><p>第二段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ECStack.push(<span class="xml"><span class="tag">&lt;<span class="name">checkscope</span>&gt;</span> functionContext);</span></div><div class="line"><span class="xml">ECStack.pop();</span></div><div class="line">ECStack.push(&lt;f&gt; functionContext);</div><div class="line">ECStack.pop();</div></pre></td></tr></table></figure><h3 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h3><p>在函数执行上下文中，用活动对象来表示变量对象。</p><p>活动对象和变量对象的区别在于：</p><ul><li><p>变量对象是规范上或 JS 引擎上实现的，并不能在 JS 环境中直接访问。</p></li><li><p>当进入到一个执行上下文后，这个变量对象会被激活，所以叫活动对象，这时活动对象上的各种属性才能被访问。</p></li></ul><p>调用函数时，会自动为其创建一个 arguments 对象，并初始化局部变量 arguments。所有作为参数传入的值都会成为 arguments 对象的数组元素。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5bf3d20ff265da61776b95da" target="_blank" rel="external">理解JavaScript 中的执行上下文和执行栈</a></li><li><a href="https://juejin.im/post/5bf3d20ff265da61776b95da" target="_blank" rel="external">JavaScript深入之执行上下文栈和变量对象</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文栈用于存储在代码执行期间创建的所有执行上下文。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Node-NodeJS核心基础知识</title>
    <link href="http://yoursite.com/2019/06/26/Node-NodeJS%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/06/26/Node-NodeJS核心基础知识/</id>
    <published>2019-06-26T15:11:52.000Z</published>
    <updated>2019-07-07T11:26:33.333Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…</p></blockquote><a id="more"></a><h3 id="Nodejs-概述"><a href="#Nodejs-概述" class="headerlink" title="Nodejs 概述"></a>Nodejs 概述</h3><p>Nodejs 是基于 Chrome V8 引擎构建的，由事件循环分布 I/O 任务，最终工作线程会将任务放到线程池中执行，而事件循环等待执行结果就可以了。</p><ul><li><p>Nodejs 是 Javascript 的运行时环境。</p></li><li><p>Nodejs 构建在 Chrome V8 这个著名的 Javascript 引擎上。</p></li><li><p>Nodejs 每个函数都是同步的，而 I/O 操作是异步的。</p></li><li><p>Nodejs 使用 npm 作为包管理器。</p></li></ul><h3 id="Nodejs-安装"><a href="#Nodejs-安装" class="headerlink" title="Nodejs 安装"></a>Nodejs 安装</h3><p>Nodejs 支持 macOS、Linux 以及 Windows 等多个主流操作系统。</p><h4 id="3m-安装法"><a href="#3m-安装法" class="headerlink" title="3m 安装法"></a>3m 安装法</h4><ul><li><p>nvm 开源的 Nodejs 版本管理器</p></li><li><p>npm Nodejs 包管理端</p></li><li><p>nrm 解决 npm 镜像访问慢的问题。</p></li></ul><h5 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h5><h6 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h6><p>首先，在终端执行如下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -o- https:<span class="comment">//raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</span></div></pre></td></tr></table></figure><p>意思是通过 curl 命令下载 install.sh 脚本并执行。执行完成后，重新打开终端窗口，执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi ~<span class="regexp">/.zshrc</span></div></pre></td></tr></table></figure><p>把 nvm 命令的执行路径放到 ~/.zshrc 文件下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> NVM_DIR=<span class="string">"$HOME/.nvm"</span></div><div class="line">[ -s <span class="string">"$NVM_DIR/nvm.sh"</span> ] &amp;&amp; . <span class="string">"$NVM_DIR/nvm.sh"</span></div></pre></td></tr></table></figure><p>执行 source 命令，使系统环境变量生效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~<span class="regexp">/.zshrc</span></div></pre></td></tr></table></figure><p>输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nvm --version</div><div class="line"></div><div class="line"><span class="number">0.33</span><span class="number">.1</span></div></pre></td></tr></table></figure><h6 id="查看可安装的-Nodejs-版本"><a href="#查看可安装的-Nodejs-版本" class="headerlink" title="查看可安装的 Nodejs 版本"></a>查看可安装的 Nodejs 版本</h6><p>安装 Node 之前，需要了解通过 nvm 可以安装哪些版本的 Node。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm ls-remote</div></pre></td></tr></table></figure><ul><li><p>LTS 版本是指长期支持版本，推荐给大部分用户使用，一般在生产环境中使用。</p></li><li><p>Current 版本是指当前正在开发的尝鲜版本，不完全版本，需要经过一段时间的测试、开发和修复 bug 等才能变为 LTS 版本，一般供开发者学习。</p></li></ul><h6 id="安装-Node"><a href="#安装-Node" class="headerlink" title="安装 Node"></a>安装 Node</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm install <span class="number">10.15</span><span class="number">.3</span></div></pre></td></tr></table></figure><p>通过 nvm 安装的 Node 位于用户目录下，而非系统目录下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">which node</div><div class="line">/Users/wangqian/.nvm/versions/node/v10<span class="number">.15</span><span class="number">.3</span>/bin/node</div></pre></td></tr></table></figure><p>默认使用某个 Node 版本来编译代码，需要手动指定一个 default 别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nvm alias <span class="keyword">default</span> node</div><div class="line"><span class="keyword">default</span> -&gt; node (-&gt; v10<span class="number">.15</span><span class="number">.3</span>)</div></pre></td></tr></table></figure><p>此时，输入 node -v，以后在终端的任何地方使用的默认版本都会是你设置的版本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node -v</div><div class="line">v10<span class="number">.15</span><span class="number">.3</span></div></pre></td></tr></table></figure><p>如何使用 nvm 切换 Node 版本？首先安装 Node 8.x</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm install <span class="number">8</span></div></pre></td></tr></table></figure><p>切换到 8.x 版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nvm use <span class="number">8</span></div><div class="line">Now using node v8<span class="number">.16</span><span class="number">.0</span> (npm v6<span class="number">.4</span><span class="number">.1</span>)</div><div class="line">node -v</div><div class="line">v8<span class="number">.16</span><span class="number">.0</span></div></pre></td></tr></table></figure><p>如何知道本机通过 nvm 安装了哪些 Node 版本呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">nvm ls</div><div class="line">-&gt;      v8<span class="number">.16</span><span class="number">.0</span></div><div class="line">       v10<span class="number">.15</span><span class="number">.3</span></div><div class="line"><span class="keyword">default</span> -&gt; node (-&gt; v10<span class="number">.15</span><span class="number">.3</span>)</div><div class="line">node -&gt; stable (-&gt; v10<span class="number">.15</span><span class="number">.3</span>) (<span class="keyword">default</span>)</div><div class="line">stable -&gt; <span class="number">10.15</span> (-&gt; v10<span class="number">.15</span><span class="number">.3</span>) (<span class="keyword">default</span>)</div><div class="line">iojs -&gt; N/A (<span class="keyword">default</span>)</div><div class="line">lts<span class="comment">/* -&gt; lts/dubnium (-&gt; N/A)</span></div><div class="line"><span class="comment">lts/argon -&gt; v4.9.1 (-&gt; N/A)</span></div><div class="line"><span class="comment">lts/boron -&gt; v6.17.1 (-&gt; N/A)</span></div><div class="line"><span class="comment">lts/carbon -&gt; v8.16.0</span></div><div class="line"><span class="comment">lts/dubnium -&gt; v10.16.0 (-&gt; N/A)</span></div></pre></td></tr></table></figure><p>若要经常切换 Node 版本，最痛苦的莫过于全局模块需要重新安装。针对这种情况，nvm 提供了一个很贴心的一键安装全局模块的 nvm reinstall-packages命令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm reinstall-packages <span class="number">6</span></div></pre></td></tr></table></figure><p>nvm 默认远端下载地址是 <a href="https://nodejs.org/dist，如果想安装自定义的" target="_blank" rel="external">https://nodejs.org/dist，如果想安装自定义的</a> Node 版本，可以指定 nvm 的远端下载地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NVM_NODEJS_ORG_MIRROR=https:<span class="comment">//nodejs.org/download/chakracore-nightly</span></div></pre></td></tr></table></figure><p>对于一些正在测试的尝鲜版本，可以在下面的地址下载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NVM_NODEJS_ORG_MIRROR=https:<span class="comment">//nodejs.org/download/test</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>JS-this、call、apply</title>
    <link href="http://yoursite.com/2019/06/13/JS-this%E3%80%81call%E3%80%81apply/"/>
    <id>http://yoursite.com/2019/06/13/JS-this、call、apply/</id>
    <published>2019-06-13T05:00:52.000Z</published>
    <updated>2019-06-16T09:51:28.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。</p></blockquote><a id="more"></a><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>Javascript 中的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的。</p><h4 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h4><p>在具体实际应用中，this 的指向通常可分为以下4种:</p><ul><li><p>作为对象的方法调用</p></li><li><p>作为普通函数调用</p></li><li><p>作为构造器调用</p></li><li><p>Function.prototype.call、Function.prototype.apply</p></li></ul><h5 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h5><p>当函数作为对象的方法调用时，this 指向该对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">1</span>,</div><div class="line">  getA: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.getA()</div><div class="line"></div><div class="line"><span class="comment">// 1</span></div></pre></td></tr></table></figure><h5 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h5><p>函数作为普通函数调用，此时的 this 总是指向全局对象。在浏览器中，这个全局对象是 window 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()</div><div class="line"><span class="comment">// 1</span></div></pre></td></tr></table></figure><h5 id="作为构造器调用"><a href="#作为构造器调用" class="headerlink" title="作为构造器调用"></a>作为构造器调用</h5><p>当用 new 运算符调用函数时，该函数会返回一个对象。通常情况下，构造器里的 this 就指向返回的这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'sven'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass()</div><div class="line"><span class="built_in">console</span>.log(obj.name)</div><div class="line"><span class="comment">// 'sven'</span></div></pre></td></tr></table></figure><p>如果构造器显式地返回了一个对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'sven'</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    name: <span class="string">'wang'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass()</div><div class="line"><span class="built_in">console</span>.log(obj.name)</div><div class="line"><span class="comment">// wang</span></div></pre></td></tr></table></figure><p>如果构造器不显式地返回任何数据，或者返回一个非对象类型的数据，就不会造成上述问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'sven'</span></div><div class="line">  <span class="keyword">return</span> <span class="string">'wang'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = n</div><div class="line"><span class="built_in">console</span>.log(obj.name)</div><div class="line"><span class="comment">// 'sven'</span></div></pre></td></tr></table></figure><h5 id="Function-prototype-call、Function-prototype-apply"><a href="#Function-prototype-call、Function-prototype-apply" class="headerlink" title="Function.prototype.call、Function.prototype.apply"></a>Function.prototype.call、Function.prototype.apply</h5><p>用 Function.prototype.call、Function.prototype.apply 可以动态改变传入函数的 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  name: <span class="string">'wang'</span>,</div><div class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  name: <span class="string">'zhang'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">obj1.getName()</div><div class="line">obj1.getName.call(obj2)</div><div class="line"></div><div class="line"><span class="comment">// 'wang'</span></div><div class="line"><span class="comment">// 'zhang'</span></div></pre></td></tr></table></figure><hr><h4 id="丢失的-this"><a href="#丢失的-this" class="headerlink" title="丢失的 this"></a>丢失的 this</h4><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'wang'</span>,</div><div class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.getName()</div><div class="line">getName = obj.getName</div><div class="line">getName()</div><div class="line"></div><div class="line"><span class="comment">// 'wang'</span></div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>当调用 obj.getName 时，此时 this 指向 obj 对象，所以输出 ‘wang’。</p><p>当用另外一个变量 getName 来引用 obj.getName，并且调用时，它是被当作普通函数来调用，此时 this 指向 window 对象，所以输出 undefined。</p><hr><h4 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h4><p>在实际开发中，特别是在一些函数式风格的代码编写中，call 和 apply 方法尤为重要。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>call 和 apply 作用一模一样，区别在于传入参数形式的不同。</p><p>apply 接受两个参数，第一个参数指定了函数体内的 this 对象的指向，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。</p><p>call 传入的参数数量不固定，跟 apply 不同的是，第一个参数也是代表函数体内 this 对象的指向，从第二个参数开始，每个参数依此传入函数。</p><p>当使用 call 或者 apply 时，如果我们传入的第一个参数为 null，则函数体内的 this 会指向默认的宿主对象。</p><p>但如果在严格模式下，函数体内的 this 还是为 null。</p><h5 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h5><p>下面将详细介绍 call 和 apply 在实际开发中的用途。</p><h6 id="改变-this-指向"><a href="#改变-this-指向" class="headerlink" title="改变 this 指向"></a>改变 this 指向</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  name: <span class="string">'wang'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  name: <span class="string">'zhang'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> name = <span class="string">'qian'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName () <span class="comment">// 'qian'</span></div><div class="line">getName.call(obj1)  <span class="comment">// 'wang'</span></div><div class="line">getName.call(obj2) <span class="comment">// 'zhang'</span></div></pre></td></tr></table></figure><h6 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h6><p>大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向。即使没有原生的 Function.prototype.bind ，我们也可以自己来模拟：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span> <span class="comment">// 保存原函数</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回一个新的函数</span></div><div class="line">    <span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>) <span class="comment">// 执行新的函数时，会把之前传入的 context 当作新函数体内的 this</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'seven'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;.bind(obj)</div><div class="line"></div><div class="line">func()</div></pre></td></tr></table></figure><p>上述为一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一些，使得可以在 func 函数中预先填入一些参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>, <span class="comment">// 保存原函数</span></div><div class="line">      context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 需要绑定的 this 上下文</span></div><div class="line">      args = [].slice.call(<span class="built_in">arguments</span>) <span class="comment">// 剩余的参数转化为数组</span></div><div class="line">  <span class="built_in">console</span>.log(context)</div><div class="line">  <span class="built_in">console</span>.log(args)</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回一个新韩淑</span></div><div class="line">    <span class="keyword">return</span> self.apply(context, [].concat(args, [].slice.call(<span class="built_in">arguments</span>))) <span class="comment">// 执行新的函数时，把之前传入的 context 当作新函数体内的 this，并且组合两次分别传入的参数，作为新函数的参数</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'seven'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, d</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">  <span class="built_in">console</span>.log([a, b, c, d])</div><div class="line">&#125;.bind(obj, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">func(<span class="number">3</span>, <span class="number">4</span>)</div></pre></td></tr></table></figure><h6 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h6><p>借用方法的第一种场景是”借用构造函数“，通过这种技术，可以实现一些类似继承的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  A.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">B.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="string">'wang'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b.getName()) <span class="comment">// 'wang'</span></div></pre></td></tr></table></figure><p>附：</p><p>函数的参数列表 arguments 是一个类数组对象，并不是真正的数组。</p><p>如果想在 arguments 中添加一个元素，通常会借用 Array.prototype.push</p><p>如果想把 arguments 转换为真正的数组，通常会借用 Array.prototype.slice</p><p>如果想截取 arguments 中的第一个元素，通常会借用 Array.prototype.shift</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue-源码系列随读笔记之Object变化侦测</title>
    <link href="http://yoursite.com/2019/05/16/Vue-%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E9%9A%8F%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8BObject%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/05/16/Vue-源码系列随读笔记之Object变化侦测/</id>
    <published>2019-05-16T10:34:52.000Z</published>
    <updated>2019-08-17T17:08:47.848Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档</p></blockquote><a id="more"></a><h3 id="什么是变化侦测"><a href="#什么是变化侦测" class="headerlink" title="什么是变化侦测"></a>什么是变化侦测</h3><p>从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。</p><p>简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。</p><p>Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。</p><hr><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">     enumerable: <span class="literal">true</span>,</div><div class="line">     configurable: <span class="literal">true</span>,</div><div class="line">     get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> val</div><div class="line">     &#125;,</div><div class="line">     set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">           <span class="keyword">return</span> </div><div class="line">        &#125;</div><div class="line">        val = newVal</div><div class="line">     &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。</p><p>由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。</p><hr><h3 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h3><p>思考以下问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> globalObj = &#123;</div><div class="line">  text1: <span class="string">'text1'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  template:</div><div class="line">    <span class="string">`&lt;div&gt;</span></div><div class="line"><span class="string">       &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></div><div class="line"><span class="string">    &lt;div&gt;`</span>,</div><div class="line">  data: globalObj</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  template:</div><div class="line">     <span class="string">`&lt;div&gt;</span></div><div class="line"><span class="string">        &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></div><div class="line"><span class="string">     &lt;div&gt;`</span>,</div><div class="line">  data: globalObj</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？</p><p>对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。</p><p>即：在 getter 中收集依赖，在 setter 中触发依赖。</p><hr><h3 id="依赖收集到哪里（Dep）"><a href="#依赖收集到哪里（Dep）" class="headerlink" title="依赖收集到哪里（Dep）"></a>依赖收集到哪里（Dep）</h3><p> 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">constructor</span> () &#123;</div><div class="line">    <span class="keyword">this</span>.subs = [] <span class="comment">// 观察者集合</span></div><div class="line">  &#125;</div><div class="line"> <span class="comment">// 添加观察者</span></div><div class="line">  addSub (sub) &#123;</div><div class="line">    <span class="keyword">this</span>.subs.push(sub)</div><div class="line">  &#125;</div><div class="line"> <span class="comment">// 移除观察者</span></div><div class="line">  removeSub (sub) &#123;</div><div class="line">    remove(<span class="keyword">this</span>.subs, sub)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  depend () &#123; <span class="comment">// 如果存在 Dep.target，则进行依赖收集操作</span></div><div class="line">    <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">      <span class="keyword">this</span>.addSub(Dep.target)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  notify () &#123;</div><div class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice() <span class="comment">// 避免污染原来的集合</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</div><div class="line">      subs[i].update() <span class="comment">// 更新</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arr.length) &#123;</div><div class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</div><div class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>改造 defineReactive</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">     enumerable: <span class="literal">true</span>,</div><div class="line">     configurable: <span class="literal">true</span>,</div><div class="line">     get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        dep.depend()</div><div class="line">           <span class="keyword">return</span> val</div><div class="line">     &#125;,</div><div class="line">     set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">           <span class="keyword">return</span> </div><div class="line">        &#125;</div><div class="line">        val = newVal</div><div class="line">        dep.notify()</div><div class="line">     &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="什么是依赖"><a href="#什么是依赖" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。</p><p>然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。</p><p>收集谁？Watcher!</p><hr><h3 id="什么是-Watcher"><a href="#什么是-Watcher" class="headerlink" title="什么是 Watcher"></a>什么是 Watcher</h3><p>Watcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm.$watch(<span class="string">'a.b.c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。</p><p>把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">constructor</span> (</div><div class="line">    vm: Component, // 组件实例</div><div class="line">    expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作</div><div class="line">    cb: Function // 被观察者发生变化后的回调</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">this</span>.vm = vm <span class="comment">// Watcher有一个 vm 属性，表明它是属于哪个组件的</span></div><div class="line">    <span class="keyword">this</span>.cb = cb <span class="comment">// 回调</span></div><div class="line">    <span class="keyword">this</span>.getter = parsePath(expOrFn)</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get () &#123; <span class="comment">// 触发取值操作，进而触发属性的getter</span></div><div class="line">    Dep.target = <span class="keyword">this</span></div><div class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm)</div><div class="line">    Dep.target = <span class="literal">null</span></div><div class="line">    <span class="keyword">return</span> value</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  update () &#123; <span class="comment">// 更新</span></div><div class="line">    <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</div><div class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.value, oldValue)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。</p><p>在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。</p><p>只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。</p><p>依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。</p><p>不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。</p><p>parsePath函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">'.'</span>)</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></div><div class="line">      obj = obj[segments[i]]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="递归侦测所有Key"><a href="#递归侦测所有Key" class="headerlink" title="递归侦测所有Key"></a>递归侦测所有Key</h3><p>前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value</div><div class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">            <span class="keyword">this</span>.walk(value)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    walk (obj) &#123;</div><div class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">            defineReactive (obj, keys[i], obj[keys[i]])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'object'</span>) &#123;</div><div class="line">      <span class="keyword">new</span> Observer(val)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">       enumerable: <span class="literal">true</span>,</div><div class="line">       configurable: <span class="literal">true</span>,</div><div class="line">       get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          dep.depend()</div><div class="line">             <span class="keyword">return</span> val</div><div class="line">       &#125;,</div><div class="line">       set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">          <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">             <span class="keyword">return</span> </div><div class="line">          &#125;</div><div class="line">          val = newVal</div><div class="line">          dep.notify()</div><div class="line">       &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Observer 类，用于将一个正常的 object 转换成被侦测的 object。</p><p>判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。</p><p>最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。</p><p>当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。</p><p>Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。</p><p>我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。</p><p>收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。</p><p>所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。</p><p>Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。</p><p>由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。</p><p>在 Vue 中，对象新增属性或删除属性都无法被侦测到。</p><p><img src="https://screenshot.net/zh/qv9nwto" alt=""></p><p>Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。</p><p>当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。</p><p>当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。</p><p>Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JS-数据结构与算法之链表</title>
    <link href="http://yoursite.com/2019/03/25/JS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/03/25/JS-数据结构与算法之链表/</id>
    <published>2019-03-25T12:57:52.000Z</published>
    <updated>2019-03-25T12:24:33.483Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>使用列表对数据进行排序，底层储存数据的数据结构是数组。然而，数组并不总是最优选择。</p></blockquote><a id="more"></a>               <hr><h3 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h3><p>数组不总是组织数据的最佳数据结构，原因如下：在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再需要加入新的元素就会非常困难。</p><p>在数组中，添加和删除元素也很麻烦，需要将数组中的其它元素向前或向后移动，以反映数组刚刚进行了添加或删除操作。</p><p>如果你发现数组在实际使用时很慢，就可以考虑使用链表来替代它。除了对数据的随机访问，</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;使用列表对数据进行排序，底层储存数据的数据结构是数组。然而，数组并不总是最优选择。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS-数据结构与算法之队列</title>
    <link href="http://yoursite.com/2019/03/16/JS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/03/16/JS-数据结构与算法之队列/</id>
    <published>2019-03-16T12:57:52.000Z</published>
    <updated>2019-03-23T09:33:40.176Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>队列是一种列表，不同的是，队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。</p></blockquote><a id="more"></a>               <hr><h3 id="对队列的操作"><a href="#对队列的操作" class="headerlink" title="对队列的操作"></a>对队列的操作</h3><p>队列的两种主要操作是：向队列中插入新元素和删除队列中的元素。插入操作也叫做入队，删除操作也叫做出队。入队操作在队尾插入新元素，出队操作删除队头的元素。</p><p>队列的另一项重要操作是读取队头的元素，这个操作叫 peek() 。该操作返回队头元素，但不把它从队列中删除。除了读取队头元素，我们还可以用 length 属性来知道队列中存储了多少元素，用 clear() 方法来清空队列中的元素。</p><p><img src="https://www.oreilly.com/library/view/data-structures-and/9781449373931/images/dsaj_0501.png" alt=""></p><hr><h3 id="用数组实现的队列"><a href="#用数组实现的队列" class="headerlink" title="用数组实现的队列"></a>用数组实现的队列</h3><p>使用数组来实现队列看起来顺理成章。数组的 push() 方法可以在数组末尾加入元素，shift() 方法则可以删除数组的第一个元素。</p><p>push() 方法将它的参数插入数组中第一个开放的位置，该位置总在数组的末尾，即使是个空数组也是如此。</p><p>准备开始实现 Queue 类，先从构造函数开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore = []</div><div class="line">  <span class="keyword">this</span>.enqueue = enqueue</div><div class="line">  <span class="keyword">this</span>.dequeue = dequeue</div><div class="line">  <span class="keyword">this</span>.front = front</div><div class="line">  <span class="keyword">this</span>.back = back</div><div class="line">  <span class="keyword">this</span>.toString = toString</div><div class="line">  <span class="keyword">this</span>.empty = empty</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>enqueue() 方法向队尾添加一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore.push(element)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>dequeue() 方法删除队首的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.shift()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用如下的方法读取队首和队尾的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="number">0</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">back</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.dataStore.length <span class="number">-1</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>toString() 方法显示队列内的所有元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> retStr = <span class="string">''</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; i++) &#123;</div><div class="line">    retStr += <span class="keyword">this</span>.dataStore[i] + <span class="string">' '</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> retStr</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>empty() 方法判断队列是否为空</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">empty</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length === <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="使用队列：方块舞的舞伴分配问题"><a href="#使用队列：方块舞的舞伴分配问题" class="headerlink" title="使用队列：方块舞的舞伴分配问题"></a>使用队列：方块舞的舞伴分配问题</h3><p>男男女女来到舞池，他们按照自己的性别排成两队。当舞池中有地方空出来时，选两个队列中第一个人组成舞伴。他们身后的人各自向前移动一个位置，变成新的队首。当一对舞伴迈入舞池时，主持人会大声喊出他们的名字。当一队舞伴走出舞池，且两排队伍中有任意一队没人时，主持人也会把这个情况告诉大家。</p><p>为了模拟这种情况，我们把跳方块舞的男男女女的姓名储存在 dancers 变量中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dancers = <span class="string">'F Allison \n M Frank \n M Mason \n M Clayton \n F Cheryl \n M Raymond \n F Jennifer \n M Bryan \n M David \n M Danny \n F Aurora'</span></div></pre></td></tr></table></figure><p>每个舞者的信息都被存储在一个 Dancer 对象中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dancer</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.sex = sex</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面我们需要一个函数，将舞者信息读到程序中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDancers</span> (<span class="params">maleDancers, femaleDancers</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> names = dancers.split(<span class="string">'\n'</span>)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</div><div class="line">    names[i] = names[i].trim()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> dancer = names[i].split(<span class="string">' '</span>)</div><div class="line">    <span class="keyword">var</span> sex = dancer[<span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> name = dancer[<span class="number">1</span>]</div><div class="line">    <span class="keyword">if</span> (sex === <span class="string">'F'</span>) &#123;</div><div class="line">      femaleDancers.enqueue(<span class="keyword">new</span> Dancer(name, sex))</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      maleDancers.enqueue(<span class="keyword">new</span> Dancer(name, sex))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>舞者的姓名被从变量 dancers 中读入数组。然后 trim() 函数除去了每行字符串的空格。第二个循环将每行字符串按姓名和性别分成两部分存入一个数组。然后根据性别，将舞者加入不同的队列。</p><p>下一个函数将男性和女性组成舞伴，并且宣布配对结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dance</span> (<span class="params">females, males</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'the dance partners are: '</span>)</div><div class="line">  <span class="keyword">let</span> person</div><div class="line">  <span class="keyword">while</span> (!females.empty() &amp;&amp; !males.empty()) &#123;</div><div class="line">    person = females.dequeue()</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'female dancer is '</span>, person)</div><div class="line">    person = males.dequeue()</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'and male dancer is '</span>, person)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="使用队列对数据进行排序"><a href="#使用队列对数据进行排序" class="headerlink" title="使用队列对数据进行排序"></a>使用队列对数据进行排序</h3><p>队列不仅用于执行现实生活中与排队有关的操作，还可以用于对数据进行排序。对于0 ~99 的数字，我们可以基于基数排序对数据扫描两次。第一次按个位上的数字进行排序，第二次按十位上的数字进行排序。每个数字根据对应位上的数值被分在不同的盒子上。假设有以下数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">91, 46, 85, 15, 92, 35, 31, 22</div></pre></td></tr></table></figure><p>经过基数排序第一次扫描之后，数字被分配到如下的盒子里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Bin 0:</div><div class="line">Bin 1: 91, 31</div><div class="line">Bin 2: 92, 22</div><div class="line">Bin 3:</div><div class="line">Bin 4:</div><div class="line">Bin 5: 85, 15, 35</div><div class="line">Bin 6: 46</div><div class="line">Bin 7:</div><div class="line">Bin 8:</div><div class="line">Bin 9:</div></pre></td></tr></table></figure><p>根据盒子的顺序，第一次排序的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">91, 31, 92, 22, 85, 15, 35, 46</div></pre></td></tr></table></figure><p>然后根据十位上的数值再次将上述排序的结果分配到不同的盒子里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Bin 0:</div><div class="line">Bin 1: 15</div><div class="line">Bin 2: 22</div><div class="line">Bin 3: 31, 35</div><div class="line">Bin 4: 46</div><div class="line">Bin 5: </div><div class="line">Bin 6: </div><div class="line">Bin 7: </div><div class="line">Bin 8: 85</div><div class="line">Bin 9: 91, 92</div></pre></td></tr></table></figure><p>最后，将盒子中的数字取出，组成一个新的列表，该列表即为排好序的数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">15， 22， 31， 35， 46， 85， 91， 92</div></pre></td></tr></table></figure><p>使用队列代表盒子，可以实现这个算法。我们需要九个队列，每个对应一个数字，将所有队列保存在一个数组中，使用取余和除法操作决定个位和十位。算法的剩余部分将数字加入相应的队列，根据个位数值对其重新排序，然后再根据十位上的数值进行排序，结果即为排好序的数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore = []</div><div class="line">  <span class="keyword">this</span>.enqueue = enqueue</div><div class="line">  <span class="keyword">this</span>.dequeue = dequeue</div><div class="line">  <span class="keyword">this</span>.front = front</div><div class="line">  <span class="keyword">this</span>.back = back</div><div class="line">  <span class="keyword">this</span>.toString = toString</div><div class="line">  <span class="keyword">this</span>.count = count</div><div class="line">  <span class="keyword">this</span>.empty = empty</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore.push(element)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.shift()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="number">0</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">back</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.dataStore.length <span class="number">-1</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> retStr = <span class="string">''</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; i++) &#123;</div><div class="line">    retStr += <span class="keyword">this</span>.dataStore[i] + <span class="string">' '</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> retStr</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">empty</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length === <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//基数排序</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> queues = []   <span class="comment">//定义队列数组</span></div><div class="line"><span class="keyword">var</span> nums = []     <span class="comment">//定义数字数组</span></div><div class="line"></div><div class="line"><span class="comment">//选十个0~99的随机数进行排序</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</div><div class="line">    queues[i] = <span class="keyword">new</span> Queue()</div><div class="line">    nums[i] = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">101</span> )</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//排序之前</span></div><div class="line"><span class="built_in">console</span>.log( <span class="string">'before radix sort: '</span> + nums )</div><div class="line"></div><div class="line"><span class="comment">//基数排序</span></div><div class="line">distribution(nums, queues , <span class="number">10</span> , <span class="number">1</span>)</div><div class="line">collect(queues, nums)</div><div class="line">distribution(nums, queues , <span class="number">10</span> , <span class="number">10</span>)</div><div class="line">collect(queues, nums)</div><div class="line"></div><div class="line"><span class="comment">//排序之后</span></div><div class="line"><span class="built_in">console</span>.info(<span class="string">'after radix sort: '</span> + nums)</div><div class="line"></div><div class="line"><span class="comment">//根据相应的（个位和十位）数值，将数字分配到相应队列</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">distribution</span> (<span class="params">nums, queues, n, digit</span>) </span>&#123;  <span class="comment">//digit表示个位或者十位的值</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(digit == <span class="number">1</span>)&#123;</div><div class="line">            queues[nums[i] % <span class="number">10</span>].enqueue(nums[i])</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            queues[<span class="built_in">Math</span>.floor(nums[i] / <span class="number">10</span>)].enqueue(nums[i])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="built_in">console</span>.log(queues.toString())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//从队列中收集数字</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collect</span> (<span class="params">queues, nums</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> digit = <span class="number">0</span>; digit &lt; <span class="number">10</span> ; digit++ )&#123;</div><div class="line">        <span class="keyword">while</span> (!queues[digit].empty())&#123;</div><div class="line">            nums[i++] = queues[digit].dequeue()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>一般情况下，从队列中删除元素，一定是最新入队的元素，但是也有一些使用队列的应用，在删除元素时不必遵循先进先出的约定。这种应用，需要使用一个叫做优先队列的数据结构来进行模拟。</p><p>从优先队列中删除元素时，需要考虑优先权的限制。</p><p>先来定义存储队列元素的对象，然后在构建我们的优先队列系统：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Patient</span> (<span class="params">name, code</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.code = code</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>变量 code 是一个整数，表示优先级。</p><p>现在需要重新定义 dequeue() 方法，使其删除队列中拥有最高优先级的元素。我们规定，优先码的值最小，代表优先级最高。新的 dequeue() 方法遍历队列的底层存储数组，从中找出优先码值最小的元素，然后使用数组的 splice() 方法删除优先级最高的元素。新的 dequeue() 方法定义如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> entry = <span class="number">0</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i].code &lt; <span class="keyword">this</span>.dataStore[entry].code) &#123;</div><div class="line">      entry = i</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.splice(entry, <span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>优先队列的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore = []</div><div class="line">  <span class="keyword">this</span>.enqueue = enqueue</div><div class="line">  <span class="keyword">this</span>.dequeue = dequeue</div><div class="line">  <span class="keyword">this</span>.front = front</div><div class="line">  <span class="keyword">this</span>.back = back</div><div class="line">  <span class="keyword">this</span>.toString = toString</div><div class="line">  <span class="keyword">this</span>.count = count</div><div class="line">  <span class="keyword">this</span>.empty = empty</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore.push(element)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> entry = <span class="number">0</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i].code &lt; <span class="keyword">this</span>.dataStore[entry].code) &#123;</div><div class="line">      entry = i</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.splice(entry, <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="number">0</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">back</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.dataStore.length <span class="number">-1</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> retStr = <span class="string">''</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; i++) &#123;</div><div class="line">    retStr += <span class="keyword">this</span>.dataStore[i].name + <span class="string">' code:'</span> + <span class="keyword">this</span>.dataStore[i].code + <span class="string">' '</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> retStr</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">empty</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length === <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Patient</span> (<span class="params">name, code</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.code = code</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Patient(<span class="string">'smith'</span>, <span class="number">5</span>)</div><div class="line"><span class="keyword">var</span> ed = <span class="keyword">new</span> Queue()</div><div class="line">ed.enqueue(p)</div><div class="line">p = <span class="keyword">new</span> Patient(<span class="string">'Jones'</span>, <span class="number">4</span>)</div><div class="line">ed.enqueue(p)</div><div class="line">p = <span class="keyword">new</span> Patient(<span class="string">'Wang'</span>, <span class="number">6</span>)</div><div class="line">ed.enqueue(p)</div><div class="line">p = <span class="keyword">new</span> Patient(<span class="string">'Qian'</span>, <span class="number">1</span>)</div><div class="line">ed.enqueue(p)</div><div class="line">p = <span class="keyword">new</span> Patient(<span class="string">'Brown'</span>, <span class="number">1</span>)</div><div class="line">ed.enqueue(p)</div><div class="line"><span class="keyword">var</span> seen = ed.dequeue()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patient being treated: '</span> + seen[<span class="number">0</span>].name)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patients watting to be seen:'</span>)</div><div class="line"><span class="built_in">console</span>.log(ed.toString())</div><div class="line"></div><div class="line">seen = ed.dequeue()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patient being treated: '</span> + seen[<span class="number">0</span>].name)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patients watting to be seen:'</span>)</div><div class="line"><span class="built_in">console</span>.log(ed.toString())</div><div class="line"></div><div class="line">seen = ed.dequeue()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patient being treated: '</span> + seen[<span class="number">0</span>].name)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patients watting to be seen:'</span>)</div><div class="line"><span class="built_in">console</span>.log(ed.toString())</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;队列是一种列表，不同的是，队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS-数据结构与算法之栈</title>
    <link href="http://yoursite.com/2019/03/15/JS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88/"/>
    <id>http://yoursite.com/2019/03/15/JS-数据结构与算法之栈/</id>
    <published>2019-03-15T12:57:52.000Z</published>
    <updated>2019-03-18T12:55:26.303Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>栈是和列表类似的一种数据结构，它可以用来解决计算机世界里的很多问题。</p></blockquote><a id="more"></a><hr><h3 id="对栈的操作"><a href="#对栈的操作" class="headerlink" title="对栈的操作"></a>对栈的操作</h3><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈被称为一种后入先出 (LIFO，last-in-first-out) 的数据结构。</p><p>由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，必须先拿掉上面的元素。</p><p>对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用 push() 方法，出栈使用 pop() 方法。</p><p>另一个常用的操作就是预览栈顶的元素。 pop() 方法虽然可以访问到栈顶的元素，但是该方法也将栈顶元素永久性地删除了。peek() 方法则只返回栈顶元素，而不删除它。</p><p><img src="https://www.oreilly.com/library/view/data-structures-and/9781449373931/images/dsaj_0401.png" alt=""></p><p>为了记录栈顶的位置，同时也为了哪里可以加入新元素，我们使用变量 top 。当向栈内压入元素时，该变量增大。当从栈内弹出元素时，该变量减小。</p><p>push()、pop()、peek() 是栈的3个主要方法，但是栈还有其它方法和属性。clear() 清除栈内所有元素，length 属性记录栈内元素的个数，empty 属性，用以表示栈内是否有元素。</p><hr><h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><p>实现一个栈，首先是要决定存储数据的底层数据结构。这里，我们选用数组。</p><p>我们从实现以定义 Stack 类的构造函数开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore = []</div><div class="line">  <span class="keyword">this</span>.top = <span class="number">0</span></div><div class="line">  <span class="keyword">this</span>.push = push</div><div class="line">  <span class="keyword">this</span>.pop = pop</div><div class="line">  <span class="keyword">this</span>.peek = peek</div><div class="line">  <span class="keyword">this</span>.clear = clear</div><div class="line">  <span class="keyword">this</span>.length = length</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们用数组 dataStore 来保存栈内的元素，构造函数将其初始化为一个空数组。变量 top 记录栈顶位置，被构造函数初始化为 0 ，表示栈顶对应数组的起始位置 0 。如果有元素被压入栈内，该变量的值将随之变化。</p><p>push() 方法 – 当向栈内压入一个新元素时，需要将其保存在数组中变量 top 所对应的位置，然后将 top 值加 1，让其指向数组中下一个空位值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top++] = element</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里需要注意 ++ 操作符的位置，它放在 this.top 的后面，这样新入栈的元素就会被放在 top 的当前值指向的位置，然后再将 top 的值加 1 ，指向下一个位置。</p><p>pop() 方法 – 返回栈顶元素，同时将变量 top 的值减 1 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[--<span class="keyword">this</span>.top]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>peek() 方法 – 返回栈顶元素，即将变量 top 的值减 1 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">peek</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top - <span class="number">1</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果对一个空栈调用 peek() 方法，结果为 undefined 。</p><p>length() 方法 – 通过返回变量 top 值得方式来获取栈内存储了多少元素。</p><p>clear() – 将变量 top 的值设为 0 ，轻松清空一个栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.top = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="使用-Stack-类"><a href="#使用-Stack-类" class="headerlink" title="使用 Stack 类"></a>使用 Stack 类</h3><p>在开发过程中，有一些问题特别适合用栈来解决：</p><h4 id="数制间的相互转换"><a href="#数制间的相互转换" class="headerlink" title="数制间的相互转换"></a>数制间的相互转换</h4><p>可以利用栈实现一个数字从一种数制转换为另一种数制。假设想将数字 n 转换为以 b 为基数的数字，实现转换的算法如下(注：此算法只针对基数为2—9的情况)：</p><p>(1) 最高位为 n % b，将此位压入栈。<br>(2) 使用 n / b 代替 n 。<br>(3) 重复步骤 1 和 2 ，直到 n 等于 0 ，且没有余数。<br>(4) 持续将栈内元素弹出，直到栈为空，依次将这些元素排列，就得到转换后数字的字符串形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mulBase</span> (<span class="params">num, base</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Stack()</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    s.push(num % base)</div><div class="line">    num = <span class="built_in">Math</span>.floor(num /= base)</div><div class="line">  &#125; <span class="keyword">while</span> (num &gt; <span class="number">0</span>)</div><div class="line">  <span class="keyword">var</span> converted = <span class="string">''</span></div><div class="line">  <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">    converted += s.pop()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> converted</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h4><p>回文是指这样一种现象：一个单词、短语或数字，从前往后写和从后往前写都是一样的。如：单词 ‘dad’ , ‘racecar’ 就是回文。</p><p>使用栈，可以轻松判断一个字符串是否是回文。我们将拿到的字符串的每个字符从左到右的顺序压入栈。当字符串中的字符都入栈后，栈内就保存了一个反转后的字符串，最后的字符在栈顶，第一个字符在栈底。</p><p><img src="https://www.oreilly.com/library/view/data-structures-and/9781449373931/images/dsaj_0402.png" alt=""></p><p>字符串完整压入栈内后，通过持续弹出栈中的每个字母就可以得到一个新字符串，该字符串刚好与原来的字符串顺序相反。我们只需比较这两个字符串即可，如果它们相等，就是一个回文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span> (<span class="params">word</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Stack()</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> word) &#123;</div><div class="line">    s.push(i)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> rWord = <span class="string">''</span></div><div class="line">  <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">    rWord += s.pop()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> rWord == word</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="递归演示"><a href="#递归演示" class="headerlink" title="递归演示"></a>递归演示</h4><p>为了演示如何用栈实现递归，考虑一下求阶乘函数的递归定义，首先看看 5 的阶乘是怎么定义的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用栈模拟递归的过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Stack()</div><div class="line">  <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</div><div class="line">    s.push(n--)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> product = <span class="number">1</span></div><div class="line">  <span class="built_in">console</span>.log(s.length())</div><div class="line">  <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">    product *= s.pop()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> product</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;栈是和列表类似的一种数据结构，它可以用来解决计算机世界里的很多问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Node-阿里云ECS部署</title>
    <link href="http://yoursite.com/2018/11/27/Node-%E9%98%BF%E9%87%8C%E4%BA%91ECS%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/11/27/Node-阿里云ECS部署/</id>
    <published>2018-11-27T04:19:00.000Z</published>
    <updated>2019-06-04T02:56:38.236Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？</p></blockquote><a id="more"></a><p>此教程仅供新手借鉴，多少有些缺陷，有问题还望各位大佬指正。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>一个域名</li><li>阿里云ECS(实例镜像：CentOS7.4)</li><li>如果使用Windows，推荐xshell。如果是Mac，推荐iTerm2</li></ul><p>(注：因本人使用Mac，以下均已Mac为主)</p><hr><h3 id="终端连接服务器"><a href="#终端连接服务器" class="headerlink" title="终端连接服务器"></a>终端连接服务器</h3><ul><li>打开iTerm2，输入连接命令ssh username@ip公网地址，回车，输入你在购买服务器时设置的密码。</li></ul><p><img src="http://images.gitbook.cn/fb945240-f68e-11e7-b8d1-49d5de1a2fe1" alt=""></p><ul><li>密码输入正确，进入服务器。</li></ul><p><img src="http://images.gitbook.cn/8a21b2f0-f68f-11e7-b8d1-49d5de1a2fe1" alt=""></p><p>cd / 进入根目录，创建一个空目录 mkdir soft，用来放我们的安装包。</p><hr><h3 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h3><p>下载node包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz</div></pre></td></tr></table></figure><p>下载完成后，进行压缩包解压。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf v8.9.4.tar.gz</div></pre></td></tr></table></figure><p>进入解压好的目录并执行config配置命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd node-v8.9.4 &amp;&amp; ./configure</div></pre></td></tr></table></figure><p>执行编译及安装命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p>经过漫长的等待之后，一个node环境就安装好了。可以通过node -v 或者 npm -v来检查当前node/npm是否安装成功。</p><p><img src="http://images.gitbook.cn/aa87c390-f6e4-11e7-b0db-b9b8a7444865" alt=""></p><p>如果你需要升级node和npm版本，执行以下命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm i -g n</div><div class="line">n stable</div></pre></td></tr></table></figure><hr><h3 id="安装nrm和pm2"><a href="#安装nrm和pm2" class="headerlink" title="安装nrm和pm2"></a>安装nrm和pm2</h3><p>nrm是一个管理npm源的插件，方便切换国内外以及私人npm库。</p><p>pm2是node服务器的守护进程，方便管理当前服务器上的所有服务。</p><p>这里说一下cnpm，如果安装依赖包很慢或者根本没进度，输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure><p>然后使用cnpm代替npm安装。</p><p>回到我们熟悉的soft目录。</p><hr><h4 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h4><p>安装nrm。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g nrm</div></pre></td></tr></table></figure><p>常用命令：</p><ul><li>nrm add name address 添加新的源</li><li>nrm use name 切换到源</li><li>nrm ls 查看所有可用的源</li></ul><p><img src="http://images.gitbook.cn/ef923690-f6e5-11e7-b28d-519a9998aa5b" alt=""></p><hr><h4 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h4><p>安装pm2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g pm2</div></pre></td></tr></table></figure><p>常用命令：</p><ul><li>pm2 list 查看pm2守护服务</li><li>pm2 start index.js 启动一个pm2守护进程命令</li><li>pm2 restart id/name 重启一个pm2守护进程命令</li><li>pm2 delete id/name 删除一个正在使用的进程</li><li>pm2 delete all 删除所有正在使用的进程</li><li>pm2 monit 查看pm2的消耗</li></ul><p><img src="http://images.gitbook.cn/24e04d00-f6e6-11e7-b0db-b9b8a7444865" alt=""></p><hr><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>卸载已有的mysql。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rpm -qa|grep -i mysql</div><div class="line">yum remove &apos;mysql&apos;</div></pre></td></tr></table></figure><p>下载mysql源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 5.7.24</div><div class="line">wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm</div></pre></td></tr></table></figure><p>安装下载的源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh mysql57-community-release-el7-7.noarch.rpm</div></pre></td></tr></table></figure><p>下载安装mysql。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum install mysql-server</div><div class="line">yum install mysql-devel</div><div class="line">yum install mysql</div></pre></td></tr></table></figure><p>启动mysql。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysqld start</div></pre></td></tr></table></figure><p>常用命令：</p><ul><li>service mysqld status 查看mysql当前的状态</li><li>service mysqld stop 停止mysql</li><li>service mysqld restart 重启mysql</li><li>service mysqld start 启动mysql</li></ul><p>如果遇到错误：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket /var/lib/mysql/mysql.sock’，请在tmp下创建一个软连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /tmp/mysql.sock /var/lib/mysql</div></pre></td></tr></table></figure><p>打开my.cnf并修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/my.cnf</div></pre></td></tr></table></figure><p><img src="http://images.gitbook.cn/4d980cc0-f6ea-11e7-9a49-93c72a04fa82" alt=""></p><p>重启数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysqld restart</div></pre></td></tr></table></figure><p>登录(默认root是没有密码的)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root</div></pre></td></tr></table></figure><p>这时出现ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)，登录root帐号需要密码，现在我们没有设置密码，哪来的密码。</p><p>于是我们开始忘记密码的操作</p><p>第一步，在/etc/my.cnf文件中添加skip-grant-tables<br>第二步，重启mysql，service mysqld restart<br>第三步，登录mysql，mysql -u root<br>第四步，修改密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt;use mysql;</div><div class="line">mysql&gt;update mysql.user set authentication_string=password(&apos;your password&apos;) where user=&apos;root&apos;;</div><div class="line">mysql&gt;flush privileges;</div><div class="line">mysql&gt;exit;</div></pre></td></tr></table></figure><p>第五步，恢复/etc/my.cnf，将skip-grant-tables删除或者注释掉<br>第六步，重启mysql，service mysqld restart</p><p>分配用户</p><p>host指定该用户在哪个主机上可以登陆，此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录;也可以指定某台机器可以远程登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;</div><div class="line">CREATE USER &apos;test&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;;</div></pre></td></tr></table></figure><p>给创建的用户权限</p><ul><li>privileges 用户的操作权限,如SELECT，INSERT，UPDATE等.如果要授予所的权限则使用ALL</li><li>databasename 数据库名</li><li>tablename 表名,如果要授予该用户对所有数据库和表的相应操作权限则可用表示, 如.*.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos;</div></pre></td></tr></table></figure><hr><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><p>Redis是一个非常好用的数据仓库，既可以做nosql数据库，也可以做缓存数据库。</p><p>下载安装包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-4.0.6.tar.gz</div></pre></td></tr></table></figure><p>解压并进入解压之后的文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf redis-4.0.6.tar.gz &amp;&amp;cd redis-4.0.6</div></pre></td></tr></table></figure><p>编译并安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p>启动redis服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server redis.conf</div></pre></td></tr></table></figure><p><img src="http://images.gitbook.cn/9ab114d0-f82e-11e7-b753-f548c55dc4dd" alt=""></p><p>此时我们发现，不能再输入任何命令，因为redis-server已经占用了这个命令行客户端。我们需要再打开一个命令行工具并连接服务器。</p><p>使用redis客户端连接Redis服务，执行Redis文件夹下的redis-cli文件redis-cli，输入几个命令测试一下简单的set/get：</p><p><img src="http://images.gitbook.cn/c4d479e0-f82f-11e7-bec2-d1185e7bb6e2" alt=""></p><p>关掉客户端，redis服务也会停止。这时，我们就需要修改redis.conf文件，将daemonizede的值改为yes。</p><p><img src="http://images.gitbook.cn/afb6f050-f830-11e7-b753-f548c55dc4dd" alt=""></p><p>再次运行Redis的启动命令redis-server redis.conf，这次就不会占用命令行了，可以继续操作其他的，Redis服务也不会停止。</p><hr><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>nginx在转发请求，负载均衡等方面非常有用。它可以将几个不同的服务集中在一个80端口下，根据域名或者请求路径来区分。</p><p>在安装nginx之前，先要安装几个依赖插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install -y pcre pcre-devel</div><div class="line">yum install -y zlib zlib-devel</div></pre></td></tr></table></figure><p>安装openssl。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y openssl openssl-devel</div></pre></td></tr></table></figure><p>下载nginx包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://nginx.org/download/nginx-1.15.6.tar.gz</div></pre></td></tr></table></figure><p>解压并进入解压好的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf nginx-1.15.6.tar.gz &amp;&amp; cd nginx-1.15.6</div></pre></td></tr></table></figure><p>执行配置命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure</div></pre></td></tr></table></figure><p>编译并安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p>查看安装结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">whereis nginx</div></pre></td></tr></table></figure><p><img src="http://images.gitbook.cn/d892e470-f835-11e7-b753-f548c55dc4dd" alt=""></p><p>跳转到安装好的nginx目录下，进入sbin目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/nginx/sbin</div></pre></td></tr></table></figure><p>启动nginx。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./nginx</div></pre></td></tr></table></figure><p>常用命令：</p><ul><li>./nginx 启动nginx</li><li>./nginx -s stop 停止nginx</li><li>./nginx -s quit 退出nginx</li><li>./nginx -s reload 重启nginx</li></ul><hr><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>centOS上没有安装git，有需要的话，我们可以自己手动安装一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install git</div><div class="line">git --version</div></pre></td></tr></table></figure><hr><h3 id="使用pm2启动项目"><a href="#使用pm2启动项目" class="headerlink" title="使用pm2启动项目"></a>使用pm2启动项目</h3><p>在本地搭建并测试好node项目，上传到GitHub。然后git clone一下。</p><p>配置ECS安全组规则，暴露3000接口。</p><p>如果项目中使用数据库，运行之前要先建立好数据库，然后再运行项目，登录数据库执行create database dabasename;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/***</div><div class="line">cd ***</div><div class="line">cnpm i</div><div class="line">pm2 start index.js</div></pre></td></tr></table></figure><p>注：项目监听3000端口，如果顺利的话，项目已经运行起来了。<br>   可以使用pm2 list查看进程列表，使用pm2 log打印日志。</p><hr><h3 id="Linux常用操作指令列表"><a href="#Linux常用操作指令列表" class="headerlink" title="Linux常用操作指令列表"></a>Linux常用操作指令列表</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ssh username@ip</td><td>连接服务器</td></tr><tr><td>cd path</td><td>跳转到路径对应的目录下</td></tr><tr><td>rm filename</td><td>删除文件</td></tr><tr><td>rm -rf path</td><td>删除目录及目录下的所有文件</td></tr><tr><td>ls [-a]</td><td>查看当前目录下的文件和目录(-a：查看所有文件，包括隐藏文件)</td></tr><tr><td>ll</td><td>查看当前目录下的文件详情(文件权限)</td></tr><tr><td>pwd</td><td>查看当前路径的完整路径</td></tr><tr><td>which name</td><td>默认位置查找该名字</td></tr><tr><td>mkdir dirname</td><td>创建空目录</td></tr><tr><td>cat path</td><td>查看文件内容</td></tr><tr><td>cp origin target</td><td>复制一个文件到另一个地方</td></tr><tr><td>mv origin target</td><td>移动一个文件到另一个地方</td></tr><tr><td>ps -aux</td><td>显示当前进程</td></tr><tr><td>kill -9 processid</td><td>结束进程</td></tr><tr><td>tar -zxvf filename</td><td>解压文件</td></tr><tr><td>tar -zcvf filename</td><td>压缩文件</td></tr><tr><td>vi path</td><td>进入文件编辑模式</td></tr><tr><td>vi编辑文件，按下i进入编辑模式</td></tr><tr><td>vi退出文件，esc+:wq或esc+:x保存退出</td></tr><tr><td>vi退出文件，esc+:q或esc+:q!强制退出</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>JS-深拷贝与浅拷贝</title>
    <link href="http://yoursite.com/2018/10/11/JS-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/10/11/JS-深拷贝与浅拷贝/</id>
    <published>2018-10-11T10:11:52.000Z</published>
    <updated>2018-12-11T14:03:41.509Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。</p></blockquote><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123;x: 10, y: 10&#125;</div><div class="line">var b = a</div><div class="line">b.x = 100</div><div class="line">b.y = 100</div></pre></td></tr></table></figure><p>打印一下a和b的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(a) // &#123;x: 100, y: 200&#125;</div><div class="line">console.log(b) // &#123;x: 100, y: 200&#125;</div></pre></td></tr></table></figure><p>发现改变b的值，同时也改了a的值。</p><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = 10</div><div class="line">var b = a</div><div class="line">b = 20</div></pre></td></tr></table></figure><p>打印一下a和b的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(a) // 10</div><div class="line">console.log(b) // 20</div></pre></td></tr></table></figure><p>??? b的值改变并没有引起a的值改变。</p><hr><h3 id="值类型-vs-引用类型"><a href="#值类型-vs-引用类型" class="headerlink" title="值类型 vs 引用类型"></a>值类型 vs 引用类型</h3><p>在JS中，变量传递方式分为值类型和引用类型。值类型包括String，Number，Null，Boolean，Undefined。引用类型包括Object类的所有，如Date，Array，Function。</p><p>在参数传递方式上，值类型是按值传递。引用类型是按共享传递(指向同一个内存地址，两者引用同一个值，当一者改变值，另一者也改变)。</p><p>JS这样设计的原因在于：按值传递的类型，复制一份存入栈内存，这类类型一般不会占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值，保证过大的对象等不会因为不停复制内容而造成内存的浪费。</p><p>深拷贝和浅拷贝最根本的区别在于是否真正获取了一个对象的拷贝实体，而不只是引用。</p><hr><h3 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h3><h4 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;username: &apos;kobe&apos;, age: 39, sex: &#123;option1: &apos;男&apos;, option2: &apos;女&apos;&#125;&#125;</div><div class="line">let obj1 = obj</div><div class="line">obj1.sex.option1 = &apos;不男不女&apos; // 修改复制的对象会影响原对象</div></pre></td></tr></table></figure><p>打印obj1的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(obj1) // &#123;username: &apos;kobe&apos;, age: 39, sex: &#123;option1: &apos;不男不女&apos;, option2: &apos;女&apos;&#125;&#125;</div></pre></td></tr></table></figure><hr><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">  username: &apos;kobe&apos;</div><div class="line">&#125;;</div><div class="line">let obj1 = Object.assign(obj)</div><div class="line">obj1.username = &apos;wang&apos;</div></pre></td></tr></table></figure><p>打印obj的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(obj) // &#123; username: &quot;wang&quot; &#125;</div></pre></td></tr></table></figure><hr><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat"></a>Array.prototype.concat</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let arr = [1, 3, &#123;</div><div class="line">    username: &apos;kobe&apos;</div><div class="line">&#125;]</div><div class="line">let arr2=arr.concat()</div><div class="line">arr2[2].username = &apos;wang&apos;</div></pre></td></tr></table></figure><p>打印arr的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(arr) // [1, 3, &#123; username: &quot;wade&quot; &#125;]</div></pre></td></tr></table></figure><hr><h4 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice"></a>Array.prototype.slice</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let arr = [1, 3, &#123;</div><div class="line">    username: &apos;kobe&apos;</div><div class="line">&#125;]</div><div class="line">let arr2=arr.slice()</div><div class="line">arr2[2].username = &apos;wang&apos;</div></pre></td></tr></table></figure><p>打印arr的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(arr) // [1, 3, &#123; username: &quot;wade&quot; &#125;]</div></pre></td></tr></table></figure><hr><h4 id="Array-prototype-concat-vs-Array-prototype-slice"><a href="#Array-prototype-concat-vs-Array-prototype-slice" class="headerlink" title="Array.prototype.concat vs Array.prototype.slice"></a>Array.prototype.concat vs Array.prototype.slice</h4><p>关于Array的concat和slice补充说明：Array的concat和slice方法不改变原始数组，只是返回了一个浅复制原数组中的元素的一个新数组。</p><p>原数组中的元素会按照下述规则拷贝：</p><ul><li><p>如果该元素是个引用类型，slice或者concat会拷贝这个引用到新的数组里，两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新数组和原数组中的这个元素都会发生改变。</p></li><li><p>如果该元素是个值类型，slice或者concat会复制一份这些值到新数组里。在别的数组里修改这些值，并不会影响另一个数组。</p></li></ul><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let arr = [1, 3, &#123;</div><div class="line">    username: &apos;kobe&apos;</div><div class="line">&#125;];</div><div class="line">let arr3 = arr.slice();</div><div class="line">arr3[1] = 2</div><div class="line">console.log(arr, arr3)</div></pre></td></tr></table></figure><p>打印arr和arr3的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(arr, arr3)</div><div class="line">// ---result</div><div class="line">// [1, 3, &#123; username: &quot;kobe&quot; &#125;]</div><div class="line">// [1, 2, &#123; username: &quot;kobe&quot; &#125;]</div></pre></td></tr></table></figure><hr><h3 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h3><h4 id="Object-assign-1"><a href="#Object-assign-1" class="headerlink" title="Object.assign"></a>Object.assign</h4><p>Object.assign可以进行一层深度拷贝</p><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj1 = Object.assign(&#123;&#125;, obj1)</div><div class="line">obj1.age = 24</div><div class="line">console.log(obj, obj1)</div></pre></td></tr></table></figure><p>打印obj和obj1的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(obj, obj1)</div><div class="line">// ----result</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;  &#125; &#125;</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;  &#125;, age: 24 &#125;</div></pre></td></tr></table></figure><p>然而。。。。。</p><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj1 = Object.assign(&#123;&#125;, obj1)</div><div class="line">obj1.test4.age = 24</div></pre></td></tr></table></figure><p>打印obj和obj1的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(obj, obj1)</div><div class="line">// ----result</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; age: 24 &#125; &#125;</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; age: 24 &#125; &#125;</div></pre></td></tr></table></figure><hr><h4 id="JSON-parse-JSON-stringfy-obj"><a href="#JSON-parse-JSON-stringfy-obj" class="headerlink" title="JSON.parse(JSON.stringfy(obj))"></a>JSON.parse(JSON.stringfy(obj))</h4><p>说到深拷贝，你肯定会想到JSON.parse(JSON.stringfy(obj))。</p><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test: &#123;</div><div class="line">            name: &apos;test&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">var obj1 = JSON.parse(JSON.stringify(obj))</div><div class="line">obj1.test.name = 24</div></pre></td></tr></table></figure><p>打印obj和obj1的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(obj, obj1)</div><div class="line">// ----result</div><div class="line">// &#123; name: &quot;wang&quot;, test: &#123; name: &quot;test&quot; &#125; &#125;</div><div class="line">// &#123; name: &quot;wang&quot;, test: &#123; name: 24 &#125; &#125;</div></pre></td></tr></table></figure><p>然而。。。。</p><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">        test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj1 = JSON.parse(JSON.stringify(obj))</div></pre></td></tr></table></figure><p>打印obj和obj1的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(obj, obj1)</div><div class="line">// ---result</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;  &#125; &#125;</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test4: &#123;  &#125; &#125;</div></pre></td></tr></table></figure><p>???test2和test3不见了。。。。。</p><p>JSON.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个JSON字符串，不能接受函数。</p><hr><h4 id="手写递归方法"><a href="#手写递归方法" class="headerlink" title="手写递归方法"></a>手写递归方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function deepClone(obj) &#123;</div><div class="line">let result</div><div class="line">    let toString = Object.prototype.toString</div><div class="line">    if (toString.call(obj) === &apos;[Object Array]&apos;) &#123;</div><div class="line">    result = []</div><div class="line">      for (var i =0; i&lt;obj.length; i++) &#123;</div><div class="line">        result[i] = deepClone(obj[i])</div><div class="line">        &#125;</div><div class="line">    &#125; else if (toString.call(obj) === &apos;[Object Object]&apos;) &#123;</div><div class="line">    result = &#123;&#125;</div><div class="line">      for (var key in obj) &#123;</div><div class="line">        if (obj.hasOwnProperty(key)) &#123;</div><div class="line">            result[key] = deepClone(obj[key])</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    return obj</div><div class="line">    &#125;</div><div class="line">  return result</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>🌰：调用函数并打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">        test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj1 = deepClone(obj)</div><div class="line">console.log(obj, obj21)</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: Object &#123;  &#125; &#125;</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: Object &#123;  &#125; &#125;</div></pre></td></tr></table></figure><hr><h4 id="jQuery实现"><a href="#jQuery实现" class="headerlink" title="jQuery实现"></a>jQuery实现</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">        test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj2 = $.extend(true, &#123;&#125;, obj1)</div></pre></td></tr></table></figure><hr><h4 id="lodash实现"><a href="#lodash实现" class="headerlink" title="lodash实现"></a>lodash实现</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;</div><div class="line">        name: &apos;wclimb&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">        test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj2 = _.cloneDeep(obj1)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-基础使用</title>
    <link href="http://yoursite.com/2018/09/25/Webpack-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/09/25/Webpack-基础使用/</id>
    <published>2018-09-25T07:15:00.000Z</published>
    <updated>2018-12-11T14:03:41.515Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用npm或者yarn来安装webpack</p><hr><h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ npm i webpack webpack-cli -g</div><div class="line"></div><div class="line">or</div><div class="line"></div><div class="line">$ yarn -g add webpack webpack-cli</div></pre></td></tr></table></figure><p>等待安装完毕，就可以全局执行webpack命令了。注：webpack-cli在4.x版本之后不再作为webpack的依赖了，我们使用时需要单独安装。</p><hr><h4 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h4><p>在项目中，我们更推荐将webpack作为项目的开发依赖来安装使用，这样可以指定项目中使用的webpack版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ npm i webpack webpack-cli -D</div><div class="line"></div><div class="line">or</div><div class="line"></div><div class="line">$ yarn add webpack webpack-cli -D</div></pre></td></tr></table></figure><p>等待安装完毕，webpack会出现在项目的package.json文件中，我们添加一个npm scripts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;build&quot;: &quot;webpack --mode production&quot;</div><div class="line">&#125;,</div><div class="line">&quot;devDependencies&quot;: &#123;</div><div class="line">  &quot;webpack&quot;: &quot;^4.1.1&quot;,</div><div class="line">  &quot;webpack-cli&quot;: &quot;^2.0.12&quot;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>项目根目录新建./src/index.js，任意写JS代码，保存，执行npm run build或者yarn build命令，我们会发现项目根目录下新增了一个dist目录，里面存放了webpack构建好的main.js文件。</p><p>webpack4.x可以零配置就开始构建，但有时我们的项目需要更多的功能。</p><hr><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>先放一张经典图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623bfac4a1e0945?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><hr><h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><p>如上图左上角的.js，这个.js就是多个代码模块的入口，也是webpack构建的入口。webpack会读取这个文件，并从它开始解析依赖，然后进行打包。</p><p>在我们的项目中，如果是单页应用，那么可能入口只有一个。如果是多页应用，那么经常是一个页面对应一个构建入口。</p><p>用法：entry</p><hr><h5 id="单个入口语法"><a href="#单个入口语法" class="headerlink" title="单个入口语法"></a>单个入口语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 简写</div><div class="line">module.exports = &#123;</div><div class="line">  entry: &apos;./src/index&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    main: &apos;./src/index&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h5 id="多个入口语法"><a href="#多个入口语法" class="headerlink" title="多个入口语法"></a>多个入口语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    foo: &apos;./src/foo&apos;,</div><div class="line">    bar: &apos;./src/bar&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出即指webpack最终构建出来的静态文件，构建结果的文件名，路径等都是可以配置的。</p><p>用法：output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">    filename: &apos;bundle.js&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 多个入口生成不同的文件</div><div class="line">module.exports = &#123;</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">    filename: &apos;[name].js&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 路径中使用hash，每次构建都有一个不同的hash值，避免发布新版本使用浏览器缓存</div><div class="line">module.exports = &#123;</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, &apos;dist/[hash]&apos;),</div><div class="line">    filename: &apos;[name].js&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>loader，我们可以理解为一个转换器，负责把某种文件格式的内容转换成webpack可以支持打包的模块。</p><p>默认情况下，webpack会默认把所有依赖打包成JS文件，如果入口文件依赖一个.pug模块文件或者.scss样式文件，那么我们就需要相应的loader来把不同格式的文件转换为JavaScript，以便打包后在浏览器运行。</p><p>用法：module.rules</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.jsx?/, // 条件</div><div class="line">        include: [</div><div class="line">          path.resolve(__dirname, &apos;src&apos;)</div><div class="line">        ], // 条件</div><div class="line">        use: &apos;babel-loader&apos; // 规则应用结果</div><div class="line">      &#125; // 一个Object即一条规则</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>loader匹配规则中最重要的两个因素：匹配条件和匹配规则后的应用。</p><hr><h5 id="规则条件配置"><a href="#规则条件配置" class="headerlink" title="规则条件配置"></a>规则条件配置</h5><p>匹配条件通常使用请求资源文件的绝对路径来进行匹配，官方文档成为resource。</p><p>上述代码中的test和include都用于匹配resource路径，是resource.test和resource.include的简写。你也可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  rules: [</div><div class="line">      &#123;</div><div class="line">        resource: &#123; // resource 的匹配条件</div><div class="line">          test: /\.jsx?/,</div><div class="line">          include: [</div><div class="line">            path.resolve(__dirname, &apos;src&apos;),</div><div class="line">          ]</div><div class="line">        &#125;,</div><div class="line">        use: &apos;babel-loader&apos;</div><div class="line">      &#125;,</div><div class="line">      // ...</div><div class="line">    ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>webpack为loader提供了多种匹配条件的配置方式：</p><ul><li>test: … 匹配特定条件</li><li>include: … 匹配特定路径</li><li>exclude: … 排除特定路径</li><li>and: [] 必须匹配数组中的所有条件</li><li>or: [] 匹配数组中的任意一个条件</li><li>not: [] 排除匹配数组中的所有条件</li></ul><p>条件值类型：</p><ul><li>字符串：必须以提供的字符串开始（绝对路径）</li><li>正则表达式</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件</li><li>函数：返回true表示匹配</li></ul><hr><h5 id="规则应用配置"><a href="#规则应用配置" class="headerlink" title="规则应用配置"></a>规则应用配置</h5><p>匹配规则后的应用，我们可以使用use字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">rules: [</div><div class="line">  &#123;</div><div class="line">    test: /\.less/,</div><div class="line">    use: [</div><div class="line">      &apos;style-loader&apos;,</div><div class="line">      &#123;</div><div class="line">        loader: &apos;css-loader&apos;,</div><div class="line">        options: &#123;</div><div class="line">          // ...</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        loader: &apos;less-loader&apos;,</div><div class="line">        options: &#123;</div><div class="line">          // ...</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure><p>使用options可以给对应的loader传递一些配置项。</p><p>对于上述的less规则应用配置，一个less模块文件可以经过多个loader的转换处理，执行顺序为从右到左。</p><p>如果多个rule匹配了同一个模块文件，loader的应用顺序应该如何处理？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">rules: [</div><div class="line">  &#123;</div><div class="line">    test: /\.js$/,</div><div class="line">    loader: &quot;eslint-loader&quot;,</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    test: /\.js$/,</div><div class="line">    loader: &quot;babel-loader&quot;,</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure><p>eslint-loader用于检查人工编写的代码，babel-loader用于转换代码。所以，eslint-loader应该在babel-loader之前执行，那么该如何保证执行顺序？</p><p>webpack为每一个匹配规则提供了enforce字段来配置当前rule得的loader类型。pre(前置) &gt; 行内 &gt; 普通 &gt; 后置(post)。 我们要确保eslint-loader在babel-loader之前执行，只需给rule规则项添加enforce字段，并设置其值为pre。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rules: [</div><div class="line">  &#123;</div><div class="line">    enforce: &apos;pre&apos;,</div><div class="line">    test: /\.js$/,</div><div class="line">    loader: &quot;eslint-loader&quot;,</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    test: /\.js$/,</div><div class="line">    loader: &quot;babel-loader&quot;,</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure><hr><h5 id="常用rule配置项"><a href="#常用rule配置项" class="headerlink" title="常用rule配置项"></a>常用rule配置项</h5><h6 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.css$/,</div><div class="line">        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">          fallback: &apos;style-loader&apos;,</div><div class="line">          use: &apos;css-loader&apos;,</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 引入插件，配置文件名，这里同样可以使用 [hash]</div><div class="line">    new ExtractTextPlugin(&apos;[name].css&apos;),</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>css-loader：负责解析CSS代码，主要处理CSS中的依赖，🌰：@import、url()等。</li><li>style-loader：将css-loader解析的结果转变为JS代码，运行时动态插入style标签来让CSS生效。</li></ul><hr><h6 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.less/,</div><div class="line">        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">          fallback: &apos;style-loader&apos;,</div><div class="line">          use: [&apos;css-loader&apos;, &apos;less-loader&apos;],</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 引入插件，配置文件名，这里同样可以使用 [hash]</div><div class="line">    new ExtractTextPlugin(&apos;[name].css&apos;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h6 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h6><p>webpack无法处理图片格式，我们选择file-loader，它不仅可以处理图片格式，还可用于处理其它很多类型的文件。直接输出文件，将构建后的文件路径返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.(png|jpg|gif)$/,</div><div class="line">        use: &apos;file-loader&apos;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h6 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h6><p>Babel是一个让我们能够使用ES6、ES7等新标准来编写JS的编译工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.jsx?/,</div><div class="line">        loader: &apos;babel-loader&apos;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h4 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h4><p>插件是webpack的支柱功能，在于解决loader无法实现的其他事情。</p><p>用法：plugin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const UglifyPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [new UglifyPlugin()]</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h5 id="常见webpack-plugin使用"><a href="#常见webpack-plugin使用" class="headerlink" title="常见webpack plugin使用"></a>常见webpack plugin使用</h5><h6 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h6><p>webpack默认从作为入口的JS文件进行构建，但通常一个前端项目都是从一个页面(HTML)出发的。通常我们会创建一个HTML文件，使用script标签直接引入构建好的js文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure><p>然而，问题来了，如果我们的文件名或者路径变化，每次构建完成后，我们要手动去修改HTML文件中的js路径?</p><p>如果能将HTML引用路径和我们的webpack构建结果关联起来就好了。</p><p>html-webpack-plugin就可以帮我们解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm i html-webpack-plugin -D</div><div class="line"></div><div class="line">or</div><div class="line"></div><div class="line">yarn add html-webpack-plugin -D</div></pre></td></tr></table></figure><p>然后在webpack配置中，将html-webpack-plugin添加到plugins列表中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  plugins: [</div><div class="line">    new HtmlWebpackPlugin(),</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>配置好之后，构建时html-webpack-plugin会为我们创建一个HTML文件，其中会引用构建出来的JS文件。</p><p>我们还可以在html-webpack-plugin中传递我们自己写好的HTML模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  plugins: [</div><div class="line">    new HtmlWebpackPlugin(&#123;</div><div class="line">      filename: &quot;index.html&quot;,</div><div class="line">      template: &quot;assets/index.html&quot;</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h6 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h6><p>DefinePlugin是webpack的内置插件，可以通过webpack.DefinePlugin直接引用。</p><p>主要用于创建一些在编译时可以配置的全局变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  plugins: [</div><div class="line">    new webpack.DefinePlugin(&#123;</div><div class="line">      VERSION: JSON.stringfy(&apos;v1.1.0&apos;), // const VERSION = &apos;v1.1.0&apos;</div><div class="line">      TWO: &apos;1 + 1&apos;, // const TWO = 2</div><div class="line">      BROWSER_SUPPORT: true, // const BROWSER_SUPPORT = &apos;true&apos;</div><div class="line">      CONSTANTS: &#123;</div><div class="line">        APP_VERSION: JSON.stringfy(&apos;1.1.1&apos;)</div><div class="line">      &#125; // const CONSTANTS = &#123; APP_VERSION: &apos;1.1.1&apos;&#125;</div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>配置好之后，我们就可以在应用代码中，访问配置好的变量了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(VERSION)</div></pre></td></tr></table></figure><p>有关配置的值，简述一下配置规则：</p><ul><li><p>如果配置的值为字符串，那么整个字符串会被当做代码片段来执行，其结果将作为最终配置的值。</p></li><li><p>如果配置的值不是字符串，也不是对象字面量，那么该值会被转换为一个字符串。</p></li><li><p>如果配置的值是一个对象字面量，那么该对象的所有key会以同样的方式去定义。</p></li></ul><hr><h6 id="CopyWebpackPlugin"><a href="#CopyWebpackPlugin" class="headerlink" title="CopyWebpackPlugin"></a>CopyWebpackPlugin</h6><p>通常我们会把源码和资源文件放在项目的src目录下，构建完成后会有一个dist目录，我们会直接拿dist目录中的所有文件来发布。有些文件没有经过webpack处理，但是我们希望它们也能出现在dist目录下，这时，我们就可以使用CopyWebpackPlugin来处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  plugins: [</div><div class="line">    new CopyWebpackPlugin([</div><div class="line">       &#123; from: &apos;src/*.txt&apos;, to: &apos;dist/*.txt&apos; &#125; // from: 配置来源；to: 配置目标</div><div class="line">    ])</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h6 id="ExtractTextWebpackPlugin"><a href="#ExtractTextWebpackPlugin" class="headerlink" title="ExtractTextWebpackPlugin"></a>ExtractTextWebpackPlugin</h6><p>通常CSS经过相应的loader处理后，会转换为JS，和index.js一起打包。如果需要单独把CSS文件分离出来，就需要使用extract-text-webpack-plugin插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const ExtractTextWebpackPlugin = require(&apos;extract-text-webpack-plugin&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.css$/,</div><div class="line">        use: ExtractTextWebpackPlugin.extract(&#123;</div><div class="line">          fallback: &apos;style-loader&apos;,</div><div class="line">          use: &apos;css-loader&apos;</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    //  style.css 作为单独分离出来的文件名</div><div class="line">    new ExtractTextWebpackPlugin(&apos;style.css&apos;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它还可以为每一个入口创建单独分离的文件，所以，最好这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">  new ExtractTextPlugin(&apos;[name].css&apos;),</div><div class="line">]</div></pre></td></tr></table></figure><hr><h6 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h6><p>ProvidePlugin是webpack的内置插件，可以通过webpack.ProvidePlugin直接引用。</p><p>主要用于自动加载模块，不必到处import或require</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">new webpack.ProvidePlugin(&#123;</div><div class="line">  identifier: &apos;module&apos;,</div><div class="line">  // ...</div><div class="line">&#125;)</div><div class="line"></div><div class="line">or</div><div class="line"></div><div class="line">new webpack.ProvidePlugin(&#123;</div><div class="line">  identifier: [&apos;module&apos;, &apos;property&apos;], // 即引用 module 下的 property，类似 import &#123; property &#125; from &apos;module&apos;</div><div class="line">  // ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>任何时候，当identifier被当作未赋值的变量时，module就会自动被加载，并且identifier会被这个module输出的内容所赋值。</p><p>注：如果是ES的default export，那么你需要指定模块的default属性：identifier: [‘module’, ‘default’]。</p><hr><h6 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h6><p>IgnorePlugin是webpack的内置插件，可以通过webpack.IgnorePlugin直接引用。</p><p>主要用于忽略某些特定的模块，让webpack不把这些指定的模块打包进去。</p><p>配置参数：匹配引入模块路径的正则表达式，匹配模块的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  plugins: [</div><div class="line">    new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
</feed>
