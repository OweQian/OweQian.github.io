<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>W | 个人博客 | web前端</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-10T14:17:42.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wangxiaobai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Babel-如何写好.babelrc?</title>
    <link href="http://yoursite.com/2018/04/12/Babel-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD.babelrc%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/04/12/Babel-如何写好.babelrc？/</id>
    <published>2018-04-12T06:06:52.000Z</published>
    <updated>2018-06-10T14:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Babel-The compiler for writing next generation Javascript. 下一代JavaScript 语法的编译器。</p></blockquote><a id="more"></a><h2 id="什么是Babel？"><a href="#什么是Babel？" class="headerlink" title="什么是Babel？"></a>什么是Babel？</h2><p>作为前端开发，由于浏览器的版本和兼容性等问题，很多JS的新的方法都不能使用，等到可以大胆使用的时候，可能已经过去很久。Babel就因此而生，它可以让你放心使用大部分的JS的新的标准的方法，然后编译成兼容绝大多数的主流浏览器的代码。</p><p>在升级到Babel6.X版本之后，所有的插件都是可插拔的，这也意味着你安装了Babel之后，是不能工作的，需要配置对应的.babelrc文件才能发挥完整的作用。</p><hr><h2 id="预设（presets）"><a href="#预设（presets）" class="headerlink" title="预设（presets）"></a>预设（presets）</h2><p>使用时需要安装对应的插件，对应babel-preset-xxx。例如下配置，需要npm i babel-preset-es2015。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;presets&quot;: [&quot;es2015&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;presets&quot;: [&quot;env&quot;, options]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="新增选项，有以下options选择。"><a href="#新增选项，有以下options选择。" class="headerlink" title="新增选项，有以下options选择。"></a>新增选项，有以下options选择。</h4><h5 id="targets-string-number-，默认"><a href="#targets-string-number-，默认" class="headerlink" title="targets: {[string]: number}，默认{}"></a>targets: {[string]: number}，默认{}</h5><p>需要支持的环境，可选例如：chrome，edge，firefox，safari等，甚至可以指定版本，如node：6.5。也使用node：current代表使用当前的版本。</p><h5 id="browsers-array-string，默认"><a href="#browsers-array-string，默认" class="headerlink" title="browsers: array | string，默认[]"></a>browsers: array | string，默认[]</h5><p>浏览器列表，使用的是browserslist，可选例如：last 2 versions, &gt; 5%。</p><h5 id="loose-boolean，默认false"><a href="#loose-boolean，默认false" class="headerlink" title="loose: boolean，默认false"></a>loose: boolean，默认false</h5><p>是否使用宽松模式，如果设置为true，plugins里的插件如果允许，都会采用宽松模式。</p><h5 id="debug-boolean，默认false"><a href="#debug-boolean，默认false" class="headerlink" title="debug: boolean，默认false"></a>debug: boolean，默认false</h5><p>编译是否会去掉console.log。</p><h5 id="whitelist-array，默认"><a href="#whitelist-array，默认" class="headerlink" title="whitelist: array，默认[]"></a>whitelist: array，默认[]</h5><p>设置一直引入的plugins列表。<br>es2015/es2016/es2017/latest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;presets&quot;: [&quot;es2015&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h6 id="es2015"><a href="#es2015" class="headerlink" title="es2015"></a>es2015</h6><p>使用es2015，简单翻译如下，更多细节可以参看文档。</p><ul><li><p>check-es2015-constants // 检验const常量是否被重新赋值。</p></li><li><p>transform-es2015-arrow-functions // 编译箭头函数。</p></li><li><p>transform-es2015-block-scoped-functions // 函数声明在作用域内。</p></li><li><p>transform-es2015-block-scoping // 编译const和let。</p></li><li><p>transform-es2015-classes // 编译class。</p></li><li><p>transform-es2015-computed-properties // 编译计算对象属性。</p></li><li><p>transform-es2015-destructuring // 编译解构赋值。</p></li><li><p>transform-es2015-duplicate-keys // 编译对象中重复的key，其实是转换成计算对象属性。</p></li><li><p>transform-es2015-for-of // 编译for…of。</p></li><li><p>transform-es2015-function-name // 将function.name语义应用于所有的function。</p></li><li><p>transform-es2015-literals // 编译整数(8进制/16进制)和unicode。</p></li><li><p>transform-es2015-modules-commonjs // 将modules编译成commonjs。</p></li><li><p>transform-es2015-object-super // 编译super。</p></li><li><p>transform-es2015-parameters // 编译参数，包括默认参数，不定参数和解构参数。</p></li><li><p>transform-es2015-shorthand-properties // 编译属性缩写。</p></li><li><p>transform-es2015-spread // 编译展开运算符。</p></li><li><p>transform-es2015-sticky-regex // 正则添加sticky属性。</p></li><li><p>transform-es2015-template-literals // 编译模版字符串。</p></li><li><p>transform-es2015-typeof-symbol // 编译Symbol类型。</p></li><li><p>transform-es2015-unicode-regex // 正则添加unicode模式。</p></li><li><p>transform-regenerator // 编译generator函数。</p></li></ul><hr><h6 id="es2016"><a href="#es2016" class="headerlink" title="es2016"></a>es2016</h6><p>使用es2016，更多细节可以参看文档。</p><ul><li>transform-exponentiation-operator // 编译幂运算符</li></ul><hr><h6 id="es2017"><a href="#es2017" class="headerlink" title="es2017"></a>es2017</h6><p>使用es2017的相关插件，更多细节可以参看文档。</p><ul><li><p>syntax-trailing-function-commas // function最后一个参数允许使用逗号。</p></li><li><p>transform-async-to-generator // 把async函数转化成generator函数。</p></li></ul><hr><h6 id="latest"><a href="#latest" class="headerlink" title="latest"></a>latest</h6><p>latest是一个特殊的presets，包括了es2015，es2016，es2017的插件（目前为止，以后有es2018也会包括进去）。</p><hr><h6 id="react"><a href="#react" class="headerlink" title="react"></a>react</h6><p>react是一个比较特别的官方推荐的presets，大概是因为比较火吧。加入了flow，jsx等语法，具体可以看文档。</p><hr><h6 id="stage-x-stage-0-1-2-3-4"><a href="#stage-x-stage-0-1-2-3-4" class="headerlink" title="stage-x(stage-0/1/2/3/4)"></a>stage-x(stage-0/1/2/3/4)</h6><p>stage-x和上面的es2015等有些类似，但是它是按照JavaScript的提案阶段区分的，一共有5个阶段。而数字越小，阶段越靠后，存在依赖关系。也就是说stage-0是包括stage-1的，以此类推。</p><hr><h6 id="stage-4"><a href="#stage-4" class="headerlink" title="stage-4"></a>stage-4</h6><p>已完成的提案，与年度发布的release有关，包含2015年到明年正式发布的内容。例如，现在是2016年，stage-4应该是包括es2015，es2016，es2017。经过测试，babel-preset-stage-4这个npm包是不存在的，如果你单纯的需要stage-4的相关方法，需要引入es2015~es2017的presets。</p><hr><h6 id="stage-3"><a href="#stage-3" class="headerlink" title="stage-3"></a>stage-3</h6><p>除了stage-4的内容，还包括以下插件，更多细节请看文档。</p><ul><li><p>transform-object-rest-spread // 编译对象的解构赋值和不定参数。</p></li><li><p>transform-async-generator-functions // 将async generator function和for await编译为es2015的generator。</p></li></ul><hr><h6 id="stage-2"><a href="#stage-2" class="headerlink" title="stage-2"></a>stage-2</h6><p>除了stage-3的内容，还包括以下插件，更多细节请看文档。</p><ul><li>transform-class-properties // 编译静态属性(es2015)和属性初始化语法声明的属性(es2016)。</li></ul><hr><h6 id="stage-1"><a href="#stage-1" class="headerlink" title="stage-1"></a>stage-1</h6><p>除了stage-2的内容，还包括以下插件，更多细节请看文档。</p><ul><li><p>transform-class-constructor-call // 编译class中的constructor，在Babel7中会被移除。</p></li><li><p>transform-export-extensions // 编译额外的export语法，如export * as ns from “mod”。</p></li></ul><hr><h6 id="stage-0"><a href="#stage-0" class="headerlink" title="stage-0"></a>stage-0</h6><p>除了stage-1的内容，还包括以下插件，更多细节请看文档。</p><ul><li><p>transform-do-expressions // 编译do表达式。</p></li><li><p>transform-function-bind // 编译bind运算符，也就是::。</p></li></ul><hr><h2 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h2><p>其实看了上面的应该也明白了，presets，也就是一堆plugins的预设，起到方便的作用。如果你不采用presets，完全可以单独引入某个功能，比如以下的设置就会引入编译箭头函数的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p>还有一些方法是presets中不提供的，这时候就需要单独引入了，介绍几个常见的插件。</p><h3 id="transform-runtime"><a href="#transform-runtime" class="headerlink" title="transform-runtime"></a>transform-runtime</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>主要有以下options选择。</p><ul><li><p>helpers: boolean // 默认为true，使用babel的helper函数。</p></li><li><p>polyfill: boolean // 默认为true，使用babel的polyfill，但不能完全取代bebel-polyfill。</p></li><li><p>regenerator: boolean // 默认为true，使用babel的regenerator。</p></li><li><p>noduleName: string // 默认babel-runtime，使用对应module处理。</p></li></ul><p>options一般不用自己设置，使用默认的即可。这个插件的作用主要是：</p><ul><li><p>解决编译中产生的重复的工具函数，减小代码体积</p></li><li><p>非实例方法的poly-fill，如Object.assign，但是实例方法不支持，如”foobar”.includes(“foo”)，这时候需要单独引入babel-polyfill。</p></li></ul><p>更多细节参见文档。</p><hr><h3 id="transform-remove-console"><a href="#transform-remove-console" class="headerlink" title="transform-remove-console"></a>transform-remove-console</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;plugins&quot;: [&quot;transform-remove-console&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用这个插件，编译后的代码都会移除console.*，妈妈再也不用担心线上代码有多余的console.log了。当然很多时候，我们如果使用webpack，会在webpack中配置。</p><p>这也告诉我们，Babel不仅仅是编译代码的工具，还能对代码进行压缩，也许有一天，你不再需要代码压缩的插件了，因为你有了Babel！</p><hr><h2 id="自定义预设或插件"><a href="#自定义预设或插件" class="headerlink" title="自定义预设或插件"></a>自定义预设或插件</h2><p>Babel支持自定义的预设(presets)或插件(plugins)。如果你的插件在npm上，可以直接采用这种方式”plugins”: [“babel-plugin-myPlugin”]，当然，你也可以缩写，它和”plugins”: [“myPlugin”]是等价的。此外，你还可以采用本地的相对路径引入插件，比如”plugins”: [“./node_modules/asdf/plugin”]。</p><p>presets同理。</p><hr><h2 id="plugins-presets排序"><a href="#plugins-presets排序" class="headerlink" title="plugins/presets排序"></a>plugins/presets排序</h2><p>也许你会问，plugins和presets编译，也许会有相同的功能，或者有联系的功能，按照怎么的顺序进行编译？答案是会按照一定的顺序。</p><ul><li><p>具体而言，plugins优先于presets进行编译。</p></li><li><p>plugins按照数组的index增序(从数组第一个到最后一个)进行编译。</p></li><li><p>presets按照数组的index倒序(从数组最后一个到第一个)进行编译。因为作者认为大部分会把presets写成[“es2015”, “stage-0”]。具体细节可以看这个。</p></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [</div><div class="line">    [<span class="string">"env"</span>, &#123;</div><div class="line">      <span class="string">"modules"</span>: <span class="literal">false</span>,</div><div class="line">      <span class="string">"targets"</span>: &#123;</div><div class="line">        <span class="string">"browsers"</span>: [<span class="string">"&gt; 1%"</span>, <span class="string">"last 2 versions"</span>, <span class="string">"not ie &lt;= 8"</span>]</div><div class="line">      &#125;</div><div class="line">    &#125;],</div><div class="line">    <span class="string">"stage-2"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>, <span class="string">"transform-vue-jsx"</span>],</div><div class="line">  <span class="string">"comments"</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>强烈推荐使用transform-runtime。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Babel-The compiler for writing next generation Javascript. 下一代JavaScript 语法的编译器。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6---Airbnb JavaScript（ES6）代码规范</title>
    <link href="http://yoursite.com/2018/04/11/ES6---Airbnb%20JavaScript%EF%BC%88ES6%EF%BC%89%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/04/11/ES6---Airbnb JavaScript（ES6）代码规范/</id>
    <published>2018-04-11T08:06:52.000Z</published>
    <updated>2018-04-11T15:14:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本文摘自—Airbnb JavaScript（ES6）代码规范。</p></blockquote><a id="more"></a><h2 id="声明变量的新姿势"><a href="#声明变量的新姿势" class="headerlink" title="声明变量的新姿势"></a>声明变量的新姿势</h2><h3 id="用let不用var"><a href="#用let不用var" class="headerlink" title="用let不用var"></a>用let不用var</h3><p>ES6之前我们使用var声明一个变量，但是它有很多弊病：</p><ul><li>无块级作用域变量，很容易声明全局变量。</li><li>变量提升。</li><li>可重复声明。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">  a[i] = function () &#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[6](); // 10</div><div class="line">a[7](); // 10</div><div class="line">a[8](); // 10</div><div class="line">a[9](); // 10</div></pre></td></tr></table></figure><p>所以，你有什么理由不用let?</p><hr><h3 id="某些场景，const比let更好"><a href="#某些场景，const比let更好" class="headerlink" title="某些场景，const比let更好"></a>某些场景，const比let更好</h3><p>const和let的唯一区别就是，const不可以被更改，所以当声明变量的时候，尤其是在声明容易被更改的全局变量的时候，尽量使用const。</p><ul><li>更好的代码语义化，一眼看到就是常量。</li><li>另一个原因是因为JavaScript 编译器对const的优化要比let好，多使用const，有利于提高程序的运行效率。</li><li>所有的函数都应该设置为常量。</li></ul><hr><h2 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h2><p>不要使用“双引号”，一律用单引号或反引号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">const a = &quot;foobar&quot;;</div><div class="line">const b = &apos;foo&apos; + a + &apos;bar&apos;;</div><div class="line"></div><div class="line">// best</div><div class="line">const a = &apos;foobar&apos;;</div><div class="line">const b = `foo$&#123;a&#125;bar`;</div><div class="line">const c = &apos;foobar&apos;;</div></pre></td></tr></table></figure><hr><h2 id="解构赋值的骚操作"><a href="#解构赋值的骚操作" class="headerlink" title="解构赋值的骚操作"></a>解构赋值的骚操作</h2><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>在用到数组成员对变量赋值时，尽量使用解构赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const arr = [1, 2, 3, 4];</div><div class="line"></div><div class="line">// low</div><div class="line">const first = arr[0];</div><div class="line">const second = arr[1];</div><div class="line"></div><div class="line">// good</div><div class="line">const [first, second] = arr;</div></pre></td></tr></table></figure><hr><h3 id="函数传对象"><a href="#函数传对象" class="headerlink" title="函数传对象"></a>函数传对象</h3><p>函数的参数如果是对象的成员，优先使用解构赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">function getFullName(user) &#123;</div><div class="line">  const firstName = user.firstName;</div><div class="line">  const lastName = user.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">function getFullName(&#123; firstName, lastName &#125;) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">function processInput(input) &#123;</div><div class="line">  return [left, right, top, bottom];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">function processInput(input) &#123;</div><div class="line">  return &#123; left, right, top, bottom &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const &#123; left, right &#125; = processInput(input);</div></pre></td></tr></table></figure><hr><h3 id="关于对象的细节"><a href="#关于对象的细节" class="headerlink" title="关于对象的细节"></a>关于对象的细节</h3><h4 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h4><p>单行定义的对象结尾不要逗号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">const a = &#123; k1: v1, k2: v2, &#125;;</div><div class="line"></div><div class="line">// good</div><div class="line">const a = &#123; k1: v1, k2: v2 &#125;;</div></pre></td></tr></table></figure><p>多行定义的对象要保留逗号：：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">const b = &#123;</div><div class="line">  k1: v1,</div><div class="line">  k2: v2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// good</div><div class="line">const b = &#123;</div><div class="line">  k1: v1,</div><div class="line">  k2: v2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h4 id="一次性初始化完全"><a href="#一次性初始化完全" class="headerlink" title="一次性初始化完全"></a>一次性初始化完全</h4><p>不要声明之后又给对象添加新属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">const a = &#123;&#125;;</div><div class="line">a.x = 3;</div><div class="line"></div><div class="line">// good</div><div class="line">const a = &#123; x: null &#125;;</div><div class="line">a.x = 3;</div></pre></td></tr></table></figure><p>如果一定非要加请使用Object.assign：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const a = &#123;&#125;;</div><div class="line">Object.assign(a, &#123; x: 3 &#125;);</div></pre></td></tr></table></figure><p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/ low</div><div class="line">const obj = &#123;</div><div class="line">  id: 5,</div><div class="line">  name: &apos;San Francisco&apos;,</div><div class="line">&#125;;</div><div class="line">obj[getKey(&apos;enabled&apos;)] = true;</div><div class="line"></div><div class="line">// good</div><div class="line">const obj = &#123;</div><div class="line">  id: 5,</div><div class="line">  name: &apos;San Francisco&apos;,</div><div class="line">[getKey(&apos;enabled&apos;)]: true,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="在简洁一点"><a href="#在简洁一点" class="headerlink" title="在简洁一点"></a>在简洁一点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var ref = &apos;some value&apos;;</div><div class="line"></div><div class="line">// low</div><div class="line">const atom = &#123;</div><div class="line">  ref: ref,</div><div class="line"></div><div class="line">  value: 1,</div><div class="line"></div><div class="line">  addValue: function (value) &#123;</div><div class="line">    return atom.value + value;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// good</div><div class="line">const atom = &#123;</div><div class="line">  ref,</div><div class="line"></div><div class="line">  value: 1,</div><div class="line"></div><div class="line">  addValue(value) &#123;</div><div class="line">    return atom.value + value;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h3><p>使用扩展运算符（…）拷贝数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 还在用for i 你就太low了</div><div class="line">const len = items.length;</div><div class="line">const itemsCopy = [];</div><div class="line">let i;</div><div class="line"></div><div class="line">for (i = 0; i &lt; len; i++) &#123;</div><div class="line">  itemsCopy[i] = items[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// cool !</div><div class="line">const itemsCopy = [...items];</div></pre></td></tr></table></figure><hr><h3 id="Array-form（）"><a href="#Array-form（）" class="headerlink" title="Array.form（）"></a>Array.form（）</h3><p>用 Array.from 方法，将类似数组的对象转为数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const foo = document.querySelectorAll(&apos;.foo&apos;);</div><div class="line">const nodes = Array.from(foo);</div></pre></td></tr></table></figure><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="箭头函数-gt"><a href="#箭头函数-gt" class="headerlink" title="箭头函数=&gt;"></a>箭头函数=&gt;</h3><p>立即执行函数可以写成箭头函数的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(() =&gt; &#123;</div><div class="line">  console.log(&apos;Welcome to the Internet.&apos;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>尽量写箭头函数使你的代码看起来简洁优雅：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">[1, 2, 3].map(function (x) &#123;</div><div class="line">  return x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// cool !</div><div class="line">[1, 2, 3].map(x =&gt; x * x);</div></pre></td></tr></table></figure><hr><h3 id="别再用arguments（类数组）了！"><a href="#别再用arguments（类数组）了！" class="headerlink" title="别再用arguments（类数组）了！"></a>别再用arguments（类数组）了！</h3><p>使用 rest 运算符（…）代替，rest 运算符可以提供一个真正的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">function concatenateAll() &#123;</div><div class="line">  const args = Array.prototype.slice.call(arguments);</div><div class="line">  return args.join(&apos;&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">function concatenateAll(...args) &#123;</div><div class="line">  return args.join(&apos;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="传参时试试设置默认值"><a href="#传参时试试设置默认值" class="headerlink" title="传参时试试设置默认值"></a>传参时试试设置默认值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">function handleThings(opts) &#123;</div><div class="line">  opts = opts || &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">function handleThings(opts = &#123;&#125;) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="Object？Map！"><a href="#Object？Map！" class="headerlink" title="Object？Map！"></a>Object？Map！</h2><h3 id="简单的键值对优先Map"><a href="#简单的键值对优先Map" class="headerlink" title="简单的键值对优先Map"></a>简单的键值对优先Map</h3><p>如果只是简单的key: value结构，建议优先使用Map，因为Map提供方便的遍历机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let map = new Map(arr);</div><div class="line">// 遍历key值</div><div class="line">for (let key of map.keys()) &#123;</div><div class="line">  console.log(key);</div><div class="line">&#125;</div><div class="line">// 遍历value值</div><div class="line">for (let value of map.values()) &#123;</div><div class="line">  console.log(value);</div><div class="line">&#125;</div><div class="line">// 遍历key和value值</div><div class="line">for (let item of map.entries()) &#123;</div><div class="line">  console.log(item[0], item[1]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="class语法"><a href="#class语法" class="headerlink" title="class语法"></a>class语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">function Queue(contents = []) &#123;</div><div class="line">  this._queue = [...contents];</div><div class="line">&#125;</div><div class="line">Queue.prototype.pop = function() &#123;</div><div class="line">  const value = this._queue[0];</div><div class="line">  this._queue.splice(0, 1);</div><div class="line">  return value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">class Queue &#123;</div><div class="line">  constructor(contents = []) &#123;</div><div class="line">    this._queue = [...contents];</div><div class="line">  &#125;</div><div class="line">  pop() &#123;</div><div class="line">    const value = this._queue[0];</div><div class="line">    this._queue.splice(0, 1);</div><div class="line">    return value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><p>使用import取代require，因为Module是Javascript模块的标准写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">const moduleA = require(&apos;moduleA&apos;);</div><div class="line">const func1 = moduleA.func1;</div><div class="line">const func2 = moduleA.func2;</div><div class="line"></div><div class="line">// good</div><div class="line">import &#123; func1, func2 &#125; from &apos;moduleA&apos;;</div></pre></td></tr></table></figure><hr><h3 id="输出模块"><a href="#输出模块" class="headerlink" title="输出模块"></a>输出模块</h3><p>使用export输出变量，拒绝module.exports:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line"></div><div class="line">class Breadcrumbs extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;nav /&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default Breadcrumbs;</div></pre></td></tr></table></figure><ul><li>输出单个值，使用export default。</li><li>输出多个值，使用export。</li><li>export default与普通的export不要同时使用。</li></ul><hr><h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><p>模块输出一个函数，首字母应该小写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function getData() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default getData;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本文摘自—Airbnb JavaScript（ES6）代码规范。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Markdown---入门指南</title>
    <link href="http://yoursite.com/2017/10/12/markdown-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2017/10/12/markdown-入门指南/</id>
    <published>2017-10-12T08:06:52.000Z</published>
    <updated>2018-04-11T15:14:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Markdown 是一种轻量级的「标记语言」，语法十分简单，常用的标记符号不超过十个。</p></blockquote><a id="more"></a><h2 id="Markdown-语法的简要规则"><a href="#Markdown-语法的简要规则" class="headerlink" title="Markdown 语法的简要规则"></a>Markdown 语法的简要规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>在Markdown中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line"></div><div class="line">## 二级标题</div><div class="line"></div><div class="line">### 三级标题</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure><p>以此类推，总共六级标题，建议在 # 号后加空格。</p><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表分为有序列表和无序列表。在Markdown下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要与文字之间加上一个空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#### 无序列表</div><div class="line">* 1</div><div class="line">* 2</div><div class="line">* 3</div><div class="line"></div><div class="line">#### 有序列表</div><div class="line">1. 1</div><div class="line">2. 2</div><div class="line">3. 3</div></pre></td></tr></table></figure><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式</p><blockquote><p>例如这样</p></blockquote><p>只需要在文本前加入 &gt; 这种尖括号即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; 例如这样</div></pre></td></tr></table></figure><hr><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>插入链接与插入图片的语法很相似，区别在一个 ！号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">图片为： ![]()</div><div class="line">链接为： []()</div></pre></td></tr></table></figure><hr><h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体与斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*我是斜体*</div><div class="line">**我是粗体**</div></pre></td></tr></table></figure><hr><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| Table | Are | Cool |</div><div class="line">| --- | --- | --- |</div><div class="line">| col 3 is | right | $3000 |</div></pre></td></tr></table></figure><p>效果为：</p><table><thead><tr><th>Table</th><th>Are</th><th>Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td>right</td><td>$3000</td></tr></tbody></table><hr><h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>如果你是个程序猿，需要在文章里优雅的引用代码框， 在Markdown下实现也非常简单，只需要用两个`把中间的代码包裹起来即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`&lt;b&gt;Markdown&lt;/b&gt;`</div></pre></td></tr></table></figure><p>使用 tab 键即可缩进。</p><hr><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要三个 * 号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">***</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种轻量级的「标记语言」，语法十分简单，常用的标记符号不超过十个。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
