<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>W | 个人博客 | web前端</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-15T06:32:37.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wangxiaobai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）</title>
    <link href="http://yoursite.com/2018/04/12/Vue-%20%E6%89%8B%E6%91%B8%E6%89%8B%EF%BC%8C%E5%B8%A6%E4%BD%A0%E7%94%A8Vue%E6%9E%84%E5%BB%BA%E5%85%AC%E8%B7%AF%E6%94%B6%E8%B4%B9%E4%BA%91%E5%B9%B3%E5%8F%B0%20%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/12/Vue- 手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）/</id>
    <published>2018-04-12T12:06:52.000Z</published>
    <updated>2018-06-15T06:32:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>说好的总结终于来了，本篇文章主要来说说在开始写实际业务代码之前的一些准备工作，这里不会教你Webpack的基础配置，热更新原理等，有需求的请自行 Google。</p></blockquote><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ow43yt5wd.bkt.clouddn.com/%E5%85%AC%E8%B7%AF%E6%94%B6%E8%B4%B9%E4%BA%91.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>完整项目地址：<a href="http://vue.xjsf.org" target="_blank" rel="external">公路收费云平台</a></li><li>系类文章一：手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）</li><li>系类文章二：手摸手，带你用Vue构建公路收费云平台 系列二（登录权限篇）</li><li>系类文章三：手摸手，带你用Vue构建公路收费云平台 系列三（实战篇）</li><li>系类文章四：手摸手，带你用Vue构建公路收费云平台 系列四（挖坑填坑篇）</li></ul><hr><h2 id="前端技术选型"><a href="#前端技术选型" class="headerlink" title="前端技术选型"></a>前端技术选型</h2><p>在三大框架中选择了VUE，因为自己对这个框架更为熟悉，同时，VUE在国内的生态环境已经相当成熟，各类组件库，插件库都比较丰富。搭配上vue-router和vuex组成vue全家桶，在UI框架上选择了专门针对pc端的ElementUI，ajax库选择了vue-resource，css预编译使用scss，js语言使用了支持 async function 的ES7，搭配babel编译成生产环境可运行的ES5。打包工具使用webpack。</p><ul><li>前端框架： vue</li><li>路由管理： vue-router</li><li>状态管理： vuex、sessionStorage、localStorage</li><li>UI框架： ElementUI</li><li>Ajax库： vue-resource</li><li>JS语言： ES6、ES7、babel</li><li>CSS预编译语言： scss</li><li>打包工具： webpack</li><li>图表：echarts</li><li>ESLint</li><li>CSS 预处理： SASS</li></ul><hr><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ow43yt5wd.bkt.clouddn.com/%E5%85%AC%E8%B7%AF%E6%94%B6%E8%B4%B9%E4%BA%91%E7%9A%84%E5%89%AF%E6%9C%AC.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">├── build           // 构建相关  </div><div class="line">├── config           // 配置相关</div><div class="line">├── dist            // 编译后静态文件</div><div class="line">├── documents         // api ui等相关文档  </div><div class="line">├── node_modules        // 依赖相关</div><div class="line">├── src            // 源代码</div><div class="line">│  ├── api          // 所有请求</div><div class="line">│  ├── api-elk        // elk所有请求</div><div class="line">│  ├── assets         // 主题 字体等静态资源</div><div class="line">│  ├── components       // 全局公用组件</div><div class="line">│  ├── directive       // 全局指令</div><div class="line">│  ├── filtres        // 全局 filter</div><div class="line">│  ├── http          // 全局拦截器</div><div class="line">│  ├── mixin         // mixin</div><div class="line">│  ├── pages         // pages</div><div class="line">│  ├── router         // 路由</div><div class="line">│  ├── storage         // localStorage, sessionStorage</div><div class="line">│  ├── store         // 全局 store管理</div><div class="line">│  ├── styles         // 全局样式</div><div class="line">│  ├── svg          // svg</div><div class="line">│  ├── config.js       // appConfig</div><div class="line">│  ├── main.js        // 入口 加载组件 初始化等</div><div class="line">│  ├── resources.js      // api resources</div><div class="line">│  ├── utils.js        // 全局公用方法</div><div class="line">├── static           // 第三方不打包资源</div><div class="line">├── .babelrc          // babel-loader 配置</div><div class="line">├── .editorconfig       // 编辑器格式化代码配置</div><div class="line">├── .eslintrc.js        // eslint 配置项</div><div class="line">├── .gitignore         // git 忽略项</div><div class="line">├── index.html         // html模板</div><div class="line">└── package.json        // package.json</div></pre></td></tr></table></figure><hr><p>简单介绍一下src：</p><h3 id="api-和-pages"><a href="#api-和-pages" class="headerlink" title="api 和 pages"></a>api 和 pages</h3><p>随着业务的不断迭代，模块会越来越多，所以我们建议根据业务模块来划分pages和api，使之一一对应，从而方便维护。如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ow43yt5wd.bkt.clouddn.com/WechatIMG15.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ow43yt5wd.bkt.clouddn.com/WechatIMG14.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><h3 id="components"><a href="#components" class="headerlink" title="components"></a>components</h3><p>这里的components放置的都是全局公用的一些组件，如自定义卡片组件，日期选择组件等。一些页面级的组件建议还是放在各自的pages文件夹下，方便管理。如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ow43yt5wd.bkt.clouddn.com/WechatIMG18.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样写大大减少了初始页面 js 的大小并且能更好的利用游览器的缓存。</p><p>我们选择结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  path: &apos;/login&apos;,</div><div class="line">  name: &apos;login&apos;,</div><div class="line">  component: (resolve) =&gt; require([&apos;../../pages/Login.vue&apos;], resolve),</div><div class="line">  meta: &#123;</div><div class="line">    auth: false</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><p>出于某些方面的考虑，我们在项目中用到了Window.sessionStorage和Window.localStorage，在这里关于其原理及相应语法不再进行介绍，有需求的请自行 Google。</p><hr><h3 id="styles"><a href="#styles" class="headerlink" title="styles"></a>styles</h3><p>Sass(Scss)号称是世界上最成熟、稳定和强大的专业级CSS扩展语言，通过Sass(Scss)来改变前端工程师，提高效率，降低成本。在这里，我们建议将颜色、屏幕分比率常用值等这些反复使用的css属性值定义成变量，与项目其它常规样式分开，便于维护。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ow43yt5wd.bkt.clouddn.com/WechatIMG19.jpeg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><p>项目中涉及到一些小图标，我们统一采用svg图形格式。在这里推荐<a href="https://github.com/cenkai88/vue-svg-icon" target="_blank" rel="external">vue-svg-icon</a>—-一个 vue的可变彩色 svg 图标方案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;icon name=&quot;chameleon&quot; :scale=&quot;20&quot;&gt;&lt;/icon&gt;</div></pre></td></tr></table></figure><hr><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>个人建议不要为了用 vuex 而用 vuex。就拿收费云来说，它虽然比较庞大，几十个业务模块，几十种权限，但业务之间的耦合度是很低的，所以没有必要使用 vuex 来存储data，每个页面里存放自己的 data 就行。当然有些数据还是需要用 vuex 来统一管理的，如登录token，用户信息等，还是用vuex管理更加的方便，具体当然还是要结合自己的业务场景的。<br>总之还是那句话，不要为了用vuex而用vuex！</p><hr><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>这里是用vue-cli的webpack-template为基础模板构建的，如果你对这个有什么疑惑请自行Google，相关的配置介绍其他文章已经介绍地很详细了，这里将不再展开。</p><table><thead><tr><th style="text-align:left">开发环境</th><th style="text-align:left">生产环境</th></tr></thead><tbody><tr><td style="text-align:left">cors</td><td style="text-align:left">cors</td></tr><tr><td style="text-align:left">proxy</td><td style="text-align:left">nginx</td></tr></tbody></table><hr><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>当项目逐渐变大之后，文件与文件之间的直接引用关系会很复杂，这时候就需要使用alias了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">  extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</div><div class="line">  alias: &#123;</div><div class="line">    &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</div><div class="line">    &apos;@&apos;: resolve(&apos;src&apos;),</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 使用</div><div class="line">import dataPicker from &apos;@/components/base-date-picker&apos;</div></pre></td></tr></table></figure><hr><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>不管是多人合作还是个人项目，代码规范是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性，简单介绍一下我们的.eslintrc。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  root: true,</div><div class="line">  // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style</div><div class="line">  parserOptions: &#123;</div><div class="line">    parser: &apos;babel-eslint&apos;</div><div class="line">  &#125;,</div><div class="line">  extends: [</div><div class="line">    // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention</div><div class="line">    // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules.</div><div class="line">    &apos;plugin:vue/essential&apos;,</div><div class="line">    // https://github.com/standard/standard/blob/master/docs/RULES-en.md</div><div class="line">    &apos;standard&apos;</div><div class="line">  ],</div><div class="line">  env: &#123;</div><div class="line">    browser: true,</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    &apos;vue&apos;</div><div class="line">  ],</div><div class="line">  rules: &#123;</div><div class="line">    &apos;eol-last&apos;: 0,</div><div class="line">    &apos;arrow-parens&apos;: 0,</div><div class="line">    // allow debugger during development</div><div class="line">    &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? 2 : 0,</div><div class="line">    &quot;no-new&quot;: 0,</div><div class="line">    &quot;no-useless-escape&quot;: 0,</div><div class="line">    &quot;spaced-comment&quot;: [&quot;error&quot;, &quot;always&quot;, &#123; &quot;exceptions&quot;: [&quot;-&quot;] &#125;],</div><div class="line">    &quot;space-before-function-paren&quot;: 0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>在平时的开发中，交流占据了我们很大一部分时间。但如果前后端有一个好的协作方式的话能节省很多时间。我们的开发流程是前后端一起开会讨论项目，之后后端根据需求，首先定义数据格式和api，然后 mock api 生成好文档，我们前端才开始对接接口。</p><p>如果后端不肯来帮你mock数据的话，前端自己来mock也是很简单的。你可以了解下eoLinker，通过eoLinker的Mock API，随机生成虚拟数据接口，让前端在脱离后端的情况下独立进行测试，帮助你实现由文档驱动的敏捷开发。</p><hr><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>前后端交互不可避免的就会遇到跨域问题，在这里推荐两种跨域解决方案。</p><p>最推荐的常用方式就是<strong>cors</strong>全称为 Cross Origin Resource Sharing（跨域资源共享）。这玩意对应前端来说和平时发请求写法上没有任何区别，工作量基本都在后端这里。每一次请求浏览器必须先以 OPTIONS 请求方式发送一个预请求，从而获知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。推荐的原因是只要第一次配好了，之后不管有多少接口和项目复用就可以了，一劳永逸的解决了跨域问题，而且不管是开发环境还是测试环境都能方便的使用。</p><p>但总有后端觉得麻烦不想这么搞。那前端也是有解决方案的，在开发环境下可使用<strong>webpack 的 proxy，使用也是很方便的，看一下文档就会使用了。但这种方法在生成环境中是不适用的，在生产环境中需要使用Nginx反向代理</strong>。不管是 proxy 和 nginx 的原理都是一样的通过搭建一个中转服务器来转发请求规避跨域的问题。</p><hr><h3 id="封装HTTP请求"><a href="#封装HTTP请求" class="headerlink" title="封装HTTP请求"></a>封装HTTP请求</h3><p>在讨论与后端数据交互的选型中，我们选择了vue-resource，它是一个非常轻量的用于处理HTTP请求的插件，提供了两种方式来处理HTTP请求：使用Vue.http或this.$http 使用Vue.resource或this.$resource。</p><p>主要特点如下：</p><ul><li><p>体积小：压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。</p></li><li><p>支持主流的浏览器：除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。</p></li><li>支持Promise API和URI Templates**：Promise对象用于异步计算。URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。</li><li>支持拦截器：拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">import Vue from &apos;vue&apos;</div><div class="line">import &#123; HOST &#125; from &apos;../config&apos;</div><div class="line">import store from &apos;../store&apos;</div><div class="line">import router from &apos;../router&apos;</div><div class="line">import VueResource from &apos;vue-resource&apos;</div><div class="line">import &#123; Message &#125; from &apos;element-ui&apos;</div><div class="line"></div><div class="line">Vue.use(VueResource)</div><div class="line">// 设置全局 api ROOT</div><div class="line">Vue.http.options.root = HOST</div><div class="line">// request 请求拦截</div><div class="line">Vue.http.interceptors.push((request, next) =&gt; &#123;</div><div class="line">  // if logged in, add the token to the header</div><div class="line">  if (store.state.token) &#123;</div><div class="line">    // // 越权请求拦截</div><div class="line">    // if (store.state.permission) &#123;</div><div class="line">    //   let path = `$&#123;request.url&#125;`.replace(HOST, &apos;&apos;)</div><div class="line">    //   let perName = `$&#123;request.method&#125;,$&#123;path&#125;`</div><div class="line">    //   console.error(&apos;perName&apos;, perName)</div><div class="line">    //   if (store.state.permission.hasOwnProperty(perName)) &#123;</div><div class="line">    //     if (!store.state.permission[perName]) &#123;</div><div class="line">    //       this.$message(&#123;</div><div class="line">    //         message: &apos;无访问权限，请联系企业管理员&apos;,</div><div class="line">    //         type: &apos;warning&apos;</div><div class="line">    //       &#125;)</div><div class="line">    //     &#125;</div><div class="line">    //   &#125;</div><div class="line">    // &#125;</div><div class="line">    request.headers.set(&apos;Authorization&apos;, `JWT $&#123;store.state.token&#125;`)</div><div class="line">  &#125;</div><div class="line">  next()</div><div class="line">&#125;)</div><div class="line">//  response 拦截</div><div class="line">Vue.http.interceptors.push((request, next) =&gt; &#123;</div><div class="line">  next((response) =&gt; &#123;</div><div class="line">    // don&apos;t handle for login page</div><div class="line">    if (store.state.route.path === &apos;/login&apos;) &#123;</div><div class="line">      return</div><div class="line">    &#125;</div><div class="line">    if (response.status === 403) &#123;</div><div class="line">      store.commit(&apos;LOG_OUT&apos;)</div><div class="line">      router.push(&#123;path: &apos;/login&apos;, query: &#123;redirect: store.state.route.fullPath&#125;&#125;)</div><div class="line">    &#125;</div><div class="line">    if (response.status === 401</div><div class="line">    ) &#123;</div><div class="line">      store.commit(&apos;LOG_OUT&apos;)</div><div class="line">      router.push(&#123;path: &apos;/login&apos;, query: &#123;redirect: store.state.route.fullPath&#125;&#125;)</div><div class="line">    &#125;</div><div class="line">    if (response.status === 500) &#123;</div><div class="line">      Message.error(&#123;</div><div class="line">        dangerouslyUseHTMLString: true,</div><div class="line">        message: `服务器错误&lt;div&gt;$&#123;response.url&#125;&lt;/div&gt;`</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><hr><h2 id="占坑"><a href="#占坑" class="headerlink" title="占坑"></a>占坑</h2><ul><li>系类文章一：手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）</li><li>系类文章二：手摸手，带你用Vue构建公路收费云平台 系列二（登录权限篇）</li><li>系类文章三：手摸手，带你用Vue构建公路收费云平台 系列三（实战篇）</li><li>系类文章四：手摸手，带你用Vue构建公路收费云平台 系列四（挖坑填坑篇）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;说好的总结终于来了，本篇文章主要来说说在开始写实际业务代码之前的一些准备工作，这里不会教你Webpack的基础配置，热更新原理等，有需求的请自行 Google。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Babel-如何写好.babelrc?</title>
    <link href="http://yoursite.com/2018/04/12/Babel-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD.babelrc%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/04/12/Babel-如何写好.babelrc？/</id>
    <published>2018-04-12T06:06:52.000Z</published>
    <updated>2018-06-10T14:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Babel-The compiler for writing next generation Javascript. 下一代JavaScript 语法的编译器。</p></blockquote><a id="more"></a><h2 id="什么是Babel？"><a href="#什么是Babel？" class="headerlink" title="什么是Babel？"></a>什么是Babel？</h2><p>作为前端开发，由于浏览器的版本和兼容性等问题，很多JS的新的方法都不能使用，等到可以大胆使用的时候，可能已经过去很久。Babel就因此而生，它可以让你放心使用大部分的JS的新的标准的方法，然后编译成兼容绝大多数的主流浏览器的代码。</p><p>在升级到Babel6.X版本之后，所有的插件都是可插拔的，这也意味着你安装了Babel之后，是不能工作的，需要配置对应的.babelrc文件才能发挥完整的作用。</p><hr><h2 id="预设（presets）"><a href="#预设（presets）" class="headerlink" title="预设（presets）"></a>预设（presets）</h2><p>使用时需要安装对应的插件，对应babel-preset-xxx。例如下配置，需要npm i babel-preset-es2015。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;presets&quot;: [&quot;es2015&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;presets&quot;: [&quot;env&quot;, options]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="新增选项，有以下options选择。"><a href="#新增选项，有以下options选择。" class="headerlink" title="新增选项，有以下options选择。"></a>新增选项，有以下options选择。</h4><h5 id="targets-string-number-，默认"><a href="#targets-string-number-，默认" class="headerlink" title="targets: {[string]: number}，默认{}"></a>targets: {[string]: number}，默认{}</h5><p>需要支持的环境，可选例如：chrome，edge，firefox，safari等，甚至可以指定版本，如node：6.5。也使用node：current代表使用当前的版本。</p><h5 id="browsers-array-string，默认"><a href="#browsers-array-string，默认" class="headerlink" title="browsers: array | string，默认[]"></a>browsers: array | string，默认[]</h5><p>浏览器列表，使用的是browserslist，可选例如：last 2 versions, &gt; 5%。</p><h5 id="loose-boolean，默认false"><a href="#loose-boolean，默认false" class="headerlink" title="loose: boolean，默认false"></a>loose: boolean，默认false</h5><p>是否使用宽松模式，如果设置为true，plugins里的插件如果允许，都会采用宽松模式。</p><h5 id="debug-boolean，默认false"><a href="#debug-boolean，默认false" class="headerlink" title="debug: boolean，默认false"></a>debug: boolean，默认false</h5><p>编译是否会去掉console.log。</p><h5 id="whitelist-array，默认"><a href="#whitelist-array，默认" class="headerlink" title="whitelist: array，默认[]"></a>whitelist: array，默认[]</h5><p>设置一直引入的plugins列表。<br>es2015/es2016/es2017/latest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;presets&quot;: [&quot;es2015&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h6 id="es2015"><a href="#es2015" class="headerlink" title="es2015"></a>es2015</h6><p>使用es2015，简单翻译如下，更多细节可以参看文档。</p><ul><li><p>check-es2015-constants // 检验const常量是否被重新赋值。</p></li><li><p>transform-es2015-arrow-functions // 编译箭头函数。</p></li><li><p>transform-es2015-block-scoped-functions // 函数声明在作用域内。</p></li><li><p>transform-es2015-block-scoping // 编译const和let。</p></li><li><p>transform-es2015-classes // 编译class。</p></li><li><p>transform-es2015-computed-properties // 编译计算对象属性。</p></li><li><p>transform-es2015-destructuring // 编译解构赋值。</p></li><li><p>transform-es2015-duplicate-keys // 编译对象中重复的key，其实是转换成计算对象属性。</p></li><li><p>transform-es2015-for-of // 编译for…of。</p></li><li><p>transform-es2015-function-name // 将function.name语义应用于所有的function。</p></li><li><p>transform-es2015-literals // 编译整数(8进制/16进制)和unicode。</p></li><li><p>transform-es2015-modules-commonjs // 将modules编译成commonjs。</p></li><li><p>transform-es2015-object-super // 编译super。</p></li><li><p>transform-es2015-parameters // 编译参数，包括默认参数，不定参数和解构参数。</p></li><li><p>transform-es2015-shorthand-properties // 编译属性缩写。</p></li><li><p>transform-es2015-spread // 编译展开运算符。</p></li><li><p>transform-es2015-sticky-regex // 正则添加sticky属性。</p></li><li><p>transform-es2015-template-literals // 编译模版字符串。</p></li><li><p>transform-es2015-typeof-symbol // 编译Symbol类型。</p></li><li><p>transform-es2015-unicode-regex // 正则添加unicode模式。</p></li><li><p>transform-regenerator // 编译generator函数。</p></li></ul><hr><h6 id="es2016"><a href="#es2016" class="headerlink" title="es2016"></a>es2016</h6><p>使用es2016，更多细节可以参看文档。</p><ul><li>transform-exponentiation-operator // 编译幂运算符</li></ul><hr><h6 id="es2017"><a href="#es2017" class="headerlink" title="es2017"></a>es2017</h6><p>使用es2017的相关插件，更多细节可以参看文档。</p><ul><li><p>syntax-trailing-function-commas // function最后一个参数允许使用逗号。</p></li><li><p>transform-async-to-generator // 把async函数转化成generator函数。</p></li></ul><hr><h6 id="latest"><a href="#latest" class="headerlink" title="latest"></a>latest</h6><p>latest是一个特殊的presets，包括了es2015，es2016，es2017的插件（目前为止，以后有es2018也会包括进去）。</p><hr><h6 id="react"><a href="#react" class="headerlink" title="react"></a>react</h6><p>react是一个比较特别的官方推荐的presets，大概是因为比较火吧。加入了flow，jsx等语法，具体可以看文档。</p><hr><h6 id="stage-x-stage-0-1-2-3-4"><a href="#stage-x-stage-0-1-2-3-4" class="headerlink" title="stage-x(stage-0/1/2/3/4)"></a>stage-x(stage-0/1/2/3/4)</h6><p>stage-x和上面的es2015等有些类似，但是它是按照JavaScript的提案阶段区分的，一共有5个阶段。而数字越小，阶段越靠后，存在依赖关系。也就是说stage-0是包括stage-1的，以此类推。</p><hr><h6 id="stage-4"><a href="#stage-4" class="headerlink" title="stage-4"></a>stage-4</h6><p>已完成的提案，与年度发布的release有关，包含2015年到明年正式发布的内容。例如，现在是2016年，stage-4应该是包括es2015，es2016，es2017。经过测试，babel-preset-stage-4这个npm包是不存在的，如果你单纯的需要stage-4的相关方法，需要引入es2015~es2017的presets。</p><hr><h6 id="stage-3"><a href="#stage-3" class="headerlink" title="stage-3"></a>stage-3</h6><p>除了stage-4的内容，还包括以下插件，更多细节请看文档。</p><ul><li><p>transform-object-rest-spread // 编译对象的解构赋值和不定参数。</p></li><li><p>transform-async-generator-functions // 将async generator function和for await编译为es2015的generator。</p></li></ul><hr><h6 id="stage-2"><a href="#stage-2" class="headerlink" title="stage-2"></a>stage-2</h6><p>除了stage-3的内容，还包括以下插件，更多细节请看文档。</p><ul><li>transform-class-properties // 编译静态属性(es2015)和属性初始化语法声明的属性(es2016)。</li></ul><hr><h6 id="stage-1"><a href="#stage-1" class="headerlink" title="stage-1"></a>stage-1</h6><p>除了stage-2的内容，还包括以下插件，更多细节请看文档。</p><ul><li><p>transform-class-constructor-call // 编译class中的constructor，在Babel7中会被移除。</p></li><li><p>transform-export-extensions // 编译额外的export语法，如export * as ns from “mod”。</p></li></ul><hr><h6 id="stage-0"><a href="#stage-0" class="headerlink" title="stage-0"></a>stage-0</h6><p>除了stage-1的内容，还包括以下插件，更多细节请看文档。</p><ul><li><p>transform-do-expressions // 编译do表达式。</p></li><li><p>transform-function-bind // 编译bind运算符，也就是::。</p></li></ul><hr><h2 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h2><p>其实看了上面的应该也明白了，presets，也就是一堆plugins的预设，起到方便的作用。如果你不采用presets，完全可以单独引入某个功能，比如以下的设置就会引入编译箭头函数的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p>还有一些方法是presets中不提供的，这时候就需要单独引入了，介绍几个常见的插件。</p><h3 id="transform-runtime"><a href="#transform-runtime" class="headerlink" title="transform-runtime"></a>transform-runtime</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>主要有以下options选择。</p><ul><li><p>helpers: boolean // 默认为true，使用babel的helper函数。</p></li><li><p>polyfill: boolean // 默认为true，使用babel的polyfill，但不能完全取代bebel-polyfill。</p></li><li><p>regenerator: boolean // 默认为true，使用babel的regenerator。</p></li><li><p>noduleName: string // 默认babel-runtime，使用对应module处理。</p></li></ul><p>options一般不用自己设置，使用默认的即可。这个插件的作用主要是：</p><ul><li><p>解决编译中产生的重复的工具函数，减小代码体积</p></li><li><p>非实例方法的poly-fill，如Object.assign，但是实例方法不支持，如”foobar”.includes(“foo”)，这时候需要单独引入babel-polyfill。</p></li></ul><p>更多细节参见文档。</p><hr><h3 id="transform-remove-console"><a href="#transform-remove-console" class="headerlink" title="transform-remove-console"></a>transform-remove-console</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;plugins&quot;: [&quot;transform-remove-console&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用这个插件，编译后的代码都会移除console.*，妈妈再也不用担心线上代码有多余的console.log了。当然很多时候，我们如果使用webpack，会在webpack中配置。</p><p>这也告诉我们，Babel不仅仅是编译代码的工具，还能对代码进行压缩，也许有一天，你不再需要代码压缩的插件了，因为你有了Babel！</p><hr><h2 id="自定义预设或插件"><a href="#自定义预设或插件" class="headerlink" title="自定义预设或插件"></a>自定义预设或插件</h2><p>Babel支持自定义的预设(presets)或插件(plugins)。如果你的插件在npm上，可以直接采用这种方式”plugins”: [“babel-plugin-myPlugin”]，当然，你也可以缩写，它和”plugins”: [“myPlugin”]是等价的。此外，你还可以采用本地的相对路径引入插件，比如”plugins”: [“./node_modules/asdf/plugin”]。</p><p>presets同理。</p><hr><h2 id="plugins-presets排序"><a href="#plugins-presets排序" class="headerlink" title="plugins/presets排序"></a>plugins/presets排序</h2><p>也许你会问，plugins和presets编译，也许会有相同的功能，或者有联系的功能，按照怎么的顺序进行编译？答案是会按照一定的顺序。</p><ul><li><p>具体而言，plugins优先于presets进行编译。</p></li><li><p>plugins按照数组的index增序(从数组第一个到最后一个)进行编译。</p></li><li><p>presets按照数组的index倒序(从数组最后一个到第一个)进行编译。因为作者认为大部分会把presets写成[“es2015”, “stage-0”]。具体细节可以看这个。</p></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [</div><div class="line">    [<span class="string">"env"</span>, &#123;</div><div class="line">      <span class="string">"modules"</span>: <span class="literal">false</span>,</div><div class="line">      <span class="string">"targets"</span>: &#123;</div><div class="line">        <span class="string">"browsers"</span>: [<span class="string">"&gt; 1%"</span>, <span class="string">"last 2 versions"</span>, <span class="string">"not ie &lt;= 8"</span>]</div><div class="line">      &#125;</div><div class="line">    &#125;],</div><div class="line">    <span class="string">"stage-2"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>, <span class="string">"transform-vue-jsx"</span>],</div><div class="line">  <span class="string">"comments"</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>强烈推荐使用transform-runtime。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Babel-The compiler for writing next generation Javascript. 下一代JavaScript 语法的编译器。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6---Airbnb JavaScript（ES6）代码规范</title>
    <link href="http://yoursite.com/2018/04/11/ES6---Airbnb%20JavaScript%EF%BC%88ES6%EF%BC%89%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/04/11/ES6---Airbnb JavaScript（ES6）代码规范/</id>
    <published>2018-04-11T08:06:52.000Z</published>
    <updated>2018-04-11T15:14:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本文摘自—Airbnb JavaScript（ES6）代码规范。</p></blockquote><a id="more"></a><h2 id="声明变量的新姿势"><a href="#声明变量的新姿势" class="headerlink" title="声明变量的新姿势"></a>声明变量的新姿势</h2><h3 id="用let不用var"><a href="#用let不用var" class="headerlink" title="用let不用var"></a>用let不用var</h3><p>ES6之前我们使用var声明一个变量，但是它有很多弊病：</p><ul><li>无块级作用域变量，很容易声明全局变量。</li><li>变量提升。</li><li>可重复声明。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">  a[i] = function () &#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[6](); // 10</div><div class="line">a[7](); // 10</div><div class="line">a[8](); // 10</div><div class="line">a[9](); // 10</div></pre></td></tr></table></figure><p>所以，你有什么理由不用let?</p><hr><h3 id="某些场景，const比let更好"><a href="#某些场景，const比let更好" class="headerlink" title="某些场景，const比let更好"></a>某些场景，const比let更好</h3><p>const和let的唯一区别就是，const不可以被更改，所以当声明变量的时候，尤其是在声明容易被更改的全局变量的时候，尽量使用const。</p><ul><li>更好的代码语义化，一眼看到就是常量。</li><li>另一个原因是因为JavaScript 编译器对const的优化要比let好，多使用const，有利于提高程序的运行效率。</li><li>所有的函数都应该设置为常量。</li></ul><hr><h2 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h2><p>不要使用“双引号”，一律用单引号或反引号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">const a = &quot;foobar&quot;;</div><div class="line">const b = &apos;foo&apos; + a + &apos;bar&apos;;</div><div class="line"></div><div class="line">// best</div><div class="line">const a = &apos;foobar&apos;;</div><div class="line">const b = `foo$&#123;a&#125;bar`;</div><div class="line">const c = &apos;foobar&apos;;</div></pre></td></tr></table></figure><hr><h2 id="解构赋值的骚操作"><a href="#解构赋值的骚操作" class="headerlink" title="解构赋值的骚操作"></a>解构赋值的骚操作</h2><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>在用到数组成员对变量赋值时，尽量使用解构赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const arr = [1, 2, 3, 4];</div><div class="line"></div><div class="line">// low</div><div class="line">const first = arr[0];</div><div class="line">const second = arr[1];</div><div class="line"></div><div class="line">// good</div><div class="line">const [first, second] = arr;</div></pre></td></tr></table></figure><hr><h3 id="函数传对象"><a href="#函数传对象" class="headerlink" title="函数传对象"></a>函数传对象</h3><p>函数的参数如果是对象的成员，优先使用解构赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">function getFullName(user) &#123;</div><div class="line">  const firstName = user.firstName;</div><div class="line">  const lastName = user.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">function getFullName(&#123; firstName, lastName &#125;) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">function processInput(input) &#123;</div><div class="line">  return [left, right, top, bottom];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">function processInput(input) &#123;</div><div class="line">  return &#123; left, right, top, bottom &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const &#123; left, right &#125; = processInput(input);</div></pre></td></tr></table></figure><hr><h3 id="关于对象的细节"><a href="#关于对象的细节" class="headerlink" title="关于对象的细节"></a>关于对象的细节</h3><h4 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h4><p>单行定义的对象结尾不要逗号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">const a = &#123; k1: v1, k2: v2, &#125;;</div><div class="line"></div><div class="line">// good</div><div class="line">const a = &#123; k1: v1, k2: v2 &#125;;</div></pre></td></tr></table></figure><p>多行定义的对象要保留逗号：：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">const b = &#123;</div><div class="line">  k1: v1,</div><div class="line">  k2: v2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// good</div><div class="line">const b = &#123;</div><div class="line">  k1: v1,</div><div class="line">  k2: v2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h4 id="一次性初始化完全"><a href="#一次性初始化完全" class="headerlink" title="一次性初始化完全"></a>一次性初始化完全</h4><p>不要声明之后又给对象添加新属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">const a = &#123;&#125;;</div><div class="line">a.x = 3;</div><div class="line"></div><div class="line">// good</div><div class="line">const a = &#123; x: null &#125;;</div><div class="line">a.x = 3;</div></pre></td></tr></table></figure><p>如果一定非要加请使用Object.assign：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const a = &#123;&#125;;</div><div class="line">Object.assign(a, &#123; x: 3 &#125;);</div></pre></td></tr></table></figure><p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/ low</div><div class="line">const obj = &#123;</div><div class="line">  id: 5,</div><div class="line">  name: &apos;San Francisco&apos;,</div><div class="line">&#125;;</div><div class="line">obj[getKey(&apos;enabled&apos;)] = true;</div><div class="line"></div><div class="line">// good</div><div class="line">const obj = &#123;</div><div class="line">  id: 5,</div><div class="line">  name: &apos;San Francisco&apos;,</div><div class="line">[getKey(&apos;enabled&apos;)]: true,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="在简洁一点"><a href="#在简洁一点" class="headerlink" title="在简洁一点"></a>在简洁一点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var ref = &apos;some value&apos;;</div><div class="line"></div><div class="line">// low</div><div class="line">const atom = &#123;</div><div class="line">  ref: ref,</div><div class="line"></div><div class="line">  value: 1,</div><div class="line"></div><div class="line">  addValue: function (value) &#123;</div><div class="line">    return atom.value + value;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// good</div><div class="line">const atom = &#123;</div><div class="line">  ref,</div><div class="line"></div><div class="line">  value: 1,</div><div class="line"></div><div class="line">  addValue(value) &#123;</div><div class="line">    return atom.value + value;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h3><p>使用扩展运算符（…）拷贝数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 还在用for i 你就太low了</div><div class="line">const len = items.length;</div><div class="line">const itemsCopy = [];</div><div class="line">let i;</div><div class="line"></div><div class="line">for (i = 0; i &lt; len; i++) &#123;</div><div class="line">  itemsCopy[i] = items[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// cool !</div><div class="line">const itemsCopy = [...items];</div></pre></td></tr></table></figure><hr><h3 id="Array-form（）"><a href="#Array-form（）" class="headerlink" title="Array.form（）"></a>Array.form（）</h3><p>用 Array.from 方法，将类似数组的对象转为数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const foo = document.querySelectorAll(&apos;.foo&apos;);</div><div class="line">const nodes = Array.from(foo);</div></pre></td></tr></table></figure><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="箭头函数-gt"><a href="#箭头函数-gt" class="headerlink" title="箭头函数=&gt;"></a>箭头函数=&gt;</h3><p>立即执行函数可以写成箭头函数的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(() =&gt; &#123;</div><div class="line">  console.log(&apos;Welcome to the Internet.&apos;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>尽量写箭头函数使你的代码看起来简洁优雅：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">[1, 2, 3].map(function (x) &#123;</div><div class="line">  return x * x;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// cool !</div><div class="line">[1, 2, 3].map(x =&gt; x * x);</div></pre></td></tr></table></figure><hr><h3 id="别再用arguments（类数组）了！"><a href="#别再用arguments（类数组）了！" class="headerlink" title="别再用arguments（类数组）了！"></a>别再用arguments（类数组）了！</h3><p>使用 rest 运算符（…）代替，rest 运算符可以提供一个真正的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">function concatenateAll() &#123;</div><div class="line">  const args = Array.prototype.slice.call(arguments);</div><div class="line">  return args.join(&apos;&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">function concatenateAll(...args) &#123;</div><div class="line">  return args.join(&apos;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="传参时试试设置默认值"><a href="#传参时试试设置默认值" class="headerlink" title="传参时试试设置默认值"></a>传参时试试设置默认值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">function handleThings(opts) &#123;</div><div class="line">  opts = opts || &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">function handleThings(opts = &#123;&#125;) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="Object？Map！"><a href="#Object？Map！" class="headerlink" title="Object？Map！"></a>Object？Map！</h2><h3 id="简单的键值对优先Map"><a href="#简单的键值对优先Map" class="headerlink" title="简单的键值对优先Map"></a>简单的键值对优先Map</h3><p>如果只是简单的key: value结构，建议优先使用Map，因为Map提供方便的遍历机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let map = new Map(arr);</div><div class="line">// 遍历key值</div><div class="line">for (let key of map.keys()) &#123;</div><div class="line">  console.log(key);</div><div class="line">&#125;</div><div class="line">// 遍历value值</div><div class="line">for (let value of map.values()) &#123;</div><div class="line">  console.log(value);</div><div class="line">&#125;</div><div class="line">// 遍历key和value值</div><div class="line">for (let item of map.entries()) &#123;</div><div class="line">  console.log(item[0], item[1]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="class语法"><a href="#class语法" class="headerlink" title="class语法"></a>class语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// low</div><div class="line">function Queue(contents = []) &#123;</div><div class="line">  this._queue = [...contents];</div><div class="line">&#125;</div><div class="line">Queue.prototype.pop = function() &#123;</div><div class="line">  const value = this._queue[0];</div><div class="line">  this._queue.splice(0, 1);</div><div class="line">  return value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">class Queue &#123;</div><div class="line">  constructor(contents = []) &#123;</div><div class="line">    this._queue = [...contents];</div><div class="line">  &#125;</div><div class="line">  pop() &#123;</div><div class="line">    const value = this._queue[0];</div><div class="line">    this._queue.splice(0, 1);</div><div class="line">    return value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><p>使用import取代require，因为Module是Javascript模块的标准写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">const moduleA = require(&apos;moduleA&apos;);</div><div class="line">const func1 = moduleA.func1;</div><div class="line">const func2 = moduleA.func2;</div><div class="line"></div><div class="line">// good</div><div class="line">import &#123; func1, func2 &#125; from &apos;moduleA&apos;;</div></pre></td></tr></table></figure><hr><h3 id="输出模块"><a href="#输出模块" class="headerlink" title="输出模块"></a>输出模块</h3><p>使用export输出变量，拒绝module.exports:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line"></div><div class="line">class Breadcrumbs extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;nav /&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default Breadcrumbs;</div></pre></td></tr></table></figure><ul><li>输出单个值，使用export default。</li><li>输出多个值，使用export。</li><li>export default与普通的export不要同时使用。</li></ul><hr><h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><p>模块输出一个函数，首字母应该小写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function getData() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default getData;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本文摘自—Airbnb JavaScript（ES6）代码规范。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Markdown---入门指南</title>
    <link href="http://yoursite.com/2017/10/12/markdown-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2017/10/12/markdown-入门指南/</id>
    <published>2017-10-12T08:06:52.000Z</published>
    <updated>2018-04-11T15:14:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Markdown 是一种轻量级的「标记语言」，语法十分简单，常用的标记符号不超过十个。</p></blockquote><a id="more"></a><h2 id="Markdown-语法的简要规则"><a href="#Markdown-语法的简要规则" class="headerlink" title="Markdown 语法的简要规则"></a>Markdown 语法的简要规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>在Markdown中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line"></div><div class="line">## 二级标题</div><div class="line"></div><div class="line">### 三级标题</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure><p>以此类推，总共六级标题，建议在 # 号后加空格。</p><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表分为有序列表和无序列表。在Markdown下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要与文字之间加上一个空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#### 无序列表</div><div class="line">* 1</div><div class="line">* 2</div><div class="line">* 3</div><div class="line"></div><div class="line">#### 有序列表</div><div class="line">1. 1</div><div class="line">2. 2</div><div class="line">3. 3</div></pre></td></tr></table></figure><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式</p><blockquote><p>例如这样</p></blockquote><p>只需要在文本前加入 &gt; 这种尖括号即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; 例如这样</div></pre></td></tr></table></figure><hr><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>插入链接与插入图片的语法很相似，区别在一个 ！号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">图片为： ![]()</div><div class="line">链接为： []()</div></pre></td></tr></table></figure><hr><h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体与斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*我是斜体*</div><div class="line">**我是粗体**</div></pre></td></tr></table></figure><hr><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| Table | Are | Cool |</div><div class="line">| --- | --- | --- |</div><div class="line">| col 3 is | right | $3000 |</div></pre></td></tr></table></figure><p>效果为：</p><table><thead><tr><th>Table</th><th>Are</th><th>Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td>right</td><td>$3000</td></tr></tbody></table><hr><h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>如果你是个程序猿，需要在文章里优雅的引用代码框， 在Markdown下实现也非常简单，只需要用两个`把中间的代码包裹起来即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`&lt;b&gt;Markdown&lt;/b&gt;`</div></pre></td></tr></table></figure><p>使用 tab 键即可缩进。</p><hr><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要三个 * 号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">***</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种轻量级的「标记语言」，语法十分简单，常用的标记符号不超过十个。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
