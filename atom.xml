<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>W | 个人博客 | web前端</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-07T04:00:14.591Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wangxiaobai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webpack-Webpack系列之资源输入输出</title>
    <link href="http://yoursite.com/2020/01/14/Webpack-Webpack%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B5%84%E6%BA%90%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://yoursite.com/2020/01/14/Webpack-Webpack系列之资源输入输出/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-07T04:00:14.591Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="资源输入输出"><a href="#资源输入输出" class="headerlink" title="资源输入输出"></a>资源输入输出</h1><h2 id="资源处理流程"><a href="#资源处理流程" class="headerlink" title="资源处理流程"></a>资源处理流程</h2><p>在一切流程的最开始，我们需要指定一个或多个入口（entry），也就是告诉Webpack具体从源码目录下的哪个文件开始打包。如果把工程中各个模块的依赖关系当作一棵树，那么入口就是这棵依赖树的根，这些存在依赖关系的模块会在打包时被封装为一个chunk。</p><p>chunk字面的意思是代码块，在Webpack中可以理解成被抽象和包装过后的一些模块。它就像一个装着很多文件的文件袋，里面的文件就是各个模块，Webpack在外面加了一层包裹，从而形成了chunk。根据具体配置不同，一个工程打包时可能会产生一个或多个chunk。</p><p>Webpack会从入口文件开始检索，并将具有依赖关系的模块生成一棵依赖树，最终得到一个chunk。由这个chunk得到的打包产物我们一般称之为bundle。</p><h2 id="配置资源入口"><a href="#配置资源入口" class="headerlink" title="配置资源入口"></a>配置资源入口</h2><p>通过context和entry这两个配置项来共同决定入口文件的路径。在配置入口时，实际上做了两件事：</p><ul><li><p>确定入口模块位置，告诉Webpack从哪里开始进行打包。</p></li><li><p>定义chunk name。如果工程只有一个入口，那么默认其chunk name为“main”；如果工程有多个入口，我们需要为每个入口定义chunk name，来作为该chunk的唯一标识。</p></li></ul><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>context可以理解为资源入口的路径前缀，在配置时要求必须使用绝对路径的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    context: path.join(__dirname, <span class="string">'./src/script'</span>),</div><div class="line">    entry: <span class="string">'./index.js'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>配置context的主要目的是让entry的编写更加简洁，尤其是在多入口的情况下。context可以省略，默认值为当前工程的根目录。</p><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>entry的配置可以有多种形式：字符串、数组、对象、函数。可以根据不同的需求场景来选择。</p><ul><li>字符串类型入口</li></ul><p>直接传入文件路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./src/index'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>数组类型入口</li></ul><p>传入一个数组的作用是将多个资源预先合并，在打包时Webpack会将数组中的最后一个元素作为实际的入口路径。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: [<span class="string">'babel-polyfill'</span>, <span class="string">'./src/index'</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>对象类型入口</li></ul><p>如果想要定义多入口，则必须使用对象的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    foo: <span class="string">'./src/foo'</span>,</div><div class="line">    bar: <span class="string">'./src/bar'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>函数类型入口</li></ul><p>用函数定义入口时，只要返回上面介绍的任何配置形式即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</div><div class="line">                    foo: <span class="string">'./src/foo'</span>,</div><div class="line">                    bar: <span class="string">'./src/bar'</span></div><div class="line">                  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>所有与出口相关的配置都集中在output对象里。</p><h4 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h4><p>filename的作用是控制输出资源的文件名。</p><ul><li>字符串形式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在多入口的场景中，我们需要为对应产生的每个bundle指定不同的名字，Webpack支持使用一种类似模板语言的形式动态地生成文件名。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 多个入口生成不同的文件</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    filename: <span class="string">'[name].js'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>路径中使用hash，每次构建都有一个不同的hash值，避免发布新版本使用浏览器缓存。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist/[hash]'</span>),</div><div class="line">    filename: <span class="string">'[name].js'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>path可以指定资源输出的位置，要求值必须为绝对路径。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><p>publicPath是一个非常重要的配置项，并且容易与path相混淆。从功能上来说，path用来指定资源的输出位置，而publicPath则用来指定资源的请求位置。让我们详细解释这两个定义。</p><ul><li><p>输出位置：打包完成后资源产生的目录，一般将其指定为工程中的dist目录。</p></li><li><p>请求位置：由JS或CSS所请求的间接资源路径。页面中的资源分为两种，一种是由HTML页面直接请求的，比如通过script标签加载的JS；另一种是由JS或CSS请求的，如异步加载的JS、从CSS请求的图片字体等。publicPath的作用就是指定这部分间接资源的请求位置。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之预处理器</title>
    <link href="http://yoursite.com/2020/01/14/Webpack-Webpack%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A0%B7%E5%BC%8F%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/14/Webpack-Webpack系列之样式处理/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-07T13:50:51.364Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h1><h2 id="分离样式文件"><a href="#分离样式文件" class="headerlink" title="分离样式文件"></a>分离样式文件</h2><p>Webpack社区有专门的插件：extract-text-webpack-plugin（适用于Webpack 4之前版本）和mini-css-extract-plugin（适用于Webpack 4及以上版本），它们就是专门用于提取样式到CSS文件的。</p><h3 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i extract-text-webpack-plugin</div></pre></td></tr></table></figure><p>在 webpack.config.js 中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.css$/</span>,</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">            fallback: <span class="string">'style-loader'</span>,</div><div class="line">            use: <span class="string">'css-loader'</span></div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    ]&#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'bundle.css'</span>)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>内部的fallback属性用于指定当插件无法提取样式时所采用的loader。</p><p>use（extract方法里面的）用于指定在提取样式之前采用哪些loader来预先进行处理。</p><p>除此之外，还要在Webpack的plugins配置中添加该插件，并传入提取后的资源文件名。</p><h3 id="多样式文件处理"><a href="#多样式文件处理" class="headerlink" title="多样式文件处理"></a>多样式文件处理</h3><p>上面我们将bundle.css作为文件名传给了extract-text-webpack-plugin，但当工程有多个入口时就会发生重名问题。就像在前面的章节中我们配置动态的output.filename一样，这里我们也要对插件提取的CSS文件使用类似模板的命名方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.css$/</span>,</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">            fallback: <span class="string">'style-loader'</span>,</div><div class="line">            use: <span class="string">'css-loader'</span></div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    ]&#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].css'</span>)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>说到mini-css-extract-plugin的特性，最重要的就是它支持按需加载CSS，以前在使用extract-text-webpack-plugin的时候我们是做不到这一点的。</p><p>举个例子，a.js通过import()函数异步加载了b.js，b.js里面加载了style.css，那么style.css最终只能被同步加载（通过HTML的link标签）。但是现在mini-css-extract-plugin会单独打包出一个0.css（假设使用默认配置），这个CSS文件将由a.js通过动态插入link标签的方式加载。</p><p>在配置上mini-css-extract-plugin与extract-text-webpack-plugin有以下几点不同：</p><ul><li><p>loader规则设置的形式不同，并且mini-css-extract-plugin支持配置publicPath，用来指定异步CSS的加载路径。</p></li><li><p>不需要设置fallback。</p></li><li><p>在plugins设置中，除了指定同步加载的CSS资源名（filename），还要指定异步加载的CSS资源名（chunkFilename）</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.css$/</span>,</div><div class="line">        use: [</div><div class="line">            &#123;</div><div class="line">                loader: MiniCssExtractPlugin.loader,</div><div class="line">                options: &#123;</div><div class="line">                    publicPath: <span class="string">'../'</span></div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            <span class="string">'css-loader'</span></div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    ]&#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</div><div class="line">    filename: <span class="string">'[name].css'</span>,</div><div class="line">    chunkFilename: <span class="string">'[id].css'</span></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="样式预处理"><a href="#样式预处理" class="headerlink" title="样式预处理"></a>样式预处理</h2><p>样式预处理指的是在开发中我们经常会使用一些样式预编译语言，如SCSS、Less等，在项目打包过程中再将这些预编译语言转换为CSS。</p><h3 id="Sass-与-Scss"><a href="#Sass-与-Scss" class="headerlink" title="Sass 与 Scss"></a>Sass 与 Scss</h3><p>sass-loader就是将SCSS语法编译为CSS，因此在使用时通常还要搭配css-loader和style-loader。类似于我们装babel-loader时还要安装babel-core，loader本身只是编译核心库与Webpack的连接器，因此这里我们除了sass-loader以外还要安装node-sass，node-sass是真正用来编译SCSS的，而sass-loader只是起到黏合的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i sass-loader node-sass</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.scss$/,</div><div class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;]</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i less-loader less</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.less/,</div><div class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;]</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="PostCss"><a href="#PostCss" class="headerlink" title="PostCss"></a>PostCss</h2><p>PostCSS并不能算是一个CSS的预编译器，它只是一个编译插件的容器。它的工作模式是接收样式源代码并交由编译插件处理，最后输出CSS。</p><h3 id="PostCss-与-Webpack"><a href="#PostCss-与-Webpack" class="headerlink" title="PostCss 与 Webpack"></a>PostCss 与 Webpack</h3><p>使用postcss-loader可以轻松地将PostCSS与Webpack连接起来。使用npm进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i postcss-loader</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.css/,</div><div class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos;]</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>postcss-loader可以结合css-loader使用，也可以单独使用，也就是说不配置css-loader也可以达到相同的效果。唯一不同的是，单独使用postcss-loader时不建议使用CSS中的@import语句，否则会产生冗余代码。</p><p>除此之外，PostCSS要求必须有一个单独的配置文件。我们需要在项目的根目录下创建一个postcss.config.js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="自动前缀"><a href="#自动前缀" class="headerlink" title="自动前缀"></a>自动前缀</h3><p>Autoprefixer是一个样式工具，可以根据caniuse.com上的数据，自动决定是否要为某一特性添加厂商前缀，并且可以由开发者为其指定支持浏览器的范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i autoprefixer</div></pre></td></tr></table></figure><p>在postcss.config.js中添加autoprefixer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const autoprefixer = require(&apos;autoprefixer&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  plugins: [</div><div class="line">    autoprefixer(&#123;</div><div class="line">      grid: true,</div><div class="line">      browsers: [</div><div class="line">        &apos;&gt; 1%&apos;,</div><div class="line">        &apos;last 3 versions&apos;,</div><div class="line">        &apos;android 4.2&apos;,</div><div class="line">        &apos;ie 8&apos;</div><div class="line">      ]</div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="stylelint"><a href="#stylelint" class="headerlink" title="stylelint"></a>stylelint</h3><p>stylelint是一个CSS的质量检测工具，就像eslint一样，我们可以为其添加各种规则，来统一项目的代码风格，确保代码质量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i stylelint</div></pre></td></tr></table></figure><p>在postcss.config.js中添加相应配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const autoprefixer = require(&apos;autoprefixer&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  plugins: [</div><div class="line">    stylelint(&#123;</div><div class="line">      config: &#123;</div><div class="line">        rules: &#123;</div><div class="line">          &apos;declaration-no-important&apos;: true</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里我们添加了declaration-no-important这样一条规则，当我们的代码中出现了“！important”时就会给出警告。</p><p>使用stylelint可以检测出代码中的样式问题（语法错误、重复的属性等），帮助我们写出更加安全并且风格更加一致的代码。</p><h3 id="CssNext"><a href="#CssNext" class="headerlink" title="CssNext"></a>CssNext</h3><p>PostCSS可以与CSSNext结合使用，让我们在应用中使用最新的CSS语法特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i postcss-cssnext</div></pre></td></tr></table></figure><p>在postcss.config.js中添加相应配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const postcssCssnext = require(&apos;postcss-cssnext&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  plugins: [</div><div class="line">    postcssCssnext(&#123;</div><div class="line">      browsers: [</div><div class="line">        &apos;&gt; 1%&apos;,</div><div class="line">        &apos;last 2 versions&apos;,</div><div class="line">      ]</div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>指定好需要支持的浏览器之后，我们就可以顺畅地使用CSSNext的特性了。</p><h2 id="Css-Modules"><a href="#Css-Modules" class="headerlink" title="Css Modules"></a>Css Modules</h2><p>CSS Modules是近年来比较流行的一种开发模式，其理念就是把CSS模块化，让CSS也拥有模块的特点:</p><ul><li><p>每个CSS文件中的样式都拥有单独的作用域，不会和外界发生命名冲突。</p></li><li><p>对CSS进行依赖管理，可以通过相对路径引入CSS文件。</p></li><li><p>可以通过composes轻松复用其他CSS模块</p></li></ul><p>使用CSS Modules不需要额外安装模块，只要开启css-loader中的modules配置项即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.css$/</span>,</div><div class="line">        use: [</div><div class="line">        <span class="string">'style-loader'</span>,</div><div class="line">        &#123;</div><div class="line">           loader: <span class="string">'css-loader'</span>,</div><div class="line">           options: &#123;</div><div class="line">                 modules: <span class="literal">true</span>,</div><div class="line">                 localIdentName: <span class="string">'[name]__[local]__[hash:base64:5]'</span></div><div class="line">              &#125;</div><div class="line">           &#125;</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    ]&#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里比较值得一提的是localIdentName配置项，它用于指明CSS代码中的类名会如何来编译。</p><p>例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* style.css */</span></div><div class="line"></div><div class="line"><span class="selector-class">.title</span> &#123;</div><div class="line"><span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>经过编译后可能将成为.style<strong>title</strong>1CFy6。</p><ul><li><p>[name]指代的是模块名，这里被替换为style。</p></li><li><p>[local]指代的是原本的选择器标识符，这里被替换为title。</p></li><li><p>[hash：base64：5]指代的是一个5位的hash值，这个hash值是根据模块名和标识符计算的，因此不同模块中相同的标识符也不会造成样式冲突。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之预处理器</title>
    <link href="http://yoursite.com/2020/01/14/Webpack-Webpack%E7%B3%BB%E5%88%97%E4%B9%8B%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://yoursite.com/2020/01/14/Webpack-Webpack系列之预处理器/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-07T04:01:19.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="预处理器（loader）"><a href="#预处理器（loader）" class="headerlink" title="预处理器（loader）"></a>预处理器（loader）</h1><p>每个loader本质上都是一个函数。在Webpack 4之前，函数的输入和输出都必须为字符串；在Webpack 4之后，loader也同时支持抽象语法树（AST）的传递，通过这种方法来减少重复的代码解析。用公式表达loader的本质则为以下形式：</p><p>output=loader(input)</p><p>这里的input可能是工程源文件的字符串，也可能是上一个loader转化后的结果，包括转化后的结果（也是字符串类型）、source map，以及AST对象；output同样包含这几种信息，转化后的文件字符串、source map，以及AST。如果这是最后一个loader，结果将直接被送到Webpack进行后续处理，否则将作为下一个loader的输入向后传递。</p><h2 id="loader-的配置"><a href="#loader-的配置" class="headerlink" title="loader 的配置"></a>loader 的配置</h2><p>Webpack本身只认识JavaScript，对于其他类型的资源必须预先定义一个或多个loader对其进行转译，输出为Webpack能够接收的形式再继续进行，因此loader做的实际上是一个预处理的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.jsx?/, // 条件</div><div class="line">        use: &apos;babel-loader&apos; // 规则应用结果</div><div class="line">      &#125; // 一个Object即一条规则</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与loader相关的配置都在module对象中，其中module.rules代表了模块的处理规则。每条规则内部可以包含很多配置项，这里我们只使用了最重要的两项—test和use。</p><ul><li><p>test可接收一个正则表达式或者一个元素为正则表达式的数组，只有正则匹配上的模块才会使用这条规则。</p></li><li><p>use可接收一个数组，数组包含该规则所使用的loader。</p></li></ul><h3 id="链式-loader"><a href="#链式-loader" class="headerlink" title="链式 loader"></a>链式 loader</h3><p>很多时候，在处理某一类资源时我们都需要使用多个loader。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.css?/, // 条件</div><div class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;] // 规则应用结果</div><div class="line">      &#125; // 一个Object即一条规则</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>把style-loader加到了css-loader前面，这是因为在Webpack打包时是按照数组从后往前的顺序将资源交给loader处理的，因此要把最后生效的放在前面。</p><h3 id="loader-options"><a href="#loader-options" class="headerlink" title="loader options"></a>loader options</h3><p>webpack为loader提供了多种匹配条件的配置方式：</p><ul><li>test: … 匹配特定条件</li><li>include: … 匹配特定路径</li><li>exclude: … 排除特定路径</li><li>and: [] 必须匹配数组中的所有条件</li><li>or: [] 匹配数组中的任意一个条件</li><li>not: [] 排除匹配数组中的所有条件</li></ul><p>条件值类型：</p><ul><li>字符串：必须以提供的字符串开始（绝对路径）</li><li>正则表达式</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件</li><li>函数：返回true表示匹配</li></ul><hr><h5 id="规则应用配置"><a href="#规则应用配置" class="headerlink" title="规则应用配置"></a>规则应用配置</h5><p>匹配规则后的应用，我们可以使用use字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">rules: [</div><div class="line">  &#123;</div><div class="line">    test: /\.less/,</div><div class="line">    use: [</div><div class="line">      &apos;style-loader&apos;,</div><div class="line">      &#123;</div><div class="line">        loader: &apos;css-loader&apos;,</div><div class="line">        options: &#123;</div><div class="line">          // ...</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        loader: &apos;less-loader&apos;,</div><div class="line">        options: &#123;</div><div class="line">          // ...</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure><p>使用options可以给对应的loader传递一些配置项。</p><p>对于上述的less规则应用配置，一个less模块文件可以经过多个loader的转换处理，执行顺序为从右到左。</p><p>如果多个rule匹配了同一个模块文件，loader的应用顺序应该如何处理？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">rules: [</div><div class="line">  &#123;</div><div class="line">    test: /\.js$/,</div><div class="line">    loader: &quot;eslint-loader&quot;,</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    test: /\.js$/,</div><div class="line">    loader: &quot;babel-loader&quot;,</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure><p>eslint-loader用于检查人工编写的代码，babel-loader用于转换代码。所以，eslint-loader应该在babel-loader之前执行，那么该如何保证执行顺序？</p><p>webpack为每一个匹配规则提供了enforce字段来配置当前rule得的loader类型。pre(前置) &gt; 行内 &gt; 普通 &gt; 后置(post)。 我们要确保eslint-loader在babel-loader之前执行，只需给rule规则项添加enforce字段，并设置其值为pre。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rules: [</div><div class="line">  &#123;</div><div class="line">    enforce: &apos;pre&apos;,</div><div class="line">    test: /\.js$/,</div><div class="line">    loader: &quot;eslint-loader&quot;,</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    test: /\.js$/,</div><div class="line">    loader: &quot;babel-loader&quot;,</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure><h2 id="常用-loader-介绍"><a href="#常用-loader-介绍" class="headerlink" title="常用 loader 介绍"></a>常用 loader 介绍</h2><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p> babel-loader用来处理ES6+并将其编译为ES5。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i babel-loader @babel/core @babel/preset-env</div></pre></td></tr></table></figure><p>各个模块的作用如下:</p><ul><li><p>babel-loader：它是使Babel与Webpack协同工作的模块。</p></li><li><p>@babel/core：顾名思义，它是Babel编译器的核心模块。</p></li><li><p>@babel/preset-env：它是Babel官方推荐的预置器，可根据用户设置的目标环境自动添加所需的插件和补丁来编译ES6+代码。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.jsx?/,</div><div class="line">        loader: &apos;babel-loader&apos;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="ts-loader"><a href="#ts-loader" class="headerlink" title="ts-loader"></a>ts-loader</h3><p>ts-loader与babel-loader的性质类似，它是用于连接Webpack与Typescript的模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i ts-loader typescript</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.ts?/,</div><div class="line">        loader: &apos;ts-loader&apos;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h3><p>html-loader用于将HTML文件转化为字符串并进行格式化，这使得我们可以把一个HTML片段通过JS加载进来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i html-loader</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.html?/,</div><div class="line">        loader: &apos;html-loader&apos;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="handlebars-loader"><a href="#handlebars-loader" class="headerlink" title="handlebars-loader"></a>handlebars-loader</h3><p>handlebars-loader用于处理handlebars模板，在安装时要额外安装handlebars。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i handlebars-loader handlebars</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.handlebars?/,</div><div class="line">        loader: &apos;handlebars-loader&apos;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>handlebars文件加载后得到的是一个函数，可以接收一个变量对象并返回最终的字符串。</p><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>file-loader用于打包文件类型的资源，并返回其publicPath。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i file-loader</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.(png|jpg|gif)$/,</div><div class="line">        use: &apos;file-loader&apos;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>url-loader与file-loader作用类似，唯一的不同在于用户可以设置一个文件大小的阈值，当大于该阈值时与file-loader一样返回publicPath，而小于该阈值时则返回文件base64形式编码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i url-loader</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // ...</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.(png|jpg|gif)$/,</div><div class="line">        use: &#123;</div><div class="line">            loader: &apos;file-loader&apos;,</div><div class="line">            options: &#123;</div><div class="line">                limit: 10240,</div><div class="line">                name: &apos;[name].[ext]&apos;,</div><div class="line">                publicPath: &apos;./assets-path/&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之简介</title>
    <link href="http://yoursite.com/2020/01/14/Webpack-Webpack%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/01/14/Webpack-Webpack系列之简介/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-07T03:56:32.065Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="Webpack-简介"><a href="#Webpack-简介" class="headerlink" title="Webpack 简介"></a>Webpack 简介</h1><h2 id="Webpack是什么"><a href="#Webpack是什么" class="headerlink" title="Webpack是什么"></a>Webpack是什么</h2><p>Webpack是一个开源的JavaScript模块打包工具，其最核心的功能是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个JS文件（有时会有多个，这里讨论的只是最基本的情况）。</p><h2 id="模块打包工具"><a href="#模块打包工具" class="headerlink" title="模块打包工具"></a>模块打包工具</h2><p>模块打包工具（module bundler）的任务就是解决模块间的依赖，使其打包后的结果能运行在浏览器上。它的工作方式主要分为两种</p><ul><li><p>将存在依赖关系的模块按照特定规则合并为单个JS文件，一次全部加载进页面中。</p></li><li><p>在页面初始时加载一个入口模块，其他模块异步地进行加载。</p></li></ul><h2 id="Webpack-优势"><a href="#Webpack-优势" class="headerlink" title="Webpack 优势"></a>Webpack 优势</h2><ul><li><p>默认支持多种模块标准，包括AMD、CommonJS，以及最新的ES6模块。</p></li><li><p>完备的代码分割（code splitting）解决方案，首屏只加载重要的部分。</p></li><li><p>可以处理各种类型的资源。除了JavaScript以外，Webpack还可以处理样式、模板，甚至图片等。</p></li><li><p>拥有庞大的社区支持。</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用npm或者yarn来安装webpack</p><hr><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ npm i webpack webpack-cli -g</div><div class="line"></div><div class="line">or</div><div class="line"></div><div class="line">$ yarn -g add webpack webpack-cli</div></pre></td></tr></table></figure><p>等待安装完毕，就可以全局执行webpack命令了。注：webpack-cli在4.x版本之后不再作为webpack的依赖了，我们使用时需要单独安装。</p><hr><h3 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h3><p>在项目中，我们更推荐将webpack作为项目的开发依赖来安装使用，这样可以指定项目中使用的webpack版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ npm i webpack webpack-cli -D</div><div class="line"></div><div class="line">or</div><div class="line"></div><div class="line">$ yarn add webpack webpack-cli -D</div></pre></td></tr></table></figure><p>等待安装完毕，webpack会出现在项目的package.json文件中，我们添加一个npm scripts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;build&quot;: &quot;webpack --mode production&quot;</div><div class="line">&#125;,</div><div class="line">&quot;devDependencies&quot;: &#123;</div><div class="line">  &quot;webpack&quot;: &quot;^4.1.1&quot;,</div><div class="line">  &quot;webpack-cli&quot;: &quot;^2.0.12&quot;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack-dev-server可以看作一个服务者，它的主要工作就是接收浏览器的请求，然后将资源返回。当服务启动时，会先让Webpack进行模块打包并将资源准备好（在示例中就是bundle.js）。当webpack-dev-server接收到浏览器的资源请求时，它会首先进行URL地址校验。如果该地址是资源服务地址（上面配置的publicPath），就会从Webpack的打包结果中寻找该资源并返回给浏览器。反之，如果请求地址不属于资源服务地址，则直接读取硬盘中的源文件并将其返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i webpack-dev-server -D</div></pre></td></tr></table></figure><p>为了便捷地启动webpack-dev-server，我们在package.json中添加一个dev指令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">  "build": "webpack",</div><div class="line">  "dev": "webpack-dev-server"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后，我们还需要对webpack-dev-server进行配置。编辑webpack.config.js如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    entry: <span class="string">"./src/index.js"</span>,</div><div class="line">    output: &#123;</div><div class="line">        filename: <span class="string">"./bundle.js"</span></div><div class="line">    &#125;,</div><div class="line">    mode: <span class="string">"development"</span>,</div><div class="line">    devServer: &#123;</div><div class="line">        publicPath: <span class="string">"/dist"</span></div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有一点需要注意。直接用Webpack开发和使用webpack-dev-server有一个很大的区别，前者每次都会生成budnle.js，而webpack-dev-server只是将打包结果放在内存中，并不会写入实际的bundle.js，在每次webpack-dev-server接收到请求时都只是将内存中的打包结果返回给浏览器。</p><p>webpack-dev-server还有一项很便捷的特性就是live-reloading（自动刷新）。</p><p>注：关于内容自动更新，webpack-dev-server 与 hot-module-replacement（模块热替换）的区别在于：前者会刷新浏览器，后者不需要刷新浏览器就能获得更新之后的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-Webpack系列之模块打包</title>
    <link href="http://yoursite.com/2020/01/14/Webpack-Webpack%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/2020/01/14/Webpack-Webpack系列之模块打包/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-02-07T03:57:52.343Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="模块打包"><a href="#模块打包" class="headerlink" title="模块打包"></a>模块打包</h1><h2 id="多种不同的模块机制"><a href="#多种不同的模块机制" class="headerlink" title="多种不同的模块机制"></a>多种不同的模块机制</h2><h3 id="Commonjs"><a href="#Commonjs" class="headerlink" title="Commonjs"></a>Commonjs</h3><p>CommonJS最初只为服务端而设计，直到有了Browserify——一个运行在Node.js环境下的模块打包工具，它可以将CommonJS模块打包为浏览器可以运行的单个文件。这意味着客户端的代码也可以遵循CommonJS标准来编写了。</p><p>CommonJS中规定每个文件是一个模块，所有的变量及函数只有自己能访问，对外是不可见的。</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>在CommonJS中，通过module.exports可以导出模块中的内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    name: <span class="string">"calculate"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>CommonJS模块内部会有一个module对象用于存放当前模块的信息。</p><p>属性。为了书写方便，CommonJS也支持另一种简化的导出方式—直接使用exports:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exports.name = <span class="string">"caculate"</span></div></pre></td></tr></table></figure><p>另外，要注意导出语句不代表模块的末尾，在module.exports或exports后面的代码依旧会照常执行。</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>在CommonJS中使用require进行模块导入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> calculator = <span class="built_in">require</span>(<span class="string">'./caculate.js'</span>)</div><div class="line"><span class="keyword">const</span> name = calculator.name</div></pre></td></tr></table></figure><p>当我们require一个模块时会有两种情况：</p><ul><li><p>require的模块是第一次被加载。这时会首先执行该模块，然后导出内容。</p></li><li><p>require的模块曾被加载过。这时该模块的代码不会再次执行，而是直接导出上次执行后得到的结果。</p></li></ul><p>模块会有一个module对象用来存放其信息，这个对象中有一个属性loaded用于记录该模块是否被加载过。它的值默认为false，当模块第一次被加载和执行过后会置为true，后面再次加载时检查到module.loaded为true，则不会再次执行模块代码。</p><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6 Module也是将每个文件作为一个模块，每个模块拥有自身的作用域，不同的是导入、导出语句。</p><p>ES6 Module会自动采用严格模式 – “use strict”。</p><h4 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h4><p>在ES6 Module中使用export命令来导出模块。</p><p>export有两种形式：</p><ul><li><p>命名导出</p></li><li><p>默认导出</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">"calculate"</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="string">"add"</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> name = <span class="string">"calculate"</span></div><div class="line"><span class="keyword">const</span> add = <span class="string">"add"</span></div><div class="line"><span class="keyword">export</span> &#123; name, add &#125;</div></pre></td></tr></table></figure><p>在使用命名导出时，可以通过as关键字对变量重命名。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> name = <span class="string">"calculate"</span></div><div class="line"><span class="keyword">const</span> add = <span class="string">"add"</span></div><div class="line"><span class="keyword">export</span> &#123; name, add <span class="keyword">as</span> sum &#125;</div></pre></td></tr></table></figure><p>将export default 默认导出，我们可以理解为对外输出了一个名为default的变量，因此不需要像命名导出一样进行变量声明，直接导出值即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">"calculate"</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span>  <span class="class"><span class="keyword">class</span> </span>&#123;...&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h4><p>ES6 Module中使用import语法导入模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">'./caculate.js'</span></div></pre></td></tr></table></figure><p>与命名导出类似，我们可以通过as关键字可以对导入的变量重命名。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> caculate &#125; <span class="keyword">from</span> <span class="string">'./caculate.js'</span></div></pre></td></tr></table></figure><p>在导入多个变量时，我们还可以采用整体导入的方式。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> caculate <span class="keyword">from</span> <span class="string">'./caculate.js'</span></div><div class="line"><span class="keyword">const</span> name = caculate.name</div></pre></td></tr></table></figure><p>对于默认导出来说，import后面直接跟变量名，并且这个名字可以自由指定（比如这里是myCalculator）。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> myCalculator <span class="keyword">from</span> <span class="string">'./caculate.js'</span></div></pre></td></tr></table></figure><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD是英文Asynchronous Module Definition（异步模块定义）的缩写:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">'getSum'</span>, [<span class="string">'calculate'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(calculate.add(a, b))</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>在AMD中使用define函数来定义模块，它可以接受3个参数:</p><p>第1个参数是当前模块的id，相当于模块名；</p><p>第2个参数是当前模块的依赖，比如上面我们定义的getSum模块需要引入calculator模块作为依赖；</p><p>第3个参数用来描述模块的导出值，可以是函数或对象。如果是函数则导出的是函数的返回值；如果是对象则直接导出对象本身。</p><p>和CommonJS类似，AMD也使用require函数来加载模块，只不过采用异步的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'getSum'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">getSum</span>) </span>&#123;</div><div class="line">  getSum(<span class="number">2</span>, <span class="number">3</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>require的第1个参数指定了加载的模块，第2个参数是当加载完成后执行的回调函数。</p><p>通过AMD这种形式定义模块的好处在于其模块加载是非阻塞性的，当执行到require函数时并不会停下来去执行被加载的模块，而是继续执行require后面的代码，这使得模块加载操作并不会阻塞浏览器。</p><h2 id="模块打包原理"><a href="#模块打包原理" class="headerlink" title="模块打包原理"></a>模块打包原理</h2><p>Webpack 将项目中成百上千个有依赖关系的模块组织在一起，打包后将会成为如下的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 立即执行匿名函数</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</div><div class="line">    <span class="comment">// 模块缓存</span></div><div class="line">    <span class="keyword">var</span> installedModules = &#123;&#125;</div><div class="line">    <span class="comment">// 实现 require</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 执行入口模块的加载</span></div><div class="line">    <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// modules: 以 key-value 的形式存储所有被打包的模块</span></div><div class="line">        <span class="number">0</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</div><div class="line">           <span class="comment">// 打包入口</span></div><div class="line">            <span class="built_in">module</span>.exports = __webpack_require__(<span class="string">"3qiv"</span>)</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"3qiv"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</div><div class="line">            <span class="comment">// 打包入口</span></div><div class="line">            <span class="built_in">module</span>.exports = __webpack_require__(<span class="string">"3qiv"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>上面的bundle分为以下几个部分：</p><ul><li><p>最外层立即执行匿名函数。它用来包裹整个bundle，并构成自身的作用域。</p></li><li><p>installedModules对象。每个模块只在第一次被加载的时候执行，之后其导出值就被存储到这个对象里面，当再次被加载的时候直接从这里取值，而不会重新执行。</p></li><li><p><strong>webpack_require</strong>函数。对模块加载的实现，在浏览器中可以通过调用<strong>webpack_require</strong>(module_id)来完成模块导入。</p></li><li><p>modules对象。工程中所有产生了依赖关系的模块都会以key-value的形式放在这里。key可以理解为一个模块的id，由数字或者一个很短的hash字符串构成；value则是由一个匿名函数包裹的模块实体，匿名函数的参数则赋予了每个模块导出和导入的能力。</p></li></ul><p>bundle是如何在浏览器中执行的：</p><ul><li><p>在最外层的匿名函数中会初始化浏览器执行环境，包括定义installedModules对象、<strong>webpack_require</strong>函数等，为模块的加载和执行做一些准备工作。</p></li><li><p>加载入口模块。每个bundle都有且只有一个入口模块，例如：index.js是入口模块，在浏览器中会从它开始执行。</p></li><li><p>执行模块代码。如果执行到了module.exports则记录下模块的导出值；如果中间遇到require函数（准确地说是<strong>webpack_require</strong>），则会暂时交出执行权，进入<strong>webpack_require</strong>函数体内进行加载其他模块的逻辑。</p></li><li><p>在<strong>webpack_require</strong>中会判断即将加载的模块是否存在于installedModules中。如果存在则直接取值，否则回到上一步，执行该模块的代码来获取导出值。</p></li><li><p>所有依赖的模块都已执行完毕，最后执行权又回到入口模块。当入口模块的代码执行到结尾，也就意味着整个bundle运行结束。</p></li></ul><p>不难看出，第3步和第4步是一个递归的过程。Webpack为每个模块创造了一个可以导出和导入模块的环境，但本质上并没有修改代码的执行逻辑，因此代码执行的顺序与模块加载的顺序是完全一致的，这就是Webpack模块打包的奥秘。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>面试题-常见面试题系列之JS基础</title>
    <link href="http://yoursite.com/2019/11/25/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97%E4%B9%8BJS%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/11/25/面试题-常见面试题系列之JS基础/</id>
    <published>2019-11-25T01:46:52.000Z</published>
    <updated>2019-11-25T20:02:59.098Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><p>本系列旨在整理 JS 常见面试题，帮助梳理 JS 基础知识点。</p><h3 id="🌰-‘1’-‘2’-‘3’-map-parseInt-输出结果"><a href="#🌰-‘1’-‘2’-‘3’-map-parseInt-输出结果" class="headerlink" title="🌰 [‘1’, ‘2’, ‘3’].map(parseInt) 输出结果"></a>🌰 [‘1’, ‘2’, ‘3’].map(parseInt) 输出结果</h3><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h4><p>解析一个字符串参数，返回一个指定基数的整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> intValue = <span class="built_in">parseInt</span>(string[, radix]);</div></pre></td></tr></table></figure><p>string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串。字符串开头的空白符会被忽略。</p><p>radix 一个介于 2~36之间的整数，表示上述字符串的基数，默认值为 10。</p><p>parseInt 返回一个整数或 NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>); <span class="comment">// 100</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>, <span class="number">10</span>); <span class="comment">// 1*10*10 + 0*10*1 + 0*10*0 = 100</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>, <span class="number">2</span>); <span class="comment">// 1*2*2 + 0*2*1 + 0*2*0 = 4</span></div></pre></td></tr></table></figure><p>在 radix 为 undefined ，或 radix 为 0 或没有指定的情况下，JS 作如下处理：</p><ul><li><p>string 以 ‘0x’ 或 ‘0X’ 开头，则 radix 为 16。</p></li><li><p>string 以 ‘0’ 开头，radix 为 8 或者 10，具体哪个基数由实现环境决定。</p></li><li><p>string 以其它任何值开头，则 radix 为 10。</p></li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[,index[, array]]</span>) </span>&#123;</div><div class="line"> <span class="comment">// Return element for new_array</span></div><div class="line"> &#125;[, thisArg])</div></pre></td></tr></table></figure><p>callback 回调函数需要三个参数，分别为 currentValue(数组中当前正在处理的元素的值)、index(数组中当前正在处理的元素的索引)、array(map 方法中被调用的数组)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">arr.map(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>) <span class="comment">// [2, 4, 6]</span></div></pre></td></tr></table></figure><h4 id="‘1’-‘2’-‘3’-map-parseInt-输出"><a href="#‘1’-‘2’-‘3’-map-parseInt-输出" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt) 输出"></a>[‘1’, ‘2’, ‘3’].map(parseInt) 输出</h4><p>对于每个迭代 map，parseInt() 传递两个参数：字符串和基数。所以实际执行的代码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">parseInt</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> <span class="built_in">parseInt</span>(item, index))</div></pre></td></tr></table></figure><p>执行步骤为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>); <span class="comment">// 1 (10 进制)</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>); <span class="comment">// NaN radix(2-36)</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>); <span class="comment">// NaN 不符合2进制位数取值(0-1)</span></div></pre></td></tr></table></figure><p>所以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">parseInt</span>) <span class="comment">// [1, NaN, NaN]</span></div></pre></td></tr></table></figure><h3 id="🌰-什么是节流和防抖？区别？如何实现？"><a href="#🌰-什么是节流和防抖？区别？如何实现？" class="headerlink" title="🌰 什么是节流和防抖？区别？如何实现？"></a>🌰 什么是节流和防抖？区别？如何实现？</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>动作绑定事件，动作发生后一定时间内触发时间，在这段时间内如果该动作又发生，则重新等待一定时间再触发事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 防抖 debounce 定时器</span></div><div class="line"><span class="comment"> * @param fn &#123;function&#125; 回调函数</span></div><div class="line"><span class="comment"> * @param wait &#123;number&#125; 时间间隔</span></div><div class="line"><span class="comment"> * @author wangxiaobai</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, wait</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 清除上次执行得定时器</span></div><div class="line">    <span class="keyword">if</span> (timer) &#123;</div><div class="line">      clearTimeout(timer);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设立新定时器</span></div><div class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125;, wait);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>动作绑定事件，动作发生后一定时间内触发事件，在这段时间内如果该动作又发生，则无视该动作，直到事件执行完后，才能重新触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 节流 throttle 定时器</span></div><div class="line"><span class="comment"> * @param fn &#123;function&#125; 回调函数</span></div><div class="line"><span class="comment"> * @param wait &#123;number&#125; 时间间隔</span></div><div class="line"><span class="comment"> * @author wangxiaobai</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, wait</span>) </span>&#123;</div><div class="line">  <span class="comment">// 上一次函数的执行时间  </span></div><div class="line">  <span class="keyword">let</span> activeTime = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">let</span> currentTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">      <span class="keyword">if</span> (currentTime - activeTime &gt; wait) &#123;</div><div class="line">          fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">          activeTime = currentTime;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="🌰-Set、Map、WeakSet、WeakMap"><a href="#🌰-Set、Map、WeakSet、WeakMap" class="headerlink" title="🌰 Set、Map、WeakSet、WeakMap"></a>🌰 Set、Map、WeakSet、WeakMap</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>一种叫做集合的数据结构，类似于数组，成员唯一且无序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new Set([iterable])</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].forEach(<span class="function"><span class="params">item</span> =&gt;</span> s.add(item));</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> s) &#123;</div><div class="line">    <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 3 4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</div><div class="line">[... new <span class="built_in">Set</span>(arr)]; <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure><p>Set 允许你存储任何类型的唯一值，无论是原始值还是对象引用。</p><p>向 Set 加入值的时候，不会发生类型转换，所以 5 和 ‘5’ 是两个不同的值。</p><p>在 Set 中，NaN 等于自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="literal">NaN</span>);</div><div class="line">set.add(<span class="literal">NaN</span>);</div><div class="line">set; <span class="comment">// &#123;NaN&#125; </span></div><div class="line"></div><div class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set1.add(<span class="number">5</span>);</div><div class="line">set1.add(<span class="string">'5'</span>);</div><div class="line">set; <span class="comment">// &#123;5, '5'&#125;</span></div></pre></td></tr></table></figure><ul><li>Set 实例属性</li></ul><p>constructor: 构造函数</p><p>size: 元素数量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</div><div class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 3</span></div></pre></td></tr></table></figure><ul><li>Set 实例方法</li></ul><p>操作方法：</p><p>add(value) 新增</p><p>delete(value) 存在即删除集合中的 value</p><p>has(value) 判断集合中是否存在 value</p><p>clear() 清空集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">1</span>);</div><div class="line"></div><div class="line">set.size; <span class="comment">// 2</span></div><div class="line">set.has(<span class="number">1</span>); <span class="comment">// true</span></div><div class="line">set.has(<span class="number">3</span>); <span class="comment">// false</span></div><div class="line">set.delete(<span class="number">1</span>);</div><div class="line">set.has(<span class="number">1</span>); <span class="comment">// false</span></div><div class="line">set.clear();</div><div class="line">set.size; <span class="comment">// 0</span></div></pre></td></tr></table></figure><p>Array.from 可以将 Set 结构转化为数组    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]);</div><div class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items);</div><div class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="comment">// 或</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> arr = [...items]</div><div class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure><p>遍历方法：</p><p>keys() 返回一个包含集合中所有键的迭代器</p><p>values() 返回一个包含集合中所有值的迭代器</p><p>entries() 返回一个包含集合中所有键值对的迭代器</p><p>forEach(callbackFn, thisArg)</p><p>map(callbackFn, thisArg)</p><p>filter(callbackFn, thisArg)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="built_in">console</span>.log(set.keys()); <span class="comment">// SetIterator &#123;1, 2, 3&#125;</span></div><div class="line"><span class="built_in">console</span>.log(set.values()); <span class="comment">// SetIterator &#123;1, 2, 3&#125;</span></div><div class="line"><span class="built_in">console</span>.log(set.entries()); <span class="comment">// SetIterator &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span></div><div class="line">set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value);</div><div class="line">&#125;);<span class="comment">// 1:1 2:2 3:3</span></div><div class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>));</div><div class="line"><span class="built_in">console</span>.log(set);<span class="comment">// &#123;2, 4, 6&#125;</span></div><div class="line"></div><div class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">item</span> =&gt;</span> (item &gt;= <span class="number">4</span>)));</div><div class="line"><span class="built_in">console</span>.log(set);<span class="comment">// &#123;4, 6&#125;</span></div></pre></td></tr></table></figure><p>因此，Set 很容易实现两个数组的交集、并集、差集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</div><div class="line"></div><div class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1].filter(<span class="function"><span class="params">value</span> =&gt;</span> set2.has(value)));</div><div class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1, ...set2]);</div><div class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...set1].filter(<span class="function"><span class="params">value</span> =&gt;</span> !set2.has(value)));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(intersect); <span class="comment">// &#123;2, 3&#125;</span></div><div class="line"><span class="built_in">console</span>.log(union); <span class="comment">// &#123;1, 2, 3, 4&#125;</span></div><div class="line"><span class="built_in">console</span>.log(difference); <span class="comment">// &#123;1&#125;</span></div></pre></td></tr></table></figure><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>允许你将弱引用对象储存在一个集合中。</p><p>WeakSet 与 Set 的区别：</p><ul><li><p>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</p></li><li><p>WeakSet 中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的引用，如果没有其它的变量或属性引用这个对象值，则这个对象或被垃圾回收掉</p></li></ul><p>属性：</p><p>constructor: 构造函数</p><p>方法：</p><p>add(value) 添加元素 value</p><p>has(value) 判断是否包含 value</p><p>delete(value) 删除 value</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;</div><div class="line"><span class="keyword">var</span> foo = &#123;&#125;</div><div class="line"></div><div class="line">ws.add(obj);</div><div class="line">ws.add(foo);</div><div class="line"></div><div class="line">ws.has(obj); <span class="comment">// true</span></div><div class="line">ws.has(foo); <span class="comment">// false</span></div><div class="line"></div><div class="line">ws.delete(obj);</div><div class="line">ws.has(obj); <span class="comment">// false</span></div></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>一种叫做字典的数据结构，以 [key, value] 的形式存储</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"><span class="keyword">const</span> o = &#123;</div><div class="line">    p: <span class="string">'haha'</span></div><div class="line">&#125;;</div><div class="line">m.set(o, <span class="string">'content'</span>);</div><div class="line">m.get(o); <span class="comment">// 'content'</span></div><div class="line"></div><div class="line">m.has(o); <span class="comment">// true</span></div><div class="line">m.delete(o);</div><div class="line">m.has(o); <span class="comment">// false</span></div></pre></td></tr></table></figure><p>任何具有 Iterator 接口，每个成员都是一个双元素的数组的数据结构都可以当做 Map 构造函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</div><div class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</div><div class="line">]);</div><div class="line"></div><div class="line">map.size; <span class="comment">// 2</span></div><div class="line">map.has(<span class="string">'name'</span>); <span class="comment">// true</span></div><div class="line">map.get(<span class="string">'name'</span>); <span class="comment">// "张三"</span></div><div class="line">map.has(<span class="string">'title'</span>); <span class="comment">// true</span></div><div class="line">map.get(<span class="string">'title'</span>); <span class="comment">// "Author"</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([</div><div class="line">  [<span class="string">'foo'</span>, <span class="number">1</span>],</div><div class="line">  [<span class="string">'bar'</span>, <span class="number">2</span>]</div><div class="line">]);</div><div class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>(set);</div><div class="line">m1.get(<span class="string">'foo'</span>); <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'baz'</span>, <span class="number">3</span>]]);</div><div class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="built_in">Map</span>(m2);</div><div class="line">m3.get(<span class="string">'baz'</span>); <span class="comment">// 3</span></div></pre></td></tr></table></figure><p>如果读取一个未知的键，则返回undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Map</span>().get(<span class="string">'asfddfsasadf'</span>); <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</div><div class="line">map.get([<span class="string">'a'</span>]); <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">map.set(<span class="number">-0</span>, <span class="number">123</span>);</div><div class="line">map.get(+<span class="number">0</span>); <span class="comment">// 123</span></div><div class="line"></div><div class="line">map.set(<span class="literal">true</span>, <span class="number">1</span>);</div><div class="line">map.set(<span class="string">'true'</span>, <span class="number">2</span>);</div><div class="line">map.get(<span class="literal">true</span>); <span class="comment">// 1</span></div><div class="line"></div><div class="line">map.set(<span class="literal">undefined</span>, <span class="number">3</span>);</div><div class="line">map.set(<span class="literal">null</span>, <span class="number">4</span>);</div><div class="line">map.get(<span class="literal">undefined</span>); <span class="comment">// 3</span></div><div class="line"></div><div class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>);</div><div class="line">map.get(<span class="literal">NaN</span>); <span class="comment">// 123</span></div></pre></td></tr></table></figure><p>属性：</p><p>constructor：构造函数</p><p>size: 字典中所包含的元素个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="string">'name'</span>, <span class="string">'An'</span>],</div><div class="line">  [<span class="string">'des'</span>, <span class="string">'JS'</span>]</div><div class="line">]);</div><div class="line"></div><div class="line">map.size; <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>操作方法：</p><p>set(key, value) 添加新元素</p><p>get(key) 通过键查找特定的数值并返回</p><p>has(key) 判断字典中是否存在 key</p><p>delete(key) 通过键 key 从字典中移除对应的数据</p><p>clear() 字典中所有元素删除</p><p>遍历方法：</p><p>keys() 将字典中包含的所有键名以迭代器形式返回</p><p>values() 将字典中包含的所有数值以迭代器形式返回</p><p>entries() 返回所有成员的迭代器</p><p>forEach() 遍历字典的所有成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">            [<span class="string">'name'</span>, <span class="string">'An'</span>],</div><div class="line">            [<span class="string">'des'</span>, <span class="string">'JS'</span>]</div><div class="line">        ]);</div><div class="line"><span class="built_in">console</span>.log(map.entries());<span class="comment">// MapIterator &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125;</span></div><div class="line"><span class="built_in">console</span>.log(map.keys()); <span class="comment">// MapIterator &#123;"name", "des"&#125;</span></div></pre></td></tr></table></figure><p>与其它数据结构相互转换</p><ol><li>Map 转 Array</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</div><div class="line"><span class="built_in">console</span>.log([...map]); <span class="comment">// [[1, 1], [2, 2], [3, 3]]</span></div></pre></td></tr></table></figure><ol><li>Array 转 map</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</div><div class="line"><span class="built_in">console</span>.log(map);<span class="comment">// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span></div></pre></td></tr></table></figure><ol><li>Map 转 Object</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToObj</span>(<span class="params">map</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">        obj[key] = value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'name'</span>, <span class="string">'An'</span>).set(<span class="string">'des'</span>, <span class="string">'JS'</span>);</div><div class="line">mapToObj(map);  <span class="comment">// &#123;name: "An", des: "JS"&#125;</span></div></pre></td></tr></table></figure><ol><li>Object 转 Map</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToMap</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> obj.keys()) &#123;</div><div class="line">        map.set(key, obj[key])</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> map</div><div class="line">&#125;</div><div class="line">objToMap(&#123;<span class="string">'name'</span>: <span class="string">'An'</span>, <span class="string">'des'</span>: <span class="string">'JS'</span>&#125;) <span class="comment">// Map &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125;</span></div></pre></td></tr></table></figure><ol><li>Map 转 JSON</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToJson</span>(<span class="params">map</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'name'</span>, <span class="string">'An'</span>).set(<span class="string">'des'</span>, <span class="string">'JS'</span>);</div><div class="line">mapToJson(map);<span class="comment">// [["name","An"],["des","JS"]]</span></div></pre></td></tr></table></figure><ol><li>JSON 转 Map</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> objToMap(<span class="built_in">JSON</span>.parse(jsonStr));</div><div class="line">&#125;</div><div class="line"></div><div class="line">jsonToStrMap(<span class="string">'&#123;"name": "An", "des": "JS"&#125;'</span>); <span class="comment">// Map &#123;"name" =&gt; "An", "des" =&gt; "JS"&#125;</span></div></pre></td></tr></table></figure><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap 对象是一组键值对的集合，其中键是弱引用对象，而值可以是任意。</p><p>每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收。</p><p>属性：</p><p>constructor: 构造函数</p><p>方法：</p><p>has(key)：判断是否有 key 关联对象</p><p>get(key)：返回key关联对象（没有则则返回 undefined）</p><p>set(key)：设置一组key关联对象</p><p>delete(key)：移除 key 的关联对象</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>Set</li></ul><p>成员唯一、无序</p><p>可以遍历</p><ul><li>WeakSet</li></ul><p>成员都是对象</p><p>成员都是弱引用，可以被垃圾回收机制回收</p><p>不能遍历</p><ul><li>Map</li></ul><p>本质是键值对的集合</p><p>可以遍历</p><ul><li>WeakMap</li></ul><p>只接受对象作为键名</p><p>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收机制回收</p><p>不能遍历</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;p&gt;本系列旨在整理 JS 常见面试题，帮助梳理 JS 基础知识点。&lt;/p&gt;
&lt;h3 id=&quot;🌰-‘1’-‘2’-‘3’-map-parseIn
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CSS-常见面试题系列之BFC</title>
    <link href="http://yoursite.com/2019/08/26/CSS-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B3%BB%E5%88%97%E4%B9%8BBFC/"/>
    <id>http://yoursite.com/2019/08/26/CSS-常见面试题系列之BFC/</id>
    <published>2019-08-26T08:24:52.000Z</published>
    <updated>2019-08-29T08:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>BFC (Block Formatting Context) 块级格式化上下文，页面的可视化 CSS 渲染的一部分，是一个独立的渲染区域，块内的子元素布局与块外的元素互不干扰。</p></blockquote><h3 id="BFC-解决的问题"><a href="#BFC-解决的问题" class="headerlink" title="BFC 解决的问题"></a>BFC 解决的问题</h3><ul><li>浮动定位</li><li>消除外边距折叠</li><li>清除浮动</li><li>自适应多栏布局<br>…</li></ul><hr><h3 id="BFC-的创建"><a href="#BFC-的创建" class="headerlink" title="BFC 的创建"></a>BFC 的创建</h3><ul><li>body根元素</li><li>浮动: float 除 none 以外的值</li><li>绝对定位: position (absolute, fixed)</li><li>overflow 值不为 visible</li><li>弹性布局或网格布局</li></ul><hr><h3 id="BFC-的约束规则"><a href="#BFC-的约束规则" class="headerlink" title="BFC 的约束规则"></a>BFC 的约束规则</h3><ul><li>属于同一个 BFC 中的两个相邻的 Box 的 margin 会发生折叠。</li><li>每个元素的左外边距与包含块的左边界相接触，即使浮动元素也是如此。</li><li>BFC 的区域不会与 float 的元素区域重叠</li><li>计算 BFC 的高度时，浮动子元素也参与计算</li></ul><hr><h3 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h3><h4 id="防止-margin-重叠"><a href="#防止-margin-重叠" class="headerlink" title="防止 margin 重叠"></a>防止 margin 重叠</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>top<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>bottom<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">  p &#123;</span></div><div class="line"><span class="undefined">    width: 100px;</span></div><div class="line"><span class="undefined">    height: 100px;</span></div><div class="line"><span class="undefined">    background: yellow;</span></div><div class="line"><span class="undefined">    line-height: 100px;</span></div><div class="line"><span class="undefined">    margin: 10px;</span></div><div class="line"><span class="undefined">    text-align: center</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/css-bfc.png&#39;" alt=""></p><p>两个 box 中间的间距为 10px，而不是 20px，因为它们处于同一个 BFC 中(body)。</p><p>解决方案为给第二个 box 包一层 div，设置其 overflow 属性，使它们处于不同的 BFC。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>top<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>bottom<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">  p &#123;</span></div><div class="line"><span class="undefined">    width: 100px;</span></div><div class="line"><span class="undefined">    height: 100px;</span></div><div class="line"><span class="undefined">    background: yellow;</span></div><div class="line"><span class="undefined">    line-height: 100px;</span></div><div class="line"><span class="undefined">    margin: 10px;</span></div><div class="line"><span class="undefined">    text-align: center</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined">  div &#123;</span></div><div class="line"><span class="undefined">    overflow: hidden;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/css-bfc-margin.png&#39;" alt=""></p><h4 id="让浮动内容与周围内容等高"><a href="#让浮动内容与周围内容等高" class="headerlink" title="让浮动内容与周围内容等高"></a>让浮动内容与周围内容等高</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>浮动元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>未浮动元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">.box &#123;</span></div><div class="line"><span class="undefined">    background-color: rgb(224, 206, 247);</span></div><div class="line"><span class="undefined">    border: 5px solid rebeccapurple;</span></div><div class="line"><span class="undefined">&#125;</span></div><div class="line"><span class="undefined">.float &#123;</span></div><div class="line"><span class="undefined">    float: left;</span></div><div class="line"><span class="undefined">    width: 200px;</span></div><div class="line"><span class="undefined">    height: 150px;</span></div><div class="line"><span class="undefined">    background-color: white;</span></div><div class="line"><span class="undefined">    border:1px solid black;</span></div><div class="line"><span class="undefined">    padding: 10px;</span></div><div class="line"><span class="undefined">&#125;      </span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/float-bfc-margin.png&#39;" alt=""></p><p>由于浮动，使得浮动元素的高度高于旁边的元素，解决方式为使父 box 生成一个 BFC，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>浮动元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>未浮动元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">.box &#123;</span></div><div class="line"><span class="undefined">    background-color: rgb(224, 206, 247);</span></div><div class="line"><span class="undefined">    border: 5px solid rebeccapurple;</span></div><div class="line"><span class="undefined">    overflow: auto;</span></div><div class="line"><span class="undefined">&#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="undefined">.float &#123;</span></div><div class="line"><span class="undefined">    float: left;</span></div><div class="line"><span class="undefined">    width: 200px;</span></div><div class="line"><span class="undefined">    height: 150px;</span></div><div class="line"><span class="undefined">    background-color: white;</span></div><div class="line"><span class="undefined">    border:1px solid black;</span></div><div class="line"><span class="undefined">    padding: 10px;</span></div><div class="line"><span class="undefined">&#125;      </span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/float-bfc.png&#39;" alt=""></p><h4 id="阻止元素被浮动元素覆盖"><a href="#阻止元素被浮动元素覆盖" class="headerlink" title="阻止元素被浮动元素覆盖"></a>阻止元素被浮动元素覆盖</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>我是一个没有设置浮动, 也没有触发 BFC 元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">.float &#123;</span></div><div class="line"><span class="undefined">  width: 100px;</span></div><div class="line"><span class="undefined">  height: 100px;</span></div><div class="line"><span class="undefined">  background: #eee;</span></div><div class="line"><span class="undefined">  float: left;</span></div><div class="line"><span class="undefined">&#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="undefined">.box &#123;</span></div><div class="line"><span class="undefined">  width: 200px;</span></div><div class="line"><span class="undefined">  height: 200px;</span></div><div class="line"><span class="undefined">  background: yellow;</span></div><div class="line"><span class="undefined">&#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/column-css.png&#39;" alt=""></p><p>第二个元素有部分被浮动元素覆盖，此时可触发第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>我是一个没有设置浮动, 也没有触发 BFC 元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">    .float &#123;</span></div><div class="line"><span class="undefined">      width: 100px;</span></div><div class="line"><span class="undefined">      height: 100px;</span></div><div class="line"><span class="undefined">      background: #eee;</span></div><div class="line"><span class="undefined">      float: left;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined">    </span></div><div class="line"><span class="undefined">    .box &#123;</span></div><div class="line"><span class="undefined">      overflow: hidden;</span></div><div class="line"><span class="undefined">      width: 200px;</span></div><div class="line"><span class="undefined">      height: 200px;</span></div><div class="line"><span class="undefined">      background: yellow;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>展示效果：</p><p><img src="&#39;http://pwvl8v6t5.bkt.clouddn.com/columb-css-bfc.png&#39;" alt=""></p><p>此方法可用来实现两列自适应布局</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/louzhedong/blog/issues/145" target="_blank" rel="external">BFC原理解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="external">10 分钟理解 BFC 原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;BFC (Block Formatting Context) 块级格式化上下文，页面的可视化 CSS 渲染的一部分
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue-源码系列随读笔记之Array变化侦测</title>
    <link href="http://yoursite.com/2019/08/18/Vue-%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E9%9A%8F%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8BArray%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/08/18/Vue-源码系列随读笔记之Array变化侦测/</id>
    <published>2019-08-18T10:34:52.000Z</published>
    <updated>2019-08-17T17:13:30.468Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档</p></blockquote><a id="more"></a><h3 id="什么是变化侦测"><a href="#什么是变化侦测" class="headerlink" title="什么是变化侦测"></a>什么是变化侦测</h3><p>从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。</p><p>简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。</p><p>Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。</p><hr><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">     enumerable: <span class="literal">true</span>,</div><div class="line">     configurable: <span class="literal">true</span>,</div><div class="line">     get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> val</div><div class="line">     &#125;,</div><div class="line">     set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">           <span class="keyword">return</span> </div><div class="line">        &#125;</div><div class="line">        val = newVal</div><div class="line">     &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。</p><p>由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。</p><hr><h3 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h3><p>思考以下问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> globalObj = &#123;</div><div class="line">  text1: <span class="string">'text1'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  template:</div><div class="line">    <span class="string">`&lt;div&gt;</span></div><div class="line"><span class="string">       &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></div><div class="line"><span class="string">    &lt;div&gt;`</span>,</div><div class="line">  data: globalObj</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  template:</div><div class="line">     <span class="string">`&lt;div&gt;</span></div><div class="line"><span class="string">        &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></div><div class="line"><span class="string">     &lt;div&gt;`</span>,</div><div class="line">  data: globalObj</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？</p><p>对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。</p><p>即：在 getter 中收集依赖，在 setter 中触发依赖。</p><hr><h3 id="依赖收集到哪里（Dep）"><a href="#依赖收集到哪里（Dep）" class="headerlink" title="依赖收集到哪里（Dep）"></a>依赖收集到哪里（Dep）</h3><p> 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">constructor</span> () &#123;</div><div class="line">    <span class="keyword">this</span>.subs = [] <span class="comment">// 观察者集合</span></div><div class="line">  &#125;</div><div class="line"> <span class="comment">// 添加观察者</span></div><div class="line">  addSub (sub) &#123;</div><div class="line">    <span class="keyword">this</span>.subs.push(sub)</div><div class="line">  &#125;</div><div class="line"> <span class="comment">// 移除观察者</span></div><div class="line">  removeSub (sub) &#123;</div><div class="line">    remove(<span class="keyword">this</span>.subs, sub)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  depend () &#123; <span class="comment">// 如果存在 Dep.target，则进行依赖收集操作</span></div><div class="line">    <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">      <span class="keyword">this</span>.addSub(Dep.target)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  notify () &#123;</div><div class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice() <span class="comment">// 避免污染原来的集合</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</div><div class="line">      subs[i].update() <span class="comment">// 更新</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arr.length) &#123;</div><div class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</div><div class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>改造 defineReactive</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">     enumerable: <span class="literal">true</span>,</div><div class="line">     configurable: <span class="literal">true</span>,</div><div class="line">     get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        dep.depend()</div><div class="line">           <span class="keyword">return</span> val</div><div class="line">     &#125;,</div><div class="line">     set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">           <span class="keyword">return</span> </div><div class="line">        &#125;</div><div class="line">        val = newVal</div><div class="line">        dep.notify()</div><div class="line">     &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="什么是依赖"><a href="#什么是依赖" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。</p><p>然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。</p><p>收集谁？Watcher!</p><hr><h3 id="什么是-Watcher"><a href="#什么是-Watcher" class="headerlink" title="什么是 Watcher"></a>什么是 Watcher</h3><p>Watcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm.$watch(<span class="string">'a.b.c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。</p><p>把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">constructor</span> (</div><div class="line">    vm: Component, // 组件实例</div><div class="line">    expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作</div><div class="line">    cb: Function // 被观察者发生变化后的回调</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">this</span>.vm = vm <span class="comment">// Watcher有一个 vm 属性，表明它是属于哪个组件的</span></div><div class="line">    <span class="keyword">this</span>.cb = cb <span class="comment">// 回调</span></div><div class="line">    <span class="keyword">this</span>.getter = parsePath(expOrFn)</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get () &#123; <span class="comment">// 触发取值操作，进而触发属性的getter</span></div><div class="line">    Dep.target = <span class="keyword">this</span></div><div class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm)</div><div class="line">    Dep.target = <span class="literal">null</span></div><div class="line">    <span class="keyword">return</span> value</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  update () &#123; <span class="comment">// 更新</span></div><div class="line">    <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</div><div class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.value, oldValue)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。</p><p>在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。</p><p>只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。</p><p>依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。</p><p>不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。</p><p>parsePath函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">'.'</span>)</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></div><div class="line">      obj = obj[segments[i]]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="递归侦测所有Key"><a href="#递归侦测所有Key" class="headerlink" title="递归侦测所有Key"></a>递归侦测所有Key</h3><p>前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value</div><div class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">            <span class="keyword">this</span>.walk(value)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    walk (obj) &#123;</div><div class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">            defineReactive (obj, keys[i], obj[keys[i]])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'object'</span>) &#123;</div><div class="line">      <span class="keyword">new</span> Observer(val)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">       enumerable: <span class="literal">true</span>,</div><div class="line">       configurable: <span class="literal">true</span>,</div><div class="line">       get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          dep.depend()</div><div class="line">             <span class="keyword">return</span> val</div><div class="line">       &#125;,</div><div class="line">       set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">          <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">             <span class="keyword">return</span> </div><div class="line">          &#125;</div><div class="line">          val = newVal</div><div class="line">          dep.notify()</div><div class="line">       &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Observer 类，用于将一个正常的 object 转换成被侦测的 object。</p><p>判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。</p><p>最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。</p><p>当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。</p><p>Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。</p><p>我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。</p><p>收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。</p><p>所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。</p><p>Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。</p><p>由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。</p><p>在 Vue 中，对象新增属性或删除属性都无法被侦测到。</p><p><img src="https://screenshot.net/zh/qv9nwto" alt=""></p><p>Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。</p><p>当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。</p><p>当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。</p><p>Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JS-执行上下文和执行上下文栈</title>
    <link href="http://yoursite.com/2019/07/26/JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <id>http://yoursite.com/2019/07/26/JS-执行上下文和执行栈/</id>
    <published>2019-07-26T07:18:52.000Z</published>
    <updated>2019-07-26T07:28:37.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文栈用于存储在代码执行期间创建的所有执行上下文。</p></blockquote><a id="more"></a><h2 id="理解执行上下文和执行上下文栈"><a href="#理解执行上下文和执行上下文栈" class="headerlink" title="理解执行上下文和执行上下文栈"></a>理解执行上下文和执行上下文栈</h2><h3 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h3><p>执行上下文总共有三种类型：</p><ul><li><p>全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 会指向这个全局对象。</p></li><li><p>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p></li><li><p>Eval 函数执行上下文：运行在 Eval 函数中的代码。</p></li></ul><hr><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>接下来问题来了，我们写了那么多函数，如何管理创建的那么多执行上下文呢？</p><p>Javascript 创建了执行上下文栈，也叫调用栈，来管理在代码执行期间创建的所有执行上下文。</p><p>首次运行 Javascript 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。</p><p>根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从栈中 Pop 出，上下文控制权将会移到当前执行栈的下一个执行上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'Hello World!'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Inside first function'</span>);  </div><div class="line">  second();  </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Again inside first function'</span>);  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Inside second function'</span>);  </div><div class="line">&#125;</div><div class="line"></div><div class="line">first();  </div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Inside Global Execution Context'</span>);</div></pre></td></tr></table></figure><p><img src="&#39;https://user-gold-cdn.xitu.io/2018/11/5/166e258e1d0281a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#39;" alt=""></p><hr><h3 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h3><p>执行上下文分为两个阶段创建：1） 创建阶段 2）执行阶段</p><h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><ul><li><p>确定 this 的值，也被称为 This Binding</p></li><li><p>LexicalEnvironment-词法环境组件被创建</p></li><li><p>VariableEnvironment-变量环境组件被创建</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ExecutionContext = &#123;</div><div class="line">    ThisBinding: <span class="xml"><span class="tag">&lt;<span class="name">this</span> <span class="attr">value</span>&gt;</span>, // 确定 this</span></div><div class="line"><span class="xml">    LexicalEnvironment: &#123;...&#125;, // 词法环境</span></div><div class="line"><span class="xml">    VariableEnvironment: &#123;...&#125; // 变量环境</span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure><h5 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h5><ul><li><p>全局执行上下文中，this 指向全局对象，在浏览器中 this 的值指向 window 对象，而在 nodejs 中指向这个文件的 module 对象。</p></li><li><p>函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显示绑定、new 绑定等。</p></li></ul><h5 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h5><p>词法环境有两个组成部分：</p><ul><li><p>环境记录：存储变量和函数声明的实际位置</p></li><li><p>对外部环境的引用：可以访问其外部词法环境</p></li></ul><p>词法环境有两种类型：</p><ul><li><p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window）及其关联的方法和属性以及任何用户自定义的全局变量， this 的值指向这个全局对象。</p></li><li><p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境，</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">GlobalExectionContext = &#123;  <span class="comment">// 全局执行上下文</span></div><div class="line">  LexicalEnvironment: &#123;          <span class="comment">// 词法环境</span></div><div class="line">    EnvironmentRecord: &#123;          <span class="comment">// 环境记录</span></div><div class="line">      Type: <span class="string">"Object"</span>,                <span class="comment">// 全局环境</span></div><div class="line">      <span class="comment">// 标识符绑定在这里 </span></div><div class="line">      outer: <span class="xml"><span class="tag">&lt;<span class="name">null</span>&gt;</span>                 // 对外部环境的引用</span></div><div class="line"><span class="xml">  &#125;  </span></div><div class="line"><span class="xml">&#125;</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">FunctionExectionContext = &#123; // 函数执行上下文</span></div><div class="line"><span class="xml">  LexicalEnvironment: &#123;     // 词法环境</span></div><div class="line"><span class="xml">      EnvironmentRecord: &#123;      // 环境记录</span></div><div class="line"><span class="xml">        Type: "Declarative",        // 函数环境</span></div><div class="line"><span class="xml">        // 标识符绑定在这里          // 对外部环境的引用</span></div><div class="line">        outer: &lt;Global or outer function environment reference&gt;  </div><div class="line">    &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure><h5 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h5><p>  变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>  在ES6中，词法环境和变量环境的区别在于前者用于存储函数声明和变量(let const)绑定，后者仅用于存储变量(var)绑定。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">GlobalExectionContext = &#123;</div><div class="line"></div><div class="line">  ThisBinding: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">  LexicalEnvironment: &#123;  </span></div><div class="line"><span class="xml">    EnvironmentRecord: &#123;  </span></div><div class="line"><span class="xml">      Type: "Object",  </span></div><div class="line"><span class="xml">      // 标识符绑定在这里  </span></div><div class="line"><span class="xml">      a: <span class="tag">&lt; <span class="attr">uninitialized</span> &gt;</span>,  </span></div><div class="line"><span class="xml">      b: <span class="tag">&lt; <span class="attr">uninitialized</span> &gt;</span>,  </span></div><div class="line"><span class="xml">      multiply: <span class="tag">&lt; <span class="attr">func</span> &gt;</span>  </span></div><div class="line"><span class="xml">    &#125;  </span></div><div class="line">    outer: &lt;null&gt;  </div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  VariableEnvironment: &#123;  </div><div class="line">    EnvironmentRecord: &#123;  </div><div class="line">      Type: "Object",  </div><div class="line">      // 标识符绑定在这里  </div><div class="line">      c: undefined,  </div><div class="line">    &#125;  </div><div class="line">    outer: &lt;null&gt;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">FunctionExectionContext = &#123;  </div><div class="line">   </div><div class="line">  ThisBinding: &lt;Global Object&gt;,</div><div class="line">  </div><div class="line">  LexicalEnvironment: &#123;  </div><div class="line">    EnvironmentRecord: &#123;  </div><div class="line">      Type: "Declarative",  </div><div class="line">      // 标识符绑定在这里  </div><div class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,  </div><div class="line">    &#125;,  </div><div class="line">    outer: &lt;GlobalLexicalEnvironment&gt;  </div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  VariableEnvironment: &#123;  </div><div class="line">    EnvironmentRecord: &#123;  </div><div class="line">      Type: "Declarative",  </div><div class="line">      // 标识符绑定在这里  </div><div class="line">      g: undefined  </div><div class="line">    &#125;,  </div><div class="line">    outer: &lt;GlobalLexicalEnvironment&gt;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined (var 情况下) 或保持未初始化 (let、const 情况下)。所以这就是为什么可以在声明之前访问 var 定义的变量，如果在声明之前访问 let 和 const 定义的变量会提示引用错误的原因。这就是所谓的变量提升。</p><h5 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h5><p>  执行上下文的代码分为两个阶段进行处理：</p><ul><li><p>进入执行上下文</p></li><li><p>代码执行</p><h6 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h6><p>此时的变量对象包括（如下顺序初始化）：</p></li><li><p>函数所有的形参：没有实参，属性值设为 undefined。</p></li><li><p>函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li><li><p>变量声明：如果变量名称与已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">  b = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>);</div></pre></td></tr></table></figure></li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AO = &#123;</div><div class="line">    <span class="built_in">arguments</span>: &#123;</div><div class="line">        <span class="number">0</span>: <span class="number">1</span>,</div><div class="line">        length: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    b: <span class="literal">undefined</span>,</div><div class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">    d: <span class="literal">undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  形参 arguments 已经有值了，但是变量还是 undefined，只是初始化的值。</p><h6 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h6><p>  这个阶段会顺序执行代码，并修改变量的值。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AO = &#123;</div><div class="line">    <span class="built_in">arguments</span>: &#123;</div><div class="line">        <span class="number">0</span>: <span class="number">1</span>,</div><div class="line">        length: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    b: <span class="number">3</span>,</div><div class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">    d: reference to FunctionExpression <span class="string">"d"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  总结如下：</p><ul><li><p>全局上下文的变量对象初始化是全局对象。</p></li><li><p>函数上下文的变量对象初始化只包括 arguments 对象。</p></li><li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值。</p></li><li><p>在代码执行阶段，会再次修改变量对象的属性值。</p></li></ul><h2 id="深入执行上下文和执行上下文栈"><a href="#深入执行上下文和执行上下文栈" class="headerlink" title="深入执行上下文和执行上下文栈"></a>深入执行上下文和执行上下文栈</h2><p>JS 是单线程的语言，执行顺序是顺序执行，但是 JS 引擎并不是一行一行地分析和执行代码，而是一段一段地分析和执行，先进行编译然后才是执行。</p><p>有如下两段代码，执行结果是一样的，但是两段代码究竟有什么不同？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> scope;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> f();</div><div class="line">&#125;</div><div class="line">checkscope();</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> scope;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> f;</div><div class="line">&#125;</div><div class="line">checkscope()();</div></pre></td></tr></table></figure><p>答案是执行上下文栈的变化不一样。</p><p>第一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ECStack.push(<span class="xml"><span class="tag">&lt;<span class="name">checkscope</span>&gt;</span> functionContext);</span></div><div class="line">ECStack.push(&lt;f&gt; functionContext);</div><div class="line">ECStack.pop();</div><div class="line">ECStack.pop();</div></pre></td></tr></table></figure><p>第二段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ECStack.push(<span class="xml"><span class="tag">&lt;<span class="name">checkscope</span>&gt;</span> functionContext);</span></div><div class="line"><span class="xml">ECStack.pop();</span></div><div class="line">ECStack.push(&lt;f&gt; functionContext);</div><div class="line">ECStack.pop();</div></pre></td></tr></table></figure><h3 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h3><p>在函数执行上下文中，用活动对象来表示变量对象。</p><p>活动对象和变量对象的区别在于：</p><ul><li><p>变量对象是规范上或 JS 引擎上实现的，并不能在 JS 环境中直接访问。</p></li><li><p>当进入到一个执行上下文后，这个变量对象会被激活，所以叫活动对象，这时活动对象上的各种属性才能被访问。</p></li></ul><p>调用函数时，会自动为其创建一个 arguments 对象，并初始化局部变量 arguments。所有作为参数传入的值都会成为 arguments 对象的数组元素。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5bf3d20ff265da61776b95da" target="_blank" rel="external">理解JavaScript 中的执行上下文和执行栈</a></li><li><a href="https://juejin.im/post/5bf3d20ff265da61776b95da" target="_blank" rel="external">JavaScript深入之执行上下文栈和变量对象</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文栈用于存储在代码执行期间创建的所有执行上下文。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Node-NodeJS核心基础知识</title>
    <link href="http://yoursite.com/2019/06/26/Node-NodeJS%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/06/26/Node-NodeJS核心基础知识/</id>
    <published>2019-06-26T15:11:52.000Z</published>
    <updated>2019-07-07T11:26:33.333Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…</p></blockquote><a id="more"></a><h3 id="Nodejs-概述"><a href="#Nodejs-概述" class="headerlink" title="Nodejs 概述"></a>Nodejs 概述</h3><p>Nodejs 是基于 Chrome V8 引擎构建的，由事件循环分布 I/O 任务，最终工作线程会将任务放到线程池中执行，而事件循环等待执行结果就可以了。</p><ul><li><p>Nodejs 是 Javascript 的运行时环境。</p></li><li><p>Nodejs 构建在 Chrome V8 这个著名的 Javascript 引擎上。</p></li><li><p>Nodejs 每个函数都是同步的，而 I/O 操作是异步的。</p></li><li><p>Nodejs 使用 npm 作为包管理器。</p></li></ul><h3 id="Nodejs-安装"><a href="#Nodejs-安装" class="headerlink" title="Nodejs 安装"></a>Nodejs 安装</h3><p>Nodejs 支持 macOS、Linux 以及 Windows 等多个主流操作系统。</p><h4 id="3m-安装法"><a href="#3m-安装法" class="headerlink" title="3m 安装法"></a>3m 安装法</h4><ul><li><p>nvm 开源的 Nodejs 版本管理器</p></li><li><p>npm Nodejs 包管理端</p></li><li><p>nrm 解决 npm 镜像访问慢的问题。</p></li></ul><h5 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h5><h6 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h6><p>首先，在终端执行如下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -o- https:<span class="comment">//raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</span></div></pre></td></tr></table></figure><p>意思是通过 curl 命令下载 install.sh 脚本并执行。执行完成后，重新打开终端窗口，执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi ~<span class="regexp">/.zshrc</span></div></pre></td></tr></table></figure><p>把 nvm 命令的执行路径放到 ~/.zshrc 文件下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> NVM_DIR=<span class="string">"$HOME/.nvm"</span></div><div class="line">[ -s <span class="string">"$NVM_DIR/nvm.sh"</span> ] &amp;&amp; . <span class="string">"$NVM_DIR/nvm.sh"</span></div></pre></td></tr></table></figure><p>执行 source 命令，使系统环境变量生效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~<span class="regexp">/.zshrc</span></div></pre></td></tr></table></figure><p>输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nvm --version</div><div class="line"></div><div class="line"><span class="number">0.33</span><span class="number">.1</span></div></pre></td></tr></table></figure><h6 id="查看可安装的-Nodejs-版本"><a href="#查看可安装的-Nodejs-版本" class="headerlink" title="查看可安装的 Nodejs 版本"></a>查看可安装的 Nodejs 版本</h6><p>安装 Node 之前，需要了解通过 nvm 可以安装哪些版本的 Node。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm ls-remote</div></pre></td></tr></table></figure><ul><li><p>LTS 版本是指长期支持版本，推荐给大部分用户使用，一般在生产环境中使用。</p></li><li><p>Current 版本是指当前正在开发的尝鲜版本，不完全版本，需要经过一段时间的测试、开发和修复 bug 等才能变为 LTS 版本，一般供开发者学习。</p></li></ul><h6 id="安装-Node"><a href="#安装-Node" class="headerlink" title="安装 Node"></a>安装 Node</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm install <span class="number">10.15</span><span class="number">.3</span></div></pre></td></tr></table></figure><p>通过 nvm 安装的 Node 位于用户目录下，而非系统目录下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">which node</div><div class="line">/Users/wangqian/.nvm/versions/node/v10<span class="number">.15</span><span class="number">.3</span>/bin/node</div></pre></td></tr></table></figure><p>默认使用某个 Node 版本来编译代码，需要手动指定一个 default 别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nvm alias <span class="keyword">default</span> node</div><div class="line"><span class="keyword">default</span> -&gt; node (-&gt; v10<span class="number">.15</span><span class="number">.3</span>)</div></pre></td></tr></table></figure><p>此时，输入 node -v，以后在终端的任何地方使用的默认版本都会是你设置的版本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node -v</div><div class="line">v10<span class="number">.15</span><span class="number">.3</span></div></pre></td></tr></table></figure><p>如何使用 nvm 切换 Node 版本？首先安装 Node 8.x</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm install <span class="number">8</span></div></pre></td></tr></table></figure><p>切换到 8.x 版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nvm use <span class="number">8</span></div><div class="line">Now using node v8<span class="number">.16</span><span class="number">.0</span> (npm v6<span class="number">.4</span><span class="number">.1</span>)</div><div class="line">node -v</div><div class="line">v8<span class="number">.16</span><span class="number">.0</span></div></pre></td></tr></table></figure><p>如何知道本机通过 nvm 安装了哪些 Node 版本呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">nvm ls</div><div class="line">-&gt;      v8<span class="number">.16</span><span class="number">.0</span></div><div class="line">       v10<span class="number">.15</span><span class="number">.3</span></div><div class="line"><span class="keyword">default</span> -&gt; node (-&gt; v10<span class="number">.15</span><span class="number">.3</span>)</div><div class="line">node -&gt; stable (-&gt; v10<span class="number">.15</span><span class="number">.3</span>) (<span class="keyword">default</span>)</div><div class="line">stable -&gt; <span class="number">10.15</span> (-&gt; v10<span class="number">.15</span><span class="number">.3</span>) (<span class="keyword">default</span>)</div><div class="line">iojs -&gt; N/A (<span class="keyword">default</span>)</div><div class="line">lts<span class="comment">/* -&gt; lts/dubnium (-&gt; N/A)</span></div><div class="line"><span class="comment">lts/argon -&gt; v4.9.1 (-&gt; N/A)</span></div><div class="line"><span class="comment">lts/boron -&gt; v6.17.1 (-&gt; N/A)</span></div><div class="line"><span class="comment">lts/carbon -&gt; v8.16.0</span></div><div class="line"><span class="comment">lts/dubnium -&gt; v10.16.0 (-&gt; N/A)</span></div></pre></td></tr></table></figure><p>若要经常切换 Node 版本，最痛苦的莫过于全局模块需要重新安装。针对这种情况，nvm 提供了一个很贴心的一键安装全局模块的 nvm reinstall-packages命令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvm reinstall-packages <span class="number">6</span></div></pre></td></tr></table></figure><p>nvm 默认远端下载地址是 <a href="https://nodejs.org/dist，如果想安装自定义的" target="_blank" rel="external">https://nodejs.org/dist，如果想安装自定义的</a> Node 版本，可以指定 nvm 的远端下载地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NVM_NODEJS_ORG_MIRROR=https:<span class="comment">//nodejs.org/download/chakracore-nightly</span></div></pre></td></tr></table></figure><p>对于一些正在测试的尝鲜版本，可以在下面的地址下载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NVM_NODEJS_ORG_MIRROR=https:<span class="comment">//nodejs.org/download/test</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>JS-this、call、apply</title>
    <link href="http://yoursite.com/2019/06/13/JS-this%E3%80%81call%E3%80%81apply/"/>
    <id>http://yoursite.com/2019/06/13/JS-this、call、apply/</id>
    <published>2019-06-13T05:00:52.000Z</published>
    <updated>2019-06-16T09:51:28.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。</p></blockquote><a id="more"></a><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>Javascript 中的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的。</p><h4 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h4><p>在具体实际应用中，this 的指向通常可分为以下4种:</p><ul><li><p>作为对象的方法调用</p></li><li><p>作为普通函数调用</p></li><li><p>作为构造器调用</p></li><li><p>Function.prototype.call、Function.prototype.apply</p></li></ul><h5 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h5><p>当函数作为对象的方法调用时，this 指向该对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">1</span>,</div><div class="line">  getA: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.getA()</div><div class="line"></div><div class="line"><span class="comment">// 1</span></div></pre></td></tr></table></figure><h5 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h5><p>函数作为普通函数调用，此时的 this 总是指向全局对象。在浏览器中，这个全局对象是 window 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()</div><div class="line"><span class="comment">// 1</span></div></pre></td></tr></table></figure><h5 id="作为构造器调用"><a href="#作为构造器调用" class="headerlink" title="作为构造器调用"></a>作为构造器调用</h5><p>当用 new 运算符调用函数时，该函数会返回一个对象。通常情况下，构造器里的 this 就指向返回的这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'sven'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass()</div><div class="line"><span class="built_in">console</span>.log(obj.name)</div><div class="line"><span class="comment">// 'sven'</span></div></pre></td></tr></table></figure><p>如果构造器显式地返回了一个对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'sven'</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    name: <span class="string">'wang'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass()</div><div class="line"><span class="built_in">console</span>.log(obj.name)</div><div class="line"><span class="comment">// wang</span></div></pre></td></tr></table></figure><p>如果构造器不显式地返回任何数据，或者返回一个非对象类型的数据，就不会造成上述问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'sven'</span></div><div class="line">  <span class="keyword">return</span> <span class="string">'wang'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = n</div><div class="line"><span class="built_in">console</span>.log(obj.name)</div><div class="line"><span class="comment">// 'sven'</span></div></pre></td></tr></table></figure><h5 id="Function-prototype-call、Function-prototype-apply"><a href="#Function-prototype-call、Function-prototype-apply" class="headerlink" title="Function.prototype.call、Function.prototype.apply"></a>Function.prototype.call、Function.prototype.apply</h5><p>用 Function.prototype.call、Function.prototype.apply 可以动态改变传入函数的 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  name: <span class="string">'wang'</span>,</div><div class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  name: <span class="string">'zhang'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">obj1.getName()</div><div class="line">obj1.getName.call(obj2)</div><div class="line"></div><div class="line"><span class="comment">// 'wang'</span></div><div class="line"><span class="comment">// 'zhang'</span></div></pre></td></tr></table></figure><hr><h4 id="丢失的-this"><a href="#丢失的-this" class="headerlink" title="丢失的 this"></a>丢失的 this</h4><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'wang'</span>,</div><div class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.getName()</div><div class="line">getName = obj.getName</div><div class="line">getName()</div><div class="line"></div><div class="line"><span class="comment">// 'wang'</span></div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>当调用 obj.getName 时，此时 this 指向 obj 对象，所以输出 ‘wang’。</p><p>当用另外一个变量 getName 来引用 obj.getName，并且调用时，它是被当作普通函数来调用，此时 this 指向 window 对象，所以输出 undefined。</p><hr><h4 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h4><p>在实际开发中，特别是在一些函数式风格的代码编写中，call 和 apply 方法尤为重要。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>call 和 apply 作用一模一样，区别在于传入参数形式的不同。</p><p>apply 接受两个参数，第一个参数指定了函数体内的 this 对象的指向，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。</p><p>call 传入的参数数量不固定，跟 apply 不同的是，第一个参数也是代表函数体内 this 对象的指向，从第二个参数开始，每个参数依此传入函数。</p><p>当使用 call 或者 apply 时，如果我们传入的第一个参数为 null，则函数体内的 this 会指向默认的宿主对象。</p><p>但如果在严格模式下，函数体内的 this 还是为 null。</p><h5 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h5><p>下面将详细介绍 call 和 apply 在实际开发中的用途。</p><h6 id="改变-this-指向"><a href="#改变-this-指向" class="headerlink" title="改变 this 指向"></a>改变 this 指向</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  name: <span class="string">'wang'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  name: <span class="string">'zhang'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> name = <span class="string">'qian'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName () <span class="comment">// 'qian'</span></div><div class="line">getName.call(obj1)  <span class="comment">// 'wang'</span></div><div class="line">getName.call(obj2) <span class="comment">// 'zhang'</span></div></pre></td></tr></table></figure><h6 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h6><p>大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向。即使没有原生的 Function.prototype.bind ，我们也可以自己来模拟：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span> <span class="comment">// 保存原函数</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回一个新的函数</span></div><div class="line">    <span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>) <span class="comment">// 执行新的函数时，会把之前传入的 context 当作新函数体内的 this</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'seven'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;.bind(obj)</div><div class="line"></div><div class="line">func()</div></pre></td></tr></table></figure><p>上述为一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一些，使得可以在 func 函数中预先填入一些参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>, <span class="comment">// 保存原函数</span></div><div class="line">      context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 需要绑定的 this 上下文</span></div><div class="line">      args = [].slice.call(<span class="built_in">arguments</span>) <span class="comment">// 剩余的参数转化为数组</span></div><div class="line">  <span class="built_in">console</span>.log(context)</div><div class="line">  <span class="built_in">console</span>.log(args)</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回一个新韩淑</span></div><div class="line">    <span class="keyword">return</span> self.apply(context, [].concat(args, [].slice.call(<span class="built_in">arguments</span>))) <span class="comment">// 执行新的函数时，把之前传入的 context 当作新函数体内的 this，并且组合两次分别传入的参数，作为新函数的参数</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'seven'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, d</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">  <span class="built_in">console</span>.log([a, b, c, d])</div><div class="line">&#125;.bind(obj, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">func(<span class="number">3</span>, <span class="number">4</span>)</div></pre></td></tr></table></figure><h6 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h6><p>借用方法的第一种场景是”借用构造函数“，通过这种技术，可以实现一些类似继承的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  A.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">B.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="string">'wang'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b.getName()) <span class="comment">// 'wang'</span></div></pre></td></tr></table></figure><p>附：</p><p>函数的参数列表 arguments 是一个类数组对象，并不是真正的数组。</p><p>如果想在 arguments 中添加一个元素，通常会借用 Array.prototype.push</p><p>如果想把 arguments 转换为真正的数组，通常会借用 Array.prototype.slice</p><p>如果想截取 arguments 中的第一个元素，通常会借用 Array.prototype.shift</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue-源码系列随读笔记之Object变化侦测</title>
    <link href="http://yoursite.com/2019/05/16/Vue-%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E9%9A%8F%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8BObject%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/05/16/Vue-源码系列随读笔记之Object变化侦测/</id>
    <published>2019-05-16T10:34:52.000Z</published>
    <updated>2019-08-17T17:08:47.848Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档</p></blockquote><a id="more"></a><h3 id="什么是变化侦测"><a href="#什么是变化侦测" class="headerlink" title="什么是变化侦测"></a>什么是变化侦测</h3><p>从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。</p><p>简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。</p><p>Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。</p><hr><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">     enumerable: <span class="literal">true</span>,</div><div class="line">     configurable: <span class="literal">true</span>,</div><div class="line">     get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> val</div><div class="line">     &#125;,</div><div class="line">     set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">           <span class="keyword">return</span> </div><div class="line">        &#125;</div><div class="line">        val = newVal</div><div class="line">     &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。</p><p>由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。</p><hr><h3 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h3><p>思考以下问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> globalObj = &#123;</div><div class="line">  text1: <span class="string">'text1'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  template:</div><div class="line">    <span class="string">`&lt;div&gt;</span></div><div class="line"><span class="string">       &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></div><div class="line"><span class="string">    &lt;div&gt;`</span>,</div><div class="line">  data: globalObj</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  template:</div><div class="line">     <span class="string">`&lt;div&gt;</span></div><div class="line"><span class="string">        &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></div><div class="line"><span class="string">     &lt;div&gt;`</span>,</div><div class="line">  data: globalObj</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？</p><p>对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。</p><p>即：在 getter 中收集依赖，在 setter 中触发依赖。</p><hr><h3 id="依赖收集到哪里（Dep）"><a href="#依赖收集到哪里（Dep）" class="headerlink" title="依赖收集到哪里（Dep）"></a>依赖收集到哪里（Dep）</h3><p> 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">constructor</span> () &#123;</div><div class="line">    <span class="keyword">this</span>.subs = [] <span class="comment">// 观察者集合</span></div><div class="line">  &#125;</div><div class="line"> <span class="comment">// 添加观察者</span></div><div class="line">  addSub (sub) &#123;</div><div class="line">    <span class="keyword">this</span>.subs.push(sub)</div><div class="line">  &#125;</div><div class="line"> <span class="comment">// 移除观察者</span></div><div class="line">  removeSub (sub) &#123;</div><div class="line">    remove(<span class="keyword">this</span>.subs, sub)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  depend () &#123; <span class="comment">// 如果存在 Dep.target，则进行依赖收集操作</span></div><div class="line">    <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">      <span class="keyword">this</span>.addSub(Dep.target)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  notify () &#123;</div><div class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice() <span class="comment">// 避免污染原来的集合</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</div><div class="line">      subs[i].update() <span class="comment">// 更新</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (arr.length) &#123;</div><div class="line">    <span class="keyword">const</span> index = arr.indexOf(item)</div><div class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>改造 defineReactive</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">     enumerable: <span class="literal">true</span>,</div><div class="line">     configurable: <span class="literal">true</span>,</div><div class="line">     get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        dep.depend()</div><div class="line">           <span class="keyword">return</span> val</div><div class="line">     &#125;,</div><div class="line">     set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">           <span class="keyword">return</span> </div><div class="line">        &#125;</div><div class="line">        val = newVal</div><div class="line">        dep.notify()</div><div class="line">     &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="什么是依赖"><a href="#什么是依赖" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。</p><p>然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。</p><p>收集谁？Watcher!</p><hr><h3 id="什么是-Watcher"><a href="#什么是-Watcher" class="headerlink" title="什么是 Watcher"></a>什么是 Watcher</h3><p>Watcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm.$watch(<span class="string">'a.b.c'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。</p><p>把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">constructor</span> (</div><div class="line">    vm: Component, // 组件实例</div><div class="line">    expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作</div><div class="line">    cb: Function // 被观察者发生变化后的回调</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">this</span>.vm = vm <span class="comment">// Watcher有一个 vm 属性，表明它是属于哪个组件的</span></div><div class="line">    <span class="keyword">this</span>.cb = cb <span class="comment">// 回调</span></div><div class="line">    <span class="keyword">this</span>.getter = parsePath(expOrFn)</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get () &#123; <span class="comment">// 触发取值操作，进而触发属性的getter</span></div><div class="line">    Dep.target = <span class="keyword">this</span></div><div class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm)</div><div class="line">    Dep.target = <span class="literal">null</span></div><div class="line">    <span class="keyword">return</span> value</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  update () &#123; <span class="comment">// 更新</span></div><div class="line">    <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</div><div class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.value, oldValue)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。</p><p>在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。</p><p>只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。</p><p>依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。</p><p>不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。</p><p>parsePath函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">'.'</span>)</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></div><div class="line">      obj = obj[segments[i]]</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="递归侦测所有Key"><a href="#递归侦测所有Key" class="headerlink" title="递归侦测所有Key"></a>递归侦测所有Key</h3><p>前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value</div><div class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">            <span class="keyword">this</span>.walk(value)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    walk (obj) &#123;</div><div class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">            defineReactive (obj, keys[i], obj[keys[i]])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'object'</span>) &#123;</div><div class="line">      <span class="keyword">new</span> Observer(val)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">       enumerable: <span class="literal">true</span>,</div><div class="line">       configurable: <span class="literal">true</span>,</div><div class="line">       get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          dep.depend()</div><div class="line">             <span class="keyword">return</span> val</div><div class="line">       &#125;,</div><div class="line">       set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</div><div class="line">          <span class="keyword">if</span> (val === newVal) &#123;</div><div class="line">             <span class="keyword">return</span> </div><div class="line">          &#125;</div><div class="line">          val = newVal</div><div class="line">          dep.notify()</div><div class="line">       &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Observer 类，用于将一个正常的 object 转换成被侦测的 object。</p><p>判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。</p><p>最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。</p><p>当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。</p><p>Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。</p><p>我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。</p><p>收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。</p><p>所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。</p><p>Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。</p><p>由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。</p><p>在 Vue 中，对象新增属性或删除属性都无法被侦测到。</p><p><img src="https://screenshot.net/zh/qv9nwto" alt=""></p><p>Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。</p><p>当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。</p><p>当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。</p><p>Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JS-数据结构与算法之链表</title>
    <link href="http://yoursite.com/2019/03/25/JS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/03/25/JS-数据结构与算法之链表/</id>
    <published>2019-03-25T12:57:52.000Z</published>
    <updated>2019-03-25T12:24:33.483Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>使用列表对数据进行排序，底层储存数据的数据结构是数组。然而，数组并不总是最优选择。</p></blockquote><a id="more"></a>               <hr><h3 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h3><p>数组不总是组织数据的最佳数据结构，原因如下：在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再需要加入新的元素就会非常困难。</p><p>在数组中，添加和删除元素也很麻烦，需要将数组中的其它元素向前或向后移动，以反映数组刚刚进行了添加或删除操作。</p><p>如果你发现数组在实际使用时很慢，就可以考虑使用链表来替代它。除了对数据的随机访问，</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;使用列表对数据进行排序，底层储存数据的数据结构是数组。然而，数组并不总是最优选择。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS-数据结构与算法之队列</title>
    <link href="http://yoursite.com/2019/03/16/JS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/03/16/JS-数据结构与算法之队列/</id>
    <published>2019-03-16T12:57:52.000Z</published>
    <updated>2019-03-23T09:33:40.176Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>队列是一种列表，不同的是，队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。</p></blockquote><a id="more"></a>               <hr><h3 id="对队列的操作"><a href="#对队列的操作" class="headerlink" title="对队列的操作"></a>对队列的操作</h3><p>队列的两种主要操作是：向队列中插入新元素和删除队列中的元素。插入操作也叫做入队，删除操作也叫做出队。入队操作在队尾插入新元素，出队操作删除队头的元素。</p><p>队列的另一项重要操作是读取队头的元素，这个操作叫 peek() 。该操作返回队头元素，但不把它从队列中删除。除了读取队头元素，我们还可以用 length 属性来知道队列中存储了多少元素，用 clear() 方法来清空队列中的元素。</p><p><img src="https://www.oreilly.com/library/view/data-structures-and/9781449373931/images/dsaj_0501.png" alt=""></p><hr><h3 id="用数组实现的队列"><a href="#用数组实现的队列" class="headerlink" title="用数组实现的队列"></a>用数组实现的队列</h3><p>使用数组来实现队列看起来顺理成章。数组的 push() 方法可以在数组末尾加入元素，shift() 方法则可以删除数组的第一个元素。</p><p>push() 方法将它的参数插入数组中第一个开放的位置，该位置总在数组的末尾，即使是个空数组也是如此。</p><p>准备开始实现 Queue 类，先从构造函数开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore = []</div><div class="line">  <span class="keyword">this</span>.enqueue = enqueue</div><div class="line">  <span class="keyword">this</span>.dequeue = dequeue</div><div class="line">  <span class="keyword">this</span>.front = front</div><div class="line">  <span class="keyword">this</span>.back = back</div><div class="line">  <span class="keyword">this</span>.toString = toString</div><div class="line">  <span class="keyword">this</span>.empty = empty</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>enqueue() 方法向队尾添加一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore.push(element)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>dequeue() 方法删除队首的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.shift()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用如下的方法读取队首和队尾的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="number">0</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">back</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.dataStore.length <span class="number">-1</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>toString() 方法显示队列内的所有元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> retStr = <span class="string">''</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; i++) &#123;</div><div class="line">    retStr += <span class="keyword">this</span>.dataStore[i] + <span class="string">' '</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> retStr</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>empty() 方法判断队列是否为空</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">empty</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length === <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="使用队列：方块舞的舞伴分配问题"><a href="#使用队列：方块舞的舞伴分配问题" class="headerlink" title="使用队列：方块舞的舞伴分配问题"></a>使用队列：方块舞的舞伴分配问题</h3><p>男男女女来到舞池，他们按照自己的性别排成两队。当舞池中有地方空出来时，选两个队列中第一个人组成舞伴。他们身后的人各自向前移动一个位置，变成新的队首。当一对舞伴迈入舞池时，主持人会大声喊出他们的名字。当一队舞伴走出舞池，且两排队伍中有任意一队没人时，主持人也会把这个情况告诉大家。</p><p>为了模拟这种情况，我们把跳方块舞的男男女女的姓名储存在 dancers 变量中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dancers = <span class="string">'F Allison \n M Frank \n M Mason \n M Clayton \n F Cheryl \n M Raymond \n F Jennifer \n M Bryan \n M David \n M Danny \n F Aurora'</span></div></pre></td></tr></table></figure><p>每个舞者的信息都被存储在一个 Dancer 对象中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dancer</span> (<span class="params">name, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.sex = sex</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面我们需要一个函数，将舞者信息读到程序中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDancers</span> (<span class="params">maleDancers, femaleDancers</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> names = dancers.split(<span class="string">'\n'</span>)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</div><div class="line">    names[i] = names[i].trim()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> dancer = names[i].split(<span class="string">' '</span>)</div><div class="line">    <span class="keyword">var</span> sex = dancer[<span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> name = dancer[<span class="number">1</span>]</div><div class="line">    <span class="keyword">if</span> (sex === <span class="string">'F'</span>) &#123;</div><div class="line">      femaleDancers.enqueue(<span class="keyword">new</span> Dancer(name, sex))</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      maleDancers.enqueue(<span class="keyword">new</span> Dancer(name, sex))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>舞者的姓名被从变量 dancers 中读入数组。然后 trim() 函数除去了每行字符串的空格。第二个循环将每行字符串按姓名和性别分成两部分存入一个数组。然后根据性别，将舞者加入不同的队列。</p><p>下一个函数将男性和女性组成舞伴，并且宣布配对结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dance</span> (<span class="params">females, males</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'the dance partners are: '</span>)</div><div class="line">  <span class="keyword">let</span> person</div><div class="line">  <span class="keyword">while</span> (!females.empty() &amp;&amp; !males.empty()) &#123;</div><div class="line">    person = females.dequeue()</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'female dancer is '</span>, person)</div><div class="line">    person = males.dequeue()</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'and male dancer is '</span>, person)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="使用队列对数据进行排序"><a href="#使用队列对数据进行排序" class="headerlink" title="使用队列对数据进行排序"></a>使用队列对数据进行排序</h3><p>队列不仅用于执行现实生活中与排队有关的操作，还可以用于对数据进行排序。对于0 ~99 的数字，我们可以基于基数排序对数据扫描两次。第一次按个位上的数字进行排序，第二次按十位上的数字进行排序。每个数字根据对应位上的数值被分在不同的盒子上。假设有以下数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">91, 46, 85, 15, 92, 35, 31, 22</div></pre></td></tr></table></figure><p>经过基数排序第一次扫描之后，数字被分配到如下的盒子里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Bin 0:</div><div class="line">Bin 1: 91, 31</div><div class="line">Bin 2: 92, 22</div><div class="line">Bin 3:</div><div class="line">Bin 4:</div><div class="line">Bin 5: 85, 15, 35</div><div class="line">Bin 6: 46</div><div class="line">Bin 7:</div><div class="line">Bin 8:</div><div class="line">Bin 9:</div></pre></td></tr></table></figure><p>根据盒子的顺序，第一次排序的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">91, 31, 92, 22, 85, 15, 35, 46</div></pre></td></tr></table></figure><p>然后根据十位上的数值再次将上述排序的结果分配到不同的盒子里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Bin 0:</div><div class="line">Bin 1: 15</div><div class="line">Bin 2: 22</div><div class="line">Bin 3: 31, 35</div><div class="line">Bin 4: 46</div><div class="line">Bin 5: </div><div class="line">Bin 6: </div><div class="line">Bin 7: </div><div class="line">Bin 8: 85</div><div class="line">Bin 9: 91, 92</div></pre></td></tr></table></figure><p>最后，将盒子中的数字取出，组成一个新的列表，该列表即为排好序的数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">15， 22， 31， 35， 46， 85， 91， 92</div></pre></td></tr></table></figure><p>使用队列代表盒子，可以实现这个算法。我们需要九个队列，每个对应一个数字，将所有队列保存在一个数组中，使用取余和除法操作决定个位和十位。算法的剩余部分将数字加入相应的队列，根据个位数值对其重新排序，然后再根据十位上的数值进行排序，结果即为排好序的数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore = []</div><div class="line">  <span class="keyword">this</span>.enqueue = enqueue</div><div class="line">  <span class="keyword">this</span>.dequeue = dequeue</div><div class="line">  <span class="keyword">this</span>.front = front</div><div class="line">  <span class="keyword">this</span>.back = back</div><div class="line">  <span class="keyword">this</span>.toString = toString</div><div class="line">  <span class="keyword">this</span>.count = count</div><div class="line">  <span class="keyword">this</span>.empty = empty</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore.push(element)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.shift()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="number">0</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">back</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.dataStore.length <span class="number">-1</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> retStr = <span class="string">''</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; i++) &#123;</div><div class="line">    retStr += <span class="keyword">this</span>.dataStore[i] + <span class="string">' '</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> retStr</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">empty</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length === <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//基数排序</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> queues = []   <span class="comment">//定义队列数组</span></div><div class="line"><span class="keyword">var</span> nums = []     <span class="comment">//定义数字数组</span></div><div class="line"></div><div class="line"><span class="comment">//选十个0~99的随机数进行排序</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</div><div class="line">    queues[i] = <span class="keyword">new</span> Queue()</div><div class="line">    nums[i] = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">101</span> )</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//排序之前</span></div><div class="line"><span class="built_in">console</span>.log( <span class="string">'before radix sort: '</span> + nums )</div><div class="line"></div><div class="line"><span class="comment">//基数排序</span></div><div class="line">distribution(nums, queues , <span class="number">10</span> , <span class="number">1</span>)</div><div class="line">collect(queues, nums)</div><div class="line">distribution(nums, queues , <span class="number">10</span> , <span class="number">10</span>)</div><div class="line">collect(queues, nums)</div><div class="line"></div><div class="line"><span class="comment">//排序之后</span></div><div class="line"><span class="built_in">console</span>.info(<span class="string">'after radix sort: '</span> + nums)</div><div class="line"></div><div class="line"><span class="comment">//根据相应的（个位和十位）数值，将数字分配到相应队列</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">distribution</span> (<span class="params">nums, queues, n, digit</span>) </span>&#123;  <span class="comment">//digit表示个位或者十位的值</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(digit == <span class="number">1</span>)&#123;</div><div class="line">            queues[nums[i] % <span class="number">10</span>].enqueue(nums[i])</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            queues[<span class="built_in">Math</span>.floor(nums[i] / <span class="number">10</span>)].enqueue(nums[i])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="built_in">console</span>.log(queues.toString())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//从队列中收集数字</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collect</span> (<span class="params">queues, nums</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> digit = <span class="number">0</span>; digit &lt; <span class="number">10</span> ; digit++ )&#123;</div><div class="line">        <span class="keyword">while</span> (!queues[digit].empty())&#123;</div><div class="line">            nums[i++] = queues[digit].dequeue()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>一般情况下，从队列中删除元素，一定是最新入队的元素，但是也有一些使用队列的应用，在删除元素时不必遵循先进先出的约定。这种应用，需要使用一个叫做优先队列的数据结构来进行模拟。</p><p>从优先队列中删除元素时，需要考虑优先权的限制。</p><p>先来定义存储队列元素的对象，然后在构建我们的优先队列系统：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Patient</span> (<span class="params">name, code</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.code = code</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>变量 code 是一个整数，表示优先级。</p><p>现在需要重新定义 dequeue() 方法，使其删除队列中拥有最高优先级的元素。我们规定，优先码的值最小，代表优先级最高。新的 dequeue() 方法遍历队列的底层存储数组，从中找出优先码值最小的元素，然后使用数组的 splice() 方法删除优先级最高的元素。新的 dequeue() 方法定义如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> entry = <span class="number">0</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i].code &lt; <span class="keyword">this</span>.dataStore[entry].code) &#123;</div><div class="line">      entry = i</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.splice(entry, <span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>优先队列的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore = []</div><div class="line">  <span class="keyword">this</span>.enqueue = enqueue</div><div class="line">  <span class="keyword">this</span>.dequeue = dequeue</div><div class="line">  <span class="keyword">this</span>.front = front</div><div class="line">  <span class="keyword">this</span>.back = back</div><div class="line">  <span class="keyword">this</span>.toString = toString</div><div class="line">  <span class="keyword">this</span>.count = count</div><div class="line">  <span class="keyword">this</span>.empty = empty</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore.push(element)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> entry = <span class="number">0</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i].code &lt; <span class="keyword">this</span>.dataStore[entry].code) &#123;</div><div class="line">      entry = i</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.splice(entry, <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="number">0</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">back</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.dataStore.length <span class="number">-1</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> retStr = <span class="string">''</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; i++) &#123;</div><div class="line">    retStr += <span class="keyword">this</span>.dataStore[i].name + <span class="string">' code:'</span> + <span class="keyword">this</span>.dataStore[i].code + <span class="string">' '</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> retStr</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">empty</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length === <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Patient</span> (<span class="params">name, code</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.code = code</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Patient(<span class="string">'smith'</span>, <span class="number">5</span>)</div><div class="line"><span class="keyword">var</span> ed = <span class="keyword">new</span> Queue()</div><div class="line">ed.enqueue(p)</div><div class="line">p = <span class="keyword">new</span> Patient(<span class="string">'Jones'</span>, <span class="number">4</span>)</div><div class="line">ed.enqueue(p)</div><div class="line">p = <span class="keyword">new</span> Patient(<span class="string">'Wang'</span>, <span class="number">6</span>)</div><div class="line">ed.enqueue(p)</div><div class="line">p = <span class="keyword">new</span> Patient(<span class="string">'Qian'</span>, <span class="number">1</span>)</div><div class="line">ed.enqueue(p)</div><div class="line">p = <span class="keyword">new</span> Patient(<span class="string">'Brown'</span>, <span class="number">1</span>)</div><div class="line">ed.enqueue(p)</div><div class="line"><span class="keyword">var</span> seen = ed.dequeue()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patient being treated: '</span> + seen[<span class="number">0</span>].name)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patients watting to be seen:'</span>)</div><div class="line"><span class="built_in">console</span>.log(ed.toString())</div><div class="line"></div><div class="line">seen = ed.dequeue()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patient being treated: '</span> + seen[<span class="number">0</span>].name)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patients watting to be seen:'</span>)</div><div class="line"><span class="built_in">console</span>.log(ed.toString())</div><div class="line"></div><div class="line">seen = ed.dequeue()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patient being treated: '</span> + seen[<span class="number">0</span>].name)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Patients watting to be seen:'</span>)</div><div class="line"><span class="built_in">console</span>.log(ed.toString())</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;队列是一种列表，不同的是，队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS-数据结构与算法之栈</title>
    <link href="http://yoursite.com/2019/03/15/JS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88/"/>
    <id>http://yoursite.com/2019/03/15/JS-数据结构与算法之栈/</id>
    <published>2019-03-15T12:57:52.000Z</published>
    <updated>2019-03-18T12:55:26.303Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>栈是和列表类似的一种数据结构，它可以用来解决计算机世界里的很多问题。</p></blockquote><a id="more"></a><hr><h3 id="对栈的操作"><a href="#对栈的操作" class="headerlink" title="对栈的操作"></a>对栈的操作</h3><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈被称为一种后入先出 (LIFO，last-in-first-out) 的数据结构。</p><p>由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，必须先拿掉上面的元素。</p><p>对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用 push() 方法，出栈使用 pop() 方法。</p><p>另一个常用的操作就是预览栈顶的元素。 pop() 方法虽然可以访问到栈顶的元素，但是该方法也将栈顶元素永久性地删除了。peek() 方法则只返回栈顶元素，而不删除它。</p><p><img src="https://www.oreilly.com/library/view/data-structures-and/9781449373931/images/dsaj_0401.png" alt=""></p><p>为了记录栈顶的位置，同时也为了哪里可以加入新元素，我们使用变量 top 。当向栈内压入元素时，该变量增大。当从栈内弹出元素时，该变量减小。</p><p>push()、pop()、peek() 是栈的3个主要方法，但是栈还有其它方法和属性。clear() 清除栈内所有元素，length 属性记录栈内元素的个数，empty 属性，用以表示栈内是否有元素。</p><hr><h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><p>实现一个栈，首先是要决定存储数据的底层数据结构。这里，我们选用数组。</p><p>我们从实现以定义 Stack 类的构造函数开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore = []</div><div class="line">  <span class="keyword">this</span>.top = <span class="number">0</span></div><div class="line">  <span class="keyword">this</span>.push = push</div><div class="line">  <span class="keyword">this</span>.pop = pop</div><div class="line">  <span class="keyword">this</span>.peek = peek</div><div class="line">  <span class="keyword">this</span>.clear = clear</div><div class="line">  <span class="keyword">this</span>.length = length</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们用数组 dataStore 来保存栈内的元素，构造函数将其初始化为一个空数组。变量 top 记录栈顶位置，被构造函数初始化为 0 ，表示栈顶对应数组的起始位置 0 。如果有元素被压入栈内，该变量的值将随之变化。</p><p>push() 方法 – 当向栈内压入一个新元素时，需要将其保存在数组中变量 top 所对应的位置，然后将 top 值加 1，让其指向数组中下一个空位值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top++] = element</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里需要注意 ++ 操作符的位置，它放在 this.top 的后面，这样新入栈的元素就会被放在 top 的当前值指向的位置，然后再将 top 的值加 1 ，指向下一个位置。</p><p>pop() 方法 – 返回栈顶元素，同时将变量 top 的值减 1 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[--<span class="keyword">this</span>.top]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>peek() 方法 – 返回栈顶元素，即将变量 top 的值减 1 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">peek</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top - <span class="number">1</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果对一个空栈调用 peek() 方法，结果为 undefined 。</p><p>length() 方法 – 通过返回变量 top 值得方式来获取栈内存储了多少元素。</p><p>clear() – 将变量 top 的值设为 0 ，轻松清空一个栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.top = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="使用-Stack-类"><a href="#使用-Stack-类" class="headerlink" title="使用 Stack 类"></a>使用 Stack 类</h3><p>在开发过程中，有一些问题特别适合用栈来解决：</p><h4 id="数制间的相互转换"><a href="#数制间的相互转换" class="headerlink" title="数制间的相互转换"></a>数制间的相互转换</h4><p>可以利用栈实现一个数字从一种数制转换为另一种数制。假设想将数字 n 转换为以 b 为基数的数字，实现转换的算法如下(注：此算法只针对基数为2—9的情况)：</p><p>(1) 最高位为 n % b，将此位压入栈。<br>(2) 使用 n / b 代替 n 。<br>(3) 重复步骤 1 和 2 ，直到 n 等于 0 ，且没有余数。<br>(4) 持续将栈内元素弹出，直到栈为空，依次将这些元素排列，就得到转换后数字的字符串形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mulBase</span> (<span class="params">num, base</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Stack()</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    s.push(num % base)</div><div class="line">    num = <span class="built_in">Math</span>.floor(num /= base)</div><div class="line">  &#125; <span class="keyword">while</span> (num &gt; <span class="number">0</span>)</div><div class="line">  <span class="keyword">var</span> converted = <span class="string">''</span></div><div class="line">  <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">    converted += s.pop()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> converted</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h4><p>回文是指这样一种现象：一个单词、短语或数字，从前往后写和从后往前写都是一样的。如：单词 ‘dad’ , ‘racecar’ 就是回文。</p><p>使用栈，可以轻松判断一个字符串是否是回文。我们将拿到的字符串的每个字符从左到右的顺序压入栈。当字符串中的字符都入栈后，栈内就保存了一个反转后的字符串，最后的字符在栈顶，第一个字符在栈底。</p><p><img src="https://www.oreilly.com/library/view/data-structures-and/9781449373931/images/dsaj_0402.png" alt=""></p><p>字符串完整压入栈内后，通过持续弹出栈中的每个字母就可以得到一个新字符串，该字符串刚好与原来的字符串顺序相反。我们只需比较这两个字符串即可，如果它们相等，就是一个回文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span> (<span class="params">word</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Stack()</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> word) &#123;</div><div class="line">    s.push(i)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> rWord = <span class="string">''</span></div><div class="line">  <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">    rWord += s.pop()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> rWord == word</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="递归演示"><a href="#递归演示" class="headerlink" title="递归演示"></a>递归演示</h4><p>为了演示如何用栈实现递归，考虑一下求阶乘函数的递归定义，首先看看 5 的阶乘是怎么定义的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用栈模拟递归的过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Stack()</div><div class="line">  <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</div><div class="line">    s.push(n--)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> product = <span class="number">1</span></div><div class="line">  <span class="built_in">console</span>.log(s.length())</div><div class="line">  <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">    product *= s.pop()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> product</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;栈是和列表类似的一种数据结构，它可以用来解决计算机世界里的很多问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Node-阿里云ECS部署</title>
    <link href="http://yoursite.com/2018/11/27/Node-%E9%98%BF%E9%87%8C%E4%BA%91ECS%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/11/27/Node-阿里云ECS部署/</id>
    <published>2018-11-27T04:19:00.000Z</published>
    <updated>2019-06-04T02:56:38.236Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？</p></blockquote><a id="more"></a><p>此教程仅供新手借鉴，多少有些缺陷，有问题还望各位大佬指正。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>一个域名</li><li>阿里云ECS(实例镜像：CentOS7.4)</li><li>如果使用Windows，推荐xshell。如果是Mac，推荐iTerm2</li></ul><p>(注：因本人使用Mac，以下均已Mac为主)</p><hr><h3 id="终端连接服务器"><a href="#终端连接服务器" class="headerlink" title="终端连接服务器"></a>终端连接服务器</h3><ul><li>打开iTerm2，输入连接命令ssh username@ip公网地址，回车，输入你在购买服务器时设置的密码。</li></ul><p><img src="http://images.gitbook.cn/fb945240-f68e-11e7-b8d1-49d5de1a2fe1" alt=""></p><ul><li>密码输入正确，进入服务器。</li></ul><p><img src="http://images.gitbook.cn/8a21b2f0-f68f-11e7-b8d1-49d5de1a2fe1" alt=""></p><p>cd / 进入根目录，创建一个空目录 mkdir soft，用来放我们的安装包。</p><hr><h3 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h3><p>下载node包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz</div></pre></td></tr></table></figure><p>下载完成后，进行压缩包解压。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf v8.9.4.tar.gz</div></pre></td></tr></table></figure><p>进入解压好的目录并执行config配置命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd node-v8.9.4 &amp;&amp; ./configure</div></pre></td></tr></table></figure><p>执行编译及安装命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p>经过漫长的等待之后，一个node环境就安装好了。可以通过node -v 或者 npm -v来检查当前node/npm是否安装成功。</p><p><img src="http://images.gitbook.cn/aa87c390-f6e4-11e7-b0db-b9b8a7444865" alt=""></p><p>如果你需要升级node和npm版本，执行以下命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm i -g n</div><div class="line">n stable</div></pre></td></tr></table></figure><hr><h3 id="安装nrm和pm2"><a href="#安装nrm和pm2" class="headerlink" title="安装nrm和pm2"></a>安装nrm和pm2</h3><p>nrm是一个管理npm源的插件，方便切换国内外以及私人npm库。</p><p>pm2是node服务器的守护进程，方便管理当前服务器上的所有服务。</p><p>这里说一下cnpm，如果安装依赖包很慢或者根本没进度，输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure><p>然后使用cnpm代替npm安装。</p><p>回到我们熟悉的soft目录。</p><hr><h4 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h4><p>安装nrm。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g nrm</div></pre></td></tr></table></figure><p>常用命令：</p><ul><li>nrm add name address 添加新的源</li><li>nrm use name 切换到源</li><li>nrm ls 查看所有可用的源</li></ul><p><img src="http://images.gitbook.cn/ef923690-f6e5-11e7-b28d-519a9998aa5b" alt=""></p><hr><h4 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h4><p>安装pm2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g pm2</div></pre></td></tr></table></figure><p>常用命令：</p><ul><li>pm2 list 查看pm2守护服务</li><li>pm2 start index.js 启动一个pm2守护进程命令</li><li>pm2 restart id/name 重启一个pm2守护进程命令</li><li>pm2 delete id/name 删除一个正在使用的进程</li><li>pm2 delete all 删除所有正在使用的进程</li><li>pm2 monit 查看pm2的消耗</li></ul><p><img src="http://images.gitbook.cn/24e04d00-f6e6-11e7-b0db-b9b8a7444865" alt=""></p><hr><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>卸载已有的mysql。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rpm -qa|grep -i mysql</div><div class="line">yum remove &apos;mysql&apos;</div></pre></td></tr></table></figure><p>下载mysql源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 5.7.24</div><div class="line">wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm</div></pre></td></tr></table></figure><p>安装下载的源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh mysql57-community-release-el7-7.noarch.rpm</div></pre></td></tr></table></figure><p>下载安装mysql。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum install mysql-server</div><div class="line">yum install mysql-devel</div><div class="line">yum install mysql</div></pre></td></tr></table></figure><p>启动mysql。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysqld start</div></pre></td></tr></table></figure><p>常用命令：</p><ul><li>service mysqld status 查看mysql当前的状态</li><li>service mysqld stop 停止mysql</li><li>service mysqld restart 重启mysql</li><li>service mysqld start 启动mysql</li></ul><p>如果遇到错误：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket /var/lib/mysql/mysql.sock’，请在tmp下创建一个软连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /tmp/mysql.sock /var/lib/mysql</div></pre></td></tr></table></figure><p>打开my.cnf并修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/my.cnf</div></pre></td></tr></table></figure><p><img src="http://images.gitbook.cn/4d980cc0-f6ea-11e7-9a49-93c72a04fa82" alt=""></p><p>重启数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysqld restart</div></pre></td></tr></table></figure><p>登录(默认root是没有密码的)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root</div></pre></td></tr></table></figure><p>这时出现ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)，登录root帐号需要密码，现在我们没有设置密码，哪来的密码。</p><p>于是我们开始忘记密码的操作</p><p>第一步，在/etc/my.cnf文件中添加skip-grant-tables<br>第二步，重启mysql，service mysqld restart<br>第三步，登录mysql，mysql -u root<br>第四步，修改密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt;use mysql;</div><div class="line">mysql&gt;update mysql.user set authentication_string=password(&apos;your password&apos;) where user=&apos;root&apos;;</div><div class="line">mysql&gt;flush privileges;</div><div class="line">mysql&gt;exit;</div></pre></td></tr></table></figure><p>第五步，恢复/etc/my.cnf，将skip-grant-tables删除或者注释掉<br>第六步，重启mysql，service mysqld restart</p><p>分配用户</p><p>host指定该用户在哪个主机上可以登陆，此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录;也可以指定某台机器可以远程登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;</div><div class="line">CREATE USER &apos;test&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;;</div></pre></td></tr></table></figure><p>给创建的用户权限</p><ul><li>privileges 用户的操作权限,如SELECT，INSERT，UPDATE等.如果要授予所的权限则使用ALL</li><li>databasename 数据库名</li><li>tablename 表名,如果要授予该用户对所有数据库和表的相应操作权限则可用表示, 如.*.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos;</div></pre></td></tr></table></figure><hr><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><p>Redis是一个非常好用的数据仓库，既可以做nosql数据库，也可以做缓存数据库。</p><p>下载安装包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-4.0.6.tar.gz</div></pre></td></tr></table></figure><p>解压并进入解压之后的文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf redis-4.0.6.tar.gz &amp;&amp;cd redis-4.0.6</div></pre></td></tr></table></figure><p>编译并安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p>启动redis服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server redis.conf</div></pre></td></tr></table></figure><p><img src="http://images.gitbook.cn/9ab114d0-f82e-11e7-b753-f548c55dc4dd" alt=""></p><p>此时我们发现，不能再输入任何命令，因为redis-server已经占用了这个命令行客户端。我们需要再打开一个命令行工具并连接服务器。</p><p>使用redis客户端连接Redis服务，执行Redis文件夹下的redis-cli文件redis-cli，输入几个命令测试一下简单的set/get：</p><p><img src="http://images.gitbook.cn/c4d479e0-f82f-11e7-bec2-d1185e7bb6e2" alt=""></p><p>关掉客户端，redis服务也会停止。这时，我们就需要修改redis.conf文件，将daemonizede的值改为yes。</p><p><img src="http://images.gitbook.cn/afb6f050-f830-11e7-b753-f548c55dc4dd" alt=""></p><p>再次运行Redis的启动命令redis-server redis.conf，这次就不会占用命令行了，可以继续操作其他的，Redis服务也不会停止。</p><hr><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>nginx在转发请求，负载均衡等方面非常有用。它可以将几个不同的服务集中在一个80端口下，根据域名或者请求路径来区分。</p><p>在安装nginx之前，先要安装几个依赖插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install -y pcre pcre-devel</div><div class="line">yum install -y zlib zlib-devel</div></pre></td></tr></table></figure><p>安装openssl。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y openssl openssl-devel</div></pre></td></tr></table></figure><p>下载nginx包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://nginx.org/download/nginx-1.15.6.tar.gz</div></pre></td></tr></table></figure><p>解压并进入解压好的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf nginx-1.15.6.tar.gz &amp;&amp; cd nginx-1.15.6</div></pre></td></tr></table></figure><p>执行配置命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure</div></pre></td></tr></table></figure><p>编译并安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p>查看安装结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">whereis nginx</div></pre></td></tr></table></figure><p><img src="http://images.gitbook.cn/d892e470-f835-11e7-b753-f548c55dc4dd" alt=""></p><p>跳转到安装好的nginx目录下，进入sbin目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/nginx/sbin</div></pre></td></tr></table></figure><p>启动nginx。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./nginx</div></pre></td></tr></table></figure><p>常用命令：</p><ul><li>./nginx 启动nginx</li><li>./nginx -s stop 停止nginx</li><li>./nginx -s quit 退出nginx</li><li>./nginx -s reload 重启nginx</li></ul><hr><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>centOS上没有安装git，有需要的话，我们可以自己手动安装一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install git</div><div class="line">git --version</div></pre></td></tr></table></figure><hr><h3 id="使用pm2启动项目"><a href="#使用pm2启动项目" class="headerlink" title="使用pm2启动项目"></a>使用pm2启动项目</h3><p>在本地搭建并测试好node项目，上传到GitHub。然后git clone一下。</p><p>配置ECS安全组规则，暴露3000接口。</p><p>如果项目中使用数据库，运行之前要先建立好数据库，然后再运行项目，登录数据库执行create database dabasename;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/***</div><div class="line">cd ***</div><div class="line">cnpm i</div><div class="line">pm2 start index.js</div></pre></td></tr></table></figure><p>注：项目监听3000端口，如果顺利的话，项目已经运行起来了。<br>   可以使用pm2 list查看进程列表，使用pm2 log打印日志。</p><hr><h3 id="Linux常用操作指令列表"><a href="#Linux常用操作指令列表" class="headerlink" title="Linux常用操作指令列表"></a>Linux常用操作指令列表</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ssh username@ip</td><td>连接服务器</td></tr><tr><td>cd path</td><td>跳转到路径对应的目录下</td></tr><tr><td>rm filename</td><td>删除文件</td></tr><tr><td>rm -rf path</td><td>删除目录及目录下的所有文件</td></tr><tr><td>ls [-a]</td><td>查看当前目录下的文件和目录(-a：查看所有文件，包括隐藏文件)</td></tr><tr><td>ll</td><td>查看当前目录下的文件详情(文件权限)</td></tr><tr><td>pwd</td><td>查看当前路径的完整路径</td></tr><tr><td>which name</td><td>默认位置查找该名字</td></tr><tr><td>mkdir dirname</td><td>创建空目录</td></tr><tr><td>cat path</td><td>查看文件内容</td></tr><tr><td>cp origin target</td><td>复制一个文件到另一个地方</td></tr><tr><td>mv origin target</td><td>移动一个文件到另一个地方</td></tr><tr><td>ps -aux</td><td>显示当前进程</td></tr><tr><td>kill -9 processid</td><td>结束进程</td></tr><tr><td>tar -zxvf filename</td><td>解压文件</td></tr><tr><td>tar -zcvf filename</td><td>压缩文件</td></tr><tr><td>vi path</td><td>进入文件编辑模式</td></tr><tr><td>vi编辑文件，按下i进入编辑模式</td></tr><tr><td>vi退出文件，esc+:wq或esc+:x保存退出</td></tr><tr><td>vi退出文件，esc+:q或esc+:q!强制退出</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>JS-深拷贝与浅拷贝</title>
    <link href="http://yoursite.com/2018/10/11/JS-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/10/11/JS-深拷贝与浅拷贝/</id>
    <published>2018-10-11T10:11:52.000Z</published>
    <updated>2018-12-11T14:03:41.509Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。</p></blockquote><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = &#123;x: 10, y: 10&#125;</div><div class="line">var b = a</div><div class="line">b.x = 100</div><div class="line">b.y = 100</div></pre></td></tr></table></figure><p>打印一下a和b的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(a) // &#123;x: 100, y: 200&#125;</div><div class="line">console.log(b) // &#123;x: 100, y: 200&#125;</div></pre></td></tr></table></figure><p>发现改变b的值，同时也改了a的值。</p><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = 10</div><div class="line">var b = a</div><div class="line">b = 20</div></pre></td></tr></table></figure><p>打印一下a和b的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(a) // 10</div><div class="line">console.log(b) // 20</div></pre></td></tr></table></figure><p>??? b的值改变并没有引起a的值改变。</p><hr><h3 id="值类型-vs-引用类型"><a href="#值类型-vs-引用类型" class="headerlink" title="值类型 vs 引用类型"></a>值类型 vs 引用类型</h3><p>在JS中，变量传递方式分为值类型和引用类型。值类型包括String，Number，Null，Boolean，Undefined。引用类型包括Object类的所有，如Date，Array，Function。</p><p>在参数传递方式上，值类型是按值传递。引用类型是按共享传递(指向同一个内存地址，两者引用同一个值，当一者改变值，另一者也改变)。</p><p>JS这样设计的原因在于：按值传递的类型，复制一份存入栈内存，这类类型一般不会占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值，保证过大的对象等不会因为不停复制内容而造成内存的浪费。</p><p>深拷贝和浅拷贝最根本的区别在于是否真正获取了一个对象的拷贝实体，而不只是引用。</p><hr><h3 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h3><h4 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;username: &apos;kobe&apos;, age: 39, sex: &#123;option1: &apos;男&apos;, option2: &apos;女&apos;&#125;&#125;</div><div class="line">let obj1 = obj</div><div class="line">obj1.sex.option1 = &apos;不男不女&apos; // 修改复制的对象会影响原对象</div></pre></td></tr></table></figure><p>打印obj1的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(obj1) // &#123;username: &apos;kobe&apos;, age: 39, sex: &#123;option1: &apos;不男不女&apos;, option2: &apos;女&apos;&#125;&#125;</div></pre></td></tr></table></figure><hr><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">  username: &apos;kobe&apos;</div><div class="line">&#125;;</div><div class="line">let obj1 = Object.assign(obj)</div><div class="line">obj1.username = &apos;wang&apos;</div></pre></td></tr></table></figure><p>打印obj的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(obj) // &#123; username: &quot;wang&quot; &#125;</div></pre></td></tr></table></figure><hr><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat"></a>Array.prototype.concat</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let arr = [1, 3, &#123;</div><div class="line">    username: &apos;kobe&apos;</div><div class="line">&#125;]</div><div class="line">let arr2=arr.concat()</div><div class="line">arr2[2].username = &apos;wang&apos;</div></pre></td></tr></table></figure><p>打印arr的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(arr) // [1, 3, &#123; username: &quot;wade&quot; &#125;]</div></pre></td></tr></table></figure><hr><h4 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice"></a>Array.prototype.slice</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let arr = [1, 3, &#123;</div><div class="line">    username: &apos;kobe&apos;</div><div class="line">&#125;]</div><div class="line">let arr2=arr.slice()</div><div class="line">arr2[2].username = &apos;wang&apos;</div></pre></td></tr></table></figure><p>打印arr的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(arr) // [1, 3, &#123; username: &quot;wade&quot; &#125;]</div></pre></td></tr></table></figure><hr><h4 id="Array-prototype-concat-vs-Array-prototype-slice"><a href="#Array-prototype-concat-vs-Array-prototype-slice" class="headerlink" title="Array.prototype.concat vs Array.prototype.slice"></a>Array.prototype.concat vs Array.prototype.slice</h4><p>关于Array的concat和slice补充说明：Array的concat和slice方法不改变原始数组，只是返回了一个浅复制原数组中的元素的一个新数组。</p><p>原数组中的元素会按照下述规则拷贝：</p><ul><li><p>如果该元素是个引用类型，slice或者concat会拷贝这个引用到新的数组里，两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新数组和原数组中的这个元素都会发生改变。</p></li><li><p>如果该元素是个值类型，slice或者concat会复制一份这些值到新数组里。在别的数组里修改这些值，并不会影响另一个数组。</p></li></ul><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let arr = [1, 3, &#123;</div><div class="line">    username: &apos;kobe&apos;</div><div class="line">&#125;];</div><div class="line">let arr3 = arr.slice();</div><div class="line">arr3[1] = 2</div><div class="line">console.log(arr, arr3)</div></pre></td></tr></table></figure><p>打印arr和arr3的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(arr, arr3)</div><div class="line">// ---result</div><div class="line">// [1, 3, &#123; username: &quot;kobe&quot; &#125;]</div><div class="line">// [1, 2, &#123; username: &quot;kobe&quot; &#125;]</div></pre></td></tr></table></figure><hr><h3 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h3><h4 id="Object-assign-1"><a href="#Object-assign-1" class="headerlink" title="Object.assign"></a>Object.assign</h4><p>Object.assign可以进行一层深度拷贝</p><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj1 = Object.assign(&#123;&#125;, obj1)</div><div class="line">obj1.age = 24</div><div class="line">console.log(obj, obj1)</div></pre></td></tr></table></figure><p>打印obj和obj1的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(obj, obj1)</div><div class="line">// ----result</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;  &#125; &#125;</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;  &#125;, age: 24 &#125;</div></pre></td></tr></table></figure><p>然而。。。。。</p><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj1 = Object.assign(&#123;&#125;, obj1)</div><div class="line">obj1.test4.age = 24</div></pre></td></tr></table></figure><p>打印obj和obj1的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(obj, obj1)</div><div class="line">// ----result</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; age: 24 &#125; &#125;</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; age: 24 &#125; &#125;</div></pre></td></tr></table></figure><hr><h4 id="JSON-parse-JSON-stringfy-obj"><a href="#JSON-parse-JSON-stringfy-obj" class="headerlink" title="JSON.parse(JSON.stringfy(obj))"></a>JSON.parse(JSON.stringfy(obj))</h4><p>说到深拷贝，你肯定会想到JSON.parse(JSON.stringfy(obj))。</p><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test: &#123;</div><div class="line">            name: &apos;test&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">var obj1 = JSON.parse(JSON.stringify(obj))</div><div class="line">obj1.test.name = 24</div></pre></td></tr></table></figure><p>打印obj和obj1的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(obj, obj1)</div><div class="line">// ----result</div><div class="line">// &#123; name: &quot;wang&quot;, test: &#123; name: &quot;test&quot; &#125; &#125;</div><div class="line">// &#123; name: &quot;wang&quot;, test: &#123; name: 24 &#125; &#125;</div></pre></td></tr></table></figure><p>然而。。。。</p><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">        test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj1 = JSON.parse(JSON.stringify(obj))</div></pre></td></tr></table></figure><p>打印obj和obj1的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(obj, obj1)</div><div class="line">// ---result</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;  &#125; &#125;</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test4: &#123;  &#125; &#125;</div></pre></td></tr></table></figure><p>???test2和test3不见了。。。。。</p><p>JSON.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个JSON字符串，不能接受函数。</p><hr><h4 id="手写递归方法"><a href="#手写递归方法" class="headerlink" title="手写递归方法"></a>手写递归方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function deepClone(obj) &#123;</div><div class="line">let result</div><div class="line">    let toString = Object.prototype.toString</div><div class="line">    if (toString.call(obj) === &apos;[Object Array]&apos;) &#123;</div><div class="line">    result = []</div><div class="line">      for (var i =0; i&lt;obj.length; i++) &#123;</div><div class="line">        result[i] = deepClone(obj[i])</div><div class="line">        &#125;</div><div class="line">    &#125; else if (toString.call(obj) === &apos;[Object Object]&apos;) &#123;</div><div class="line">    result = &#123;&#125;</div><div class="line">      for (var key in obj) &#123;</div><div class="line">        if (obj.hasOwnProperty(key)) &#123;</div><div class="line">            result[key] = deepClone(obj[key])</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">    return obj</div><div class="line">    &#125;</div><div class="line">  return result</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>🌰：调用函数并打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">        test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj1 = deepClone(obj)</div><div class="line">console.log(obj, obj21)</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: Object &#123;  &#125; &#125;</div><div class="line">// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: Object &#123;  &#125; &#125;</div></pre></td></tr></table></figure><hr><h4 id="jQuery实现"><a href="#jQuery实现" class="headerlink" title="jQuery实现"></a>jQuery实现</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;</div><div class="line">        name: &apos;wang&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">        test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj2 = $.extend(true, &#123;&#125;, obj1)</div></pre></td></tr></table></figure><hr><h4 id="lodash实现"><a href="#lodash实现" class="headerlink" title="lodash实现"></a>lodash实现</h4><p>🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;</div><div class="line">        name: &apos;wclimb&apos;,</div><div class="line">        test1: null,</div><div class="line">        test2: undefined,</div><div class="line">        test3: function()&#123;alert(1)&#125;,</div><div class="line">        test4: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">var obj2 = _.cloneDeep(obj1)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
