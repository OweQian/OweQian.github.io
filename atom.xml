<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>W | 个人博客 | web前端</title>
  
  <subtitle>wangxiaobai</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qiandream.cn/"/>
  <updated>2020-05-12T14:50:18.950Z</updated>
  <id>http://qiandream.cn/</id>
  
  <author>
    <name>wangxiaobai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-007-最长公共前缀</title>
    <link href="http://qiandream.cn/2020/05/12/leetcode/leetcode-008-zui-chang-gong-gong-qian-zhui/"/>
    <id>http://qiandream.cn/2020/05/12/leetcode/leetcode-008-zui-chang-gong-gong-qian-zhui/</id>
    <published>2020-05-12T12:01:52.000Z</published>
    <updated>2020-05-12T14:50:18.950Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：水平扫描</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="external">https://leetcode-cn.com/problems/longest-common-prefix/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。说明:所有输入只包含小写字母 a-z 。</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-水平扫描"><a href="#解法-水平扫描" class="headerlink" title="解法 - 水平扫描"></a>解法 - 水平扫描</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {string[]} strs * @return {string} */</span><span class="token keyword">var</span> longestCommonPrefix <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> strs<span class="token punctuation">.</span>length <span class="token operator">?</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> strs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</code></pre><p>输出：</p><pre><code>&quot;fl&quot;</code></pre><p>预期结果：</p><pre><code>&quot;fl&quot;</code></pre><ul><li>解题思路：</li></ul><p>首先判断数组为空或者数组长度为1，若数组为空，直接返回空字符串。若数组长度为1，直接返回数组的第一个元素。</p><p>定义变量 result，取值为数组的第一个元素，遍历 result 中的每个字符，嵌套循环遍历输入数组的其它元素，如果对比元素不相等，则截取 result 并返回子字符串。</p><p>负责，默认情况下返回 result。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-执行上下文和执行栈</title>
    <link href="http://qiandream.cn/2020/05/12/javascript/javascript-zhi-xing-shang-xia-wen-he-zhi-xing-zhan/"/>
    <id>http://qiandream.cn/2020/05/12/javascript/javascript-zhi-xing-shang-xia-wen-he-zhi-xing-zhan/</id>
    <published>2020-05-12T09:50:52.000Z</published>
    <updated>2020-05-12T11:13:18.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。<br><a id="more"></a>           </p><hr></blockquote><h1 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h1><p>JavaScript 中有三种执行上下文类型：</p><ul><li><p>全局执行上下文：任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</p></li><li><p>函数执行上下文：每当一个函数被调用时, 都会为该函数创建一个新的上下文。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤。</p></li><li><p>Eval 函数执行上下文：执行在 eval 函数内部的代码也会有它属于自己的执行上下文。</p></li></ul><h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>执行栈，也叫”调用栈”，是一种 LIFO（后进先出）的数据结构，被用来存储代码执行过程中创建的所有执行上下文。</p><p>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p><p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'Hello World!'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside first function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Again inside first function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside second function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside Global Execution Context'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f539572076fe3?imageslim" alt=""></p><p>上述代码的执行上下文栈。</p><h1 id="如何创建执行上下文"><a href="#如何创建执行上下文" class="headerlink" title="如何创建执行上下文"></a>如何创建执行上下文</h1><p>在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p><ol><li>this 绑定</li><li>创建词法环境组件</li><li>创建变量环境组件</li></ol><p>所以执行上下文在概念上表示如下：</p><pre class=" language-text"><code class="language-text">ExecutionContext = {  ThisBinding = <this value>,  LexicalEnvironment = {},  VariableEnvironment = {}}</code></pre><h2 id="This-绑定"><a href="#This-绑定" class="headerlink" title="This 绑定"></a>This 绑定</h2><p>在全局执行上下文中，this 的值指向全局对象。</p><p>在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</p><h2 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h2><p>简单来说词法环境是一种持有标识符—变量映射的结构。（这里的标识符指的是变量/函数的名字，而变量是对实际对象[包含函数类型对象]或原始数据的引用。</p><p>词法环境内部有两个组件：1）环境记录器 2）对外部环境的引用</p><ul><li>环境记录器是存储变量和函数声明的实际位置。</li><li>外部环境的引用意味着它可以访问其父级词法环境（作用域）。</li></ul><p>词法环境有两种类型：</p><ul><li>全局环境（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 null。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量。</li><li>在函数词法环境中，函数内部用户定义的变量存储在环境记录器中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</li></ul><p>环境记录器也有两种类型：</p><ol><li>声明式环境记录器存储变量、函数和参数。</li><li>对象环境记录器用来定义出现在全局上下文中的变量和函数的关系。</li></ol><p>简而言之：</p><ul><li>在全局环境中，环境记录器是对象环境记录器。</li><li>在函数环境中，环境记录器是声明式环境记录器。</li></ul><p>注意 — 对于函数环境，声明式环境记录器还包含了一个传递给函数的 arguments 对象。</p><p>伪代码：</p><pre class=" language-text"><code class="language-text">GlobalExecutionContext = {  LexicalEnvironment: {    EnvironmentRecord: {      Type: "Object",      // 在这里绑定标识符    }    outer: <null>  }}FunctionExecutionContext = {  LexicalEnvironment: {    EnvironmentRecord: {      Type: "Declarative",      // 在这里绑定标识符    }    outer: <Global or outer function environment reference>  }}</code></pre><h2 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h2><p>变量环境也是一个词法环境，它与变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。</p><p>🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">var</span> c<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">multiply</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token keyword">return</span> e <span class="token operator">*</span> f <span class="token operator">*</span> g<span class="token punctuation">;</span><span class="token punctuation">}</span>c <span class="token operator">=</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>伪代码：</p><pre class=" language-text"><code class="language-text">GlobalExecutionContext = {  ThisBinding: <Global Object>,  LexicalEnvironment: {    EnvironmentRecord: {      Type: "Object",      // 在这里绑定标识符      a: < uninitialized >,      b: < uninitialized >,      multiply: < func >    }    outer: <null>  },  VariableEnvironment: {    EnvironmentRecord: {      Type: "Object",      // 在这里绑定标识符      c: undefined,    }    outer: <null>  }}FunctionExecutionContext = {  ThisBinding: <Global Object>,  LexicalEnvironment: {    EnvironmentRecord: {      Type: "Declarative",      // 在这里绑定标识符      Arguments: {0: 20, 1: 30, length: 2},    },    outer: <GlobalLexicalEnvironment>  },VariableEnvironment: {    EnvironmentRecord: {      Type: "Declarative",      // 在这里绑定标识符      g: undefined    },    outer: <GlobalLexicalEnvironment>  }}</code></pre><p>可能你已经注意到 let 和 const 定义的变量并没有关联任何值，但 var 定义的变量被设成了 undefined。</p><p>这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 undefined（var 情况下），或者未初始化（let 和 const 情况下）。</p><p>这就是我们说的变量声明提升。</p><h1 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h1><p>完成对所有这些变量的分配，最后执行代码，在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined。</p><p>参考：</p><p>[[译] 理解 JavaScript 中的执行上下文和执行栈}]: <a href="https://juejin.im/post/5ba32171f265da0ab719a6d7" target="_blank" rel="external">https://juejin.im/post/5ba32171f265da0ab719a6d7</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://qiandream.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-006-合并两个有序链表</title>
    <link href="http://qiandream.cn/2020/05/09/leetcode/leetcode-007-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/"/>
    <id>http://qiandream.cn/2020/05/09/leetcode/leetcode-007-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/</id>
    <published>2020-05-09T12:01:52.000Z</published>
    <updated>2020-05-12T14:45:08.342Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="external">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。示例 1:给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-遍历、splice"><a href="#解法-遍历、splice" class="headerlink" title="解法 - 遍历、splice"></a>解法 - 遍历、splice</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {number[]} nums * @return {number} */</span><span class="token keyword">var</span> removeDuplicates <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token operator">--</span>i        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>[1,1,2]</code></pre><p>输出：</p><pre><code>2</code></pre><p>预期结果：</p><pre><code>2</code></pre><ul><li>解题思路：</li></ul><p>遍历数组，比较当前元素和下一个元素，如果两个元素相等，则移除元素，并处理当前索引(因为元素移除，当前索引值需要减一个值)，继续遍历，直到结束，返回数组长度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-010-实现 strStr()</title>
    <link href="http://qiandream.cn/2020/05/09/leetcode/leetcode-010-shi-xian-strstr/"/>
    <id>http://qiandream.cn/2020/05/09/leetcode/leetcode-010-shi-xian-strstr/</id>
    <published>2020-05-09T12:01:52.000Z</published>
    <updated>2020-05-12T16:02:24.042Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：字符串</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="external">https://leetcode-cn.com/problems/implement-strstr/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。示例 1:输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2示例 2:输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1说明:当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-indexOf"><a href="#解法-indexOf" class="headerlink" title="解法 - indexOf"></a>解法 - indexOf</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {string} haystack * @param {string} needle * @return {number} */</span><span class="token keyword">var</span> strStr <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>haystack<span class="token punctuation">,</span> needle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> haystack<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>&quot;hello&quot;&quot;ll&quot;</code></pre><p>输出：</p><pre><code>2</code></pre><p>预期结果：</p><pre><code>2</code></pre><ul><li>解题思路：</li></ul><p>JS 内置方法 indexOf，判断数组中是否存在判断条件中的值。如果存在，则返回第一次出现的索引；如果不存在，则返回 -1。</p><h2 id="解法-遍历，subString"><a href="#解法-遍历，subString" class="headerlink" title="解法 - 遍历，subString"></a>解法 - 遍历，subString</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {string} haystack * @param {string} needle * @return {number} */</span><span class="token keyword">var</span> strStr <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>haystack<span class="token punctuation">,</span> needle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>needle<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">+</span>needle<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">===</span> needle<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> i        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>&quot;hello&quot;&quot;ll&quot;</code></pre><p>输出：</p><pre><code>2</code></pre><p>预期结果：</p><pre><code>2</code></pre><ul><li>解题思路：</li></ul><p>判断 needle 是否为空，为空返回 0。</p><p>遍历 haystack，从 i 开始，判断 haystack 中的 i + needle.length 位是否等于 needle，是则返回对应的坐标 i。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-009-移除元素</title>
    <link href="http://qiandream.cn/2020/05/09/leetcode/leetcode-009-yi-chu-yuan-su/"/>
    <id>http://qiandream.cn/2020/05/09/leetcode/leetcode-009-yi-chu-yuan-su/</id>
    <published>2020-05-09T12:01:52.000Z</published>
    <updated>2020-05-12T15:46:32.553Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="external">https://leetcode-cn.com/problems/remove-element/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例 1:给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-遍历、splice"><a href="#解法-遍历、splice" class="headerlink" title="解法 - 遍历、splice"></a>解法 - 遍历、splice</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {number[]} nums * @param {number} val * @return {number} */</span><span class="token keyword">var</span> removeElement <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token operator">--</span>i        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>[3,2,2,3]3</code></pre><p>输出：</p><pre><code>[2,2]</code></pre><p>预期结果：</p><pre><code>[2,2]</code></pre><ul><li>解题思路：</li></ul><p>遍历数组，比较当前元素和 val，如果相等，则移除元素，并处理当前索引(因为元素移除，当前索引值需要减一个值)，继续遍历，直到结束，返回数组长度。</p><h2 id="解法-递归"><a href="#解法-递归" class="headerlink" title="解法 - 递归"></a>解法 - 递归</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {number[]} nums * @param {number} val * @return {number} */</span><span class="token keyword">var</span> removeElement <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       nums<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>       <span class="token keyword">return</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> val<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>[3,2,2,3]3</code></pre><p>输出：</p><pre><code>[2,2]</code></pre><p>预期结果：</p><pre><code>[2,2]</code></pre><ul><li>解题思路：</li></ul><p>Array.prototype.indexOf 查找数组中第一个复合条件的元素，如果存在，就移除元素，并递归调用函数进行下一轮查找。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-006-合并两个有序链表</title>
    <link href="http://qiandream.cn/2020/05/09/leetcode/leetcode-006-he-bing-liang-ge-you-xu-lian-biao/"/>
    <id>http://qiandream.cn/2020/05/09/leetcode/leetcode-006-he-bing-liang-ge-you-xu-lian-biao/</id>
    <published>2020-05-09T12:01:52.000Z</published>
    <updated>2020-05-12T15:24:35.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：链表</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="external">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p></li><li><p>题目内容：</p></li></ul><pre><code>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-递归（链表数据结构、边界）"><a href="#解法-递归（链表数据结构、边界）" class="headerlink" title="解法 - 递归（链表数据结构、边界）"></a>解法 - 递归（链表数据结构、边界）</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } */</span><span class="token comment" spellcheck="true">/** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */</span><span class="token keyword">var</span> mergeTwoLists <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 头结点</span>    <span class="token keyword">let</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 串联指针</span>    <span class="token keyword">let</span> cur <span class="token operator">=</span> head    <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果 l2 的结点值较小</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">></span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 先串起 l2 的结点</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l2            <span class="token comment" spellcheck="true">// l2 指针向前一步    </span>            l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1            l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next        <span class="token punctuation">}</span>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next    <span class="token punctuation">}</span>    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1 <span class="token operator">||</span> l2    <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>[1,2,4][1,3,4]</code></pre><p>输出：</p><pre><code>[1,1,2,3,4,4]</code></pre><p>预期结果：</p><pre><code>[1,1,2,3,4,4]</code></pre><ul><li>解题思路：</li></ul><p>使用递归来解题，将两个链表头部较小的一个与剩下的元素合并，并返回排好序的链表头，当两条链表中的一条为空时终止递归。</p><ul><li><p>时间复杂度：O(M+N)</p></li><li><p>空间复杂度：O(M+N)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-005-有效的括号</title>
    <link href="http://qiandream.cn/2020/05/08/leetcode/leetcode-005-you-xiao-de-gua-hao/"/>
    <id>http://qiandream.cn/2020/05/08/leetcode/leetcode-005-you-xiao-de-gua-hao/</id>
    <published>2020-05-08T12:01:52.000Z</published>
    <updated>2020-05-08T14:45:44.585Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组、栈</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="external">https://leetcode-cn.com/problems/valid-parentheses/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例 1:输入: &quot;()&quot;输出: true示例 2:输入: &quot;()[]{}&quot;输出: true示例 3:输入: &quot;(]&quot;输出: false示例 4:输入: &quot;([)]&quot;输出: false示例 5:输入: &quot;{[]}&quot;输出: true</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-栈"><a href="#解法-栈" class="headerlink" title="解法 - 栈"></a>解法 - 栈</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {string} s * @return {boolean} */</span><span class="token keyword">var</span> isValid <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> mapper <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">'('</span><span class="token punctuation">:</span> <span class="token string">')'</span><span class="token punctuation">,</span>        <span class="token string">'{'</span><span class="token punctuation">:</span> <span class="token string">'}'</span><span class="token punctuation">,</span>        <span class="token string">'['</span><span class="token punctuation">:</span> <span class="token string">']'</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'('</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> peak <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">!==</span> mapper<span class="token punctuation">[</span>peak<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>&quot;()[]{}&quot;</code></pre><p>输出：</p><pre><code>true</code></pre><p>预期结果：</p><pre><code>true</code></pre><ul><li>解题思路：</li></ul><p>使用栈，遍历输入字符串</p><p>如果当前字符为左半边括号时，则将其压入栈中</p><p>如果遇到右半边括号时，分类讨论：</p><p>1）如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环</p><p>2）若此时栈为空，则直接返回 false</p><p>3）若不为对应的左半边括号，反之返回 false</p><p><img src="https://github.com/azl397985856/leetcode/raw/master/assets/20.validParentheses.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-构造器模式</title>
    <link href="http://qiandream.cn/2020/05/01/she-ji-mo-shi/gou-zao-qi-mo-shi/"/>
    <id>http://qiandream.cn/2020/05/01/she-ji-mo-shi/gou-zao-qi-mo-shi/</id>
    <published>2020-05-01T03:54:52.000Z</published>
    <updated>2020-05-08T17:10:33.667Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>使用构造函数初始化对象，抽象了每个实例的变与不变。</p></blockquote><a id="more"></a><p>设计模式的核心操作是去观察你整个逻辑里面的变与不变，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。</p><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：公司员工信息录入系统，每个员工有姓名、年龄、工种，大约有500名员工。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>创建一个 User 构造函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span>name <span class="token punctuation">,</span> age<span class="token punctuation">,</span> career<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age    <span class="token keyword">this</span><span class="token punctuation">.</span>career <span class="token operator">=</span> career <span class="token punctuation">}</span></code></pre><p>接下来要做的事情，就是让程序自动地去读取数据库里面一行行的员工信息，然后把拿到的姓名、年龄等字段塞进User函数里，进行一个简单的调用：</p><pre><code>const user = new User(name, age, career)</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在创建一个user过程中，谁变了，谁不变？</p><p>很明显，变的是每个user的姓名、年龄、工种这些值，这是用户的个性，不变的是每个员工都具备姓名、年龄、工种这些属性，这是用户的共性。</p><p>那么构造器做了什么？</p><p>构造器是不是将 name、age、career 赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了共性的不变，同时将 name、age、career 各自的取值操作开放，确保了个性的灵活？</p><p>在使用构造器模式的时候，我们本质上是去抽象了每个对象实例的变与不变。</p><p>参考：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;使用构造函数初始化对象，抽象了每个实例的变与不变。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://qiandream.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://qiandream.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-代理模式</title>
    <link href="http://qiandream.cn/2020/04/15/she-ji-mo-shi/dai-li-mo-shi/"/>
    <id>http://qiandream.cn/2020/04/15/she-ji-mo-shi/dai-li-mo-shi/</id>
    <published>2020-04-15T03:54:52.000Z</published>
    <updated>2020-04-23T06:40:31.990Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>为一个对象提供一个代用品或占位符，以便控制对它的访问。</p></blockquote><a id="more"></a><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：虚拟代理实现图片懒加载</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>先通过一张 loading 图占位，然后通过异步的方式去加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> imgFunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> imgNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>imgNode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        setSrc<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>            imgNode<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> proxyImg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       imgFunc<span class="token punctuation">.</span><span class="token function">setSrc</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        setSrc<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>            imgFunc<span class="token punctuation">.</span><span class="token function">setSrc</span><span class="token punctuation">(</span><span class="token string">'./loading.gif'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            img<span class="token punctuation">.</span>src <span class="token operator">=</span> src          <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxyImg<span class="token punctuation">.</span><span class="token function">setSrc</span><span class="token punctuation">(</span><span class="token string">'./pic.pmg'</span><span class="token punctuation">)</span></code></pre><p>使用代理模式实现图片懒加载的优点还有符合单一职责原则。减少一个类或方法的粒度和耦合度。</p><p>参考：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;为一个对象提供一个代用品或占位符，以便控制对它的访问。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://qiandream.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://qiandream.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-中介者模式</title>
    <link href="http://qiandream.cn/2020/04/15/she-ji-mo-shi/zhong-jie-zhe-mo-shi/"/>
    <id>http://qiandream.cn/2020/04/15/she-ji-mo-shi/zhong-jie-zhe-mo-shi/</id>
    <published>2020-04-15T03:54:52.000Z</published>
    <updated>2020-04-23T06:51:50.749Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>通过一个中介者对象，其它所有相关对象都通过该中介者对象来通信，而不是相互引用，当其中一个对象发生变化时，只需要通知中介者对象即可。通过中介者模式可以解除对象之间的紧耦合关系。</p></blockquote><a id="more"></a><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>先通过一张 loading 图占位，然后通过异步的方式去加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> goods <span class="token operator">=</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//手机库存</span>    <span class="token string">'red|32G'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    <span class="token string">'red|64G'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">'blue|32G'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span>    <span class="token string">'blue|32G'</span><span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//中介者</span><span class="token keyword">const</span> mediator <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> colorSelect <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'colorSelect'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> memorySelect <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'memorySelect'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> numSelect <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'numSelect'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        changed<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">switch</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">case</span> colorSelect<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">//TODO</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> memorySelect<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">//TODO</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> numSelect<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">//TODO</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>colorSelect<span class="token punctuation">.</span>onchange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mediator<span class="token punctuation">.</span><span class="token function">changed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>memorySelect<span class="token punctuation">.</span>onchange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mediator<span class="token punctuation">.</span><span class="token function">changed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>numSelect<span class="token punctuation">.</span>onchange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mediator<span class="token punctuation">.</span><span class="token function">changed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>参考：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;通过一个中介者对象，其它所有相关对象都通过该中介者对象来通信，而不是相互引用，当其中一个对象发生变化时，只需要通知中介者对象即可。通过中介者模式可以解除对象之间的紧耦合关系。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://qiandream.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://qiandream.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-策略模式</title>
    <link href="http://qiandream.cn/2020/04/15/she-ji-mo-shi/ce-lue-mo-shi/"/>
    <id>http://qiandream.cn/2020/04/15/she-ji-mo-shi/ce-lue-mo-shi/</id>
    <published>2020-04-15T03:54:52.000Z</published>
    <updated>2020-04-17T04:13:28.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>定义一系列算法，将它们一个个封装起来，并使它们可以相互替换。</p></blockquote><a id="more"></a><h1 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h1><p>思考：很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放。例如：绩效为 S 的人年终奖有 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，绩效为 B 的人年终奖有 2 倍工资。假设财务要求我们提供一段代码，来方便他们计算员工的年终奖。</p><h2 id="最初代码实现"><a href="#最初代码实现" class="headerlink" title="最初代码实现"></a>最初代码实现</h2><p>我们可以编写一个 calculateBonus 函数来计算每个人的奖金额数，函数需要接受两个参数：员工的工资数额和他的绩效考核等级。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> calculateBonus <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>performanceLevel<span class="token punctuation">,</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以发现，这段代码十分简单，但存在显而易见的缺点。</p><ul><li><p>函数体庞大，包含很多if-else语句</p></li><li><p>缺乏弹性，如果新增等级 C，要修改函数内部实现</p></li><li><p>复用性差</p></li></ul><h2 id="组合函数实现"><a href="#组合函数实现" class="headerlink" title="组合函数实现"></a>组合函数实现</h2><p>一般我们最容易想到就是使用组合函数来重构代码，把各种算法封装到一个小小的函数里。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> performanceS <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> performanceA <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> performanceB <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> calculateBonus <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>performanceLevel<span class="token punctuation">,</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">performanceS</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">performanceS</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>performanceLevel <span class="token operator">===</span> <span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">performanceS</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>目前，我们的程序得到了一定的改善，但这种改善非常有限，我们依然没有解决最重要的问题：calculateBonus函数有可能越来越庞大，而且在系统变化的时候缺乏弹性。</p><h2 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h2><p>策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。</p><p>一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context,Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> strategies <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'S'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> calculateBonus <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>performanceLevel<span class="token punctuation">,</span> salary<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> strategies<span class="token punctuation">[</span>performanceLevel<span class="token punctuation">]</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>参考：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;定义一系列算法，将它们一个个封装起来，并使它们可以相互替换。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://qiandream.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://qiandream.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="http://qiandream.cn/2020/04/14/shu-ju-jie-gou/shu-ju-jie-gou-zhan/"/>
    <id>http://qiandream.cn/2020/04/14/shu-ju-jie-gou/shu-ju-jie-gou-zhan/</id>
    <published>2020-04-14T10:44:52.000Z</published>
    <updated>2020-04-14T14:22:07.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p></blockquote><a id="more"></a><h1 id="基于数组的栈"><a href="#基于数组的栈" class="headerlink" title="基于数组的栈"></a>基于数组的栈</h1><p>我们将创建一个类来表示栈，需要一种数据结构来保存栈里的元素。可以选择数组。数组允许我们在任何位置添加或删除元素。由于栈遵循LIFO原则，需要对元素的插入和删除功能进行限制。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新增元素到栈顶</span>    <span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 移除栈顶元素,同时返回被移除的元素</span>    <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈顶元素</span>    <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 是否为空栈</span>    <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈里的元素个数</span>    <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 清空栈元素</span>    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>创建一个 Stack 类最简单的方式是使用一个数组来存储其元素。在处理大量数据的时候，我们同样需要评估如何操作数据是最高效的。在使用数组时，大部分方法的时间复杂度是O(n)。</p><h1 id="基于对象的栈"><a href="#基于对象的栈" class="headerlink" title="基于对象的栈"></a>基于对象的栈</h1><p>我们将创建一个基于对象来存储栈里的元素的类来表示栈，这里新增一个 count 来表示栈的元素个数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新增元素到栈顶</span>    <span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 移除栈顶元素,同时返回被移除的元素</span>    <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 首先判断是否为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> undefined        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈顶元素</span>    <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> undefined<span class="token punctuation">;</span>        <span class="token punctuation">}</span>           <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 是否为空栈</span>    <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回栈里的元素个数</span>    <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 清空栈元素</span>    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://qiandream.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-单例模式</title>
    <link href="http://qiandream.cn/2020/04/14/she-ji-mo-shi/dan-li-mo-shi/"/>
    <id>http://qiandream.cn/2020/04/14/she-ji-mo-shi/dan-li-mo-shi/</id>
    <published>2020-04-14T03:54:52.000Z</published>
    <updated>2020-04-14T04:46:25.202Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>保证一个类只有一个实例，并提供一个访问它的全局访问点。</p></blockquote><a id="more"></a><h1 id="单例模式的实现思路"><a href="#单例模式的实现思路" class="headerlink" title="单例模式的实现思路"></a>单例模式的实现思路</h1><p>思考：如何才能保证一个类仅有一个实例？</p><p>通常，当我们创建一个类后，可以通过 new 关键字调用构造函数进而生成任意的实例。</p><pre><code>class SingleObj {    show() {        console.log(&#39;我是一个单例对象&#39;)    }}const s1 = new SingleObj()const s2 = new SingleObj()// falseconsole.log(s1 === s2)</code></pre><p>new 一个 s1，new 一个 s2，很明显 s1 和 s2 之间没有任何联系，而单例模式想要做到的是，无论实例化多少次，只返回第一次创建的那个唯一的实例。</p><p>要做到这一点，就需要构造函数具备判断自己是否已经创建过一个实例的能力。</p><ul><li>写一个静态方法判断逻辑</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">SingleObj</span> <span class="token punctuation">{</span>    <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是一个单例对象'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断是否已经new过1个实例</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>SingleObj<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 若这个唯一的实例不存在，那么先创建它</span>            SingleObj<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果这个唯一的实例已经存在，则直接返回</span>        <span class="token keyword">return</span> SingleObj<span class="token punctuation">.</span>instance    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> s1 <span class="token operator">=</span> SingleObj<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> s2 <span class="token operator">=</span> SingleObj<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// true</span>s1 <span class="token operator">===</span> s2</code></pre><ul><li>闭包</li></ul><pre class=" language-javascript"><code class="language-javascript">SingleObj<span class="token punctuation">.</span>getInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>可以看出，在 getInstance 方法的判断和拦截下，我们不管调用多少次，SingleObj 都只会给我们返回一个实例，s1 和 s2 现在都指向这个唯一的实例。</p><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><pre><code>实现 Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。</code></pre><p>思路：</p><p>考察单例模式的实现思路，只实例化一次。</p><ul><li>静态方法版</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Storage</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Storage<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Storage<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Storage<span class="token punctuation">.</span>instance      <span class="token punctuation">}</span>    getItem <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    setItem <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>闭包版</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">StorageBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>StorageBase<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getItem <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">}</span>StorageBase<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>setItem <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">const</span> Storage <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StorageBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre><code>实现一个全局唯一的Modal弹框</code></pre><p>万变不离其踪，依然考察单例模式。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;单例模式弹框&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    #modal {        height: 200px;        width: 200px;        line-height: 200px;        position: fixed;        left: 50%;        top: 50%;        transform: translate(-50%, -50%);        border: 1px solid black;        text-align: center;    }&lt;/style&gt;&lt;body&gt;    &lt;button id=&#39;open&#39;&gt;打开弹框&lt;/button&gt;    &lt;button id=&#39;close&#39;&gt;关闭弹框&lt;/button&gt;&lt;/body&gt;&lt;script&gt;    // 核心逻辑，这里采用了闭包思路来实现单例模式    const Modal = (function() {        let modal = null        return function() {            if(!modal) {                modal = document.createElement(&#39;div&#39;)                modal.innerHTML = &#39;我是一个全局唯一的Modal&#39;                modal.style.display = &#39;none&#39;                document.body.appendChild(modal)            }            return modal        }    })()    // 点击打开按钮展示模态框    document.getElementById(&#39;open&#39;).addEventListener(&#39;click&#39;, function() {        // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理        const modal = new Modal()        modal.style.display = &#39;block&#39;    })    // 点击关闭按钮隐藏模态框    document.getElementById(&#39;close&#39;).addEventListener(&#39;click&#39;, function() {        const modal = new Modal()        if(modal) {            modal.style.display = &#39;none&#39;        }    })&lt;/script&gt;&lt;/html&gt;</code></pre><p>参考：</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;保证一个类只有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://qiandream.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://qiandream.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-01-替换字符串</title>
    <link href="http://qiandream.cn/2020/04/10/jian-zhi-offer/jian-zhi-offer-01-ti-huan-zi-fu-chuan/"/>
    <id>http://qiandream.cn/2020/04/10/jian-zhi-offer/jian-zhi-offer-01-ti-huan-zi-fu-chuan/</id>
    <published>2020-04-10T10:44:52.000Z</published>
    <updated>2020-04-10T10:55:52.790Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 剑指offer 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：正则表达式、数组遍历</p></li><li><p>题目内容：</p></li></ul><pre><code>请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。例如输入“We are happy.”，则输出“We%20are%20happy.”。</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-正则表达式"><a href="#解法-正则表达式" class="headerlink" title="解法 - 正则表达式"></a>解法 - 正则表达式</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {String} str */</span><span class="token keyword">function</span> <span class="token function">replaceEmpty</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/ /g</span><span class="token punctuation">,</span> <span class="token string">'%20'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>replaceEmpty(&#39;we are family&#39;)</code></pre><p>输出：</p><pre><code>&quot;we%20are%20family&quot;</code></pre><p>预期结果：</p><pre><code>&quot;we%20are%20family&quot;</code></pre><ul><li>解题思路：</li></ul><p>直接使用正则表达式全局替换</p><p>String.prototype.replace: 返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者是一个正则表达式，替换值可以是一个字符串或者是一个每次匹配都要调用的回调函数。</p><pre><code>str.replace(regexp|substr, newSubStr|function)</code></pre><ul><li>regexp (pattern)</li></ul><p>一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。</p><ul><li>substr (pattern)</li></ul><p>一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。</p><ul><li>newSubStr (replacement)</li></ul><p>用于替换掉第一个参数在原字符串中的匹配部分的字符串。</p><ul><li>function (replacement)</li></ul><p>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。</p><p>返回值：</p><p>一个部分或全部匹配由替代模式所取代的新的字符串。</p><p>描述：</p><p>该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。</p><p>在进行全局的搜索替换时，正则表达式需包含 g 标志。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 剑指offer 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指offer" scheme="http://qiandream.cn/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-004-罗马数字转整数</title>
    <link href="http://qiandream.cn/2020/04/10/leetcode/leetcode-004-luo-ma-shu-zi-zhuan-zheng-shu/"/>
    <id>http://qiandream.cn/2020/04/10/leetcode/leetcode-004-luo-ma-shu-zi-zhuan-zheng-shu/</id>
    <published>2020-04-10T10:11:52.000Z</published>
    <updated>2020-04-10T09:53:28.189Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 </p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>难度：简单</p></li><li><p>设计知识：数组、数学</p></li><li><p>题目地址：<a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="external">https://leetcode-cn.com/problems/roman-to-integer/</a></p></li><li><p>题目内容：</p></li></ul><pre><code>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符          数值I             1V             5X             10L             50C             100D             500M             1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解法-转字符串、数组遍历，区分正常情况与特殊情况"><a href="#解法-转字符串、数组遍历，区分正常情况与特殊情况" class="headerlink" title="解法 - 转字符串、数组遍历，区分正常情况与特殊情况"></a>解法 - 转字符串、数组遍历，区分正常情况与特殊情况</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/** * @param {string} s * @return {number} */</span><span class="token keyword">var</span> romanToInt <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/**       * 特殊情况       * IV === 4       * IX === 9       * XL === 40       * XC === 90       * CD === 400       * CM === 900       * 正常情况       * I === 1       * V === 5       * X === 10       * L === 50       * C === 100       * D === 500       * M === 1000       */</span>    <span class="token keyword">let</span> arr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">9</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">40</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">90</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">400</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">900</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'I'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">5</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">50</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'C'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">100</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">500</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1000</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>执行测试</li></ul><p>输入：</p><pre><code>MCMXCIV</code></pre><p>输出：</p><pre><code>1994</code></pre><p>预期结果：</p><pre><code>1994</code></pre><ul><li><p>解题思路：转换为字符串、数组</p></li><li><p>split(): 字符串分割为数组</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://qiandream.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://qiandream.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-原型原型链</title>
    <link href="http://qiandream.cn/2020/04/03/javascript/javascript-yuan-xing-yuan-xing-lian/"/>
    <id>http://qiandream.cn/2020/04/03/javascript/javascript-yuan-xing-yuan-xing-lian/</id>
    <published>2020-04-03T09:10:52.000Z</published>
    <updated>2020-04-03T09:20:11.886Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>JavaScript 中的 原型和原型链是面试中常考的点，本文旨在分析原型和原型链是什么。</p></blockquote><a id="more"></a>           <hr><h1 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h1><p>JavaScript 通过 new 一个构造函数生成一个对象实例，但是每个对象实例的属性和方法并不是共享的，为了各个对象实例可以共享一些属性和方法，要设计一个对象专门用来存储对象共享的属性，那么我们叫它「原型对象」。</p><p>在 JS 所有对象中，只要是对象，都会有一个内置属性叫做<em>proto</em>，而且这个属性是系统自动生成的，只要你创建一个对象，这个对象就有这个属性。这个<em>proto</em>属性指向的是原型对象。</p><p>构造函数的 prototype 属性指向原型对象，原型对象的 constructor 属性指回构造函数。</p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>每个对象都一个 <strong>proto</strong> 指向原型对象，原型对象也有一个 <strong>proto</strong> 指向它的原型对象，直到原型链的顶端 null。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/24/16dfb64428ee0ce4?imageslim" alt=""></p><p>总结：</p><ul><li>所有的实例的 <strong>proto</strong> 都指向该构造函数的原型对象（prototype）。</li><li>所有的函数（包括构造函数）是 Function() 的实例，所以所有函数的 <strong>proto</strong> 的都指向 Function() 的原型对象。</li><li>所有的原型对象（包括 Function 的原型对象）都是 Object 的实例，所以 <strong>proto</strong> 都指向 Object （构造函数）的原型对象。而 Object 构造函数的 <strong>proto</strong>  指向 null。</li><li>Function 构造函数本身就是 Function 的实例，所以 <strong>proto</strong> 指向 Function 的原型对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;JavaScript 中的 原型和原型链是面试中常考的点，本文旨在分析原型和原型链是什么。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://qiandream.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://qiandream.cn/2020/04/02/http/tcp-si-ci-hui-shou/"/>
    <id>http://qiandream.cn/2020/04/02/http/tcp-si-ci-hui-shou/</id>
    <published>2020-04-02T08:24:30.882Z</published>
    <updated>2020-04-02T08:24:30.882Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP-三次握手</title>
    <link href="http://qiandream.cn/2020/04/01/http/tcp-san-ci-wo-shou/"/>
    <id>http://qiandream.cn/2020/04/01/http/tcp-san-ci-wo-shou/</id>
    <published>2020-04-01T10:10:52.000Z</published>
    <updated>2020-04-02T08:24:54.857Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>建立 TCP 连接前，客户端和服务端需要通过三次握手来确认对方的接受和传送能力是否正常</p></blockquote><a id="more"></a>           <hr><p>客户端向服务器发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，确保双方的接收和发送能力正常。</p><p>起始状态：客户端处于 closed 状态，服务端处于 listen 状态。</p><p>第一次握手：客户端给服务端发送一个 SYN 报文，并指明自己的初始化序列号（ISN） Seq = X，此时客户端处于 SYN_Send 状态。</p><p>第二次握手：服务端收到客户端的 SYN 报文后，会以自己的 SYN 报文作为应答，并且也指定了自己的初始化序列号（ISN） Seq = Y，同时会把客户端的 Seq X + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。</p><p>第三次握手：客户端回传一个 Seq Y + 1 作为 ACK 的值，Seq = Z 的数据包，代表握手结束，此时客户端处于 established 状态。</p><p>服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立起了连接。</p><p>（SYN：代表 TCP 连接 Seq：序列号 ACK：确认号）</p><p><img src="https://segmentfault.com/img/remote/1460000017184707" alt=""></p><h4 id="为什么需要3次握手"><a href="#为什么需要3次握手" class="headerlink" title="为什么需要3次握手"></a>为什么需要3次握手</h4><p>为了防止已经失效的连接请求报文突然又传送到了服务器，因为产生错误。</p><h4 id="ISN-是固定的吗"><a href="#ISN-是固定的吗" class="headerlink" title="ISN 是固定的吗"></a>ISN 是固定的吗</h4><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p><h4 id="什么是半连接队列"><a href="#什么是半连接队列" class="headerlink" title="什么是半连接队列"></a>什么是半连接队列</h4><p>服务器第一次收到客户端的 SYN 之后，此时会处于 SYN_RCVD 状态，此时双方还没有建立起连接，服务器会把这种状态的请求连接放在一个队列里，这种队列称为半连接队列。</p><p>服务器与客户端三次握手完成建立起的连接会放在全连接队列里。</p><p>如果队列满了，就可能会出现丢包现象。</p><pre><code>这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ....</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;建立 TCP 连接前，客户端和服务端需要通过三次握手来确认对方的接受和传送能力是否正常&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTP" scheme="http://qiandream.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-基础之this</title>
    <link href="http://qiandream.cn/2020/03/17/liu-lan-qi/browser-liu-lan-qi-xuan-ran-yuan-li/"/>
    <id>http://qiandream.cn/2020/03/17/liu-lan-qi/browser-liu-lan-qi-xuan-ran-yuan-li/</id>
    <published>2020-03-17T03:10:52.000Z</published>
    <updated>2020-04-02T07:30:12.718Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>本系列旨在总结浏览器相关知识，本篇围绕浏览器渲染原理展开。</p></blockquote><a id="more"></a>           <hr><h1 id="浏览器的主要组成部分"><a href="#浏览器的主要组成部分" class="headerlink" title="浏览器的主要组成部分"></a>浏览器的主要组成部分</h1><p>讲解浏览器渲染之前，先主要了解浏览器有哪些组成部分。</p><ul><li><p>用户界面：包括地址栏、前进/后退按钮，书签菜单等。</p></li><li><p>浏览器引擎：在用户界面和渲染引擎之间传送指令。</p></li><li><p>渲染引擎：负责显示请求的内容。如：解析 HTML 和 CSS，并将解析后的内容显示在屏幕上。</p></li><li><p>网络：用于网络调用，比如 HTTP 请求。</p></li><li><p>用户界面后端：用于绘制基本的窗口小部件，如组合框和窗口等。</p></li><li><p>JS 解释器：用于解析和执行 JS 代码。</p></li><li><p>数据存储：这是持久层，用于浏览器在硬盘上保存各种数据。</p></li></ul><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=531622336,2916455443&amp;fm=26&amp;gp=0.jpg" alt=""></p><h1 id="常见的浏览器内核"><a href="#常见的浏览器内核" class="headerlink" title="常见的浏览器内核"></a>常见的浏览器内核</h1><table><thead><tr><th>浏览器</th><th>内核（渲染引擎）</th><th>JS 引擎</th></tr></thead><tbody><tr><td>Chrome</td><td>Blink（28~）<br> Webkit</td><td>V8</td></tr><tr><td>Safari</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>FireFox</td><td>Gecko</td><td>SpiderMonkey</td></tr><tr><td>Edge</td><td>EdgeHTML</td><td>Chakra</td></tr><tr><td>IE</td><td>Trident</td><td>Chakra</td></tr></tbody></table><h1 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h1><p>DOM（Document Object Model 文档对象模型），是对 HTML 文档结构化的表述，允许程序和脚本动态的访问和更新文档的内容、结构和样式。服务器返回给浏览器渲染引擎的HTML的文件字节流是无法直接被浏览器渲染引擎理解的，要转化为浏览器渲染引擎可以理解的内部结构，这个结构就是 DOM。</p><h1 id="浏览器接受-HTML-文件并转换为-DOM-树"><a href="#浏览器接受-HTML-文件并转换为-DOM-树" class="headerlink" title="浏览器接受 HTML 文件并转换为 DOM 树"></a>浏览器接受 HTML 文件并转换为 DOM 树</h1><p>从服务器返回给浏览器渲染引擎的 HTML 文件字节流，第一步要经过渲染引擎中的 HTML 解析器。它实现了将 HTML 字节流转换为 DOM 树结构。HTML 文件字节流返回的过程中，HTML 解析器就一直在解析（边加载边解析）。</p><p>阶段一：在网络中传输的内容都是 0 和 1 这些字节数据，当浏览器接收到这些字节数据后，会将这些字节数据转换为字符串，就是我们平时写的代码。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754281e59587f3?imageslim" alt=""></p><p>阶段二：当数据转换为字符串后，浏览器会先将这些字符串通过分词器转化为 Token(标记)，Token 分为 Tag Token 和文本 TOken。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754288f37a5347?imageslim" alt=""></p><p>标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167540a7b5cef612?imageslim" alt=""></p><p>阶段三：将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。</p><p>HTML 解析器维护了一个 Token 栈，这个栈的目的就是用来计算节点间的父子关系，再上一个阶段生成的 Token 会被顺序压到这个栈中。</p><ul><li><p>HTML 解析器开始工作时，会默认创建一个根为 document 的空 DOM 结构，同时将一个 StartTag document 的 Token 压入栈底。</p></li><li><p>如果压入到栈中的是 StartTagToken，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将这个 DOM 节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的 DOM 节点。</p></li><li><p>如果是文本 Token，那么会生成一个文本节点，然后把这个文本 Dom 节点加入到 DOM 树中（注:文本Token不需入栈），它的 父节点就是当前栈顶 Token 所对应的 DOM 节点。</p></li><li><p>如果分词器解析出来的是 EndTag 标签，比如例子中的 EndTag div，HTML 解析器会查看 Token栈顶的元素是否是 StartTag div，如果是，就将 StartTag div从栈中弹出，边上该 div 元素解析完成。</p></li><li><p>最后按照上面的规则，分词器一路解析下来，就形成了这个简单的 DOM 树。</p></li></ul><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/6ccc9594a0dc0a616804780992d4298d.png" alt=""></p><h1 id="浏览器接受-CSS-文件并转换为-CSSOM-树"><a href="#浏览器接受-CSS-文件并转换为-CSSOM-树" class="headerlink" title="浏览器接受 CSS 文件并转换为 CSSOM 树"></a>浏览器接受 CSS 文件并转换为 CSSOM 树</h1><p>转换 CSS 到 CSSOM 树的过程和上一小节的过程极其相似。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f?imageslim" alt=""></p><h2 id="浏览器如何解析-CSS-选择器"><a href="#浏览器如何解析-CSS-选择器" class="headerlink" title="浏览器如何解析 CSS 选择器"></a>浏览器如何解析 CSS 选择器</h2><p>浏览器会【从右向左】解析 CSS 选择器。</p><p>以下段 CSS 为例：</p><pre><code>.mode-nav h3 span {font-size: 16px;}</code></pre><p>我们对应的DOM Tree如下：</p><p><img src="https://xiaomuzhu-image.oss-cn-beijing.aliyuncs.com/4fe91032bd748f2509e0f0da3e56dcc1.png" alt=""></p><p>若从左向右匹配：过程是：</p><ol><li><p>从 .mod-nav 开始，遍历子节点 header 和子节点 div</p></li><li><p>然后各自向子节点遍历。在右侧 div 的分支中</p></li><li><p>最后遍历到叶子节点 a ，发现不符合规则，需要回溯到 ul 节点，再遍历下一个 li-a，一颗DOM树的节点动不动上千，这种效率很低</p></li></ol><p>若从右向左匹配：</p><ol><li><p>先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3</p></li><li><p>由 h3再向上寻找 class=mod-nav 的节点</p></li><li><p>最后找到根元素 html 则结束这个分支的遍历</p></li></ol><p>后者匹配性能更好，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）；而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;本系列旨在总结浏览器相关知识，本篇围绕浏览器渲染原理展开。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://qiandream.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack-简介</title>
    <link href="http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-jian-jie/"/>
    <id>http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-jian-jie/</id>
    <published>2020-01-14T07:21:00.000Z</published>
    <updated>2020-04-02T08:04:30.698Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。</p></blockquote><a id="more"></a><h1 id="Webpack-简介"><a href="#Webpack-简介" class="headerlink" title="Webpack 简介"></a>Webpack 简介</h1><h2 id="Webpack是什么"><a href="#Webpack是什么" class="headerlink" title="Webpack是什么"></a>Webpack是什么</h2><p>Webpack是一个开源的JavaScript模块打包工具，其最核心的功能是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个JS文件（有时会有多个，这里讨论的只是最基本的情况）。</p><h2 id="模块打包工具"><a href="#模块打包工具" class="headerlink" title="模块打包工具"></a>模块打包工具</h2><p>模块打包工具（module bundler）的任务就是解决模块间的依赖，使其打包后的结果能运行在浏览器上。它的工作方式主要分为两种</p><ul><li><p>将存在依赖关系的模块按照特定规则合并为单个JS文件，一次全部加载进页面中。</p></li><li><p>在页面初始时加载一个入口模块，其他模块异步地进行加载。</p></li></ul><h2 id="Webpack-优势"><a href="#Webpack-优势" class="headerlink" title="Webpack 优势"></a>Webpack 优势</h2><ul><li><p>默认支持多种模块标准，包括AMD、CommonJS，以及最新的ES6模块。</p></li><li><p>完备的代码分割（code splitting）解决方案，首屏只加载重要的部分。</p></li><li><p>可以处理各种类型的资源。除了JavaScript以外，Webpack还可以处理样式、模板，甚至图片等。</p></li><li><p>拥有庞大的社区支持。</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用npm或者yarn来安装webpack</p><hr><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><pre><code>$ npm i webpack webpack-cli -gor$ yarn -g add webpack webpack-cli</code></pre><p>等待安装完毕，就可以全局执行webpack命令了。注：webpack-cli在4.x版本之后不再作为webpack的依赖了，我们使用时需要单独安装。</p><hr><h3 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h3><p>在项目中，我们更推荐将webpack作为项目的开发依赖来安装使用，这样可以指定项目中使用的webpack版本。</p><pre><code>$ npm i webpack webpack-cli -Dor$ yarn add webpack webpack-cli -D</code></pre><p>等待安装完毕，webpack会出现在项目的package.json文件中，我们添加一个npm scripts:</p><pre><code>  &quot;scripts&quot;: {    &quot;build&quot;: &quot;webpack --mode production&quot;  },  &quot;devDependencies&quot;: {    &quot;webpack&quot;: &quot;^4.1.1&quot;,    &quot;webpack-cli&quot;: &quot;^2.0.12&quot;,  }</code></pre><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack-dev-server可以看作一个服务者，它的主要工作就是接收浏览器的请求，然后将资源返回。当服务启动时，会先让Webpack进行模块打包并将资源准备好（在示例中就是bundle.js）。当webpack-dev-server接收到浏览器的资源请求时，它会首先进行URL地址校验。如果该地址是资源服务地址（上面配置的publicPath），就会从Webpack的打包结果中寻找该资源并返回给浏览器。反之，如果请求地址不属于资源服务地址，则直接读取硬盘中的源文件并将其返回。</p><pre class=" language-javascript"><code class="language-javascript">$ npm i webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server <span class="token operator">-</span>D</code></pre><p>为了便捷地启动webpack-dev-server，我们在package.json中添加一个dev指令：</p><pre class=" language-json"><code class="language-json"><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"webpack"</span><span class="token punctuation">,</span>  <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"webpack-dev-server"</span><span class="token punctuation">}</span></code></pre><p>最后，我们还需要对webpack-dev-server进行配置。编辑webpack.config.js如下：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">"./src/index.js"</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">"./bundle.js"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">"development"</span><span class="token punctuation">,</span>    devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>        publicPath<span class="token punctuation">:</span> <span class="token string">"/dist"</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p>这里有一点需要注意。直接用Webpack开发和使用webpack-dev-server有一个很大的区别，前者每次都会生成budnle.js，而webpack-dev-server只是将打包结果放在内存中，并不会写入实际的bundle.js，在每次webpack-dev-server接收到请求时都只是将内存中的打包结果返回给浏览器。</p><p>webpack-dev-server还有一项很便捷的特性就是live-reloading（自动刷新）。</p><p>注：关于内容自动更新，webpack-dev-server 与 hot-module-replacement（模块热替换）的区别在于：前者会刷新浏览器，后者不需要刷新浏览器就能获得更新之后的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://qiandream.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://qiandream.cn/tags/Webpack/"/>
    
  </entry>
  
</feed>
