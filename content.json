{"meta":{"title":"W | 个人博客 | web前端","subtitle":null,"description":"前端","author":"wangxiaobai","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-04-11T08:28:32.000Z","updated":"2018-04-11T08:28:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-11T08:28:54.000Z","updated":"2018-04-11T08:29:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue移动端自动转换px为rem(postcss-pxtorem)","slug":"Vue移动端自动转换px为rem(postcss-pxtorem)","date":"2018-10-25T09:41:00.000Z","updated":"2018-10-25T12:13:31.897Z","comments":true,"path":"2018/10/25/Vue移动端自动转换px为rem(postcss-pxtorem)/","link":"","permalink":"http://yoursite.com/2018/10/25/Vue移动端自动转换px为rem(postcss-pxtorem)/","excerpt":"导语 前端在开发移动端webapp还原设计稿的重要性母庸质疑，目前来说应用最多的应该是rem。然而很多前端开发依然选择要么自己去计算rem值，要么依靠编辑器安装插件转换。","text":"导语 前端在开发移动端webapp还原设计稿的重要性母庸质疑，目前来说应用最多的应该是rem。然而很多前端开发依然选择要么自己去计算rem值，要么依靠编辑器安装插件转换。 其实，通过一系列的配置后，我们在开发中可以直接使用设计图的尺寸，它为我们自动编译，转换成rem。 技术栈 vue-cli@3.0: 脚手架工具创建项目 postcss-pxtorem: 转换px为rem的依赖包 只需以下几步，就可以愉快地开发了😊。 创建rem.js文件123456789101112131415// 基准大小const baseSize = 32// 设置 rem 函数function setRem() &#123; // 当前页面宽度相对于 750 宽的缩放比例，可根据自己需要修改。 const scale = document.documentElement.clientWidth / 750 // 设置页面根节点字体大小 document.documentElement.style.fontSize = baseSize * Math.min(scale, 2) + &apos;px&apos;&#125;// 初始化setRem()// 改变窗口大小时重新设置 remwindow.onresize = function() &#123; setRem()&#125; main.js中引入rem.js1import &apos;./utils/rem&apos; 引入文件后，可以看到页面的html节点，被自动添加 font-size 安装并配置postcss-pxtoren安装postcss-pxtorem1$ npm install postcss-pxtorem -D 修改跟目录postcss.config.js12345678910111213141516171819202122module.exports = &#123; plugins: &#123; autoprefixer: &#123; browsers: [&apos;Android &gt;= 4.0&apos;, &apos;iOS &gt;= 7&apos;] &#125;, &apos;postcss-pxtorem&apos;: &#123; rootValue: 32, // The root element font size propList: [&apos;*&apos;], // The properties that can change from px to rem. minPixelValue: 20, // Set the minimum pixel value to replace. selectorBlackList: [ &apos;.weui-&apos;, &apos;.ig-&apos;, &apos;.vux-&apos;, &apos;.scroller-&apos;, &apos;.dp-&apos;, &apos;.mt-&apos;, &apos;.mint-&apos;, &apos;.range&apos; ] // The selectors to ignore and leave as px. &#125; &#125;&#125; 按上述完成配置后，即可在开发中直接使用px单位开发。 举个🌰： 123body &#123; width: 750px;&#125; 转换后： 123body &#123; width: 23.4375rem;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"Node-npm常用操作指令","slug":"Node-npm常用操作指令","date":"2017-03-15T08:06:52.000Z","updated":"2018-11-15T12:39:57.061Z","comments":true,"path":"2017/03/15/Node-npm常用操作指令/","link":"","permalink":"http://yoursite.com/2017/03/15/Node-npm常用操作指令/","excerpt":"导语 NPM，全程Node Package Manager，即Node.js模块管理工具。","text":"导语 NPM，全程Node Package Manager，即Node.js模块管理工具。 NPM常用操作指令列表 命令 说明 npm install 安装模块 npm uninstall 卸载模块 npm update 更新模块 npm outdated 检查模块是否已经过时 npm ls 查看安装的模块 npm init 初始化项目的package.json npm help 查看命令的详细帮助 npm root 查看包的安装路径 npm config 查看npm的配置路径 npm cache 管理模块的缓存 npm start 启动模块 npm stop 停止模块 npm restart 重启模块 npm view 查看模块的注册信息 npm version 查看模块版本 npm test 测试模块 npm adduser 添加用户 npm publish 发布模块 npm access 在发布的包上设置访问级别","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"},{"name":"NPM","slug":"NPM","permalink":"http://yoursite.com/tags/NPM/"}]},{"title":"ES6-如何写好.babelrc?","slug":"ES6-如何写好.babelrc？","date":"2017-03-14T06:06:52.000Z","updated":"2018-11-15T12:49:11.611Z","comments":true,"path":"2017/03/14/ES6-如何写好.babelrc？/","link":"","permalink":"http://yoursite.com/2017/03/14/ES6-如何写好.babelrc？/","excerpt":"导语 Babel-The compiler for writing next generation Javascript. 下一代JavaScript 语法的编译器。","text":"导语 Babel-The compiler for writing next generation Javascript. 下一代JavaScript 语法的编译器。 什么是Babel？作为前端开发，由于浏览器的版本和兼容性等问题，很多JS的新的方法都不能使用，等到可以大胆使用的时候，可能已经过去很久。Babel就因此而生，它可以让你放心使用大部分的JS的新的标准的方法，然后编译成兼容绝大多数的主流浏览器的代码。 在升级到Babel6.X版本之后，所有的插件都是可插拔的，这也意味着你安装了Babel之后，是不能工作的，需要配置对应的.babelrc文件才能发挥完整的作用。 预设（presets）使用时需要安装对应的插件，对应babel-preset-xxx。例如下配置，需要npm i babel-preset-es2015。 123&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; env123&#123; &quot;presets&quot;: [&quot;env&quot;, options]&#125; 新增选项，有以下options选择。targets: {[string]: number}，默认{}需要支持的环境，可选例如：chrome，edge，firefox，safari等，甚至可以指定版本，如node：6.5。也使用node：current代表使用当前的版本。 browsers: array | string，默认[]浏览器列表，使用的是browserslist，可选例如：last 2 versions, &gt; 5%。 loose: boolean，默认false是否使用宽松模式，如果设置为true，plugins里的插件如果允许，都会采用宽松模式。 debug: boolean，默认false编译是否会去掉console.log。 whitelist: array，默认[]设置一直引入的plugins列表。es2015/es2016/es2017/latest 123&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; es2015使用es2015，简单翻译如下，更多细节可以参看文档。 check-es2015-constants // 检验const常量是否被重新赋值。 transform-es2015-arrow-functions // 编译箭头函数。 transform-es2015-block-scoped-functions // 函数声明在作用域内。 transform-es2015-block-scoping // 编译const和let。 transform-es2015-classes // 编译class。 transform-es2015-computed-properties // 编译计算对象属性。 transform-es2015-destructuring // 编译解构赋值。 transform-es2015-duplicate-keys // 编译对象中重复的key，其实是转换成计算对象属性。 transform-es2015-for-of // 编译for…of。 transform-es2015-function-name // 将function.name语义应用于所有的function。 transform-es2015-literals // 编译整数(8进制/16进制)和unicode。 transform-es2015-modules-commonjs // 将modules编译成commonjs。 transform-es2015-object-super // 编译super。 transform-es2015-parameters // 编译参数，包括默认参数，不定参数和解构参数。 transform-es2015-shorthand-properties // 编译属性缩写。 transform-es2015-spread // 编译展开运算符。 transform-es2015-sticky-regex // 正则添加sticky属性。 transform-es2015-template-literals // 编译模版字符串。 transform-es2015-typeof-symbol // 编译Symbol类型。 transform-es2015-unicode-regex // 正则添加unicode模式。 transform-regenerator // 编译generator函数。 es2016使用es2016，更多细节可以参看文档。 transform-exponentiation-operator // 编译幂运算符 es2017使用es2017的相关插件，更多细节可以参看文档。 syntax-trailing-function-commas // function最后一个参数允许使用逗号。 transform-async-to-generator // 把async函数转化成generator函数。 latestlatest是一个特殊的presets，包括了es2015，es2016，es2017的插件（目前为止，以后有es2018也会包括进去）。 reactreact是一个比较特别的官方推荐的presets，大概是因为比较火吧。加入了flow，jsx等语法，具体可以看文档。 stage-x(stage-0/1/2/3/4)stage-x和上面的es2015等有些类似，但是它是按照JavaScript的提案阶段区分的，一共有5个阶段。而数字越小，阶段越靠后，存在依赖关系。也就是说stage-0是包括stage-1的，以此类推。 stage-4已完成的提案，与年度发布的release有关，包含2015年到明年正式发布的内容。例如，现在是2016年，stage-4应该是包括es2015，es2016，es2017。经过测试，babel-preset-stage-4这个npm包是不存在的，如果你单纯的需要stage-4的相关方法，需要引入es2015~es2017的presets。 stage-3除了stage-4的内容，还包括以下插件，更多细节请看文档。 transform-object-rest-spread // 编译对象的解构赋值和不定参数。 transform-async-generator-functions // 将async generator function和for await编译为es2015的generator。 stage-2除了stage-3的内容，还包括以下插件，更多细节请看文档。 transform-class-properties // 编译静态属性(es2015)和属性初始化语法声明的属性(es2016)。 stage-1除了stage-2的内容，还包括以下插件，更多细节请看文档。 transform-class-constructor-call // 编译class中的constructor，在Babel7中会被移除。 transform-export-extensions // 编译额外的export语法，如export * as ns from “mod”。 stage-0除了stage-1的内容，还包括以下插件，更多细节请看文档。 transform-do-expressions // 编译do表达式。 transform-function-bind // 编译bind运算符，也就是::。 插件(plugins)其实看了上面的应该也明白了，presets，也就是一堆plugins的预设，起到方便的作用。如果你不采用presets，完全可以单独引入某个功能，比如以下的设置就会引入编译箭头函数的功能。 123&#123; &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]&#125; 还有一些方法是presets中不提供的，这时候就需要单独引入了，介绍几个常见的插件。 transform-runtime123&#123; &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]&#125; 主要有以下options选择。 helpers: boolean // 默认为true，使用babel的helper函数。 polyfill: boolean // 默认为true，使用babel的polyfill，但不能完全取代bebel-polyfill。 regenerator: boolean // 默认为true，使用babel的regenerator。 noduleName: string // 默认babel-runtime，使用对应module处理。 options一般不用自己设置，使用默认的即可。这个插件的作用主要是： 解决编译中产生的重复的工具函数，减小代码体积 非实例方法的poly-fill，如Object.assign，但是实例方法不支持，如”foobar”.includes(“foo”)，这时候需要单独引入babel-polyfill。 更多细节参见文档。 transform-remove-console123&#123; &quot;plugins&quot;: [&quot;transform-remove-console&quot;]&#125; 使用这个插件，编译后的代码都会移除console.*，妈妈再也不用担心线上代码有多余的console.log了。当然很多时候，我们如果使用webpack，会在webpack中配置。 这也告诉我们，Babel不仅仅是编译代码的工具，还能对代码进行压缩，也许有一天，你不再需要代码压缩的插件了，因为你有了Babel！ 自定义预设或插件Babel支持自定义的预设(presets)或插件(plugins)。如果你的插件在npm上，可以直接采用这种方式”plugins”: [“babel-plugin-myPlugin”]，当然，你也可以缩写，它和”plugins”: [“myPlugin”]是等价的。此外，你还可以采用本地的相对路径引入插件，比如”plugins”: [“./node_modules/asdf/plugin”]。 presets同理。 plugins/presets排序也许你会问，plugins和presets编译，也许会有相同的功能，或者有联系的功能，按照怎么的顺序进行编译？答案是会按照一定的顺序。 具体而言，plugins优先于presets进行编译。 plugins按照数组的index增序(从数组第一个到最后一个)进行编译。 presets按照数组的index倒序(从数组最后一个到第一个)进行编译。因为作者认为大部分会把presets写成[“es2015”, “stage-0”]。具体细节可以看这个。 总结12345678910111213&#123; \"presets\": [ [\"env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125; &#125;], \"stage-2\" ], \"plugins\": [\"transform-runtime\", \"transform-vue-jsx\"], \"comments\": false&#125; 强烈推荐使用transform-runtime。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6-Airbnb JavaScript（ES6）代码规范","slug":"ES6-Airbnb JavaScript（ES6）代码规范","date":"2017-03-12T08:06:52.000Z","updated":"2018-11-15T12:39:23.826Z","comments":true,"path":"2017/03/12/ES6-Airbnb JavaScript（ES6）代码规范/","link":"","permalink":"http://yoursite.com/2017/03/12/ES6-Airbnb JavaScript（ES6）代码规范/","excerpt":"导语 本文摘自—Airbnb JavaScript（ES6）代码规范。","text":"导语 本文摘自—Airbnb JavaScript（ES6）代码规范。 声明变量的新姿势用let不用varES6之前我们使用var声明一个变量，但是它有很多弊病： 无块级作用域变量，很容易声明全局变量。 变量提升。 可重复声明。 12345678910var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10a[7](); // 10a[8](); // 10a[9](); // 10 所以，你有什么理由不用let? 某些场景，const比let更好const和let的唯一区别就是，const不可以被更改，所以当声明变量的时候，尤其是在声明容易被更改的全局变量的时候，尽量使用const。 更好的代码语义化，一眼看到就是常量。 另一个原因是因为JavaScript 编译器对const的优化要比let好，多使用const，有利于提高程序的运行效率。 所有的函数都应该设置为常量。 动态字符串不要使用“双引号”，一律用单引号或反引号。 12345678// lowconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// bestconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 解构赋值的骚操作变量赋值在用到数组成员对变量赋值时，尽量使用解构赋值。 12345678const arr = [1, 2, 3, 4];// lowconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数传对象函数的参数如果是对象的成员，优先使用解构赋值。 123456789// lowfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 1234567891011// lowfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 关于对象的细节逗号单行定义的对象结尾不要逗号： 12345// lowconst a = &#123; k1: v1, k2: v2, &#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;; 多行定义的对象要保留逗号：： 1234567891011// lowconst b = &#123; k1: v1, k2: v2&#125;;// goodconst b = &#123; k1: v1, k2: v2,&#125;; 一次性初始化完全不要声明之后又给对象添加新属性： 1234567// lowconst a = &#123;&#125;;a.x = 3;// goodconst a = &#123; x: null &#125;;a.x = 3; 如果一定非要加请使用Object.assign： 12const a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;); 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义： 12345678910111213/ lowconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,[getKey(&apos;enabled&apos;)]: true,&#125;; 在简洁一点1234567891011121314151617181920212223var ref = &apos;some value&apos;;// lowconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组扩展运算符…使用扩展运算符（…）拷贝数组： 1234567891011// 还在用for i 你就太low了const len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// cool !const itemsCopy = [...items]; Array.form（）用 Array.from 方法，将类似数组的对象转为数组： 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 函数箭头函数=&gt;立即执行函数可以写成箭头函数的形式： 123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 尽量写箭头函数使你的代码看起来简洁优雅： 1234567// low[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// cool ![1, 2, 3].map(x =&gt; x * x); 别再用arguments（类数组）了！使用 rest 运算符（…）代替，rest 运算符可以提供一个真正的数组。 12345678910// lowfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 传参时试试设置默认值123456789// lowfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Object？Map！简单的键值对优先Map如果只是简单的key: value结构，建议优先使用Map，因为Map提供方便的遍历机制。 12345678910111213let map = new Map(arr);// 遍历key值for (let key of map.keys()) &#123; console.log(key);&#125;// 遍历value值for (let value of map.values()) &#123; console.log(value);&#125;// 遍历key和value值for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; class语法123456789101112131415161718192021// lowfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 模块化引入模块使用import取代require，因为Module是Javascript模块的标准写法。 1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 输出模块使用export输出变量，拒绝module.exports: 123456789import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 输出单个值，使用export default。 输出多个值，使用export。 export default与普通的export不要同时使用。 编码规范模块输出一个函数，首字母应该小写： 1234function getData() &#123;&#125;export default getData;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"精心收集的48个JavaScript代码片段","slug":"JS-精心收集的48个JavaScript代码片段","date":"2017-03-11T13:06:52.000Z","updated":"2018-11-15T12:39:08.282Z","comments":true,"path":"2017/03/11/JS-精心收集的48个JavaScript代码片段/","link":"","permalink":"http://yoursite.com/2017/03/11/JS-精心收集的48个JavaScript代码片段/","excerpt":"导语 该文章摘自Github用户Chalarangelo，目前已在Github上获得了5K多个star，精心收集了多达48个有用的JavaScript代码片段。","text":"导语 该文章摘自Github用户Chalarangelo，目前已在Github上获得了5K多个star，精心收集了多达48个有用的JavaScript代码片段。 Anagrams of string(带有重复项)使用递归，对于给定字符串中的每个字母，为字母创建字谜。使用map()将字母与每部分字谜结合，然后使用reduce()将所有字谜组合到一个数据中，最基本情况是字符串长度等于2或1。 123456const anagrams = str =&gt; &#123; if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str]; return str.split(&apos;&apos;).reduce((acc, letter, i) =&gt; &#123; acc.concat(anagrams(str.slice(0, 1) + str.slice(i + 1)).map(val =&gt; letter + val))&#125;, []);&#125;;// anagrams(&apos;abc&apos;) -&gt; [&apos;abc&apos;,&apos;acb&apos;,&apos;bac&apos;,&apos;bca&apos;,&apos;cab&apos;,&apos;cba&apos;] 数组平均值使用reduce()将每个值添加到累加器，初始值为0，总和除以数组长度。 12const average = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;// avarage([1, 2, 3]) -&gt; 2 大写每个单词的首字母使用replace()匹配每个单词的第一个字符，并使用toUpperCase()来将其大写。 12const capitalizeEveryWord = str =&gt; str.replace(/\\b[a-z]/g, char =&gt; char.toUpperCase());// capitalizeEveryWord(&apos;hello world!&apos;) -&gt; &apos;Hello World!&apos; 首字母大写使用slice (0,1)和toUpperCase ()大写第一个字母，slice (1)获取字符串的其余部分。省略lowerRest参数以保持字符串的其余部分不变，或将其设置为true以转换为小写。(注：这和上一示例不是同一件事情) 1234const capitalize = (str, lowerRest = false) =&gt; &#123; str.slice(0, 1).toUpperCase() + (lowerRest ? str.slice(1).toLowerCase() : str.slice(1));&#125;// capitalize(&apos;myName&apos;, true) -&gt; &apos;Myname&apos; 检查回文将字符串转换为toLowerCase ()，并使用replace ()从中删除非字母的字符串。然后，将其转换为toLowerCase ()，将(‘’)拆分为单独字符，reverse ()，join (‘’)，与原始的非反转字符串进行比较，然后将其转换为toLowerCase ()。 12345const palindrome = str =&gt; &#123; const s = str.toLowerCase().replace(/[\\W_]/g, &apos;&apos;); return s === s.split(&apos;&apos;).reverse().join(&apos;&apos;);&#125;// palindrome(&apos;taco cat&apos;) -&gt; true 计算数组中值的出现次数每次遇到数组中的特别值时，使用reduce()来递增计数器。 12const countOccurrences = (arr, value) =&gt; arr.reduce((a, v) =&gt; v === value ? a + 1:a + 0, 0);// countOccurrences([1, 1, 2, 1, 2, 3], 1) -&gt; 3 当前URL使用windows.location.href来获取当前URL。 12const currentUrl = () =&gt; return window.location.href;// currentUrl() -&gt; &apos;https://google.com&apos; Curry使用递归。如果提供的参数(args)数量足够，则调用传递函数f，否则返回一个curried函数f。 12345const curry = (fn, arity = fn.length, ...args) =&gt; &#123; arity &lt;= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);&#125;// curry(Math.pow)(2)(10) -&gt; 1024// curry(Math.min, 3)(10)(50)(2) -&gt; 2 Deep flatten array使用递归，使用reduce()来获取所有不是数组的元素，flatten每个元素都是数组。 1234const deepFlatten = arr =&gt; &#123; arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? deepFlatten(v) : v), []);&#125;// deepFlatten([1, [2], [[3], 4], 5]) -&gt; [1, 2, 3, 4, 5] 数组之间的区别从b创建一个Set，然后在a上使用Array.filter()，只保留b中不包含的值。 12345const difference = (a, b) =&gt; &#123; const s = new Set(b); return a.filter(x =&gt; !s.has(x))&#125;// difference([1, 2, 3], [1, 2]) -&gt; [3] 两点之间的距离使用Math.hypot()计算两点之间的欧几里德距离。 12const distance = (x0, y0, x1, y1) =&gt; Math.hypot(x1 - x0, y1 - y0);// distance(1,1, 2,3) -&gt; 2.23606797749979 可以按数字整除使用模运算符(%)来检查余数是否等于0。 12const isDivisible = (dividend, divisor) =&gt; dividend % divisor === 0;// isDivisible(6, 3) -&gt; true 转义正则表达式使用replace()来转义特殊字符。 12const escapeRegExp = str =&gt; str.replace(/[.*+?^$&#123;&#125;()|[\\]\\\\]/g, &apos;\\\\$&amp;&apos;);// escapeRegExp(&apos;(test)&apos;) -&gt; \\\\(test\\\\) 偶数或奇数使用Math.abs()将逻辑扩展为负数，使用模(%)运算符进行检查。如果数字是偶数，则返回true；如果数字是奇数，则返回false。 12const isEven = num =&gt; Math.abs(num) % 2 === 0;// isEven(3) -&gt; false 阶乘使用递归。如果n小于或等于1，则返回1。否则返回n和n-1的阶乘的乘积。 12const factorial = n =&gt; n &lt;=1 ? 1 : n * factorial(n - 1);// factorial(6) -&gt; 720 斐波那契数组生成器创建一个特定长度的空数组，初始化前两个值(0和1)。使用Array.reduce()向数组中添加值，后面的一个数等于前面两个数相加之和(前两个除外)。 123const fibonacci = n =&gt; Array(n).fill(0).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []);// fibonacci(5) -&gt; [0,1,1,2,3] 过滤数组中的非唯一值将Array.filter() 用于仅包含唯一值得数组。 12const filterNonUnique = arr =&gt; arr.filter(i =&gt; arr.indexOf(i) === arr.lastIndexOf(i));// filterNonUnique([1, 2, 3, 2, 4, 4, 5]) -&gt; [1, 3, 5] Flatten数组使用reduce()来获取数组中的所有元素，并使用concat()来使它们flatten。 12const flatten = arr =&gt; arr.reduce((a, v) =&gt; a.concat(v), []);// flatten([1,[2],3,4]) -&gt; [1,2,3,4] 从数组中获取最大值用Math.max()与spread运算符(…)结合得到数组中的最大值。 12const arrayMax = arr =&gt; Math.max(...arr);// arrayMax([10, 1, 5]) -&gt; 10 从数组中获取最小值使用Math.min()与spread运算符(…)结合得到数组中的最小值。 12const arrayMin = arr =&gt; Math.min(...arr);// arrayMin([10, 1, 5]) -&gt; 1 获取滚动位置如果已定义，请使用pageXOffset和pageYOffset，否则使用scrollLeft和scrollTop，可以省略el来使用window的默认值。 1234const getScrollPos = (el = window) =&gt; (&#123;x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft, y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop&#125;);// getScrollPos() -&gt; &#123;x: 0, y: 200&#125; 最大公约数(GCD)使用递归。基本情况是当y等于0时。在这种情况下，返回x。否则，返回y的GCD和x / y的其余部分。 12const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y);// gcd (8, 36) -&gt; 4 Head of list返回ARR[0] 12const head = arr =&gt; arr[0];// head([1,2,3]) -&gt; 1 list初始化返回arr.slice(0，-1) 12const initial = arr =&gt; arr.slice(0, -1);// initial([1,2,3]) -&gt; [1,2] 用range初始化数组使用Array(end-start)创建所需长度的数组，使用map()来填充范围内的所需值 123const initializeArrayRange = (end, start = 0) =&gt; Array.apply(null, Array(end - start)).map((v, i) =&gt; i + start);// initializeArrayRange(5) -&gt; [0,1,2,3,4] 用值初始化数组使用Array(n)创建所需长度的数组，fill(v)以填充所需的值，可以忽略value使用默认值0。 12const initializeArray = (n, value = 0) =&gt; Array(n).fill(value);// initializeArray(5, 2) -&gt; [2,2,2,2,2] 列表的最后返回arr.slice(-1)[0] 12const last = arr =&gt; arr.slice(-1)[0];// last([1,2,3]) -&gt; 3 测试功能所花费的时间使用performance.now()获取函数的开始和结束时间，console.log()所花费的时间。第一个参数是函数名，随后的参数传递给函数。 12345678const timeTaken = callback =&gt; &#123; console.time(&apos;timeTaken&apos;); const r = callback(); console.timeEnd(&apos;timeTaken&apos;); return r;&#125;;// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024// (logged): timeTaken: 0.02099609375ms 来自键值对的对象使用Array.reduce()来创建和组合键值对。 12const objectFromPairs = arr.reduce((a, v) =&gt; (a[v[0]] =v[1], a), &#123;&#125;);// objectFromPairs([[&apos;a&apos;,1],[&apos;b&apos;,2]]) -&gt; &#123;a: 1, b: 2&#125; 管道使用Array.reduce()通过函数传递值。 12const pipe = (...funcs) =&gt; arg =&gt; funcs.reduce((acc, func) =&gt; func(acc), arg);// pipe(btoa, x =&gt; x.toUpperCase())(&quot;Test&quot;) -&gt; &quot;VGVZDA==&quot; Powerset使用reduce()与map()结合来遍历元素，并将其组合成包含所有组合的数组。 12const powerset = arr =&gt; arr.reduce((a, v) =&gt; a.concat(a.map(r =&gt; [v].concat(r))), [[]]);// powerset([1,2]) -&gt; [[], [1], [2], [2,1]] 范围内的随机整数使用Math.random()生成一个随机数并将其映射到所需的范围，使用Math.floor()使其成为一个整数。 12const randomIntegerInRange = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min;// randomIntegerInRange(0, 5) -&gt; 2 范围内的随机数使用Math.random()生成一个随机值，使用乘法将其映射到所需的范围。 12const randomInRange = (min, max) =&gt; Math.random() * (max - min) + min;// randomInRange(2,10) -&gt; 6.0211363285087005 随机化数组的顺序使用sort()重新排序元素，使用Math.random()来随机排序。 12const shuffle = arr =&gt; arr.sort(() =&gt; Math.random() - 0.5);// shuffle([1,2,3]) -&gt; [2,3,1] 重定向到URL使用window.location.href或window.location.replace()重定向到url。传递第二个参数来模拟链接点击(true-default)或HTTP重定向(false)。 12const redirect = (url, asLink = true) =&gt; asLink ? window.location.href = url : window.location.replace(url);// redirect(&apos;https://google.com&apos;) 反转一个字符串使用数组解构和Array.reverse()来颠倒字符串中的字符顺序。合并字符以使用join(‘’)获取字符串。 12const reverseString = str =&gt; [...str].reverse().join(&apos;&apos;);// reverseString(&apos;foobar&apos;) -&gt; &apos;raboof&apos; RGB到十六进制使用按位左移运算符(&lt;&lt;)和toString(16)，然后padStart(6，“0”)将给定的RGB参数转换为十六进制字符串以获得6位十六进制值。 12const rgbToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, &apos;0&apos;);// rgbToHex(255, 165, 1) -&gt; &apos;ffa501&apos; 滚动到顶部使用document.documentElement.scrollTop或document.body.scrollTop获取到顶部的距离。从顶部滚动一小部分距离。 使用window.requestAnimationFrame()来滚动。 12345678const scrollToTop = _ =&gt; &#123;const c = document.documentElement.scrollTop || document.body.scrollTop; if (c &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, c - c / 8); &#125;&#125;;// scrollToTop() 随机数组值使用Array.map()和Math.random()创建一个随机值的数组。使用Array.sort()根据随机值对原始数组的元素进行排序。 12345const shuffle = arr =&gt; &#123;let r = arr.map(Math.random);return arr.sort((a,b) =&gt; r[a] - r[b]);&#125;// shuffle([1, 2, 3]) -&gt; [2, 1, 3] 数组之间的相似性使用filter()移除不是values的一部分值，使用includes()确定。 12const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v));// similarity([1,2,3], [1,2,4]) -&gt; [1,2] 按字符串排序(按字母顺序排序)使用split(‘’)分割字符串，sort()使用localeCompare()，使用join(‘’)重新组合。 12const sortCharactersInString = str =&gt; str.split(&apos;&apos;).sort((a, b) =&gt; a.localeCompare(b)).join(&apos;&apos;);// sortCharactersInString(&apos;cabbage&apos;) -&gt; &apos;aabbceg&apos; 数组总和使用reduce()将每个值添加到累加器，初始化值为0。 12const sum = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0);// sum([1,2,3,4]) -&gt; 10 交换两个变量的值使用数组解构来交换两个变量之间的值。 12[varA, varB] = [varB, varA]// [x, y] = [y, x] 列表的tail返回arr.slice(1)。 123const tail = arr =&gt; arr.length &gt; 1 ? arr.slice(1) : arr;// tail([1,2,3]) -&gt; [2,3]// tail([1]) -&gt; [1] 数组唯一值使用ES6 Set和…rest操作符去掉所有重复值。 12const unique = arr =&gt; [...new Set(arr)];// unique([1, 2, 2, 3, 4, 4, 5]) -&gt; [1, 2, 3, 4, 5] URL参数使用match()与适当的正则表达式来获得所有键值对，适当的map()。使用Object.assign()和spread运算符(…)将所有键值对组合到一个对象中，将location.search()作为参数传递给当前url。 12const getUrlParameters = url =&gt; url.match(/([^?=&amp;]+)(=([^&amp;]*))/g).reduce((a, v) =&gt; (a[v.slice(0, v.indexOf(&apos;=&apos;))] = v.slice(v.indexOf(&apos;=&apos;) + 1), a), &#123;&#125;);// getUrlParameters(&apos;http://url.com/page?name=Adam&amp;surname=Smith&apos;) -&gt; &#123;name: &apos;Adam&apos;, surname: &apos;Smith&apos;&#125; UUID生成器使用crypto API生成符合RFC4122版本4的UUID。 12const uuid = _ =&gt; ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt; (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16));// uuid() -&gt; &apos;7982fcfe-5721-4632-bede-6000885be57d&apos; 验证数字使用！isNaN和parseFloat（）来检查参数是否是一个数字，使用isFinite（）来检查数字是否是有限的。 12const validateNumber = n =&gt; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n) &amp;&amp; Number(n) == n;// validateNumber(&apos;10&apos;) -&gt; true","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Vue-Chrome插件开发实录[转]","slug":"Vue-Chrome 插件开发实录[转]","date":"2017-03-10T13:06:52.000Z","updated":"2018-11-15T12:38:53.845Z","comments":true,"path":"2017/03/10/Vue-Chrome 插件开发实录[转]/","link":"","permalink":"http://yoursite.com/2017/03/10/Vue-Chrome 插件开发实录[转]/","excerpt":"导语 开发一个Chrome插件就跟我们平时做web开发流程没多大的区别，就是先搭好基本的页面，然后使用js来写交互逻辑等功能。","text":"导语 开发一个Chrome插件就跟我们平时做web开发流程没多大的区别，就是先搭好基本的页面，然后使用js来写交互逻辑等功能。 Chrome插件开发基本知识在应用商店中下载下来的插件基本上都是以.crx为文件后缀，该文件其实就是一个压缩包，包括插件所需要的html、css、javascript、图片资源等等文件。 开发一个插件就跟我们平时做web开发流程没多大的区别，就是先搭好基本的页面，然后使用js来写交互逻辑等功能。 比如我这个插件的目录文件如下： manifest.json文件文件中需要注意一下的mainfest.json这个文件，这个json文件的作用是提供插件的各种信息，例如插件能够做的事情，以及插件的文件配置等等信息。下面是一个清单文件的示例： 12345678910111213&#123; &quot;manifest_version&quot;: 2, &quot;name&quot;: &quot;One-click Kittens&quot;, &quot;description&quot;: &quot;This extension demonstrates a browser action with kittens.&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;permissions&quot;: [ &quot;https://secure.flickr.com/&quot; ], &quot;browser_action&quot;: &#123; &quot;default_icon&quot;: &quot;icon.png&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; &#125;&#125; 第一行声明我们使用清单文件格式的版本 2，必须包含（版本 1 是旧的，已弃用，不建议使用）。 接下来的部分定义扩展程序的名称、描述与版本。这些都会在 Chrome 浏览器中使用，向用户显示已安装的扩展程序，同时在 Chrome 网上应用店中向潜在的新用户显示您的扩展程序。名称应该简练，描述不要比一句话左右还长（后面将会有更多的空间用于更详细的描述）。 最后一部分首先请求权限，用于访问 https://secure.flickr.com/ 上的数据，并声明该扩展程序实现了一个浏览器按钮，同时在这一过程中为它指定一个默认图标与弹出窗口。 定义浏览器按钮时指向了两个资源文件：icon.png 与 popup.html。这两个资源都必须在扩展程序包中存在，图片是扩展的显示，html是扩展具体运行的基础文件。 具体详细的开发教程可以看看官方的这个文档，非常简明的入门教程。 功能实现-Vuejs实践整个插件的核心交互功能非常简单，如文章开头的动图所示，用户选择对齐方式，代码区域显示对应的代码。这种简单数据交互使用vuejs再适合不过了，vuejs基础知识这里就不再细说了。 这里需要注意的一点是，chrome 扩展的运行环境有一些特殊要求，称为 Content Security Policy (CSP)，使得通常的 vue 不能被正常使用。如果用的是 vue 1.x，那么可以下载 csp 版本，在 这里。如果是 2.x 版本，请参考官网文档的这一段。 核心代码如下所示。 HTML： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- 引入样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;mystique.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 class=&quot;title-box&quot;&gt;flexbox对齐就是这么简单&lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;type-select&quot;&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;!-- &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt; --&gt; &lt;div class=&quot;resule-preview&quot;&gt; &lt;div v-bind:class=&quot;selected&quot; class=&quot;cols&quot;&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;resule-code&quot;&gt; &lt;pre class=&quot;code-display&quot;&gt; &lt;code class=&quot;code-lang&quot;&gt; &#123;&#123; cssMsg &#125;&#125; &lt;/code&gt; &lt;/pre&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 先引入 Vue --&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 引入样式 --&gt; CSS就不列出来了，可以在源代码中查看。 下面来使用vuejs来实现插件的功能。 功能实现使用 v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。 而下拉框（select）列表的渲染，就可以使用vue中的v-for方法来渲染下拉列表选项，下拉选项数据写在js中的data对象中的options中。用v-bind方法来绑定option的value值，代码如下所示： XHTML 12345&lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt; 在vuejs中可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。这里在select中使用v-model方法来监听选中的值。 为了能预览不同对齐的效果，先在CSS中写好和下拉框中值相同的对应的类名样式，这样当用户选中不同的值的时候能显示不同的效果。这里我们使用v-bind方法来实现这个功能，它主要用于属性绑定，我们可以给v-bind:class一个对象，以动态地切换class。 1234567891011&lt;div v-bind:class=&quot;selected&quot; class=&quot;cols&quot;&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 下拉框这块功能就这样，简简单单几行代码就实现了。想想要是用jquery或者是原生的js来实现同样的功能，不仅代码量要大而且写起来也没有vuejs这么舒服。 接下来是代码同步功能，即在代码区域显示对应flex对齐的CSS代码。 开始之前先讲讲vuejs中的computed属性方法，可计算属性 (computed properties) 就是不存在于原始数据中，而是在运行时实时计算出来的属性。 对应到我们这个实例，就是当用户选择flexbox不同的对齐方式的时候，及时同步对应的CSS代码到代码预览区域。简单起见，直接把几个不同的代码写到js中： 12345678910111213data: &#123; selected: &apos;cols-center&apos;, cssText: &#123; &apos;cols-center&apos; : &apos;nr-webkit-justify-content: center;nr-ms-flex-pack: center;nrjustify-content: center;&apos;, &apos;cols-space-between&apos; : &apos;nr-webkit-justify-content: space-between;nr-ms-flex-pack: justify;nrjustify-content: space-between;&apos;, &apos;cols-space-around&apos; : &apos;nr-webkit-justify-content: space-around;nr-ms-flex-pack: distribute;nrjustify-content: space-around;&apos; &#125;, options: [ &#123; text: &apos;居中对齐&apos;, value: &apos;cols-center&apos;&#125;, &#123; text: &apos;两端对齐&apos;, value: &apos;cols-space-between&apos;&#125;, &#123; text: &apos;间隔相等&apos;, value: &apos;cols-space-around&apos;&#125; ] &#125; 根据不同的名字对应不同的CSS代码。然后使用computed方法来根据用户选取的值实时取出对应的CSS代码： 123456computed:&#123; cssMsg:function()&#123; console.log(this) return this.cssText[this.selected]; &#125;&#125; 完整代码如下： 12345678910111213141516171819202122var typeSelect = new Vue(&#123; el: &apos;body&apos;, data: &#123; selected: &apos;cols-center&apos;, cssText:&#123; &apos;cols-center&apos; : &apos;nr-webkit-justify-content: center;nr-ms-flex-pack: center;nrjustify-content: center;&apos;, &apos;cols-space-between&apos; : &apos;nr-webkit-justify-content: space-between;nr-ms-flex-pack: justify;nrjustify-content: space-between;&apos;, &apos;cols-space-around&apos; : &apos;nr-webkit-justify-content: space-around;nr-ms-flex-pack: distribute;nrjustify-content: space-around;&apos; &#125;, options: [ &#123; text: &apos;居中对齐&apos;, value: &apos;cols-center&apos;&#125;, &#123; text: &apos;两端对齐&apos;, value: &apos;cols-space-between&apos;&#125;, &#123; text: &apos;间隔相等&apos;, value: &apos;cols-space-around&apos;&#125; ] &#125;, computed:&#123; cssMsg:function()&#123; console.log(this) return this.cssText[this.selected]; &#125; &#125;&#125;) 最后在html中绑定通过computed方法得到数据也就是CSS： 1234567&lt;div class=&quot;resule-code&quot;&gt; &lt;pre class=&quot;code-display&quot;&gt; &lt;code class=&quot;code-lang&quot;&gt; &#123;&#123; cssMsg &#125;&#125; &lt;/code&gt; &lt;/pre&gt;&lt;/div&gt; 插件代码下载（https://share.weiyun.com/d51b9e473e12f8c43e7eaafc9e2f11a7） 开发好之后，可以直接在chrome中运行来调试。打开扩展面板，勾选开发者模式，然后加载刚开发扩展所在的目录就可以直接运行了。 一个简单的插件就完成了，通过这一个简单的chrome插件就可以体验到vuejs在web开发中简单、优雅的魅力，还有什么理由不用起来呢。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-cli中Webpack配置基础文件详解","slug":"Vue-cli中Webpack配置基础文件详解","date":"2017-03-09T12:06:52.000Z","updated":"2018-11-15T12:38:44.285Z","comments":true,"path":"2017/03/09/Vue-cli中Webpack配置基础文件详解/","link":"","permalink":"http://yoursite.com/2017/03/09/Vue-cli中Webpack配置基础文件详解/","excerpt":"导语 Vue-cli是构建Vue单页应用的脚手架，输入一串指定的命令行从而自动生成Vue.js+Wepack的项目模板。","text":"导语 Vue-cli是构建Vue单页应用的脚手架，输入一串指定的命令行从而自动生成Vue.js+Wepack的项目模板。 前言通过Vue-cli生成的Vue.js+Webpack的项目模板，这其中webpack发挥了很大的作用，它使得我们的代码模块化，引入一些插件帮我们完善功能可以将文件打包压缩，图片转base64等。后期对项目的配置使得我们对于脚手架自动生成的代码的理解更为重要，接下来我们将基于webpack3.6.0版本结合文档将文件各个击破。 主体结构12345678910111213141516171819├─build├─config├─dist├─node_modules├─src│ ├─assets│ ├─components│ ├─router│ ├─App.vue│ ├─main.js├─static├─.babelrc├─.editorconfig├─.gitignore├─.postcssrc.js├─index.html├─package-lock.json├─package.json└─README.md package.json项目作为一个大家庭，每个文件都各司其职。package.json来制定名单，需要哪些npm包来参与到项目中来，npm install命令根据这个配置文件增减来管理本地的安装包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&#123; //从name到license都是package的配置信息，也就是我们在脚手架搭建中输入的项目描述 &quot;name&quot;: &quot;shou-fei-yun&quot;, // 项目名称 &quot;version&quot;: &quot;0.2.1&quot;, // 项目版本号 &quot;description&quot;: &quot;新疆公路收费&quot;, // 项目描述 &quot;author&quot;: &quot;ETVC &lt;etvcsoft.com&gt;&quot;, // 作者名字 &quot;license&quot;: &quot;MIT&quot;, // 许可证标识 // scripts中的子项即是我们在控制台运行的脚本的缩写 &quot;scripts&quot;: &#123; // webpack-dev-server启动了http服务器，实现实时编译 // inline模式会在webpack.config.js入口配置中新增webpack-dev-server/client?http://localhost:8080/的入口 // progress显示打包的进度 &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, // 与npm run dev相同 &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, // 使用node运行build文件 &quot;brwoser-sync&quot;: &quot;cd dist &amp;&amp; browser-sync start --server&quot; &#125;, // 项目依赖库：在安装时使用--save则写入到dependencies &quot;dependencies&quot;: &#123; &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-runtime&quot;: &quot;^5.8.0&quot;, &quot;countup.js&quot;: &quot;^1.8.1&quot;, &quot;echarts&quot;: &quot;^3.3.2&quot;, &quot;hideseek&quot;: &quot;^0.7.0&quot;, &quot;http-server&quot;: &quot;^0.9.0&quot;, &quot;jquery&quot;: &quot;^2.2.2&quot;, &quot;moment&quot;: &quot;^2.18.1&quot;, &quot;vue&quot;: &quot;^2.5.9&quot;, &quot;vue-date-picker&quot;: &quot;^1.0.2&quot;, &quot;vue-localstorage&quot;: &quot;^0.1.3&quot;, &quot;vue-prism&quot;: &quot;^1.0.5&quot;, &quot;vue-prism-component&quot;: &quot;^1.0.1&quot;, &quot;vue-resource&quot;: &quot;^1.3.4&quot;, &quot;vue-router&quot;: &quot;^2.8.1&quot;, &quot;vue-scrollTo&quot;: &quot;^2.3.2&quot;, &quot;vue-uweb&quot;: &quot;^0.1.0&quot;, &quot;vuex&quot;: &quot;^2.1.1&quot;, &quot;vuex-router-sync&quot;: &quot;^4.1.0&quot;, &quot;waypoints&quot;: &quot;^4.0.1&quot; &#125;, // 开发依赖库：在安装时使用--save-dev将写入到devDependencies &quot;devDependencies&quot;: &#123; &quot;@xkeshi/vue-qrcode&quot;: &quot;^0.3.0&quot;, &quot;autoprefixer&quot;: &quot;^7.1.2&quot;, // autoprefixer作为postcss插件用来解析css补充前缀，例如 display: flex会补充为display:-webkit-box;display: -webkit-flex等 // 以下几个babel开头的都是针对es6解析的插件，用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本 &quot;babel-core&quot;: &quot;^6.22.1&quot;, // babel的核心，把js代码分析成ast，方便各个插件分析语法进行相应的处理 &quot;babel-eslint&quot;: &quot;^8.2.1&quot;, &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;, // 预制babel-template函数，提供给vue，jsx等使用 &quot;babel-loader&quot;: &quot;^7.1.1&quot;, // 使项目运行使用babel和webpack来传输js文件，使用babel-core提供的api进行转译 &quot;babel-plugin-component&quot;: &quot;^0.9.1&quot;, &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;, // 支持jsx &quot;babel-plugin-transform-runtime&quot;: &quot;^6.0.0&quot;, // 避免编译输出中的重复，直接编译到build环境中 &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.4.2&quot;, // babel转译过程中使用到的插件，避免重复 &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;, // ES第二阶段的规范 &quot;babel-register&quot;: &quot;^6.0.0&quot;, &quot;chalk&quot;: &quot;^2.0.1&quot;, // 用来在命令行中输出不同颜色文字 &quot;clipboard&quot;: &quot;^1.7.1&quot;, &quot;compression&quot;: &quot;^1.7.1&quot;, &quot;connect-history-api-fallback&quot;: &quot;^1.5.0&quot;, &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;, // 拷贝资源和文件 &quot;cross-spawn&quot;: &quot;^5.0.1&quot;, &quot;css-loader&quot;: &quot;^0.28.0&quot;, // webpack先用css-loader加载器去解析后缀名为css的文件，在使用style-loader生成一个内容为最终解析完的css的style标签，放到head标签里 &quot;element-theme-chalk&quot;: &quot;^2.0.7&quot;, &quot;element-ui&quot;: &quot;^2.4.0&quot;, &quot;eslint&quot;: &quot;^3.7.1&quot;, &quot;eslint-config-standard&quot;: &quot;^10.2.1&quot;, &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;, &quot;eslint-loader&quot;: &quot;^1.7.1&quot;, &quot;eslint-plugin-html&quot;: &quot;^1.3.0&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.8.0&quot;, &quot;eslint-plugin-node&quot;: &quot;^5.2.1&quot;, &quot;eslint-plugin-promise&quot;: &quot;3.4.0&quot;, &quot;eslint-plugin-standard&quot;: &quot;^3.0.1&quot;, &quot;eslint-plugin-vue&quot;: &quot;^4.2.0&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;, // 将一个以上的包里面的文本提取到单独文件中 &quot;file-loader&quot;: &quot;^1.1.4&quot;, // 打包压缩文件，与url-loader用法类似 &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;, // 识别某些类别的webpack错误和清理，聚合和优先排序，以提供更好的开发体验 &quot;function-bind&quot;: &quot;^1.0.2&quot;, &quot;happypack&quot;: &quot;^4.0.0-beta.1&quot;, &quot;highlight.js&quot;: &quot;^9.12.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.28.0&quot;, // 简化了HTML文件的创建，引入了外部资源，创建html的入口文件，可通过此项进行多页面的配置 &quot;http-proxy-middleware&quot;: &quot;^0.17.4&quot;, &quot;imports-loader&quot;: &quot;^0.7.0&quot;, &quot;inject-loader&quot;: &quot;^3.0.0&quot;, &quot;isparta-loader&quot;: &quot;^2.0.0&quot;, &quot;json-loader&quot;: &quot;^0.5.4&quot;, &quot;lolex&quot;: &quot;^1.4.0&quot;, &quot;mavon-editor&quot;: &quot;^2.2.6&quot;, &quot;mocha&quot;: &quot;^3.1.0&quot;, &quot;node-notifier&quot;: &quot;^5.1.2&quot;, // 支持使用node发送跨平台的本地通知 &quot;node-sass&quot;: &quot;^4.7.2&quot;, &quot;opn&quot;: &quot;^4.0.2&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^1.3.0&quot;, // 压缩提取出的css，并解决ExtractTextPlugin分离出的js重复问题(多个文件引入同一css文件) &quot;ora&quot;: &quot;^0.3.0&quot;, // 加载的插件 &quot;portfinder&quot;: &quot;^1.0.13&quot;, // 查看进程端口 &quot;postcss-import&quot;: &quot;^11.0.0&quot;, // 可以消耗本地文件、节点模块或web_modules &quot;postcss-loader&quot;: &quot;^2.0.8&quot;, // 用来兼容css的插件 &quot;postcss-url&quot;: &quot;^7.2.1&quot;, // URL上重新定位、内联或复制 &quot;prismjs&quot;: &quot;^1.9.0&quot;, &quot;pug&quot;: &quot;^2.0.0-rc.4&quot;, &quot;rimraf&quot;: &quot;^2.6.0&quot;, // 节点的UNIX命令RM—RF,强制删除文件或者目录的命令 &quot;sass-loader&quot;: &quot;^4.1.0&quot;, &quot;semver&quot;: &quot;^5.3.0&quot;, // 用来对特定的版本号做判断的 &quot;shelljs&quot;: &quot;^0.7.6&quot;, // 使用它来消除shell脚本在UNIX上的依赖性，同时仍然保留其熟悉和强大的命令，即可执行Unix系统命令 &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.6&quot;, // 压缩js文件 &quot;url-loader&quot;: &quot;^0.5.8&quot;, // 压缩文件，可将图片转化为base64 &quot;vue-data-tables&quot;: &quot;^2.1.0&quot;, &quot;vue-easytable&quot;: &quot;^1.7.0&quot;, &quot;vue-loader&quot;: &quot;^13.3.0&quot;, // VUE单文件组件的WebPACK加载器 &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;, // 类似于样式加载程序，您可以在CSS加载器之后将其链接，以将CSS动态地注入到文档中作为样式标签 &quot;vue-svg-icon&quot;: &quot;^1.2.9&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.9&quot;, //这个包可以用来预编译VUE模板到渲染函数，以避免运行时编译开销和CSP限制 &quot;vue-waypoint&quot;: &quot;^2.1.0&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;, //可视化webpack输出文件的大小 &quot;webpack-dev-middleware&quot;: &quot;^1.12.1&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;, // 提供一个提供实时重载的开发服务器 &quot;webpack-hot-middleware&quot;: &quot;^2.18.0&quot;, &quot;webpack-merge&quot;: &quot;^4.1.0&quot; // 它将数组和合并对象创建一个新对象。如果遇到函数，它将执行它们，通过算法运行结果，然后再次将返回的值封装在函数中 &#125;, // engines是引擎，指定node和npm版本 &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;= 6.0.0&quot;, &quot;npm&quot;: &quot;&gt;= 3.0.0&quot; &#125;, // 限制了浏览器或者客户端需要什么版本才可运行 &quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot; ]&#125; devDependencies和dependencies的区别： devDependencies里面的插件只用于开发环境，不用于生产环境，即辅助作用，打包的时候需要，打包完成就不需要了。而dependencies是需要发布到生产环境的，自始至终都在。比如wepack等只是在开发中使用的包就写入到devDependencies，而像vue这种项目全程依赖的包要写入到devDependencies。 file-loader和url-loader的区别：以图片为例，file-loader可对图片进行压缩，但是还是通过文件路径进行引入，当http请求增多时会降低页面性能，而url-loader通过设定limit参数，小于limit字节的图片会被转成base64的文件，大于limit字节的将进行图片压缩的操作。总而言之，url-loader是file-loader的上层封装。 .babelrc该文件是es6解析的一个配置。 123456789101112131415&#123;// 制定转码的规则 &quot;presets&quot;: [ // env是使用babel-preset-env插件将js进行转码成es5，并且设置不转码的AMD,COMMONJS的模块文件，制定浏览器的兼容 [&quot;env&quot;, &#123; &quot;modules&quot;: false, &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;] &#125; &#125;], &quot;stage-2&quot; ], &quot;plugins&quot;: [&quot;transform-runtime&quot;, &quot;transform-vue-jsx&quot;], &quot;comments&quot;: false&#125; config1234├─config│ ├─dev.env.js│ ├─index.js│ ├─prod.env.js config/dev.env.jsconfig内的文件其实是服务于build的，大部分是定义一个变量export出去。 12345678&apos;use strict&apos; // 使用严格模式const merge = require(&apos;webpack-merge&apos;)const prodEnv = require(&apos;./prod.env&apos;)//webpack-merge提供了一个合并函数，它将数组和合并对象创建一个新对象。//如果遇到函数，它将执行它们，通过算法运行结果，然后再次将返回的值封装在函数中.这边将dev和prod进行合并module.exports = merge(prodEnv, &#123; NODE_ENV: &apos;&quot;development&quot;&apos;&#125;) config/prod.env.js当开发时调用dev.env.js的开发环境配置；当发布时调用prod.env.js的生产环境配置。 1234&apos;use strict&apos;module.exports = &#123; NODE_ENV: &apos;&quot;production&quot;&apos;&#125; config/index.js1234567891011121314151617181920212223242526272829303132333435&apos;use strict&apos;const path = require(&apos;path&apos;)module.exports = &#123; dev: &#123; // 开发环境下的配置 assetsSubDirectory: &apos;static&apos;, // 子目录，一般存放css，js，image等文件 assetsPublicPath: &apos;/&apos;, // 根目录 proxyTable: &#123;&#125;, // 可利用该属性解决跨域问题 host: &apos;localhost&apos;, // 地址 port: 8080, // 端口号 autoOpenBrowser: false, // 是否在编译后打开http://localhost:8080/ errorOverlay: true, // 浏览器错误提示 notifyOnErrors: true, // 跨平台错误提示 poll: false, // 使用文件系统(file system)获取文件改动的通知devServer.watchOptions useEslint: true, showEslintErrorsInOverlay: false, devtool: &apos;cheap-module-eval-source-map&apos;, // 增加调试，该属性为原始源代码（仅限行）不可在生产环境中使用 cacheBusting: true, // 使缓存失败 cssSourceMap: true // 代码压缩后进行调bug定位将非常困难，于是引入sourcemap记录压缩前后的位置信息记录，当产生错误时直接定位到未压缩前的位置，将大大的方便我们调试 &#125;, build: &#123; // 生产环境下的配置 index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // index编译后生成的位置和名字，根据需要改变后缀，比如index.php assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), // 编译后存放生成环境代码的位置 assetsSubDirectory: &apos;static&apos;, // js,css,images存放文件夹名 assetsPublicPath: &apos;/&apos;, // 发布的根目录，通常本地打包dist后打开文件会报错，此处修改为./。如果是上线的文件，可根据文件存放位置进行更改路径 productionSourceMap: true, devtool: &apos;#source-map&apos;, productionGzip: false, //unit的gzip命令用来压缩文件，gzip模式下需要压缩的文件的扩展名有js和css productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], bundleAnalyzerReport: process.env.npm_config_report &#125;&#125; build12345678├─build│ ├─build.js│ ├─check-versions.js│ ├─utils.js│ ├─vue-loader.conf.js│ ├─webpack.base.conf.js│ ├─webpack.dev.conf.js│ ├─webpack.prod.conf.js build/build.js该文件作用，即构建生产版本。package.json中的scripts的build就是node build/build.js，输入命令行npm run build对该文件进行编译生成生产环境的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243&apos;use strict&apos;require(&apos;./check-versions&apos;)() // 调用检查版本的文件process.env.NODE_ENV = &apos;production&apos; // 设置当前是生产环境// 下面定义常量引入插件const ora = require(&apos;ora&apos;) // 加载动画const rm = require(&apos;rimraf&apos;)// 删除文件const path = require(&apos;path&apos;)const chalk = require(&apos;chalk&apos;)// 对文案输出的一个彩色设置const webpack = require(&apos;webpack&apos;)const config = require(&apos;../config&apos;) // 默认读取下面的index.js文件const webpackConfig = require(&apos;./webpack.prod.conf&apos;)// 调用start的方法实现加载动画，优化用户体验const spinner = ora(&apos;building for production...&apos;)spinner.start()// 先删除dist文件再生成新文件，因为有时候会使用hash来命名，删除整个文件可避免冗余rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; if (err) throw err webpack(webpackConfig, (err, stats) =&gt; &#123; spinner.stop() if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build. chunks: false, chunkModules: false &#125;) + &apos;\\n\\n&apos;) if (stats.hasErrors()) &#123; console.log(chalk.red(&apos; Build failed with errors.\\n&apos;)) process.exit(1) &#125; console.log(chalk.cyan(&apos; Build complete.\\n&apos;)) console.log(chalk.yellow( &apos; Tip: built files are meant to be served over an HTTP server.\\n&apos; + &apos; Opening index.html over file:// won\\&apos;t work.\\n&apos; )) &#125;)&#125;) build/check-versions.js该文件用于检测node和npm版本，实现版本依赖。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&apos;use strict&apos;const chalk = require(&apos;chalk&apos;)const semver = require(&apos;semver&apos;) // 对版本进行检查const packageConfig = require(&apos;../package.json&apos;)const shell = require(&apos;shelljs&apos;)function exec (cmd) &#123;// 返回通过child_process模块的新建子进程，执行 Unix 系统命令后转成没有空格的字符串 return require(&apos;child_process&apos;).execSync(cmd).toString().trim()&#125;const versionRequirements = [ &#123; name: &apos;node&apos;, currentVersion: semver.clean(process.version), // 使用semver格式化版本 versionRequirement: packageConfig.engines.node // 获取package.json中设置的node版本 &#125;]if (shell.which(&apos;npm&apos;)) &#123; versionRequirements.push(&#123; name: &apos;npm&apos;, currentVersion: exec(&apos;npm --version&apos;), // 自动调用npm --version命令，并且把参数返回给exec函数，从而获取纯净的版本号 versionRequirement: packageConfig.engines.npm &#125;)&#125;module.exports = function () &#123; const warnings = [] for (let i = 0; i &lt; versionRequirements.length; i++) &#123; const mod = versionRequirements[i]// 如果版本号不符合package.json文件中指定的版本号，就执行下面错误提示的代码 if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + &apos;: &apos; + chalk.red(mod.currentVersion) + &apos; should be &apos; + chalk.green(mod.versionRequirement) ) &#125; &#125; if (warnings.length) &#123; console.log(&apos;&apos;) console.log(chalk.yellow(&apos;To use this template, you must update following to modules:&apos;)) console.log() for (let i = 0; i &lt; warnings.length; i++) &#123; const warning = warnings[i] console.log(&apos; &apos; + warning) &#125; console.log() process.exit(1) &#125;&#125; build/utils.jsutils是工具的意思，是一个用来处理css的文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&apos;use strict&apos;const path = require(&apos;path&apos;)const config = require(&apos;../config&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const packageConfig = require(&apos;../package.json&apos;)// 导出文件的位置，根据环境判断开发环境和生产环境，为config文件中index.js文件中定义的build.assetsSubDirectory或dev.assetsSubDirectoryexports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory return path.posix.join(assetsSubDirectory, _path)&#125;exports.cssLoaders = function (options) &#123; options = options || &#123;&#125;// 使用了css-loader和postcssLoader，通过options.usePostCSS属性来判断是否使用postcssLoader中压缩等方法 const cssLoader = &#123; loader: &apos;css-loader&apos;, options: &#123; sourceMap: options.sourceMap &#125; &#125; const postcssLoader = &#123; loader: &apos;postcss-loader&apos;, options: &#123; sourceMap: options.sourceMap &#125; &#125; function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] if (loader) &#123; loaders.push(&#123; loader: loader + &apos;-loader&apos;, options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125; if (options.extract) &#123; // ExtractTextPlugin可提取出文本，代表首先使用上面处理的loaders，当未能正确引入时使用vue-style-loader return ExtractTextPlugin.extract(&#123; use: loaders, fallback: &apos;vue-style-loader&apos; &#125;) &#125; else &#123; // 返回vue-style-loader连接loaders的最终值 return [&apos;vue-style-loader&apos;].concat(loaders) &#125; &#125; return &#123; css: generateLoaders(), // 需要css-loader和vue-style-loader postcss: generateLoaders(), // 需要css-loader和postcssLoader和 vue-style-loader less: generateLoaders(&apos;less&apos;), // 需要less-loader和vue-style-loader sass: generateLoaders(&apos;sass&apos;, &#123; indentedSyntax: true &#125;), // 需要sass-loader和vue-style-loader scss: generateLoaders(&apos;sass&apos;), // 需要sass-loader和vue-style-loader stylus: generateLoaders(&apos;stylus&apos;), // 需要stylus-loader和vue-style-loader styl: generateLoaders(&apos;stylus&apos;) // 需要sass-loader和vue-style-loader &#125;&#125;exports.styleLoaders = function (options) &#123; const output = [] const loaders = exports.cssLoaders(options) // 将各种css,less,sass等综合在一起得出结果输出output for (const extension in loaders) &#123; const loader = loaders[extension] output.push(&#123; test: new RegExp(&apos;\\\\.&apos; + extension + &apos;$&apos;), use: loader &#125;) &#125; return output&#125;exports.createNotifierCallback = () =&gt; &#123;// 发送跨平台通知系统 const notifier = require(&apos;node-notifier&apos;) return (severity, errors) =&gt; &#123; if (severity !== &apos;error&apos;) return// 当报错时输出错误信息的标题，错误信息详情，副标题以及图标 const error = errors[0] const filename = error.file &amp;&amp; error.file.split(&apos;!&apos;).pop() notifier.notify(&#123; title: packageConfig.name, message: severity + &apos;: &apos; + error.name, subtitle: filename || &apos;&apos;, icon: path.join(__dirname, &apos;logo.png&apos;) &#125;) &#125;&#125; path.posix：提供对路径方法的POSIX（可移植性操作系统接口）特定实现的访问，即可跨平台，区别于win32。 path.join：用于连接路径，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\\” build/vue-loader.conf.js该文件的主要作用就是处理.vue文件，解析这个文件中的每个语言块(template、script、style)，转换成可用的js模块。 1234567891011121314151617181920212223&apos;use strict&apos;const utils = require(&apos;./utils&apos;)const config = require(&apos;../config&apos;)const isProduction = process.env.NODE_ENV === &apos;production&apos;const sourceMapEnabled = isProduction ? config.build.productionSourceMap : config.dev.cssSourceMap// 处理项目中的css文件，生产环境和测试环境默认是打开sourceMap，而extract中的提取样式到单独文件只有在生产环境中才需要module.exports = &#123; loaders: utils.cssLoaders(&#123; sourceMap: sourceMapEnabled, extract: isProduction &#125;), cssSourceMap: sourceMapEnabled, cacheBusting: config.dev.cacheBusting, // 在模版编译过程中，编译器可以将某些属性，如 src 路径，转换为require调用，以便目标资源可以由 webpack 处理. transformToRequire: &#123; video: [&apos;src&apos;, &apos;poster&apos;], source: &apos;src&apos;, img: &apos;src&apos;, image: &apos;xlink:href&apos; &#125;&#125; build/webpack.base.conf.jswebpack.base.conf.js是开发和生产共同使用提出来的基础配置文件，主要实现配置入口，配置输出环境，配置模块resolve和插件等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&apos;use strict&apos;const path = require(&apos;path&apos;)const utils = require(&apos;./utils&apos;)const config = require(&apos;../config&apos;)const vueLoaderConfig = require(&apos;./vue-loader.conf&apos;)function resolve (dir) &#123;// 拼接出绝对路径 return path.join(__dirname, &apos;..&apos;, dir)&#125;const createLintingRule = () =&gt; (&#123; test: /\\.(js|vue)$/, loader: &apos;eslint-loader&apos;, enforce: &apos;pre&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)], options: &#123; formatter: require(&apos;eslint-friendly-formatter&apos;), emitWarning: !config.dev.showEslintErrorsInOverlay &#125;&#125;)module.exports = &#123;// path.join将路径片段进行拼接，而path.resolve将以/开始的路径片段作为根目录，在此之前的路径将会被丢弃 context: path.resolve(__dirname, &apos;../&apos;),// 配置入口，默认为单页面所以只有app一个入口 entry: &#123; app: &apos;./src/main.js&apos; &#125;, // 配置出口，默认是/dist作为目标文件夹的路径 output: &#123; path: config.build.assetsRoot, filename: &apos;[name].js&apos;, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath // 公共存放路径 &#125;, resolve: &#123; // 自动的扩展后缀，比如一个js文件，则引用时书写可不要写.js extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], // 创建路径的别名，比如增加&apos;components&apos;: resolve(&apos;src/components&apos;)等 alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &#125; &#125;, // 使用插件配置相应文件的处理方法 module: &#123; rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), // 使用vue-loader将vue文件转化成js的模块 &#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;, options: vueLoaderConfig &#125;, // js文件需要通过babel-loader进行编译成es5文件以及压缩等操作 &#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;)] &#125;, // 图片、音像、字体都使用url-loader进行处理，超过10000会编译成base64 &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;) &#125; &#125; ] &#125;, node: &#123; // 以下选项是Node.js全局变量或模块，这里主要是防止webpack注入一些Node.js的东西到vue中 dgram: &apos;empty&apos;, fs: &apos;empty&apos;, net: &apos;empty&apos;, tls: &apos;empty&apos;, child_process: &apos;empty&apos; &#125;&#125; build/webpack.dev.conf.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&apos;use strict&apos;const utils = require(&apos;./utils&apos;)const webpack = require(&apos;webpack&apos;)const config = require(&apos;../config&apos;)// 通过webpack-merge实现webpack.dev.conf.js对wepack.base.config.js的继承const merge = require(&apos;webpack-merge&apos;)const path = require(&apos;path&apos;)const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)// 美化webpack的错误信息和日志的插件const FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;)const portfinder = require(&apos;portfinder&apos;) // 查看空闲端口位置，默认情况下搜索8000这个端口const HOST = process.env.HOST // processs为node的一个全局对象获取当前程序的环境变量，即hostconst PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)const devWebpackConfig = merge(baseWebpackConfig, &#123; module: &#123; // 规则是工具utils中处理出来的styleLoaders，生成了css，less,postcss等规则 rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, devtool: config.dev.devtool, // 增强调试，上文有提及 // 此处的配置都是在config的index.js中设定好了 devServer: &#123; clientLogLevel: &apos;warning&apos;, // 控制台显示的选项有none, error, warning或者info // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为index.html historyApiFallback: &#123; rewrites: [ &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, &apos;index.html&apos;) &#125;, ], &#125;, hot: true, // 热加载 contentBase: false, // since we use CopyWebpackPlugin. compress: true, // 压缩 host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, // 调试时自动打开浏览器 overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, // warning 和 error 都要显示 publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // 控制台是否禁止打印警告和错误,若用FriendlyErrorsPlugin 此处为 true watchOptions: &#123; poll: config.dev.poll, // 文件系统检测改动 &#125; &#125;, plugins: [ new webpack.DefinePlugin(&#123; &apos;process.env&apos;: require(&apos;../config/dev.env&apos;) &#125;), new webpack.HotModuleReplacementPlugin(), // 模块热替换插件，修改模块时不需要刷新页面 new webpack.NamedModulesPlugin(), // 显示文件的正确名字 new webpack.NoEmitOnErrorsPlugin(), // 当webpack编译错误的时候，来中断打包进程，防止错误代码打包到文件中 // 该插件可自动生成一个 html5 文件或使用模板文件将编译好的代码注入进去 new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos;, inject: true &#125;), // 复制插件 new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, &apos;../static&apos;), to: config.dev.assetsSubDirectory, ignore: [&apos;.*&apos;] &#125; ]) ]&#125;)module.exports = new Promise((resolve, reject) =&gt; &#123; portfinder.basePort = process.env.PORT || config.dev.port // 查找端口号 portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // 端口被占用时就重新设置env和devServer的端口 process.env.PORT = port devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) build/webpack.prod.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&apos;use strict&apos;const path = require(&apos;path&apos;)const utils = require(&apos;./utils&apos;)const webpack = require(&apos;webpack&apos;)const config = require(&apos;../config&apos;)const merge = require(&apos;webpack-merge&apos;)const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const OptimizeCSSPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)const env = require(&apos;../config/prod.env&apos;)const webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; // 调用utils.styleLoaders的方法 rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, // 开启调试的模式。默认为true extract: true, usePostCSS: true &#125;) &#125;, devtool: config.build.productionSourceMap ? config.build.devtool : false, output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;), chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;) &#125;, plugins: [ new webpack.DefinePlugin(&#123; &apos;process.env&apos;: env &#125;), new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; // 压缩 warnings: false, // 警告：true保留警告，false不保留 drop_console: true &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;), // 抽取文本。比如打包之后的index页面有style插入，就是这个插件抽取出来的，减少请求 new ExtractTextPlugin(&#123; filename: utils.assetsPath(&apos;css/[name].[contenthash].css&apos;), allChunks: true, &#125;), // 优化css插件 new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), // html打包 new HtmlWebpackPlugin(&#123; filename: config.build.index, template: &apos;index.html&apos;, inject: true, minify: &#123; removeComments: true, // 删除注释 collapseWhitespace: true, // 删除空格 removeAttributeQuotes: true // 删除属性的引号 &#125;, chunksSortMode: &apos;dependency&apos; // 模块排序，按照我们需要的顺序排序 &#125;), new webpack.HashedModuleIdsPlugin(), new webpack.optimize.ModuleConcatenationPlugin(), new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks (module) &#123; return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &apos;../node_modules&apos;) ) === 0 ) &#125; &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos;, minChunks: Infinity &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;app&apos;, async: &apos;vendor-async&apos;, children: true, minChunks: 3 &#125;), // 复制，比如打包完之后需要把打包的文件复制到dist里面 new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, &apos;../static&apos;), to: config.build.assetsSubDirectory, ignore: [&apos;.*&apos;] &#125; ]), new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) ]&#125;)if (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;) webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: &apos;[path].gz[query]&apos;, algorithm: &apos;gzip&apos;, test: new RegExp( &apos;\\\\.(&apos; + config.build.productionGzipExtensions.join(&apos;|&apos;) + &apos;)$&apos; ), threshold: 10240, minRatio: 0.8 &#125;) )&#125;if (config.build.bundleAnalyzerReport) &#123; const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125;module.exports = webpackConfig 结语本文将vue本身自带的英文注释删除了，但英文注释非常有用可以仔细阅读，希望对大家学习vue和webpack都有所帮助。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-cli配置环境变量[转]","slug":"Vue-cli配置环境变量[转]","date":"2017-03-06T14:19:00.000Z","updated":"2018-11-15T12:38:21.614Z","comments":true,"path":"2017/03/06/Vue-cli配置环境变量[转]/","link":"","permalink":"http://yoursite.com/2017/03/06/Vue-cli配置环境变量[转]/","excerpt":"导语 vue-cli环境下，默认已经配置了一个NODE_ENV的环境变量，有时我们可能觉得光是只有一个开发环境和生产环境还不够，比如我们还想来一个测试坏境，这时候就需要自己定义了。","text":"导语 vue-cli环境下，默认已经配置了一个NODE_ENV的环境变量，有时我们可能觉得光是只有一个开发环境和生产环境还不够，比如我们还想来一个测试坏境，这时候就需要自己定义了。 在实际项目开发中，经常会碰到需要环境变量的情景，在vue-cli的环境下，默认已经配置了一个NODE_ENV的环境变量，当npm run dev的时候这个是development， 当npm run build 的时候这个是production.用过vue-cli开发的通常对这个都不陌生，用这个最多的基本就是我们配置ajax请求的域名头了。 123if (process.env.NODE_ENV === &apos;production&apos;) &#123; axios.defaults.baseURL = &apos;http://customer.medsci.cn&apos;&#125; 通常会有测试服务器和正式服务器环境之分，我们请求的域名也得区分，所以通过proces.env.NODE_ENV来区分环境变量，通过这个能够全局访问的参数，我们可以处理很多需要环境处理不同的操作。 上面的process.env.NODE_ENV是vue-cli默认配置的，有时候我们可能觉得光是只有一个开发环境和生产环境还不够，比如我们还想来一个测试坏境，这时候就需要自己定义了。以下以windows坏境为例，mac环境类似。 首先可以安装cross-env 1npm install cross-env --save-dev vue-cli的配置本质就是webpack的配置，当我们运行npm run dev 的时候，其实执行的是package.json 中的scripts 的dev中 ，即build/dev-server.js 这里面一系列的配置启动整个服务。 我们只想加一个环境变量，可以复制一份，在dev下加一个devtest命令: 1&quot;devtest&quot;: &quot;cross-env TESTING=true node build/dev-server.js&quot; 这样我们就可以通过npm run devtest也能启动整个服务了，注意上面的命令，我们加了一个TESTING=true ，这个就是加入的环境变量，TESTING:true， 通过上面的devtest的配置，我们可以运行npm run devtest像nppm run dev那样运行起来整个程序，不过我们发现，此时在项目中我们获取不到process.env.TESTING这个变量，这是为什么呢，如果是直接用webpack是可以的，经过查看，是在vue-cli的一系列配置文件中，已经写死了这些，不过我们可以改动加上在根目录 config下，有dev.env.js和prod.env.js，这两个文件就是关键了，我们在NODE_ENV下面加一行TESTING:process.env.TESTING。 123456module.exports = &#123; NODE_ENV: &apos;&quot;production&quot;&apos;， TESTING: process.env.TESTING&#125; 这时我们就能全局访问process.env.TESTING变量了，当我们npm run dev的时候，这个是undefined，当npm run devtest的时候是true， 同理我们可以添加一个npm run test命令， 与npm run build命令对应，加入打包测试的环境变量。vue-cli的配置本质还是webpack的配置， 普通的webpack配置也可以采用此方法。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-小技巧总结[转]","slug":"Vue-小技巧总结","date":"2017-03-03T09:41:00.000Z","updated":"2018-11-15T12:37:34.946Z","comments":true,"path":"2017/03/03/Vue-小技巧总结/","link":"","permalink":"http://yoursite.com/2017/03/03/Vue-小技巧总结/","excerpt":"导语 这篇文章主要是为了将开发过程中知道的一些小技巧进行总结，帮助使用Vue开发的小伙伴们愉快地采坑。","text":"导语 这篇文章主要是为了将开发过程中知道的一些小技巧进行总结，帮助使用Vue开发的小伙伴们愉快地采坑。 组件实例style的scoped场景：在组件中用js动态创建的dom，添加样式不生效 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; let a = document.querySelector(&apos;test&apos;) let newDom = document.createElement(&apos;div&apos;) newDom.setAttribute(&apos;class&apos;, &apos;testAdd&apos;) a.appendChild(newDom)&lt;/script&gt;&lt;style scoped&gt; .test&#123; background:blue; height:100px; width:100px; &#125; .testAdd&#123; background:red; height:100px; width:100px; &#125;&lt;/style&gt; 结果： 1234567// test生效 testAdd 不生效&lt;div data-v-1b971ada class=&quot;test&quot;&gt;&lt;div class=&quot;testAdd&quot;&gt;&lt;/div&gt;&lt;/div&gt;.test[data-v-1b971ada] &#123; // 注意data-v-1b971ada background:blue; height:100px; width:100px;&#125; 原因: 当 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素。它会为组件中所有的标签和class样式添加一个scoped标识，就像上面结果中的data-v-1b971ada。所以原因就很清楚了：因为动态添加的dom没有scoped添加的标识，没有跟testAdd的样式匹配起来，导致样式失效。 解决方式： 去掉该组件的scoped 动态添加style 123newDom.style.height=&apos;100px&apos;;newDom.style.width=&apos;100px&apos;;newDom.style.background=&apos;red&apos;; Vue 数组/对象更新 视图不更新123456789101112131415161718data() &#123; // data数据 return &#123; arr: [1,2,3], obj:&#123; a: 1, b: 2 &#125; &#125;; &#125;, // 数据更新 数组视图不更新 this.arr[0] = &apos;OBKoro1&apos;; this.arr.length = 1; console.log(arr);// [&apos;OBKoro1&apos;]; // 数据更新 对象视图不更新 this.obj.c = &apos;OBKoro1&apos;; delete this.obj.a; console.log(obj); // &#123;b:2,c:&apos;OBKoro1&apos;&#125;&#125; 由于js的限制，Vue 不能检测以上数组的变动，以及对象的添加/删除，很多人会因为像上面这样操作，出现视图没有更新的问题。 解决方式： this.$set(array)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"小程序-全栈开发(mpvue+koa2+mysql)","slug":"小程序-全栈开发(mpvue+koa2+mysql)","date":"2017-03-02T08:06:52.000Z","updated":"2018-11-15T12:37:23.854Z","comments":true,"path":"2017/03/02/小程序-全栈开发(mpvue+koa2+mysql)/","link":"","permalink":"http://yoursite.com/2017/03/02/小程序-全栈开发(mpvue+koa2+mysql)/","excerpt":"导语 接触小程序并做了一些项目之后，又开始了Vue的旅程，受其核心思想的影响，对数据/状态管理、组件化、跨平台等都有较高的追求，mpvue 是一个使用 Vue.js开发小程序的前端框架，由此开始了mpvue踩坑之旅，想在提高代码可读性的同时，也增加一点Vue.js的开发体验。","text":"导语 接触小程序并做了一些项目之后，又开始了Vue的旅程，受其核心思想的影响，对数据/状态管理、组件化、跨平台等都有较高的追求，mpvue 是一个使用 Vue.js开发小程序的前端框架，由此开始了mpvue踩坑之旅，想在提高代码可读性的同时，也增加一点Vue.js的开发体验。 技术栈 前端： 微信小程序、mpvue、 eslint、sass、ES6、ES7后端：koa2、Koa-Router、Knex、腾讯云Wafer2数据库：Mysql数据库可视化工具：Navicate Premium 小程序介绍一个功能简单的小程序，包含了个人中心、图书列表、个人评论列表三个tab页，后端的数据定义、分类、和存取等，各有其色。 成果分享个人中心： 个人中心： 图书列表： 图书详情： 评论列表： 脑图 初始化项目*全局安装vue-cli $npm install –global vue-cli *创建基于mpvue-quickstart模板的新项目，一路回车。 $vue init mpvue/mpvue-quickstart koa-wx *安装依赖 $cd koa-wx $npm install $npm run dev 项目目录123456789101112131415161718192021222324252627282930313233343536373839404142├── build // 构建相关 ├── config // 配置相关├── dist // 编译后静态文件 ├── node_modules // 依赖相关├── server // 服务端源代码│ ├── controllers │ ├── middlewares │ ├── node_modules │ ├── routes │ ├── tools │ ├── .eslintrc.js │ ├── .eslintrc.json │ ├── app.js │ ├── config.js │ ├── nodemon.json │ ├── package.json │ ├── process.prod.json │ ├── qcloud.js │ ├── README.md │ ├── tools.md ├── src // 前端源代码│ ├── components │ ├── config │ ├── mock │ ├── pages │ ├── styles │ ├── utils │ ├── App.vue │ ├── main.js │ ├── store.js │ ├── weui.css ├── static ├── .babelrc ├── .editorconfig ├── .eslintignore ├── .eslintrc.js ├── .postcssrc.js ├── index.html └── package.json └── package-lock.json └── project.config.json └── README.md 搭建后端本地开发环境打开 server/config.js添加以下配置： 123456789101112const CONF = &#123; // 其他配置 ... serverHost: &apos;localhost&apos;, tunnelServerUrl: &apos;&apos;, tunnelSignatureKey: &apos;27fb7d1c161b7ca52d73cce0f1d833f9f5b5ec89&apos;, // 腾讯云相关配置可以查看云 API 秘钥控制台：https://console.cloud.tencent.com/capi qcloudAppId: &apos;您的腾讯云 AppID&apos;, qcloudSecretId: &apos;您的腾讯云 SecretId&apos;, qcloudSecretKey: &apos;您的腾讯云 SecretKey&apos;, wxMessageToken: &apos;weixinmsgtoken&apos;, networkTimeout: 30000&#125; 并修改 MySQL 相关的配置为本地的 MySQL 数据库。 12345678mysql: &#123; host: &apos;localhost&apos;, port: 3306, user: &apos;root&apos;, db: &apos;cAuth&apos;, pass: &apos;******&apos;, char: &apos;utf8mb4&apos; &#125;, *切换到服务端代码目录$cd server *安装依赖$npm install *安装全局依赖$npm install -g nodemon $npm run dev 初始化数据库 - 打开 terminal 输入如下命令： $node tools/initdb.js 进入Mysql选中刚才创建的数据库，输入 show tables; 可以看到初始化时创建了一个名叫 cSessionInfo 的表。说明本地环境已经搭建成功。 部署到腾讯云环境当本地本地开发出一版时，可以部署到腾讯云的开发环境，这样就可以在线上访问该项目。 首先修改项目根目录的 project.config.json 文件，添加： 1&quot;qcloudRoot&quot;: &quot;./server/&quot;, 然后将本地开发时添加到 server/config.js 的配置删除，在 mysql.pass 那里填上自己的 APPID。 接着进入小程序开发工具，点击右上角的 腾讯云，上传测试代码，弹出如图选项。第一次部署如下选择，之后再次上传选择 智能上传 即可。部署成功会有提示。 ###上传前端代码 在小程序开发工具右上角找到 上传 选项，填写版本信息，上传后进入开发者控制台，开发管理页面，将该小程序设置为体验版本。 然后在用户身份 ==&gt; 成员管理中，添加项目成员，配置权限，这样好友也可以体验该小程序了。 项目地址：https://github.com/wangqian2017/mpvue-koa2","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]}]}