{"meta":{"title":"W | 个人博客 | web前端","subtitle":null,"description":"前端","author":"wangxiaobai","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-04-11T08:28:54.000Z","updated":"2019-06-17T03:49:28.575Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-11T08:28:32.000Z","updated":"2019-06-17T03:49:28.576Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Node-NodeJS核心基础知识","slug":"Node-NodeJS核心基础知识","date":"2019-06-26T15:11:52.000Z","updated":"2019-06-27T06:44:23.084Z","comments":true,"path":"2019/06/26/Node-NodeJS核心基础知识/","link":"","permalink":"http://yoursite.com/2019/06/26/Node-NodeJS核心基础知识/","excerpt":"导语 截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…","text":"导语 截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node… 关于 Node 和 Javascript JavaScript 是一门编程语言，通常在浏览器的宿主环境中运行，网页是它的主战场，用户点击反馈/数据异步加载/动画控制等需要借助它和浏览器进行对话 Node 是一个基于 JavaScript 运行时，它不是一个 JavaScript 框架，也不是一门编程语言。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"JS-ES6、ES7、ES8、ES9、ES10常用特性一览","slug":"JS-ES6、ES7、ES8、ES9、ES10常用特性一览","date":"2019-06-17T04:16:52.000Z","updated":"2019-06-27T06:51:44.653Z","comments":true,"path":"2019/06/17/JS-ES6、ES7、ES8、ES9、ES10常用特性一览/","link":"","permalink":"http://yoursite.com/2019/06/17/JS-ES6、ES7、ES8、ES9、ES10常用特性一览/","excerpt":"导语 ES全称ECMAScript，ECMAScript是ECMA制定的标准化脚本语言。目前JavaScript使用的ECMAScript版本为ECMA-417。","text":"导语 ES全称ECMAScript，ECMAScript是ECMA制定的标准化脚本语言。目前JavaScript使用的ECMAScript版本为ECMA-417。 ES6 常用特性（2015）ES6的特性比较多，在 ES5 发布近 6 年（2009-11 至 2015-6）之后才将其标准化。两个发布版本之间时间跨度很大，所以ES6中的特性比较多。 在这里列举几个常用的： 类对熟悉Java，object-c，c#等纯面向对象语言的开发者来说，都会对class有一种特殊的情怀。ES6 引入了class（类），让JavaScript的面向对象编程变得更加简单和易于理解。 123456789101112131415161718192021222324252627282930313233343536 class Animal &#123; // 构造函数，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数. constructor(name,color) &#123; this.name = name; this.color = color; &#125; // toString 是原型对象上的属性 toString() &#123; console.log('name:' + this.name + ',color:' + this.color); &#125; &#125;var animal = new Animal('dog','white');//实例化Animalanimal.toString();console.log(animal.hasOwnProperty('name')); //trueconsole.log(animal.hasOwnProperty('toString')); // falseconsole.log(animal.__proto__.hasOwnProperty('toString')); // trueclass Cat extends Animal &#123; constructor(action) &#123; // 子类必须要在constructor中指定super 函数，否则在新建实例的时候会报错. // 如果没有置顶consructor,默认带super函数的constructor将会被添加、 super('cat','white'); this.action = action; &#125; toString() &#123; console.log(super.toString()); &#125;&#125;var cat = new Cat('catch')cat.toString();// 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。console.log(cat instanceof Cat); // trueconsole.log(cat instanceof Animal); // true 模块化模块的功能主要由 export 和 import 组成。每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过import来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。 导出ES6允许在一个模块中使用export来导出多个变量或函数。 导出变量12//test.jsexport var name = 'Rainbow' 导出常量12//test.jsexport const name = 'Rainbow' 导出函数1234// myModule.jsexport function myModule(someArg) &#123; return someArg;&#125; 导入12import &#123;myModule&#125; from 'myModule';// main.jsimport &#123;name&#125; from 'test';// test.js 箭头函数=&gt; 不只是关键字 function 的简写，它还带来了其它好处。箭头函数与包围它的代码共享同一个 this，能帮你很好的解决 this 的指向问题。有经验的 JavaScript 开发者都熟悉诸如 var self = this；或 var that = this 这种引用外围 this 的模式。但借助=&gt;，就不需要这种模式了。 箭头函数的结构箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。 12345678910111213// 箭头函数的例子()=&gt;1v=&gt;v+1(a,b)=&gt;a+b()=&gt;&#123; alert(\"foo\");&#125;e=&gt;&#123; if (e == 0)&#123; return 0; &#125; return 1000/e;&#125; 函数参数的默认值1234function foo(height = 50, color = 'red')&#123; // ...&#125; 不使用默认值： 123456function foo(height, color)&#123; var height = height || 50; var color = color || 'red'; //...&#125; 这样写一般没问题，但当参数的布尔值为false时，就会有问题了。比如，我们这样调用foo函数： 1foo(0, \"\") 因为0的布尔值为false，这样height的取值将是50。同理color的取值为‘red’。 所以说，函数参数默认值不仅能是代码变得更加简洁而且能规避一些问题。 模板字符串ES6支持模板字符串，使得字符串的拼接更加的简洁、直观。 不使用模板字符串： 1var name = 'Your name is ' + first + ' ' + last + '.' 使用模板字符串： 1var name = `Your name is $&#123;first&#125; $&#123;last&#125;.` 解构赋值解构赋值语法是JavaScript的一种表达式，可以方便的从数组或者对象中快速提取值赋给定义的变量。 数组解构从数组中获取值并赋值到变量中，变量的顺序与数组中对象顺序对应。 123456789101112131415161718var foo = [\"one\", \"two\", \"three\", \"four\"];var [one, two, three] = foo;console.log(one); // \"one\"console.log(two); // \"two\"console.log(three); // \"three\"//如果你要忽略某些值，你可以按照下面的写法获取你想要的值var [first, , , last] = foo;console.log(first); // \"one\"console.log(last); // \"four\"//你也可以这样写var a, b; //先声明变量[a, b] = [1, 2];console.log(a); // 1console.log(b); // 2 如果没有从数组中的获取到值，你可以为变量设置一个默认值。 12345var a, b;[a=5, b=7] = [1];console.log(a); // 1console.log(b); // 7 通过解构赋值可以方便的交换两个变量的值。 123456var a = 1;var b = 3;[a, b] = [b, a];console.log(a); // 3console.log(b); // 1 对象解构12345678910const student = &#123; name:'Ming', age:'18', city:'Shanghai' &#125;;const &#123;name,age,city&#125; = student;console.log(name); // \"Ming\"console.log(age); // \"18\"console.log(city); // \"Shanghai\" 延展操作符延展操作符…可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造对象时, 将对象表达式按key-value的方式展开。 语法函数调用 1myFunction(...iterableObj); 数组构造货字符串 1[...iterableObj, '4', ...'hello', 6]; 构造对象时，进行克隆或者属性拷贝 1let objClone = &#123; ...obj &#125;; 对象属性简写在ES6中允许我们在设置一个对象的属性的时候不指定属性名。 不使用 ES6 12345678const name='Ming',age='18',city='Shanghai'; const student = &#123; name:name, age:age, city:city&#125;;console.log(student);//&#123;name: \"Ming\", age: \"18\", city: \"Shanghai\"&#125; 使用 ES6 12345678const name='Ming',age='18',city='Shanghai'; const student = &#123; name, age, city&#125;;console.log(student);//&#123;name: \"Ming\", age: \"18\", city: \"Shanghai\"&#125; PromisePromise 是异步编程的一种解决方案，比传统的解决方案callback更加的优雅。它最早由社区提出和实现的，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 不适用 ES6 嵌套两个setTimeout回调函数： 12345678setTimeout(function()&#123; console.log('Hello'); // 1秒后输出\"Hello\" setTimeout(function() &#123; console.log('Hi'); // 2秒后输出\"Hi\" &#125;, 1000);&#125;, 1000); 使用 ES6 123456789101112131415var waitSecond = new Promise(function(resolve, reject)&#123; setTimeout(resolve, 1000);&#125;);waitSecond .then(function() &#123; console.log(\"Hello\"); // 1秒后输出\"Hello\" return waitSecond; &#125;) .then(function() &#123; console.log(\"Hi\"); // 2秒后输出\"Hi\" &#125;); 上面的的代码使用两个then来进行异步编程串行化，避免了回调地狱。 let 和 const在之前JS是没有块级作用域的，const与let填补了这方便的空白，const与let都是块级作用域。 使用var定义的变量为函数级作用域： 12345&#123; var a = 10;&#125;console.log(a); // 输出10 使用let与const定义的变量为块级作用域： 12345&#123; let a = 10;&#125;console.log(a); //-1 or Error“ReferenceError: a is not defined” ES7 常用特性 (2016)Array.prototype.includes()includes() 函数用来判断一个数组是否包含一个指定的值，如果包含则返回 true，否则返回false。 includes 函数与 indexOf 函数很相似，下面两个表达式是等价的： 12arr.includes(x)arr.indexOf(x) &gt;= 0 指数操作符在ES7中引入了指数运算符，具有与Math.pow(..)等效的计算结果。 12console.log(2**10);// 输出1024console.log(Math.paw(2, 10));// 输出1024 ES8 常用特性 (2017)async/awaitES2018引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了next()方法返回一个Promise。因此await可以和for…of循环一起使用，以串行的方式运行异步操作。例如： 12345async function process(array) &#123; for await (let i of array) &#123; doSomething(i); &#125;&#125; Object.values()Object.values()是一个与Object.keys()类似的新函数，但返回的是Object自身属性的所有值，不包括继承的值。 假设我们要遍历如下对象obj的所有值： 1const obj = &#123;a: 1, b: 2, c: 3&#125;; 不使用Object.values() :ES7 12const vals=Object.keys(obj).map(key=&gt;obj[key]);console.log(vals);//[1, 2, 3] 使用Object.values() :ES8 12const values=Object.values(obj1);console.log(values);//[1, 2, 3] Object.entries()Object.entries()函数返回一个给定对象自身可枚举属性的键值对的数组。 接下来我们来遍历上文中的obj对象的所有属性的key和value： 不使用Object.entries() :ES7 123456Object.keys(obj).forEach(key=&gt;&#123; console.log('key:'+key+' value:'+obj[key]);&#125;)//key:a value:1//key:b value:2//key:c value:3 使用Object.entries() :ES8 123456for(let [key,value] of Object.entries(obj1))&#123; console.log(`key: $&#123;key&#125; value:$&#123;value&#125;`)&#125;//key:a value:1//key:b value:2//key:c value:3 String padding在ES8中String新增了两个实例函数String.prototype.padStart和String.prototype.padEnd，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。 String.padStart(targetLength,[padString]) targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString:(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “ 12console.log('0.0'.padStart(4,'10')) //10.0console.log('0.0'.padStart(20))// 0.00 String.padEnd(targetLength,padString]) targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString:(可选) 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “； 12console.log('0.0'.padEnd(4,'0')) //0.00 console.log('0.0'.padEnd(10,'0'))//0.00000000 .函数参数列表结尾允许逗号主要作用是方便使用git进行多人协作开发时修改同一个函数减少不必要的行变更。 Object.getOwnPropertyDescriptors()Object.getOwnPropertyDescriptors()函数用来获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。 1Object.getOwnPropertyDescriptors(obj) 返回obj对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。 12345678910111213141516171819const obj2 = &#123; name: 'Jine', get age() &#123; return '18' &#125;&#125;;Object.getOwnPropertyDescriptors(obj2)// &#123;// age: &#123;// configurable: true,// enumerable: true,// get: function age()&#123;&#125;, //the getter function// set: undefined// &#125;,// name: &#123;// configurable: true,// enumerable: true,// value:\"Jine\",// writable:true// &#125;// &#125; ES9 常用特性 (2018)Promise.finally()一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。 1234567891011function doSomething() &#123; doSomething1() .then(doSomething2) .then(doSomething3) .catch(err =&gt; &#123; console.log(err); &#125;) .finally(() =&gt; &#123; // finish here! &#125;);&#125; Rest/SpreadES2015引入了Rest参数和扩展运算符。三个点（…）仅用于数组。Rest参数语法允许我们将一个不定数量的参数表示为一个数组。 1234567restParam(1, 2, 3, 4, 5);function restParam(p1, p2, ...p3) &#123; // p1 = 1 // p2 = 2 // p3 = [3, 4, 5]&#125; 展开操作符以相反的方式工作，将数组转换成可传递给函数的单独参数。例如Math.max()返回给定数字中的最大值： 12const values = [99, 100, -1, 48, 16];console.log( Math.max(...values) ); // 100 ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符，一个简单的例子： 123456789const myObject = &#123; a: 1, b: 2, c: 3&#125;;const &#123; a, ...x &#125; = myObject;// a = 1// x = &#123; b: 2, c: 3 &#125; 或者你可以使用它给函数传递参数： 12345678910restParam(&#123; a: 1, b: 2, c: 3&#125;);function restParam(&#123; a, ...x &#125;) &#123; // a = 1 // x = &#123; b: 2, c: 3 &#125;&#125; 跟数组一样，Rest参数只能在声明的结尾处使用。此外，它只适用于每个对象的顶层，如果对象中嵌套对象则无法适用。 扩展运算符可以在其他对象内使用，例如： 123const obj1 = &#123; a: 1, b: 2, c: 3 &#125;;const obj2 = &#123; ...obj1, z: 26 &#125;;// obj2 is &#123; a: 1, b: 2, c: 3, z: 26 &#125; 可以使用扩展运算符拷贝一个对象，像是这样obj2 = {…obj1}，但是 这只是一个对象的浅拷贝。另外，如果一个对象A的属性是对象B，那么在克隆后的对象cloneB中，该属性指向对象B。 正则表达式命名捕获组JavaScript正则表达式可以返回一个匹配的对象——一个包含匹配字符串的类数组，例如：以YYYY-MM-DD的格式解析日期： 123456const reDate = /([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/, match = reDate.exec('2018-04-30'), year = match[1], // 2018 month = match[2], // 04 day = match[3]; // 30 这样的代码很难读懂，并且改变正则表达式的结构有可能改变匹配对象的索引。 ES2018允许命名捕获组使用符号?，在打开捕获括号(后立即命名，示例如下： 123456const reDate = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/, match = reDate.exec('2018-04-30'), year = match.groups.year, // 2018 month = match.groups.month, // 04 day = match.groups.day; // 30 任何匹配失败的命名组都将返回undefined。 命名捕获也可以使用在replace()方法中。例如将日期转换为美国的 MM-DD-YYYY 格式： 1234const reDate = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/, d = '2018-04-30', usDate = d.replace(reDate, '$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;'); ES10 常用特性 (2019)Array.prototype.flat()flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 flat()方法最基本的作用就是数组降维 123456789101112131415var arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4]var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat();// [1, 2, 3, 4, [5, 6]]var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2);// [1, 2, 3, 4, 5, 6]//使用 Infinity 作为深度，展开任意深度的嵌套数组arr3.flat(Infinity); // [1, 2, 3, 4, 5, 6] 其次，还可以利用flat()方法的特性来去除数组的空项 123var arr4 = [1, 2, , 4, 5];arr4.flat();// [1, 2, 4, 5] Array.prototype.flatMap()flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 这里我们拿map方法与flatMap方法做一个比较。 1234567891011var arr1 = [1, 2, 3, 4];arr1.map(x =&gt; [x * 2]); // [[2], [4], [6], [8]]arr1.flatMap(x =&gt; [x * 2]);// [2, 4, 6, 8]// 只会将 flatMap 中的函数返回的数组 “压平” 一层arr1.flatMap(x =&gt; [[x * 2]]);// [[2], [4], [6], [8]] String.prototype.trimStart() String.prototype.trimEnd()新增的这两个方法很好理解，分别去除字符串首尾空白字符。 Object.fromEntries()Object.entries()方法的作用是返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。 而Object.fromEntries() 则是 Object.entries() 的反转。 Object.fromEntries() 函数传入一个键值对的列表，并返回一个带有这些键值对的新对象。这个迭代参数应该是一个能够实现@iterator方法的的对象，返回一个迭代器对象。它生成一个具有两个元素的类似数组的对象，第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值。 通过 Object.fromEntries， 可以将 Map 转化为 Object: 123const map = new Map([ ['foo', 'bar'], ['baz', 42] ]);const obj = Object.fromEntries(map);console.log(obj); // &#123; foo: \"bar\", baz: 42 &#125; 通过 Object.fromEntries， 可以将 Array 转化为 Object: arr 12const obj = Object.fromEntries(arr);console.log(obj); // &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; &#125; Symbol.prototype.description通过工厂函数Symbol（）创建符号时，您可以选择通过参数提供字符串作为描述： 1const sym = Symbol('The description'); 以前，访问描述的唯一方法是将符号转换为字符串： 1assert.equal(String(sym), 'Symbol(The description)'); 现在引入了getter Symbol.prototype.description以直接访问描述： 1assert.equal(sym.description, 'The description'); String.prototype.matchAllmatchAll() 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器。 在 matchAll 出现之前，通过在循环中调用regexp.exec来获取所有匹配项信息（regexp需使用/g标志： 12345678const regexp = RegExp('foo*','g');const str = 'table football, foosball';while ((matches = regexp.exec(str)) !== null) &#123; console.log(`Found $&#123;matches[0]&#125;. Next starts at $&#123;regexp.lastIndex&#125;.`); // expected output: \"Found foo. Next starts at 9.\" // expected output: \"Found foo. Next starts at 19.\"&#125; 如果使用matchAll ，就可以不必使用while循环加exec方式（且正则表达式需使用／g标志）。使用matchAll 会得到一个迭代器的返回值，配合 for…of, array spread, or Array.from() 可以更方便实现功能： 12345678910111213141516const regexp = RegExp('foo*','g'); const str = 'table football, foosball';let matches = str.matchAll(regexp);for (const match of matches) &#123; console.log(match);&#125;// Array [ \"foo\" ]// Array [ \"foo\" ]// matches iterator is exhausted after the for..of iteration// Call matchAll again to create a new iteratormatches = str.matchAll(regexp);Array.from(matches, m =&gt; m[0]);// Array [ \"foo\", \"foo\" ] matchAll可以更好的用于分组 123456789101112var regexp = /t(e)(st(\\d?))/g;var str = 'test1test2';str.match(regexp); // Array ['test1', 'test2']let array = [...str.matchAll(regexp)];array[0];// ['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', length: 4]array[1];// ['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', length: 4] Function.prototype.toString()返回精确字符，包括空格和注释 123456789101112function /* comment */ foo /* another comment */() &#123;&#125;// 之前不会打印注释部分console.log(foo.toString()); // function foo()&#123;&#125;// ES2019 会把注释一同打印console.log(foo.toString()); // function /* comment */ foo /* another comment */ ()&#123;&#125;// 箭头函数const bar /* comment */ = /* another comment */ () =&gt; &#123;&#125;;console.log(bar.toString()); // () =&gt; &#123;&#125; 修改 catch 绑定在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的。 ES10 提案使我们能够简单的把变量省略掉。 不算大的改动。 之前是 1try &#123;&#125; catch(e) &#123;&#125; 现在是 1try &#123;&#125; catch &#123;&#125; 新的基本类型 BigInt现在的基本数据类型（值类型）不止5种（ES6之后是六种）了哦！加上BigInt一共有七种基本数据类型，分别是： String、Number、Boolean、Null、Undefined、Symbol、BigInt 参考 ES6、ES7、ES8、ES9、ES10新特性一览 ECMAScript 6 入门","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS-this、call、apply","slug":"JS-this、call、apply","date":"2019-06-13T05:00:52.000Z","updated":"2019-06-17T03:49:28.567Z","comments":true,"path":"2019/06/13/JS-this、call、apply/","link":"","permalink":"http://yoursite.com/2019/06/13/JS-this、call、apply/","excerpt":"导语 在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。","text":"导语 在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。 thisJavascript 中的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的。 this 的指向在具体实际应用中，this 的指向通常可分为以下4种: 作为对象的方法调用 作为普通函数调用 作为构造器调用 Function.prototype.call、Function.prototype.apply 作为对象的方法调用当函数作为对象的方法调用时，this 指向该对象： 12345678910var obj = &#123; a: 1, getA: function () &#123; console.log(this.a) &#125;&#125;obj.getA()// 1 作为普通函数调用函数作为普通函数调用，此时的 this 总是指向全局对象。在浏览器中，这个全局对象是 window 对象。 12345678var a = 1var getName = function () &#123; console.log(this.a)&#125;getName()// 1 作为构造器调用当用 new 运算符调用函数时，该函数会返回一个对象。通常情况下，构造器里的 this 就指向返回的这个对象。 1234567var MyClass = function () &#123; this.name = 'sven'&#125;var obj = new MyClass()console.log(obj.name)// 'sven' 如果构造器显式地返回了一个对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this。 12345678910var MyClass = function () &#123; this.name = 'sven' return &#123; name: 'wang' &#125;&#125;var obj = new MyClass()console.log(obj.name)// wang 如果构造器不显式地返回任何数据，或者返回一个非对象类型的数据，就不会造成上述问题。 12345678var MyClass = function () &#123; this.name = 'sven' return 'wang'&#125;var obj = nconsole.log(obj.name)// 'sven' Function.prototype.call、Function.prototype.apply用 Function.prototype.call、Function.prototype.apply 可以动态改变传入函数的 this。 12345678910111213141516var obj1 = &#123; name: 'wang', getName: function () &#123; console.log(this.name) &#125;&#125;var obj2 = &#123; name: 'zhang'&#125;obj1.getName()obj1.getName.call(obj2)// 'wang'// 'zhang' 丢失的 this举个例子： 12345678910111213var obj = &#123; name: 'wang', getName: function () &#123; console.log(this.name) &#125;&#125;obj.getName()getName = obj.getNamegetName()// 'wang'// undefined 当调用 obj.getName 时，此时 this 指向 obj 对象，所以输出 ‘wang’。 当用另外一个变量 getName 来引用 obj.getName，并且调用时，它是被当作普通函数来调用，此时 this 指向 window 对象，所以输出 undefined。 call 和 apply在实际开发中，特别是在一些函数式风格的代码编写中，call 和 apply 方法尤为重要。 区别call 和 apply 作用一模一样，区别在于传入参数形式的不同。 apply 接受两个参数，第一个参数指定了函数体内的 this 对象的指向，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。 call 传入的参数数量不固定，跟 apply 不同的是，第一个参数也是代表函数体内 this 对象的指向，从第二个参数开始，每个参数依此传入函数。 当使用 call 或者 apply 时，如果我们传入的第一个参数为 null，则函数体内的 this 会指向默认的宿主对象。 但如果在严格模式下，函数体内的 this 还是为 null。 call 和 apply 的用途下面将详细介绍 call 和 apply 在实际开发中的用途。 改变 this 指向1234567891011121314151617var obj1 = &#123; name: 'wang'&#125;var obj2 = &#123; name: 'zhang'&#125;var name = 'qian'var getName = function () &#123; console.log(this.name)&#125;getName () // 'qian'getName.call(obj1) // 'wang'getName.call(obj2) // 'zhang' Function.prototype.bind大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向。即使没有原生的 Function.prototype.bind ，我们也可以自己来模拟： 1234567891011121314151617Function.prototype.bind = function (context) &#123; let self = this // 保存原函数 console.log(this) return function () &#123; // 返回一个新的函数 return self.apply(context, arguments) // 执行新的函数时，会把之前传入的 context 当作新函数体内的 this &#125;&#125;var obj = &#123; name: 'seven'&#125;var func = function () &#123; console.log(this.name)&#125;.bind(obj)func() 上述为一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一些，使得可以在 func 函数中预先填入一些参数： 123456789101112131415161718192021Function.prototype.bind = function () &#123; console.log(arguments) var self = this, // 保存原函数 context = [].shift.call(arguments), // 需要绑定的 this 上下文 args = [].slice.call(arguments) // 剩余的参数转化为数组 console.log(context) console.log(args) return function () &#123; // 返回一个新韩淑 return self.apply(context, [].concat(args, [].slice.call(arguments))) // 执行新的函数时，把之前传入的 context 当作新函数体内的 this，并且组合两次分别传入的参数，作为新函数的参数 &#125;&#125;var obj = &#123; name: 'seven'&#125;var func = function (a, b, c, d) &#123; console.log(this.name) console.log([a, b, c, d])&#125;.bind(obj, 1, 2)func(3, 4) 借用其他对象的方法借用方法的第一种场景是”借用构造函数“，通过这种技术，可以实现一些类似继承的效果： 123456789101112131415var A = function (name) &#123; this.name = name&#125;var B = function () &#123; A.apply(this, arguments)&#125;B.prototype.getName = function () &#123; return this.name&#125;var b = new B('wang')console.log(b.getName()) // 'wang' 附： 函数的参数列表 arguments 是一个类数组对象，并不是真正的数组。 如果想在 arguments 中添加一个元素，通常会借用 Array.prototype.push 如果想把 arguments 转换为真正的数组，通常会借用 Array.prototype.slice 如果想截取 arguments 中的第一个元素，通常会借用 Array.prototype.shift","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS-执行上下文和执行栈","slug":"JS-执行上下文和执行栈","date":"2019-06-03T09:08:52.000Z","updated":"2019-06-17T03:49:28.568Z","comments":true,"path":"2019/06/03/JS-执行上下文和执行栈/","link":"","permalink":"http://yoursite.com/2019/06/03/JS-执行上下文和执行栈/","excerpt":"导语 执行上下文是当前 JavaScript 被解析和执行时所在环境的抽象概念。执行栈用于存储在代码执行期间创建的所有执行上下文。","text":"导语 执行上下文是当前 JavaScript 被解析和执行时所在环境的抽象概念。执行栈用于存储在代码执行期间创建的所有执行上下文。 执行上下文的类型执行上下文总共有三种类型： 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 会指向这个全局对象。 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。 Eval 函数执行上下文：运行在 Eval 函数中的代码。 执行上下文栈接下来问题来了，我们写了那么多函数，如何管理创建的那么多执行上下文呢？ Javascript 创建了执行上下文栈，也叫调用栈，来管理在代码执行期间创建的所有执行上下文。 首次运行 Javascript 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。 根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从栈中 Pop 出，上下文控制权将会移到当前执行栈的下一个执行上下文。 1234567891011121314var a = 'Hello World!';function first() &#123; console.log('Inside first function'); second(); console.log('Again inside first function'); &#125;function second() &#123; console.log('Inside second function'); &#125;first(); console.log('Inside Global Execution Context'); 执行上下文的创建执行上下文分为两个阶段创建：1） 创建阶段 2）执行阶段 创建阶段 确定 this 的值，也被称为 This Binding LexicalEnvironment-词法环境被创建 VariableEnvironment-变量环境被创建 12345ExecutionContext = &#123; ThisBinding: &lt;this value&gt;, LexicalEnvironment: &#123;...&#125;, VariableEnvironment: &#123;...&#125;&#125; This Binding 全局执行上下文中，this 指向全局对象，在浏览器中 this 的值指向 window 对象，而在 nodejs 中指向这个文件的 module 对象。 函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显示绑定、new 绑定等。 词法环境词法环境有两个组成部分： 环境记录：存储变量和函数声明的实际位置 对外部环境的引用：可以访问其外部词法环境 词法环境有两种类型： 全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window）及其关联的方法和属性以及任何用户自定义的全局变量， this 的值指向这个全局对象。 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境， 1234567891011121314151617GlobalExectionContext = &#123; // 全局执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: \"Object\", // 全局环境 // 标识符绑定在这里 outer: &lt;null&gt; // 对外部环境的引用 &#125; &#125;FunctionExectionContext = &#123; // 函数执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: \"Declarative\", // 函数环境 // 标识符绑定在这里 // 对外部环境的引用 outer: &lt;Global or outer function environment reference&gt; &#125; &#125; 变量环境 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。 在ES6中，词法环境和变量环境的区别在于前者用于存储函数声明和变量(let const)绑定，后者仅用于存储变量(var)绑定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647GlobalExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: \"Object\", // 标识符绑定在这里 a: &lt; uninitialized &gt;, b: &lt; uninitialized &gt;, multiply: &lt; func &gt; &#125; outer: &lt;null&gt; &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: \"Object\", // 标识符绑定在这里 c: undefined, &#125; outer: &lt;null&gt; &#125; &#125;FunctionExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: \"Declarative\", // 标识符绑定在这里 Arguments: &#123;0: 20, 1: 30, length: 2&#125;, &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: \"Declarative\", // 标识符绑定在这里 g: undefined &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125; &#125; 执行阶段 此阶段，完成对所有变量的分配，然后执行代码。 参考 理解JavaScript 中的执行上下文和执行栈","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS-事件的节流(throttle)和防抖(debounce)","slug":"JS-事件的节流(throttle)和防抖(debounce)","date":"2019-05-31T07:13:52.000Z","updated":"2019-06-17T03:49:28.568Z","comments":true,"path":"2019/05/31/JS-事件的节流(throttle)和防抖(debounce)/","link":"","permalink":"http://yoursite.com/2019/05/31/JS-事件的节流(throttle)和防抖(debounce)/","excerpt":"导语 窗口的resize、scroll、mousemove、mouseover等事件被频繁触发时，其对应的回调函数也会被频繁触发而导致页面抖动甚至卡顿。","text":"导语 窗口的resize、scroll、mousemove、mouseover等事件被频繁触发时，其对应的回调函数也会被频繁触发而导致页面抖动甚至卡顿。 为了规避这种情况，我们需要一些手段来控制事件被触发的频率。此时，事件节流(throttle)和事件防抖(debounce)出现了。 节流和防抖的本质这两个东西都以“闭包”的形式存在。 它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，来判断是否执行回调函数，以此来控制事件的触发频率。 节流-throttle函数节流指某个函数在一定时间间隔内 ( 例如 3 秒 ) 只执行一次，在这 3 秒内无视后来产生的函数调用请求，也不会延长事件间隔。3 秒间隔结束后第一次遇到新的函数调用会触发执行，然后在新的 3 秒内依旧无视后来产生的函数调用请求，以此类推。 实现方案有以下两种： 第一种是用时间戳来判断是否已到执行时间，记录上次执行的时间戳，然后每次触发事件执行回调，回调中判断当前时间戳距离上次执行时间戳的间隔是否已经到达时间差，如果是则执行，并更新上次执行的时间戳，如此循环。 第二种是使用定时器，比如当 scroll 事件刚触发时，打印一个 hello word ，然后设置个 1000ms 的定时器，此后每次触发 scroll 事件回调，如果已经存在定时器，则回调不执行方法，直到定时器触发，handler 被清除，然后重新设置定时器。 理解了大致思路，我们用第一种方法实现一个 throttle: 12345678910111213141516171819/** * 节流 throttle 时间戳 * @param fn &#123;function&#125; 回调函数 * @param wait &#123;number&#125; 时间间隔 * @author wangxiaobai * @date 2019/5/30 */export function throttle (fn, wait) &#123; // 上一次函数执行的时间 let previous = 0 return function (...args) &#123; let now = +new Date() // 本次触发事件 if (now - previous &gt; wait) &#123; previous = now // 执行fn fn.apply(this, args) &#125; &#125;&#125; 防抖-debounce函数防抖指某个函数在一定时间间隔内 ( 例如 3 秒 ) 只执行一次，在这 3 秒内无视先前产生的函数调用请求，也不会延长事件间隔。3 秒间隔结束后第一次遇到新的函数调用暂时不会触发执行，然后在新的 3 秒内依旧无视先前产生的函数调用请求，以此类推。 实现方案： 使用定时器，比如当 scroll 事件刚触发时，首先清除掉旧计时器，然后设立新的计时器，等待3 秒，打印一个 hello word，此后每次触发 scroll 事件回调，如果已经存在定时器，则清除掉旧计时器，然后重新设置定时器。 理解了大致思路，我们用第一种方法实现一个 debounce: 1234567891011121314151617181920/** * 防抖 debounce 定时器 * @param fn &#123;function&#125; 回调函数 * @param wait &#123;number&#125; 时间间隔 * @author wangxiaobai * @date 2019/5/30 */export function debounce (fn, wait) &#123; let timer = null return function (...args) &#123; // 清除上次执行得定时器 if (timer) &#123; clearTimeout(timer) &#125; // 设立新定时器 timer = setTimeout(() =&gt; &#123; fn.apply(this, args) &#125;, wait) &#125;&#125; throttle 和 debounce 不仅是我们日常开发中的常用优质代码片段，更是前端面试中不可不知的高频考点。“看懂了代码”、“理解了过程”在本节都是不够的，重要的是把它写到自己的项目里去，亲自体验一把节流和防抖带来的性能提升。 参考 前端性能优化原理与实践 深入浅出节流函数throttle","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Vue-源码系列随读笔记之Object变化侦测","slug":"Vue-源码系列随读笔记之Object变化侦测","date":"2019-05-16T10:34:52.000Z","updated":"2019-06-17T03:49:28.573Z","comments":true,"path":"2019/05/16/Vue-源码系列随读笔记之Object变化侦测/","link":"","permalink":"http://yoursite.com/2019/05/16/Vue-源码系列随读笔记之Object变化侦测/","excerpt":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档","text":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档 什么是变化侦测从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。 简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。 Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。 如何追踪变化首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。 123456789101112131415function defineReactive (data, key, val) &#123; Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; return val &#125;, ser: function(newVal) &#123; if (val === newVal) &#123; return &#125; val = newVal &#125; &#125;)&#125; 此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，get 函数被触发；每当在 data 的 key 中设置新数据时， set 函数就会执行。 由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。 如何收集依赖思考以下问题： 12345678910111213141516171819let globalObj = &#123; text1: 'text1'&#125;;let o1 = new Vue(&#123; template: `&lt;div&gt; &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; &lt;div&gt;`, data: globalObj&#125;);let o2 = new Vue(&#123; template: `&lt;div&gt; &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; &lt;div&gt;`, data: globalObj&#125;); 该模板中有两个vm实例使用了text1，当它发生变化时，如果向使用了它的地方发送通知来更新视图？ 对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。 即：在 getter 中收集依赖，在 setter 中触发依赖。 依赖收集到哪里（Dep） 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849let uid = 0export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ // 唯一id this.subs = [] // 观察者集合 &#125; // 添加观察者 addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; // 移除观察者 removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; depend () &#123; // 如果存在 Dep.target，则进行依赖收集操作 if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify () &#123; const subs = this.subs.slice() // 避免污染原来的集合 // 如果不是异步执行，先进行排序，保证观察者执行顺序 if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() // 更新 &#125; &#125;&#125;Dep.target = null // 用于闭包时，保存特定的值const targetStack = []// 入栈export function pushTarget (target: ?Watcher) &#123; targetStack.push(target) Dep.target = target&#125;// 出栈export function popTarget () &#123; targetStack.pop() Dep.target = targetStack[targetStack.length - 1]&#125; 什么是依赖(Watcher)当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。 然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103let uid = 0export default class Watcher &#123; // ... constructor ( vm: Component, // 组件实例 expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作 cb: Function, // 被观察者发生变化后的回调 options?: ?Object, // 参数 isRenderWatcher?: boolean // 是否是渲染函数的观察者 ) &#123; this.vm = vm // Watcher有一个 vm 属性，表明它是属于哪个组件的 if (isRenderWatcher) &#123; vm._watcher = this &#125; vm._watchers.push(this) // 给组件实例的_watchers属性添加观察者实例 // options if (options) &#123; this.deep = !!options.deep // 深度发现对象内部值得变化 this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync // 同步执行 this.before = options.before &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false &#125; this.cb = cb // 回调 this.id = ++uid // uid for batching // 唯一标识 this.active = true // 观察者实例是否激活 this.dirty = this.lazy // for lazy watchers // 避免依赖重复收集的处理 this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' // parse expression for getter if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; // 类似于 Obj.a 的字符串 this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = noop // 空函数 process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed watching path: \"$&#123;expOrFn&#125;\" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ) &#125; &#125; this.value = this.lazy ? undefined : this.get() &#125; get () &#123; // 触发取值操作，进而触发属性的getter pushTarget(this) // Dep 中提到的：给 Dep.target 赋值 let value const vm = this.vm try &#123; // 核心，运行观察者表达式，进行取值，触发getter，从而在闭包中添加watcher value = this.getter.call(vm, vm) &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, `getter for watcher \"$&#123;this.expression&#125;\"`) &#125; else &#123; throw e &#125; &#125; finally &#123; if (this.deep) &#123; // 如果要深度监测，再对 value 执行操作 traverse(value) &#125; // 清理依赖收集 popTarget() this.cleanupDeps() &#125; return value &#125; addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; // 避免依赖重复收集 this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) // dep 添加订阅者 &#125; &#125; &#125; update () &#123; // 更新 /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() // 同步直接运行 &#125; else &#123; // 否则加入异步队列等待执行 queueWatcher(this) &#125; &#125; 递归侦测所有Key前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// observer/index.js// Observer 前的预处理方法export function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; // 是否是对象或者虚拟dom return &#125; let ob: Observer | void // 判断是否有 __ob__ 属性，有的话代表有 Observer 实例，直接返回，没有就创建 Observer if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( // 判断是否是单纯的对象 shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) // 创建Observer &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125;// Observer 实例export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() // 给 Observer 添加 Dep 实例，用于收集依赖，辅助 vm.$set/数组方法等 this.vmCount = 0 // 为被劫持的对象添加__ob__属性，指向自身 Observer 实例。作为是否 Observer 的唯一标识。 def(value, &apos;__ob__&apos;, this) if (Array.isArray(value)) &#123; // 判断是否是数组 if (hasProto) &#123; // 判断是否支持__proto__属性，用来处理数组方法 protoAugment(value, arrayMethods) // 继承 &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) // 拷贝 &#125; this.observeArray(value) // 劫持数组成员 &#125; else &#123; this.walk(value) // 劫持对象 &#125; &#125; walk (obj: Object) &#123; // 只有在值是 Object 的时候，才用此方法 const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) // 数据劫持方法 &#125; &#125;&#125; 现在，我们重新封装一下 defineReactive ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep() // 实例一个 Dep 实例 const property = Object.getOwnPropertyDescriptor(obj, key) // 获取对象自身属性 if (property &amp;&amp; property.configurable === false) &#123; // 没有属性或者属性不可写就没必要劫持了 return &#125; // 兼容预定义的 getter/setter const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; // 初始化 val val = obj[key] &#125; // 默认监听子对象，从 observe 开始，返回 __ob__ 属性 即 Observer 实例 let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val // 执行预设的getter获取值 if (Dep.target) &#123; // 依赖收集的关键 dep.depend() // 依赖收集，利用了函数闭包的特性 if (childOb) &#123; // 如果有子对象，则添加同样的依赖 childOb.dep.depend() // 即 Observer时的 this.dep = new Dep(); if (Array.isArray(value)) &#123; // value 是数组的话调用数组的方法 dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val // 原有值和新值比较，值一样则不做处理 // newVal !== newVal &amp;&amp; value !== value 这个比较有意思，但其实是为了处理 NaN if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123; customSetter() &#125; if (getter &amp;&amp; !setter) return if (setter) &#123; // 执行预设setter setter.call(obj, newVal) &#125; else &#123; // 没有预设直接赋值 val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) // 是否要观察新设置的值 dep.notify() // 发布，利用了函数闭包的特性 &#125; &#125;)&#125;// 处理数组function dependArray (value: Array&lt;any&gt;) &#123; for (let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() // 如果数组成员有 __ob__，则添加依赖 if (Array.isArray(e)) &#123; // 数组成员还是数组，递归调用 dependArray(e) &#125; &#125;&#125; 总结变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。 Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。 我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。 收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。 所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。 Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。 由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。 在 Vue 中，对象新增属性或删除属性都无法被侦测到。 Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。 当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。 当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。 Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"JS-数据结构与算法之链表","slug":"JS-数据结构与算法之链表","date":"2019-03-25T12:57:52.000Z","updated":"2019-06-17T03:49:28.569Z","comments":true,"path":"2019/03/25/JS-数据结构与算法之链表/","link":"","permalink":"http://yoursite.com/2019/03/25/JS-数据结构与算法之链表/","excerpt":"导语 使用列表对数据进行排序，底层储存数据的数据结构是数组。然而，数组并不总是最优选择。","text":"导语 使用列表对数据进行排序，底层储存数据的数据结构是数组。然而，数组并不总是最优选择。 数组的缺点数组不总是组织数据的最佳数据结构，原因如下：在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再需要加入新的元素就会非常困难。 在数组中，添加和删除元素也很麻烦，需要将数组中的其它元素向前或向后移动，以反映数组刚刚进行了添加或删除操作。 如果你发现数组在实际使用时很慢，就可以考虑使用链表来替代它。除了对数据的随机访问，","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS-数据结构与算法之队列","slug":"JS-数据结构与算法之队列","date":"2019-03-16T12:57:52.000Z","updated":"2019-06-17T03:49:28.570Z","comments":true,"path":"2019/03/16/JS-数据结构与算法之队列/","link":"","permalink":"http://yoursite.com/2019/03/16/JS-数据结构与算法之队列/","excerpt":"导语 队列是一种列表，不同的是，队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。","text":"导语 队列是一种列表，不同的是，队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。 对队列的操作队列的两种主要操作是：向队列中插入新元素和删除队列中的元素。插入操作也叫做入队，删除操作也叫做出队。入队操作在队尾插入新元素，出队操作删除队头的元素。 队列的另一项重要操作是读取队头的元素，这个操作叫 peek() 。该操作返回队头元素，但不把它从队列中删除。除了读取队头元素，我们还可以用 length 属性来知道队列中存储了多少元素，用 clear() 方法来清空队列中的元素。 用数组实现的队列使用数组来实现队列看起来顺理成章。数组的 push() 方法可以在数组末尾加入元素，shift() 方法则可以删除数组的第一个元素。 push() 方法将它的参数插入数组中第一个开放的位置，该位置总在数组的末尾，即使是个空数组也是如此。 准备开始实现 Queue 类，先从构造函数开始： 123456789function Queue () &#123; this.dataStore = [] this.enqueue = enqueue this.dequeue = dequeue this.front = front this.back = back this.toString = toString this.empty = empty&#125; enqueue() 方法向队尾添加一个元素 123function enqueue (element) &#123; this.dataStore.push(element)&#125; dequeue() 方法删除队首的元素 123function dequeue () &#123; return this.dataStore.shift()&#125; 使用如下的方法读取队首和队尾的元素 1234567function front () &#123; return this.dataStore[0]&#125;function back () &#123; return this.dataStore[this.dataStore.length -1]&#125; toString() 方法显示队列内的所有元素 1234567function toString () &#123; var retStr = '' for (var i = 0; i &lt; this.dataStore.length; i++) &#123; retStr += this.dataStore[i] + ' ' &#125; return retStr&#125; empty() 方法判断队列是否为空 123function empty () &#123; return this.dataStore.length === 0&#125; 使用队列：方块舞的舞伴分配问题男男女女来到舞池，他们按照自己的性别排成两队。当舞池中有地方空出来时，选两个队列中第一个人组成舞伴。他们身后的人各自向前移动一个位置，变成新的队首。当一对舞伴迈入舞池时，主持人会大声喊出他们的名字。当一队舞伴走出舞池，且两排队伍中有任意一队没人时，主持人也会把这个情况告诉大家。 为了模拟这种情况，我们把跳方块舞的男男女女的姓名储存在 dancers 变量中： 1var dancers = 'F Allison \\n M Frank \\n M Mason \\n M Clayton \\n F Cheryl \\n M Raymond \\n F Jennifer \\n M Bryan \\n M David \\n M Danny \\n F Aurora' 每个舞者的信息都被存储在一个 Dancer 对象中： 1234function Dancer (name, sex) &#123; this.name = name this.sex = sex&#125; 下面我们需要一个函数，将舞者信息读到程序中： 12345678910111213141516function getDancers (maleDancers, femaleDancers) &#123; var names = dancers.split('\\n') for (var i = 0; i &lt; names.length; i++) &#123; names[i] = names[i].trim() &#125; for (var i = 0; i &lt; names.length; i++) &#123; var dancer = names[i].split(' ') var sex = dancer[0] var name = dancer[1] if (sex === 'F') &#123; femaleDancers.enqueue(new Dancer(name, sex)) &#125; else &#123; maleDancers.enqueue(new Dancer(name, sex)) &#125; &#125;&#125; 舞者的姓名被从变量 dancers 中读入数组。然后 trim() 函数除去了每行字符串的空格。第二个循环将每行字符串按姓名和性别分成两部分存入一个数组。然后根据性别，将舞者加入不同的队列。 下一个函数将男性和女性组成舞伴，并且宣布配对结果。 12345678910function dance (females, males) &#123; console.log('the dance partners are: ') let person while (!females.empty() &amp;&amp; !males.empty()) &#123; person = females.dequeue() console.log('female dancer is ', person) person = males.dequeue() console.log('and male dancer is ', person) &#125;&#125; 使用队列对数据进行排序队列不仅用于执行现实生活中与排队有关的操作，还可以用于对数据进行排序。对于0 ~99 的数字，我们可以基于基数排序对数据扫描两次。第一次按个位上的数字进行排序，第二次按十位上的数字进行排序。每个数字根据对应位上的数值被分在不同的盒子上。假设有以下数字： 191, 46, 85, 15, 92, 35, 31, 22 经过基数排序第一次扫描之后，数字被分配到如下的盒子里： 12345678910Bin 0:Bin 1: 91, 31Bin 2: 92, 22Bin 3:Bin 4:Bin 5: 85, 15, 35Bin 6: 46Bin 7:Bin 8:Bin 9: 根据盒子的顺序，第一次排序的结果如下： 191, 31, 92, 22, 85, 15, 35, 46 然后根据十位上的数值再次将上述排序的结果分配到不同的盒子里： 12345678910Bin 0:Bin 1: 15Bin 2: 22Bin 3: 31, 35Bin 4: 46Bin 5: Bin 6: Bin 7: Bin 8: 85Bin 9: 91, 92 最后，将盒子中的数字取出，组成一个新的列表，该列表即为排好序的数字： 115， 22， 31， 35， 46， 85， 91， 92 使用队列代表盒子，可以实现这个算法。我们需要九个队列，每个对应一个数字，将所有队列保存在一个数组中，使用取余和除法操作决定个位和十位。算法的剩余部分将数字加入相应的队列，根据个位数值对其重新排序，然后再根据十位上的数值进行排序，结果即为排好序的数字。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function Queue () &#123; this.dataStore = [] this.enqueue = enqueue this.dequeue = dequeue this.front = front this.back = back this.toString = toString this.count = count this.empty = empty&#125;function enqueue (element) &#123; this.dataStore.push(element)&#125;function dequeue () &#123; return this.dataStore.shift()&#125;function front () &#123; return this.dataStore[0]&#125;function back () &#123; return this.dataStore[this.dataStore.length -1]&#125;function toString () &#123; var retStr = '' for (var i = 0; i &lt; this.dataStore.length; i++) &#123; retStr += this.dataStore[i] + ' ' &#125; return retStr&#125;function count () &#123; return this.dataStore.length&#125;function empty () &#123; return this.dataStore.length === 0&#125;//基数排序var queues = [] //定义队列数组var nums = [] //定义数字数组//选十个0~99的随机数进行排序for (var i = 0; i &lt; 10; i ++)&#123; queues[i] = new Queue() nums[i] = Math.floor( Math.random() * 101 )&#125;//排序之前console.log( 'before radix sort: ' + nums )//基数排序distribution(nums, queues , 10 , 1)collect(queues, nums)distribution(nums, queues , 10 , 10)collect(queues, nums)//排序之后console.info('after radix sort: ' + nums)//根据相应的（个位和十位）数值，将数字分配到相应队列function distribution (nums, queues, n, digit) &#123; //digit表示个位或者十位的值 for(var i = 0; i &lt; n; i++)&#123; if(digit == 1)&#123; queues[nums[i] % 10].enqueue(nums[i]) &#125;else&#123; queues[Math.floor(nums[i] / 10)].enqueue(nums[i]) &#125; &#125; console.log(queues.toString())&#125;//从队列中收集数字function collect (queues, nums) &#123; var i = 0 for (var digit = 0; digit &lt; 10 ; digit++ )&#123; while (!queues[digit].empty())&#123; nums[i++] = queues[digit].dequeue() &#125; &#125;&#125; 优先队列一般情况下，从队列中删除元素，一定是最新入队的元素，但是也有一些使用队列的应用，在删除元素时不必遵循先进先出的约定。这种应用，需要使用一个叫做优先队列的数据结构来进行模拟。 从优先队列中删除元素时，需要考虑优先权的限制。 先来定义存储队列元素的对象，然后在构建我们的优先队列系统： 1234function Patient (name, code) &#123; this.name = name this.code = code&#125; 变量 code 是一个整数，表示优先级。 现在需要重新定义 dequeue() 方法，使其删除队列中拥有最高优先级的元素。我们规定，优先码的值最小，代表优先级最高。新的 dequeue() 方法遍历队列的底层存储数组，从中找出优先码值最小的元素，然后使用数组的 splice() 方法删除优先级最高的元素。新的 dequeue() 方法定义如下所示： 123456789function dequeue () &#123; var entry = 0 for (var i = 1; i &lt; this.dataStore.length; ++i) &#123; if (this.dataStore[i].code &lt; this.dataStore[entry].code) &#123; entry = i &#125; &#125; return this.dataStore.splice(entry, 1)&#125; 优先队列的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function Queue () &#123; this.dataStore = [] this.enqueue = enqueue this.dequeue = dequeue this.front = front this.back = back this.toString = toString this.count = count this.empty = empty&#125;function enqueue (element) &#123; this.dataStore.push(element)&#125;function dequeue () &#123; var entry = 0 for (var i = 1; i &lt; this.dataStore.length; ++i) &#123; if (this.dataStore[i].code &lt; this.dataStore[entry].code) &#123; entry = i &#125; &#125; return this.dataStore.splice(entry, 1)&#125;function front () &#123; return this.dataStore[0]&#125;function back () &#123; return this.dataStore[this.dataStore.length -1]&#125;function toString () &#123; var retStr = '' for (var i = 0; i &lt; this.dataStore.length; i++) &#123; retStr += this.dataStore[i].name + ' code:' + this.dataStore[i].code + ' ' &#125; return retStr&#125;function count () &#123; return this.dataStore.length&#125;function empty () &#123; return this.dataStore.length === 0&#125;function Patient (name, code) &#123; this.name = name this.code = code&#125;var p = new Patient('smith', 5)var ed = new Queue()ed.enqueue(p)p = new Patient('Jones', 4)ed.enqueue(p)p = new Patient('Wang', 6)ed.enqueue(p)p = new Patient('Qian', 1)ed.enqueue(p)p = new Patient('Brown', 1)ed.enqueue(p)var seen = ed.dequeue()console.log('Patient being treated: ' + seen[0].name)console.log('Patients watting to be seen:')console.log(ed.toString())seen = ed.dequeue()console.log('Patient being treated: ' + seen[0].name)console.log('Patients watting to be seen:')console.log(ed.toString())seen = ed.dequeue()console.log('Patient being treated: ' + seen[0].name)console.log('Patients watting to be seen:')console.log(ed.toString())","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS-数据结构与算法之栈","slug":"JS-数据结构与算法之栈","date":"2019-03-15T12:57:52.000Z","updated":"2019-06-17T03:49:28.569Z","comments":true,"path":"2019/03/15/JS-数据结构与算法之栈/","link":"","permalink":"http://yoursite.com/2019/03/15/JS-数据结构与算法之栈/","excerpt":"导语 栈是和列表类似的一种数据结构，它可以用来解决计算机世界里的很多问题。","text":"导语 栈是和列表类似的一种数据结构，它可以用来解决计算机世界里的很多问题。 对栈的操作栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈被称为一种后入先出 (LIFO，last-in-first-out) 的数据结构。 由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，必须先拿掉上面的元素。 对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用 push() 方法，出栈使用 pop() 方法。 另一个常用的操作就是预览栈顶的元素。 pop() 方法虽然可以访问到栈顶的元素，但是该方法也将栈顶元素永久性地删除了。peek() 方法则只返回栈顶元素，而不删除它。 为了记录栈顶的位置，同时也为了哪里可以加入新元素，我们使用变量 top 。当向栈内压入元素时，该变量增大。当从栈内弹出元素时，该变量减小。 push()、pop()、peek() 是栈的3个主要方法，但是栈还有其它方法和属性。clear() 清除栈内所有元素，length 属性记录栈内元素的个数，empty 属性，用以表示栈内是否有元素。 栈的实现实现一个栈，首先是要决定存储数据的底层数据结构。这里，我们选用数组。 我们从实现以定义 Stack 类的构造函数开始： 123456789function Stack () &#123; this.dataStore = [] this.top = 0 this.push = push this.pop = pop this.peek = peek this.clear = clear this.length = length&#125; 我们用数组 dataStore 来保存栈内的元素，构造函数将其初始化为一个空数组。变量 top 记录栈顶位置，被构造函数初始化为 0 ，表示栈顶对应数组的起始位置 0 。如果有元素被压入栈内，该变量的值将随之变化。 push() 方法 – 当向栈内压入一个新元素时，需要将其保存在数组中变量 top 所对应的位置，然后将 top 值加 1，让其指向数组中下一个空位值。 123function push (element) &#123; this.dataStore[this.top++] = element&#125; 这里需要注意 ++ 操作符的位置，它放在 this.top 的后面，这样新入栈的元素就会被放在 top 的当前值指向的位置，然后再将 top 的值加 1 ，指向下一个位置。 pop() 方法 – 返回栈顶元素，同时将变量 top 的值减 1 。 123function pop () &#123; return this.dataStore[--this.top]&#125; peek() 方法 – 返回栈顶元素，即将变量 top 的值减 1 。 123function peek () &#123; return this.dataStore[this.top - 1]&#125; 如果对一个空栈调用 peek() 方法，结果为 undefined 。 length() 方法 – 通过返回变量 top 值得方式来获取栈内存储了多少元素。 clear() – 将变量 top 的值设为 0 ，轻松清空一个栈。 123function clear () &#123; this.top = 0&#125; 使用 Stack 类在开发过程中，有一些问题特别适合用栈来解决： 数制间的相互转换可以利用栈实现一个数字从一种数制转换为另一种数制。假设想将数字 n 转换为以 b 为基数的数字，实现转换的算法如下(注：此算法只针对基数为2—9的情况)： (1) 最高位为 n % b，将此位压入栈。(2) 使用 n / b 代替 n 。(3) 重复步骤 1 和 2 ，直到 n 等于 0 ，且没有余数。(4) 持续将栈内元素弹出，直到栈为空，依次将这些元素排列，就得到转换后数字的字符串形式。 123456789101112function mulBase (num, base) &#123; var s = new Stack() do &#123; s.push(num % base) num = Math.floor(num /= base) &#125; while (num &gt; 0) var converted = '' while (s.length() &gt; 0) &#123; converted += s.pop() &#125; return converted&#125; 回文回文是指这样一种现象：一个单词、短语或数字，从前往后写和从后往前写都是一样的。如：单词 ‘dad’ , ‘racecar’ 就是回文。 使用栈，可以轻松判断一个字符串是否是回文。我们将拿到的字符串的每个字符从左到右的顺序压入栈。当字符串中的字符都入栈后，栈内就保存了一个反转后的字符串，最后的字符在栈顶，第一个字符在栈底。 字符串完整压入栈内后，通过持续弹出栈中的每个字母就可以得到一个新字符串，该字符串刚好与原来的字符串顺序相反。我们只需比较这两个字符串即可，如果它们相等，就是一个回文。 1234567891011function isPalindrome (word) &#123; var s = new Stack() for (let i of word) &#123; s.push(i) &#125; var rWord = '' while (s.length() &gt; 0) &#123; rWord += s.pop() &#125; return rWord == word&#125; 递归演示为了演示如何用栈实现递归，考虑一下求阶乘函数的递归定义，首先看看 5 的阶乘是怎么定义的： 123456function factorial (n) &#123; if (n === 0) &#123; return 1 &#125; return n * factorial(n - 1)&#125; 使用栈模拟递归的过程 123456789101112function fact (n) &#123; var s = new Stack() while (n &gt; 1) &#123; s.push(n--) &#125; var product = 1 console.log(s.length()) while (s.length() &gt; 0) &#123; product *= s.pop() &#125; return product&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Vue-源码系列随读笔记之认识Flow","slug":"Vue-源码系列之认识Flow","date":"2019-03-01T09:02:00.000Z","updated":"2019-06-17T03:49:28.573Z","comments":true,"path":"2019/03/01/Vue-源码系列之认识Flow/","link":"","permalink":"http://yoursite.com/2019/03/01/Vue-源码系列之认识Flow/","excerpt":"导语 Flow是facebook出品的javascript静态类型检查工具。Vue.js源码利用了Flow做了静态类型检查。优先了解Flow有助于我们阅读源码。","text":"导语 Flow是facebook出品的javascript静态类型检查工具。Vue.js源码利用了Flow做了静态类型检查。优先了解Flow有助于我们阅读源码。 为什么要使用Flowjavascript是动态类型语言，它的灵活性有目共睹。但过于灵活的副作用就是容易写出非常隐蔽的隐患代码，在编译期看上去不会报错，但在运行阶段就可能出现各种奇怪的bug。 类型检查是当前动态类型语言的发展趋势。所谓类型检查，就是在编译期尽早发现bug，又不影响代码运行，使编写javascript具有和编写java等强类型语言相近的体验。 Flow的工作方式通常类型检查分为2中方式： 类型推断：通过变量使用的上下文来推断出变量类型，然后根据这些推断来检查类型。 类型注释：事先注释好我们期待的类型，Flow会基于这些注释来判断。 类型推断无需任何代码修改即可进行类型检查，最小化开发者的工作量。不会强制你改变开发习惯，因为它会自动推断出变量的类型。 1234567/*@flow*/function split(str) &#123; return str.split(&apos; &apos;)&#125;split(11) 类型注释在某些特定的场景下，添加类型注释可以提供更好更明确的检查依据。 考虑如下代码： 12345/*@flow*/function add(x, y) &#123; return x + y&#125;add(&apos;hello&apos;, 11) Flow检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 add() 的参数必须为数字。 在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以 : 开头，可以在函数参数、返回值、变量声明中使用。 如果我们在上段代码中添加类型注释，就会变成如下： 12345/*@flow*/function add(x: number, y: number) : number &#123; return x + y&#125;add(&apos;hello&apos;, 11) 现在Flow就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。 上面的例子是针对函数的类型注释。接下来我们来看看Flow能支持的一些常见的类型注释。 数组123/*@flow*/var arr: Array&lt;number&gt; = [1, 2, 3]arr.push(&apos;hello) 数组类型注释的格式为Array，T表示数组中每项的数据类型。在上述代码中，arr是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow就能检查出错误。 类和对象1234567891011121314151617181920/*@flow*/class Bar &#123; x: string y: string | number z: boolean constructor(x: string, y: string | number) &#123; this.x = x this.y = y this.z = z &#125;&#125;var bar: Bar = new Bar(&apos;hello&apos;, 11)var obj: &#123; a: string, b: number, c: Array&lt;string&gt;, d: Bar&#125; = &#123; a: &apos;hello&apos;, b: 11, c: [&apos;hello&apos;, &apos;world&apos;], d: new Bar(&apos;hello&apos;, 11)&#125; 类的类型注释可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。 对象的类型注释类似于类，需要指定对象属性的类型。 Null若想任意类型 T 可以为 null 或 undefined ，只需类似如下写成 ?T 的格式即可。 123/*@flow*/var foo ?string = null 此时，foo 可以为字符串，也可以为 null 。 Flow在Vue.js源码中的应用有时我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，检查时就会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者自定义类型。而 Vue.js 也利用了这一特性。 在 Vue.js 的主目录下有 .flowconfig 文件，它是 Flow 的配置文件。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。 这里的 [libs] 配置的是 flow ，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，就会发现文件如下： 123456789flow|-- compiler.js # 编译相关|-- component.js # 组件数据结构|-- global.api.js # Global API 结构|-- modules.js # 第三方库协议|-- options.js # 选项相关|-- ssr.js # 服务端渲染相关|-- vnode.js # 虚拟node相关|-- weex.js # weex相关 总结通过对Flow的认识，有助于阅读Vue源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Node-阿里云ECS部署","slug":"Node-阿里云ECS部署","date":"2018-11-27T04:19:00.000Z","updated":"2019-06-17T03:49:28.572Z","comments":true,"path":"2018/11/27/Node-阿里云ECS部署/","link":"","permalink":"http://yoursite.com/2018/11/27/Node-阿里云ECS部署/","excerpt":"导语 双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？","text":"导语 双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？ 此教程仅供新手借鉴，多少有些缺陷，有问题还望各位大佬指正。 准备工作 一个域名 阿里云ECS(实例镜像：CentOS7.4) 如果使用Windows，推荐xshell。如果是Mac，推荐iTerm2 (注：因本人使用Mac，以下均已Mac为主) 终端连接服务器 打开iTerm2，输入连接命令ssh username@ip公网地址，回车，输入你在购买服务器时设置的密码。 密码输入正确，进入服务器。 cd / 进入根目录，创建一个空目录 mkdir soft，用来放我们的安装包。 安装Node下载node包。 1wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz 下载完成后，进行压缩包解压。 1tar -zxvf v8.9.4.tar.gz 进入解压好的目录并执行config配置命令。 1cd node-v8.9.4 &amp;&amp; ./configure 执行编译及安装命令。 1make &amp;&amp; make install 经过漫长的等待之后，一个node环境就安装好了。可以通过node -v 或者 npm -v来检查当前node/npm是否安装成功。 如果你需要升级node和npm版本，执行以下命令即可。 12npm i -g nn stable 安装nrm和pm2nrm是一个管理npm源的插件，方便切换国内外以及私人npm库。 pm2是node服务器的守护进程，方便管理当前服务器上的所有服务。 这里说一下cnpm，如果安装依赖包很慢或者根本没进度，输入命令 1npm install -g cnpm --registry=https://registry.npm.taobao.org 然后使用cnpm代替npm安装。 回到我们熟悉的soft目录。 nrm安装nrm。 1npm install -g nrm 常用命令： nrm add name address 添加新的源 nrm use name 切换到源 nrm ls 查看所有可用的源 pm2安装pm2。 1npm install -g pm2 常用命令： pm2 list 查看pm2守护服务 pm2 start index.js 启动一个pm2守护进程命令 pm2 restart id/name 重启一个pm2守护进程命令 pm2 delete id/name 删除一个正在使用的进程 pm2 delete all 删除所有正在使用的进程 pm2 monit 查看pm2的消耗 安装mysql卸载已有的mysql。 12rpm -qa|grep -i mysqlyum remove &apos;mysql&apos; 下载mysql源。 12// 5.7.24wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm 安装下载的源。 1rpm -ivh mysql57-community-release-el7-7.noarch.rpm 下载安装mysql。 123yum install mysql-serveryum install mysql-develyum install mysql 启动mysql。 1service mysqld start 常用命令： service mysqld status 查看mysql当前的状态 service mysqld stop 停止mysql service mysqld restart 重启mysql service mysqld start 启动mysql 如果遇到错误：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket /var/lib/mysql/mysql.sock’，请在tmp下创建一个软连接： 1ln -s /tmp/mysql.sock /var/lib/mysql 打开my.cnf并修改。 1vi /etc/my.cnf 重启数据库。 1service mysqld restart 登录(默认root是没有密码的)。 1mysql -u root 这时出现ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)，登录root帐号需要密码，现在我们没有设置密码，哪来的密码。 于是我们开始忘记密码的操作 第一步，在/etc/my.cnf文件中添加skip-grant-tables第二步，重启mysql，service mysqld restart第三步，登录mysql，mysql -u root第四步，修改密码： 1234mysql&gt;use mysql;mysql&gt;update mysql.user set authentication_string=password(&apos;your password&apos;) where user=&apos;root&apos;;mysql&gt;flush privileges;mysql&gt;exit; 第五步，恢复/etc/my.cnf，将skip-grant-tables删除或者注释掉第六步，重启mysql，service mysqld restart 分配用户 host指定该用户在哪个主机上可以登陆，此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录;也可以指定某台机器可以远程登录。 12CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;CREATE USER &apos;test&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;; 给创建的用户权限 privileges 用户的操作权限,如SELECT，INSERT，UPDATE等.如果要授予所的权限则使用ALL databasename 数据库名 tablename 表名,如果要授予该用户对所有数据库和表的相应操作权限则可用表示, 如.*. 1GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; 安装RedisRedis是一个非常好用的数据仓库，既可以做nosql数据库，也可以做缓存数据库。 下载安装包。 1wget http://download.redis.io/releases/redis-4.0.6.tar.gz 解压并进入解压之后的文件夹。 1tar -zxvf redis-4.0.6.tar.gz &amp;&amp;cd redis-4.0.6 编译并安装。 1make &amp;&amp; make install 启动redis服务。 1redis-server redis.conf 此时我们发现，不能再输入任何命令，因为redis-server已经占用了这个命令行客户端。我们需要再打开一个命令行工具并连接服务器。 使用redis客户端连接Redis服务，执行Redis文件夹下的redis-cli文件redis-cli，输入几个命令测试一下简单的set/get： 关掉客户端，redis服务也会停止。这时，我们就需要修改redis.conf文件，将daemonizede的值改为yes。 再次运行Redis的启动命令redis-server redis.conf，这次就不会占用命令行了，可以继续操作其他的，Redis服务也不会停止。 nginxnginx在转发请求，负载均衡等方面非常有用。它可以将几个不同的服务集中在一个80端口下，根据域名或者请求路径来区分。 在安装nginx之前，先要安装几个依赖插件。 12yum install -y pcre pcre-develyum install -y zlib zlib-devel 安装openssl。 1yum install -y openssl openssl-devel 下载nginx包。 1wget https://nginx.org/download/nginx-1.15.6.tar.gz 解压并进入解压好的目录。 1tar -zxvf nginx-1.15.6.tar.gz &amp;&amp; cd nginx-1.15.6 执行配置命令。 1./configure 编译并安装。 1make &amp;&amp; make install 查看安装结果。 1whereis nginx 跳转到安装好的nginx目录下，进入sbin目录。 1cd /usr/local/nginx/sbin 启动nginx。 1./nginx 常用命令： ./nginx 启动nginx ./nginx -s stop 停止nginx ./nginx -s quit 退出nginx ./nginx -s reload 重启nginx 安装GitcentOS上没有安装git，有需要的话，我们可以自己手动安装一下。 12yum install gitgit --version 使用pm2启动项目在本地搭建并测试好node项目，上传到GitHub。然后git clone一下。 配置ECS安全组规则，暴露3000接口。 如果项目中使用数据库，运行之前要先建立好数据库，然后再运行项目，登录数据库执行create database dabasename; 1234git clone https://github.com/***cd ***cnpm ipm2 start index.js 注：项目监听3000端口，如果顺利的话，项目已经运行起来了。 可以使用pm2 list查看进程列表，使用pm2 log打印日志。 Linux常用操作指令列表 命令 说明 ssh username@ip 连接服务器 cd path 跳转到路径对应的目录下 rm filename 删除文件 rm -rf path 删除目录及目录下的所有文件 ls [-a] 查看当前目录下的文件和目录(-a：查看所有文件，包括隐藏文件) ll 查看当前目录下的文件详情(文件权限) pwd 查看当前路径的完整路径 which name 默认位置查找该名字 mkdir dirname 创建空目录 cat path 查看文件内容 cp origin target 复制一个文件到另一个地方 mv origin target 移动一个文件到另一个地方 ps -aux 显示当前进程 kill -9 processid 结束进程 tar -zxvf filename 解压文件 tar -zcvf filename 压缩文件 vi path 进入文件编辑模式 vi编辑文件，按下i进入编辑模式 vi退出文件，esc+:wq或esc+:x保存退出 vi退出文件，esc+:q或esc+:q!强制退出","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"JS-深拷贝与浅拷贝","slug":"JS-深拷贝与浅拷贝","date":"2018-10-11T10:11:52.000Z","updated":"2019-06-17T03:49:28.570Z","comments":true,"path":"2018/10/11/JS-深拷贝与浅拷贝/","link":"","permalink":"http://yoursite.com/2018/10/11/JS-深拷贝与浅拷贝/","excerpt":"导语 当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。","text":"导语 当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。 实例🌰： 1234var a = &#123;x: 10, y: 10&#125;var b = ab.x = 100b.y = 100 打印一下a和b的值： 12console.log(a) // &#123;x: 100, y: 200&#125;console.log(b) // &#123;x: 100, y: 200&#125; 发现改变b的值，同时也改了a的值。 🌰： 123var a = 10var b = ab = 20 打印一下a和b的值： 12console.log(a) // 10console.log(b) // 20 ??? b的值改变并没有引起a的值改变。 值类型 vs 引用类型在JS中，变量传递方式分为值类型和引用类型。值类型包括String，Number，Null，Boolean，Undefined。引用类型包括Object类的所有，如Date，Array，Function。 在参数传递方式上，值类型是按值传递。引用类型是按共享传递(指向同一个内存地址，两者引用同一个值，当一者改变值，另一者也改变)。 JS这样设计的原因在于：按值传递的类型，复制一份存入栈内存，这类类型一般不会占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值，保证过大的对象等不会因为不停复制内容而造成内存的浪费。 深拷贝和浅拷贝最根本的区别在于是否真正获取了一个对象的拷贝实体，而不只是引用。 浅拷贝的实现方式直接赋值🌰： 123let obj = &#123;username: &apos;kobe&apos;, age: 39, sex: &#123;option1: &apos;男&apos;, option2: &apos;女&apos;&#125;&#125;let obj1 = objobj1.sex.option1 = &apos;不男不女&apos; // 修改复制的对象会影响原对象 打印obj1的值 1console.log(obj1) // &#123;username: &apos;kobe&apos;, age: 39, sex: &#123;option1: &apos;不男不女&apos;, option2: &apos;女&apos;&#125;&#125; Object.assign🌰： 12345let obj = &#123; username: &apos;kobe&apos;&#125;;let obj1 = Object.assign(obj)obj1.username = &apos;wang&apos; 打印obj的值 1console.log(obj) // &#123; username: &quot;wang&quot; &#125; Array.prototype.concat🌰： 12345let arr = [1, 3, &#123; username: &apos;kobe&apos;&#125;]let arr2=arr.concat()arr2[2].username = &apos;wang&apos; 打印arr的值 1console.log(arr) // [1, 3, &#123; username: &quot;wade&quot; &#125;] Array.prototype.slice🌰： 12345let arr = [1, 3, &#123; username: &apos;kobe&apos;&#125;]let arr2=arr.slice()arr2[2].username = &apos;wang&apos; 打印arr的值 1console.log(arr) // [1, 3, &#123; username: &quot;wade&quot; &#125;] Array.prototype.concat vs Array.prototype.slice关于Array的concat和slice补充说明：Array的concat和slice方法不改变原始数组，只是返回了一个浅复制原数组中的元素的一个新数组。 原数组中的元素会按照下述规则拷贝： 如果该元素是个引用类型，slice或者concat会拷贝这个引用到新的数组里，两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新数组和原数组中的这个元素都会发生改变。 如果该元素是个值类型，slice或者concat会复制一份这些值到新数组里。在别的数组里修改这些值，并不会影响另一个数组。 🌰： 123456let arr = [1, 3, &#123; username: &apos;kobe&apos;&#125;];let arr3 = arr.slice();arr3[1] = 2console.log(arr, arr3) 打印arr和arr3的值 1234console.log(arr, arr3)// ---result// [1, 3, &#123; username: &quot;kobe&quot; &#125;]// [1, 2, &#123; username: &quot;kobe&quot; &#125;] 深拷贝的实现方式Object.assignObject.assign可以进行一层深度拷贝 🌰： 12345678910var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = Object.assign(&#123;&#125;, obj1)obj1.age = 24console.log(obj, obj1) 打印obj和obj1的值 1234console.log(obj, obj1)// ----result// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; &#125;, age: 24 &#125; 然而。。。。。 🌰： 123456789var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = Object.assign(&#123;&#125;, obj1)obj1.test4.age = 24 打印obj和obj1的值 1234console.log(obj, obj1)// ----result// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; age: 24 &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; age: 24 &#125; &#125; JSON.parse(JSON.stringfy(obj))说到深拷贝，你肯定会想到JSON.parse(JSON.stringfy(obj))。 🌰： 12345678var obj = &#123; name: &apos;wang&apos;, test: &#123; name: &apos;test&apos; &#125; &#125;;var obj1 = JSON.parse(JSON.stringify(obj))obj1.test.name = 24 打印obj和obj1的值 1234console.log(obj, obj1)// ----result// &#123; name: &quot;wang&quot;, test: &#123; name: &quot;test&quot; &#125; &#125;// &#123; name: &quot;wang&quot;, test: &#123; name: 24 &#125; &#125; 然而。。。。 🌰： 12345678var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = JSON.parse(JSON.stringify(obj)) 打印obj和obj1的值 1234console.log(obj, obj1)// ---result// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test4: &#123; &#125; &#125; ???test2和test3不见了。。。。。 JSON.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个JSON字符串，不能接受函数。 手写递归方法1234567891011121314151617181920function deepClone(obj) &#123; let result let toString = Object.prototype.toString if (toString.call(obj) === &apos;[Object Array]&apos;) &#123; result = [] for (var i =0; i&lt;obj.length; i++) &#123; result[i] = deepClone(obj[i]) &#125; &#125; else if (toString.call(obj) === &apos;[Object Object]&apos;) &#123; result = &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; result[key] = deepClone(obj[key]) &#125; &#125; &#125; else &#123; return obj &#125; return result&#125; 🌰：调用函数并打印结果 1234567891011var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = deepClone(obj)console.log(obj, obj21)// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: Object &#123; &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: Object &#123; &#125; &#125; jQuery实现🌰： 12345678var obj1 = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = $.extend(true, &#123;&#125;, obj1) lodash实现🌰： 12345678var obj1 = &#123; name: &apos;wclimb&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = _.cloneDeep(obj1)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Webpack-webpack-dev-server","slug":"Webpack-webpack-dev-server","date":"2018-09-26T07:15:00.000Z","updated":"2019-06-17T03:49:28.574Z","comments":true,"path":"2018/09/26/Webpack-webpack-dev-server/","link":"","permalink":"http://yoursite.com/2018/09/26/Webpack-webpack-dev-server/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 webpack-dev-serverwebpack-dev-server为webpack提供的一个静态服务的工具，并能够实时重新加载。 基础使用安装： 1npm i webpack-dev-server -D package.json添加scripts配置： 123456&#123; // ... &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --mode development&quot; // 指定mode为development &#125;&#125; 1npm run dev 如果项目构建了HTML文件，直接访问http://localhost:8080/就可以看到index.html页面了。否则，就会看到一个静态资源列表列表的页面。 基础配置在webpack配置中，可以通过devServer字段来配置webpack-dev-server。 12345module.exports = &#123; devServer: &#123; // ... &#125;&#125; host：指定使用一个host，默认是localhost。 port：指定端口号，默认是8080。 publicPath: 构建好的静态文件在浏览器中以什么路径去访问，默认为’/‘。假设服务器运行在http://localhost:8080，并且output.filename被设置为bundle.js。完整的访问路径是 http://localhost:8080/bundle.js，如果你配置了 publicPath: ‘assets/‘，那么上述 bundle.js 的完整访问路径就是 http://localhost:8080/assets/bundle.js。 建议devServer.publicPath和output.publicPath一样。 proxy：配置代理 123456proxy: &#123; &apos;/api&apos;: &#123; target: &apos;http://localhost:3000&apos; // 将url中带有/api的请求代理到本地3000端口的服务器上 pathRewrite: &#123;&apos;^/api&apos;: &apos;&apos;&#125; // 把URL中path部分的api去掉 &#125;&#125; color：启用/jiny9ong控制台的彩色输出。 contentBase：提供未经webpack构建的额外静态文件内容的目录。 12345// 使用当前目录下的 publiccontentBase: path.join(__dirname, &quot;public&quot;)// 也可以使用数组提供多个路径contentBase: [path.join(__dirname, &quot;public&quot;), path.join(__dirname, &quot;assets&quot;)] publicePath的优先级高于constBase。 before：在服务内部的所有其他中间件之前， 提供执行自定义中间件的功能。 after：在服务内部的所有其他中间件之后， 提供执行自定义中间件的功能。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"Webpack-基础使用","slug":"Webpack-基础使用","date":"2018-09-25T07:15:00.000Z","updated":"2019-06-17T03:49:28.574Z","comments":true,"path":"2018/09/25/Webpack-基础使用/","link":"","permalink":"http://yoursite.com/2018/09/25/Webpack-基础使用/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 安装使用npm或者yarn来安装webpack 全局安装12345$ npm i webpack webpack-cli -gor$ yarn -g add webpack webpack-cli 等待安装完毕，就可以全局执行webpack命令了。注：webpack-cli在4.x版本之后不再作为webpack的依赖了，我们使用时需要单独安装。 局部安装在项目中，我们更推荐将webpack作为项目的开发依赖来安装使用，这样可以指定项目中使用的webpack版本。 12345$ npm i webpack webpack-cli -Dor$ yarn add webpack webpack-cli -D 等待安装完毕，webpack会出现在项目的package.json文件中，我们添加一个npm scripts: 1234567&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --mode production&quot;&#125;,&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.1.1&quot;, &quot;webpack-cli&quot;: &quot;^2.0.12&quot;,&#125; 项目根目录新建./src/index.js，任意写JS代码，保存，执行npm run build或者yarn build命令，我们会发现项目根目录下新增了一个dist目录，里面存放了webpack构建好的main.js文件。 webpack4.x可以零配置就开始构建，但有时我们的项目需要更多的功能。 基本概念先放一张经典图： 入口如上图左上角的.js，这个.js就是多个代码模块的入口，也是webpack构建的入口。webpack会读取这个文件，并从它开始解析依赖，然后进行打包。 在我们的项目中，如果是单页应用，那么可能入口只有一个。如果是多页应用，那么经常是一个页面对应一个构建入口。 用法：entry 单个入口语法12345678910// 简写module.exports = &#123; entry: &apos;./src/index&apos;&#125;module.exports = &#123; entry: &#123; main: &apos;./src/index&apos; &#125;&#125; 多个入口语法123456module.exports = &#123; entry: &#123; foo: &apos;./src/foo&apos;, bar: &apos;./src/bar&apos; &#125;&#125; 输出输出即指webpack最终构建出来的静态文件，构建结果的文件名，路径等都是可以配置的。 用法：output 12345678910111213141516171819202122module.exports = &#123; output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125;// 多个入口生成不同的文件module.exports = &#123; output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].js&apos; &#125;&#125;// 路径中使用hash，每次构建都有一个不同的hash值，避免发布新版本使用浏览器缓存module.exports = &#123; output: &#123; path: path.resolve(__dirname, &apos;dist/[hash]&apos;), filename: &apos;[name].js&apos; &#125;&#125; loaderloader，我们可以理解为一个转换器，负责把某种文件格式的内容转换成webpack可以支持打包的模块。 默认情况下，webpack会默认把所有依赖打包成JS文件，如果入口文件依赖一个.pug模块文件或者.scss样式文件，那么我们就需要相应的loader来把不同格式的文件转换为JavaScript，以便打包后在浏览器运行。 用法：module.rules 12345678910111213module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.jsx?/, // 条件 include: [ path.resolve(__dirname, &apos;src&apos;) ], // 条件 use: &apos;babel-loader&apos; // 规则应用结果 &#125; // 一个Object即一条规则 ] &#125;&#125; loader匹配规则中最重要的两个因素：匹配条件和匹配规则后的应用。 规则条件配置匹配条件通常使用请求资源文件的绝对路径来进行匹配，官方文档成为resource。 上述代码中的test和include都用于匹配resource路径，是resource.test和resource.include的简写。你也可以这样写： 123456789101112131415module.exports = &#123; // ... rules: [ &#123; resource: &#123; // resource 的匹配条件 test: /\\.jsx?/, include: [ path.resolve(__dirname, &apos;src&apos;), ] &#125;, use: &apos;babel-loader&apos; &#125;, // ... ],&#125; webpack为loader提供了多种匹配条件的配置方式： test: … 匹配特定条件 include: … 匹配特定路径 exclude: … 排除特定路径 and: [] 必须匹配数组中的所有条件 or: [] 匹配数组中的任意一个条件 not: [] 排除匹配数组中的所有条件 条件值类型： 字符串：必须以提供的字符串开始（绝对路径） 正则表达式 数组：至少包含一个条件的数组 对象：匹配所有属性值的条件 函数：返回true表示匹配 规则应用配置匹配规则后的应用，我们可以使用use字段： 1234567891011121314151617181920rules: [ &#123; test: /\\.less/, use: [ &apos;style-loader&apos;, &#123; loader: &apos;css-loader&apos;, options: &#123; // ... &#125; &#125;, &#123; loader: &apos;less-loader&apos;, options: &#123; // ... &#125; &#125; ] &#125;] 使用options可以给对应的loader传递一些配置项。 对于上述的less规则应用配置，一个less模块文件可以经过多个loader的转换处理，执行顺序为从右到左。 如果多个rule匹配了同一个模块文件，loader的应用顺序应该如何处理？ 12345678910rules: [ &#123; test: /\\.js$/, loader: &quot;eslint-loader&quot;, &#125;, &#123; test: /\\.js$/, loader: &quot;babel-loader&quot;, &#125;] eslint-loader用于检查人工编写的代码，babel-loader用于转换代码。所以，eslint-loader应该在babel-loader之前执行，那么该如何保证执行顺序？ webpack为每一个匹配规则提供了enforce字段来配置当前rule得的loader类型。pre(前置) &gt; 行内 &gt; 普通 &gt; 后置(post)。 我们要确保eslint-loader在babel-loader之前执行，只需给rule规则项添加enforce字段，并设置其值为pre。 1234567891011rules: [ &#123; enforce: &apos;pre&apos;, test: /\\.js$/, loader: &quot;eslint-loader&quot;, &#125;, &#123; test: /\\.js$/, loader: &quot;babel-loader&quot;, &#125;] 常用rule配置项CSS123456789101112131415161718192021const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: &apos;css-loader&apos;, &#125;) &#125; ] &#125;, plugins: [ // 引入插件，配置文件名，这里同样可以使用 [hash] new ExtractTextPlugin(&apos;[name].css&apos;), ],&#125; css-loader：负责解析CSS代码，主要处理CSS中的依赖，🌰：@import、url()等。 style-loader：将css-loader解析的结果转变为JS代码，运行时动态插入style标签来让CSS生效。 预处理器12345678910111213141516171819module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.less/, // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [&apos;css-loader&apos;, &apos;less-loader&apos;], &#125;) &#125; ] &#125;, plugins: [ // 引入插件，配置文件名，这里同样可以使用 [hash] new ExtractTextPlugin(&apos;[name].css&apos;) ]&#125; 图片webpack无法处理图片格式，我们选择file-loader，它不仅可以处理图片格式，还可用于处理其它很多类型的文件。直接输出文件，将构建后的文件路径返回。 1234567891011module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: &apos;file-loader&apos; &#125; ] &#125;&#125; BabelBabel是一个让我们能够使用ES6、ES7等新标准来编写JS的编译工具。 1234567891011module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.jsx?/, loader: &apos;babel-loader&apos; &#125; ] &#125;&#125; plugin插件是webpack的支柱功能，在于解决loader无法实现的其他事情。 用法：plugin 12345const UglifyPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)module.exports = &#123; plugins: [new UglifyPlugin()]&#125; 常见webpack plugin使用HtmlWebpackPluginwebpack默认从作为入口的JS文件进行构建，但通常一个前端项目都是从一个页面(HTML)出发的。通常我们会创建一个HTML文件，使用script标签直接引入构建好的js文件。 1&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt; 然而，问题来了，如果我们的文件名或者路径变化，每次构建完成后，我们要手动去修改HTML文件中的js路径? 如果能将HTML引用路径和我们的webpack构建结果关联起来就好了。 html-webpack-plugin就可以帮我们解决这个问题。 12345npm i html-webpack-plugin -Doryarn add html-webpack-plugin -D 然后在webpack配置中，将html-webpack-plugin添加到plugins列表中： 12345678const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(), ],&#125; 配置好之后，构建时html-webpack-plugin会为我们创建一个HTML文件，其中会引用构建出来的JS文件。 我们还可以在html-webpack-plugin中传递我们自己写好的HTML模板： 1234567891011const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(&#123; filename: &quot;index.html&quot;, template: &quot;assets/index.html&quot; &#125;), ],&#125; DefinePluginDefinePlugin是webpack的内置插件，可以通过webpack.DefinePlugin直接引用。 主要用于创建一些在编译时可以配置的全局变量。 12345678910111213module.exports = &#123; // ... plugins: [ new webpack.DefinePlugin(&#123; VERSION: JSON.stringfy(&apos;v1.1.0&apos;), // const VERSION = &apos;v1.1.0&apos; TWO: &apos;1 + 1&apos;, // const TWO = 2 BROWSER_SUPPORT: true, // const BROWSER_SUPPORT = &apos;true&apos; CONSTANTS: &#123; APP_VERSION: JSON.stringfy(&apos;1.1.1&apos;) &#125; // const CONSTANTS = &#123; APP_VERSION: &apos;1.1.1&apos;&#125; &#125;) ]&#125; 配置好之后，我们就可以在应用代码中，访问配置好的变量了。 1console.log(VERSION) 有关配置的值，简述一下配置规则： 如果配置的值为字符串，那么整个字符串会被当做代码片段来执行，其结果将作为最终配置的值。 如果配置的值不是字符串，也不是对象字面量，那么该值会被转换为一个字符串。 如果配置的值是一个对象字面量，那么该对象的所有key会以同样的方式去定义。 CopyWebpackPlugin通常我们会把源码和资源文件放在项目的src目录下，构建完成后会有一个dist目录，我们会直接拿dist目录中的所有文件来发布。有些文件没有经过webpack处理，但是我们希望它们也能出现在dist目录下，这时，我们就可以使用CopyWebpackPlugin来处理。 12345678910const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new CopyWebpackPlugin([ &#123; from: &apos;src/*.txt&apos;, to: &apos;dist/*.txt&apos; &#125; // from: 配置来源；to: 配置目标 ]) ]&#125; ExtractTextWebpackPlugin通常CSS经过相应的loader处理后，会转换为JS，和index.js一起打包。如果需要单独把CSS文件分离出来，就需要使用extract-text-webpack-plugin插件。 1234567891011121314151617181920const ExtractTextWebpackPlugin = require(&apos;extract-text-webpack-plugin&apos;)module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: &apos;css-loader&apos; &#125;) &#125; ] &#125;, plugins: [ // style.css 作为单独分离出来的文件名 new ExtractTextWebpackPlugin(&apos;style.css&apos;) ]&#125; 它还可以为每一个入口创建单独分离的文件，所以，最好这样配置： 123plugins: [ new ExtractTextPlugin(&apos;[name].css&apos;),] ProvidePluginProvidePlugin是webpack的内置插件，可以通过webpack.ProvidePlugin直接引用。 主要用于自动加载模块，不必到处import或require 1234567891011new webpack.ProvidePlugin(&#123; identifier: &apos;module&apos;, // ...&#125;)ornew webpack.ProvidePlugin(&#123; identifier: [&apos;module&apos;, &apos;property&apos;], // 即引用 module 下的 property，类似 import &#123; property &#125; from &apos;module&apos; // ...&#125;) 任何时候，当identifier被当作未赋值的变量时，module就会自动被加载，并且identifier会被这个module输出的内容所赋值。 注：如果是ES的default export，那么你需要指定模块的default属性：identifier: [‘module’, ‘default’]。 IgnorePluginIgnorePlugin是webpack的内置插件，可以通过webpack.IgnorePlugin直接引用。 主要用于忽略某些特定的模块，让webpack不把这些指定的模块打包进去。 配置参数：匹配引入模块路径的正则表达式，匹配模块的上下文。 123456module.exports = &#123; // ... plugins: [ new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) ]&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"小程序-全栈开发(mpvue+koa2+mysql)","slug":"小程序-全栈开发(mpvue+koa2+mysql)","date":"2017-09-02T08:06:52.000Z","updated":"2019-06-17T03:49:28.575Z","comments":true,"path":"2017/09/02/小程序-全栈开发(mpvue+koa2+mysql)/","link":"","permalink":"http://yoursite.com/2017/09/02/小程序-全栈开发(mpvue+koa2+mysql)/","excerpt":"导语 接触小程序并做了一些项目之后，又开始了Vue的旅程，受其核心思想的影响，对数据/状态管理、组件化、跨平台等都有较高的追求，mpvue 是一个使用 Vue.js开发小程序的前端框架，由此开始了mpvue踩坑之旅，想在提高代码可读性的同时，也增加一点Vue.js的开发体验。","text":"导语 接触小程序并做了一些项目之后，又开始了Vue的旅程，受其核心思想的影响，对数据/状态管理、组件化、跨平台等都有较高的追求，mpvue 是一个使用 Vue.js开发小程序的前端框架，由此开始了mpvue踩坑之旅，想在提高代码可读性的同时，也增加一点Vue.js的开发体验。 技术栈 前端： 微信小程序、mpvue、 eslint、sass、ES6、ES7后端：koa2、Koa-Router、Knex、腾讯云Wafer2数据库：Mysql数据库可视化工具：Navicate Premium 小程序介绍一个功能简单的小程序，包含了个人中心、图书列表、个人评论列表三个tab页，后端的数据定义、分类、和存取等，各有其色。 成果分享个人中心： 个人中心： 图书列表： 图书详情： 评论列表： 脑图 初始化项目*全局安装vue-cli $npm install –global vue-cli *创建基于mpvue-quickstart模板的新项目，一路回车。 $vue init mpvue/mpvue-quickstart koa-wx *安装依赖 $cd koa-wx $npm install $npm run dev 项目目录123456789101112131415161718192021222324252627282930313233343536373839404142├── build // 构建相关 ├── config // 配置相关├── dist // 编译后静态文件 ├── node_modules // 依赖相关├── server // 服务端源代码│ ├── controllers │ ├── middlewares │ ├── node_modules │ ├── routes │ ├── tools │ ├── .eslintrc.js │ ├── .eslintrc.json │ ├── app.js │ ├── config.js │ ├── nodemon.json │ ├── package.json │ ├── process.prod.json │ ├── qcloud.js │ ├── README.md │ ├── tools.md ├── src // 前端源代码│ ├── components │ ├── config │ ├── mock │ ├── pages │ ├── styles │ ├── utils │ ├── App.vue │ ├── main.js │ ├── store.js │ ├── weui.css ├── static ├── .babelrc ├── .editorconfig ├── .eslintignore ├── .eslintrc.js ├── .postcssrc.js ├── index.html └── package.json └── package-lock.json └── project.config.json └── README.md 搭建后端本地开发环境打开 server/config.js添加以下配置： 123456789101112const CONF = &#123; // 其他配置 ... serverHost: &apos;localhost&apos;, tunnelServerUrl: &apos;&apos;, tunnelSignatureKey: &apos;27fb7d1c161b7ca52d73cce0f1d833f9f5b5ec89&apos;, // 腾讯云相关配置可以查看云 API 秘钥控制台：https://console.cloud.tencent.com/capi qcloudAppId: &apos;您的腾讯云 AppID&apos;, qcloudSecretId: &apos;您的腾讯云 SecretId&apos;, qcloudSecretKey: &apos;您的腾讯云 SecretKey&apos;, wxMessageToken: &apos;weixinmsgtoken&apos;, networkTimeout: 30000&#125; 并修改 MySQL 相关的配置为本地的 MySQL 数据库。 12345678mysql: &#123; host: &apos;localhost&apos;, port: 3306, user: &apos;root&apos;, db: &apos;cAuth&apos;, pass: &apos;******&apos;, char: &apos;utf8mb4&apos; &#125;, *切换到服务端代码目录$cd server *安装依赖$npm install *安装全局依赖$npm install -g nodemon $npm run dev 初始化数据库 - 打开 terminal 输入如下命令： $node tools/initdb.js 进入Mysql选中刚才创建的数据库，输入 show tables; 可以看到初始化时创建了一个名叫 cSessionInfo 的表。说明本地环境已经搭建成功。 部署到腾讯云环境当本地本地开发出一版时，可以部署到腾讯云的开发环境，这样就可以在线上访问该项目。 首先修改项目根目录的 project.config.json 文件，添加： 1&quot;qcloudRoot&quot;: &quot;./server/&quot;, 然后将本地开发时添加到 server/config.js 的配置删除，在 mysql.pass 那里填上自己的 APPID。 接着进入小程序开发工具，点击右上角的 腾讯云，上传测试代码，弹出如图选项。第一次部署如下选择，之后再次上传选择 智能上传 即可。部署成功会有提示。 ###上传前端代码 在小程序开发工具右上角找到 上传 选项，填写版本信息，上传后进入开发者控制台，开发管理页面，将该小程序设置为体验版本。 然后在用户身份 ==&gt; 成员管理中，添加项目成员，配置权限，这样好友也可以体验该小程序了。 项目地址：https://github.com/wangqian2017/mpvue-koa2","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"Vue-小技巧总结[转]","slug":"Vue-小技巧总结","date":"2017-07-03T09:41:00.000Z","updated":"2019-06-17T03:49:28.572Z","comments":true,"path":"2017/07/03/Vue-小技巧总结/","link":"","permalink":"http://yoursite.com/2017/07/03/Vue-小技巧总结/","excerpt":"导语 这篇文章主要是为了将开发过程中知道的一些小技巧进行总结，帮助使用Vue开发的小伙伴们愉快地采坑。","text":"导语 这篇文章主要是为了将开发过程中知道的一些小技巧进行总结，帮助使用Vue开发的小伙伴们愉快地采坑。 前端在开发移动端webapp还原设计稿的重要性母庸质疑，目前来说应用最多的应该是rem。然而很多前端开发依然选择要么自己去计算rem值，要么依靠编辑器安装插件转换。其实，通过一系列的配置后，我们在开发中可以直接使用设计图的尺寸，它为我们自动编译，转换成rem。 技术栈 vue-cli@3.0: 脚手架工具创建项目 postcss-pxtorem: 转换px为rem的依赖包 只需以下几步，就可以愉快地开发了😊。 创建rem.js文件123456789101112131415// 基准大小const baseSize = 32// 设置 rem 函数function setRem() &#123; // 当前页面宽度相对于 750 宽的缩放比例，可根据自己需要修改。 const scale = document.documentElement.clientWidth / 750 // 设置页面根节点字体大小 document.documentElement.style.fontSize = baseSize * Math.min(scale, 2) + &apos;px&apos;&#125;// 初始化setRem()// 改变窗口大小时重新设置 remwindow.onresize = function() &#123; setRem()&#125; main.js中引入rem.js1import &apos;./utils/rem&apos; 引入文件后，可以看到页面的html节点，被自动添加 font-size 安装并配置postcss-pxtoren安装postcss-pxtorem1$ npm install postcss-pxtorem -D 修改跟目录postcss.config.js12345678910111213141516171819202122module.exports = &#123; plugins: &#123; autoprefixer: &#123; browsers: [&apos;Android &gt;= 4.0&apos;, &apos;iOS &gt;= 7&apos;] &#125;, &apos;postcss-pxtorem&apos;: &#123; rootValue: 32, // The root element font size propList: [&apos;*&apos;], // The properties that can change from px to rem. minPixelValue: 20, // Set the minimum pixel value to replace. selectorBlackList: [ &apos;.weui-&apos;, &apos;.ig-&apos;, &apos;.vux-&apos;, &apos;.scroller-&apos;, &apos;.dp-&apos;, &apos;.mt-&apos;, &apos;.mint-&apos;, &apos;.range&apos; ] // The selectors to ignore and leave as px. &#125; &#125;&#125; 按上述完成配置后，即可在开发中直接使用px单位开发。 举个🌰： 123body &#123; width: 750px;&#125; 转换后： 123body &#123; width: 23.4375rem;&#125; 组件实例style的scoped场景：在组件中用js动态创建的dom，添加样式不生效 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; let a = document.querySelector(&apos;test&apos;) let newDom = document.createElement(&apos;div&apos;) newDom.setAttribute(&apos;class&apos;, &apos;testAdd&apos;) a.appendChild(newDom)&lt;/script&gt;&lt;style scoped&gt; .test&#123; background:blue; height:100px; width:100px; &#125; .testAdd&#123; background:red; height:100px; width:100px; &#125;&lt;/style&gt; 结果： 1234567// test生效 testAdd 不生效&lt;div data-v-1b971ada class=&quot;test&quot;&gt;&lt;div class=&quot;testAdd&quot;&gt;&lt;/div&gt;&lt;/div&gt;.test[data-v-1b971ada] &#123; // 注意data-v-1b971ada background:blue; height:100px; width:100px;&#125; 原因: 当 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素。它会为组件中所有的标签和class样式添加一个scoped标识，就像上面结果中的data-v-1b971ada。所以原因就很清楚了：因为动态添加的dom没有scoped添加的标识，没有跟testAdd的样式匹配起来，导致样式失效。 解决方式： 去掉该组件的scoped 动态添加style 123newDom.style.height=&apos;100px&apos;;newDom.style.width=&apos;100px&apos;;newDom.style.background=&apos;red&apos;; Vue 数组/对象更新 视图不更新123456789101112131415161718data() &#123; // data数据 return &#123; arr: [1,2,3], obj:&#123; a: 1, b: 2 &#125; &#125;; &#125;, // 数据更新 数组视图不更新 this.arr[0] = &apos;OBKoro1&apos;; this.arr.length = 1; console.log(arr);// [&apos;OBKoro1&apos;]; // 数据更新 对象视图不更新 this.obj.c = &apos;OBKoro1&apos;; delete this.obj.a; console.log(obj); // &#123;b:2,c:&apos;OBKoro1&apos;&#125;&#125; 由于js的限制，Vue 不能检测以上数组的变动，以及对象的添加/删除，很多人会因为像上面这样操作，出现视图没有更新的问题。 解决方式： this.$set(array)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"JS-精心收集的48个JavaScript代码片段","slug":"JS-精心收集的48个JavaScript代码片段","date":"2017-05-11T13:06:52.000Z","updated":"2019-06-17T03:49:28.571Z","comments":true,"path":"2017/05/11/JS-精心收集的48个JavaScript代码片段/","link":"","permalink":"http://yoursite.com/2017/05/11/JS-精心收集的48个JavaScript代码片段/","excerpt":"导语 该文章摘自Github用户Chalarangelo，目前已在Github上获得了5K多个star，精心收集了多达48个有用的JavaScript代码片段。","text":"导语 该文章摘自Github用户Chalarangelo，目前已在Github上获得了5K多个star，精心收集了多达48个有用的JavaScript代码片段。 Anagrams of string(带有重复项)使用递归，对于给定字符串中的每个字母，为字母创建字谜。使用map()将字母与每部分字谜结合，然后使用reduce()将所有字谜组合到一个数据中，最基本情况是字符串长度等于2或1。 123456const anagrams = str =&gt; &#123; if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str]; return str.split(&apos;&apos;).reduce((acc, letter, i) =&gt; &#123; acc.concat(anagrams(str.slice(0, 1) + str.slice(i + 1)).map(val =&gt; letter + val))&#125;, []);&#125;;// anagrams(&apos;abc&apos;) -&gt; [&apos;abc&apos;,&apos;acb&apos;,&apos;bac&apos;,&apos;bca&apos;,&apos;cab&apos;,&apos;cba&apos;] 数组平均值使用reduce()将每个值添加到累加器，初始值为0，总和除以数组长度。 12const average = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;// avarage([1, 2, 3]) -&gt; 2 大写每个单词的首字母使用replace()匹配每个单词的第一个字符，并使用toUpperCase()来将其大写。 12const capitalizeEveryWord = str =&gt; str.replace(/\\b[a-z]/g, char =&gt; char.toUpperCase());// capitalizeEveryWord(&apos;hello world!&apos;) -&gt; &apos;Hello World!&apos; 首字母大写使用slice (0,1)和toUpperCase ()大写第一个字母，slice (1)获取字符串的其余部分。省略lowerRest参数以保持字符串的其余部分不变，或将其设置为true以转换为小写。(注：这和上一示例不是同一件事情) 1234const capitalize = (str, lowerRest = false) =&gt; &#123; str.slice(0, 1).toUpperCase() + (lowerRest ? str.slice(1).toLowerCase() : str.slice(1));&#125;// capitalize(&apos;myName&apos;, true) -&gt; &apos;Myname&apos; 检查回文将字符串转换为toLowerCase ()，并使用replace ()从中删除非字母的字符串。然后，将其转换为toLowerCase ()，将(‘’)拆分为单独字符，reverse ()，join (‘’)，与原始的非反转字符串进行比较，然后将其转换为toLowerCase ()。 12345const palindrome = str =&gt; &#123; const s = str.toLowerCase().replace(/[\\W_]/g, &apos;&apos;); return s === s.split(&apos;&apos;).reverse().join(&apos;&apos;);&#125;// palindrome(&apos;taco cat&apos;) -&gt; true 计算数组中值的出现次数每次遇到数组中的特别值时，使用reduce()来递增计数器。 12const countOccurrences = (arr, value) =&gt; arr.reduce((a, v) =&gt; v === value ? a + 1:a + 0, 0);// countOccurrences([1, 1, 2, 1, 2, 3], 1) -&gt; 3 当前URL使用windows.location.href来获取当前URL。 12const currentUrl = () =&gt; return window.location.href;// currentUrl() -&gt; &apos;https://google.com&apos; Curry使用递归。如果提供的参数(args)数量足够，则调用传递函数f，否则返回一个curried函数f。 12345const curry = (fn, arity = fn.length, ...args) =&gt; &#123; arity &lt;= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);&#125;// curry(Math.pow)(2)(10) -&gt; 1024// curry(Math.min, 3)(10)(50)(2) -&gt; 2 Deep flatten array使用递归，使用reduce()来获取所有不是数组的元素，flatten每个元素都是数组。 1234const deepFlatten = arr =&gt; &#123; arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? deepFlatten(v) : v), []);&#125;// deepFlatten([1, [2], [[3], 4], 5]) -&gt; [1, 2, 3, 4, 5] 数组之间的区别从b创建一个Set，然后在a上使用Array.filter()，只保留b中不包含的值。 12345const difference = (a, b) =&gt; &#123; const s = new Set(b); return a.filter(x =&gt; !s.has(x))&#125;// difference([1, 2, 3], [1, 2]) -&gt; [3] 两点之间的距离使用Math.hypot()计算两点之间的欧几里德距离。 12const distance = (x0, y0, x1, y1) =&gt; Math.hypot(x1 - x0, y1 - y0);// distance(1,1, 2,3) -&gt; 2.23606797749979 可以按数字整除使用模运算符(%)来检查余数是否等于0。 12const isDivisible = (dividend, divisor) =&gt; dividend % divisor === 0;// isDivisible(6, 3) -&gt; true 转义正则表达式使用replace()来转义特殊字符。 12const escapeRegExp = str =&gt; str.replace(/[.*+?^$&#123;&#125;()|[\\]\\\\]/g, &apos;\\\\$&amp;&apos;);// escapeRegExp(&apos;(test)&apos;) -&gt; \\\\(test\\\\) 偶数或奇数使用Math.abs()将逻辑扩展为负数，使用模(%)运算符进行检查。如果数字是偶数，则返回true；如果数字是奇数，则返回false。 12const isEven = num =&gt; Math.abs(num) % 2 === 0;// isEven(3) -&gt; false 阶乘使用递归。如果n小于或等于1，则返回1。否则返回n和n-1的阶乘的乘积。 12const factorial = n =&gt; n &lt;=1 ? 1 : n * factorial(n - 1);// factorial(6) -&gt; 720 斐波那契数组生成器创建一个特定长度的空数组，初始化前两个值(0和1)。使用Array.reduce()向数组中添加值，后面的一个数等于前面两个数相加之和(前两个除外)。 123const fibonacci = n =&gt; Array(n).fill(0).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []);// fibonacci(5) -&gt; [0,1,1,2,3] 过滤数组中的非唯一值将Array.filter() 用于仅包含唯一值得数组。 12const filterNonUnique = arr =&gt; arr.filter(i =&gt; arr.indexOf(i) === arr.lastIndexOf(i));// filterNonUnique([1, 2, 3, 2, 4, 4, 5]) -&gt; [1, 3, 5] Flatten数组使用reduce()来获取数组中的所有元素，并使用concat()来使它们flatten。 12const flatten = arr =&gt; arr.reduce((a, v) =&gt; a.concat(v), []);// flatten([1,[2],3,4]) -&gt; [1,2,3,4] 从数组中获取最大值用Math.max()与spread运算符(…)结合得到数组中的最大值。 12const arrayMax = arr =&gt; Math.max(...arr);// arrayMax([10, 1, 5]) -&gt; 10 从数组中获取最小值使用Math.min()与spread运算符(…)结合得到数组中的最小值。 12const arrayMin = arr =&gt; Math.min(...arr);// arrayMin([10, 1, 5]) -&gt; 1 获取滚动位置如果已定义，请使用pageXOffset和pageYOffset，否则使用scrollLeft和scrollTop，可以省略el来使用window的默认值。 1234const getScrollPos = (el = window) =&gt; (&#123;x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft, y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop&#125;);// getScrollPos() -&gt; &#123;x: 0, y: 200&#125; 最大公约数(GCD)使用递归。基本情况是当y等于0时。在这种情况下，返回x。否则，返回y的GCD和x / y的其余部分。 12const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y);// gcd (8, 36) -&gt; 4 Head of list返回ARR[0] 12const head = arr =&gt; arr[0];// head([1,2,3]) -&gt; 1 list初始化返回arr.slice(0，-1) 12const initial = arr =&gt; arr.slice(0, -1);// initial([1,2,3]) -&gt; [1,2] 用range初始化数组使用Array(end-start)创建所需长度的数组，使用map()来填充范围内的所需值 123const initializeArrayRange = (end, start = 0) =&gt; Array.apply(null, Array(end - start)).map((v, i) =&gt; i + start);// initializeArrayRange(5) -&gt; [0,1,2,3,4] 用值初始化数组使用Array(n)创建所需长度的数组，fill(v)以填充所需的值，可以忽略value使用默认值0。 12const initializeArray = (n, value = 0) =&gt; Array(n).fill(value);// initializeArray(5, 2) -&gt; [2,2,2,2,2] 列表的最后返回arr.slice(-1)[0] 12const last = arr =&gt; arr.slice(-1)[0];// last([1,2,3]) -&gt; 3 测试功能所花费的时间使用performance.now()获取函数的开始和结束时间，console.log()所花费的时间。第一个参数是函数名，随后的参数传递给函数。 12345678const timeTaken = callback =&gt; &#123; console.time(&apos;timeTaken&apos;); const r = callback(); console.timeEnd(&apos;timeTaken&apos;); return r;&#125;;// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024// (logged): timeTaken: 0.02099609375ms 来自键值对的对象使用Array.reduce()来创建和组合键值对。 12const objectFromPairs = arr.reduce((a, v) =&gt; (a[v[0]] =v[1], a), &#123;&#125;);// objectFromPairs([[&apos;a&apos;,1],[&apos;b&apos;,2]]) -&gt; &#123;a: 1, b: 2&#125; 管道使用Array.reduce()通过函数传递值。 12const pipe = (...funcs) =&gt; arg =&gt; funcs.reduce((acc, func) =&gt; func(acc), arg);// pipe(btoa, x =&gt; x.toUpperCase())(&quot;Test&quot;) -&gt; &quot;VGVZDA==&quot; Powerset使用reduce()与map()结合来遍历元素，并将其组合成包含所有组合的数组。 12const powerset = arr =&gt; arr.reduce((a, v) =&gt; a.concat(a.map(r =&gt; [v].concat(r))), [[]]);// powerset([1,2]) -&gt; [[], [1], [2], [2,1]] 范围内的随机整数使用Math.random()生成一个随机数并将其映射到所需的范围，使用Math.floor()使其成为一个整数。 12const randomIntegerInRange = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min;// randomIntegerInRange(0, 5) -&gt; 2 范围内的随机数使用Math.random()生成一个随机值，使用乘法将其映射到所需的范围。 12const randomInRange = (min, max) =&gt; Math.random() * (max - min) + min;// randomInRange(2,10) -&gt; 6.0211363285087005 随机化数组的顺序使用sort()重新排序元素，使用Math.random()来随机排序。 12const shuffle = arr =&gt; arr.sort(() =&gt; Math.random() - 0.5);// shuffle([1,2,3]) -&gt; [2,3,1] 重定向到URL使用window.location.href或window.location.replace()重定向到url。传递第二个参数来模拟链接点击(true-default)或HTTP重定向(false)。 12const redirect = (url, asLink = true) =&gt; asLink ? window.location.href = url : window.location.replace(url);// redirect(&apos;https://google.com&apos;) 反转一个字符串使用数组解构和Array.reverse()来颠倒字符串中的字符顺序。合并字符以使用join(‘’)获取字符串。 12const reverseString = str =&gt; [...str].reverse().join(&apos;&apos;);// reverseString(&apos;foobar&apos;) -&gt; &apos;raboof&apos; RGB到十六进制使用按位左移运算符(&lt;&lt;)和toString(16)，然后padStart(6，“0”)将给定的RGB参数转换为十六进制字符串以获得6位十六进制值。 12const rgbToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, &apos;0&apos;);// rgbToHex(255, 165, 1) -&gt; &apos;ffa501&apos; 滚动到顶部使用document.documentElement.scrollTop或document.body.scrollTop获取到顶部的距离。从顶部滚动一小部分距离。 使用window.requestAnimationFrame()来滚动。 12345678const scrollToTop = _ =&gt; &#123;const c = document.documentElement.scrollTop || document.body.scrollTop; if (c &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, c - c / 8); &#125;&#125;;// scrollToTop() 随机数组值使用Array.map()和Math.random()创建一个随机值的数组。使用Array.sort()根据随机值对原始数组的元素进行排序。 12345const shuffle = arr =&gt; &#123;let r = arr.map(Math.random);return arr.sort((a,b) =&gt; r[a] - r[b]);&#125;// shuffle([1, 2, 3]) -&gt; [2, 1, 3] 数组之间的相似性使用filter()移除不是values的一部分值，使用includes()确定。 12const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v));// similarity([1,2,3], [1,2,4]) -&gt; [1,2] 按字符串排序(按字母顺序排序)使用split(‘’)分割字符串，sort()使用localeCompare()，使用join(‘’)重新组合。 12const sortCharactersInString = str =&gt; str.split(&apos;&apos;).sort((a, b) =&gt; a.localeCompare(b)).join(&apos;&apos;);// sortCharactersInString(&apos;cabbage&apos;) -&gt; &apos;aabbceg&apos; 数组总和使用reduce()将每个值添加到累加器，初始化值为0。 12const sum = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0);// sum([1,2,3,4]) -&gt; 10 交换两个变量的值使用数组解构来交换两个变量之间的值。 12[varA, varB] = [varB, varA]// [x, y] = [y, x] 列表的tail返回arr.slice(1)。 123const tail = arr =&gt; arr.length &gt; 1 ? arr.slice(1) : arr;// tail([1,2,3]) -&gt; [2,3]// tail([1]) -&gt; [1] 数组唯一值使用ES6 Set和…rest操作符去掉所有重复值。 12const unique = arr =&gt; [...new Set(arr)];// unique([1, 2, 2, 3, 4, 4, 5]) -&gt; [1, 2, 3, 4, 5] URL参数使用match()与适当的正则表达式来获得所有键值对，适当的map()。使用Object.assign()和spread运算符(…)将所有键值对组合到一个对象中，将location.search()作为参数传递给当前url。 12const getUrlParameters = url =&gt; url.match(/([^?=&amp;]+)(=([^&amp;]*))/g).reduce((a, v) =&gt; (a[v.slice(0, v.indexOf(&apos;=&apos;))] = v.slice(v.indexOf(&apos;=&apos;) + 1), a), &#123;&#125;);// getUrlParameters(&apos;http://url.com/page?name=Adam&amp;surname=Smith&apos;) -&gt; &#123;name: &apos;Adam&apos;, surname: &apos;Smith&apos;&#125; UUID生成器使用crypto API生成符合RFC4122版本4的UUID。 12const uuid = _ =&gt; ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt; (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16));// uuid() -&gt; &apos;7982fcfe-5721-4632-bede-6000885be57d&apos; 验证数字使用！isNaN和parseFloat（）来检查参数是否是一个数字，使用isFinite（）来检查数字是否是有限的。 12const validateNumber = n =&gt; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n) &amp;&amp; Number(n) == n;// validateNumber(&apos;10&apos;) -&gt; true","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]}
