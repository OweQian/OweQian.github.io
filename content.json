{"meta":{"title":"W | 个人博客 | web前端","subtitle":"wangxiaobai","description":"前端","author":"wangxiaobai","url":"http://qiandream.cn"},"pages":[{"title":"categories","date":"2018-04-11T08:28:54.000Z","updated":"2018-04-11T08:29:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://qiandream.cn/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-02-07T14:06:57.630Z","comments":true,"path":"friends/index.html","permalink":"http://qiandream.cn/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-11T08:28:32.000Z","updated":"2018-04-11T08:28:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://qiandream.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Webpack-Webpack系列之简介","slug":"Webpack-Webpack系列之简介","date":"2020-01-14T07:21:00.000Z","updated":"2020-02-07T03:56:32.065Z","comments":true,"path":"2020/01/14/webpack-webpack-xi-lie-zhi-jian-jie/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-jian-jie/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 Webpack 简介Webpack是什么Webpack是一个开源的JavaScript模块打包工具，其最核心的功能是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个JS文件（有时会有多个，这里讨论的只是最基本的情况）。 模块打包工具模块打包工具（module bundler）的任务就是解决模块间的依赖，使其打包后的结果能运行在浏览器上。它的工作方式主要分为两种 将存在依赖关系的模块按照特定规则合并为单个JS文件，一次全部加载进页面中。 在页面初始时加载一个入口模块，其他模块异步地进行加载。 Webpack 优势 默认支持多种模块标准，包括AMD、CommonJS，以及最新的ES6模块。 完备的代码分割（code splitting）解决方案，首屏只加载重要的部分。 可以处理各种类型的资源。除了JavaScript以外，Webpack还可以处理样式、模板，甚至图片等。 拥有庞大的社区支持。 安装使用npm或者yarn来安装webpack 全局安装$ npm i webpack webpack-cli -g or $ yarn -g add webpack webpack-cli 等待安装完毕，就可以全局执行webpack命令了。注：webpack-cli在4.x版本之后不再作为webpack的依赖了，我们使用时需要单独安装。 局部安装在项目中，我们更推荐将webpack作为项目的开发依赖来安装使用，这样可以指定项目中使用的webpack版本。 $ npm i webpack webpack-cli -D or $ yarn add webpack webpack-cli -D 等待安装完毕，webpack会出现在项目的package.json文件中，我们添加一个npm scripts: &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack --mode production&quot; }, &quot;devDependencies&quot;: { &quot;webpack&quot;: &quot;^4.1.1&quot;, &quot;webpack-cli&quot;: &quot;^2.0.12&quot;, } webpack-dev-serverwebpack-dev-server可以看作一个服务者，它的主要工作就是接收浏览器的请求，然后将资源返回。当服务启动时，会先让Webpack进行模块打包并将资源准备好（在示例中就是bundle.js）。当webpack-dev-server接收到浏览器的资源请求时，它会首先进行URL地址校验。如果该地址是资源服务地址（上面配置的publicPath），就会从Webpack的打包结果中寻找该资源并返回给浏览器。反之，如果请求地址不属于资源服务地址，则直接读取硬盘中的源文件并将其返回。 $ npm i webpack-dev-server -D 为了便捷地启动webpack-dev-server，我们在package.json中添加一个dev指令： \"scripts\": { \"build\": \"webpack\", \"dev\": \"webpack-dev-server\" } 最后，我们还需要对webpack-dev-server进行配置。编辑webpack.config.js如下： module.exports = { entry: \"./src/index.js\", output: { filename: \"./bundle.js\" }, mode: \"development\", devServer: { publicPath: \"/dist\" } } 这里有一点需要注意。直接用Webpack开发和使用webpack-dev-server有一个很大的区别，前者每次都会生成budnle.js，而webpack-dev-server只是将打包结果放在内存中，并不会写入实际的bundle.js，在每次webpack-dev-server接收到请求时都只是将内存中的打包结果返回给浏览器。 webpack-dev-server还有一项很便捷的特性就是live-reloading（自动刷新）。 注：关于内容自动更新，webpack-dev-server 与 hot-module-replacement（模块热替换）的区别在于：前者会刷新浏览器，后者不需要刷新浏览器就能获得更新之后的内容。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-Webpack系列之生产环境配置","slug":"Webpack-Webpack系列之生产环境配置","date":"2020-01-14T07:21:00.000Z","updated":"2020-02-09T09:58:39.267Z","comments":true,"path":"2020/01/14/webpack-webpack-xi-lie-zhi-sheng-chan-huan-jing-pei-zhi/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-sheng-chan-huan-jing-pei-zhi/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 生产环境配置在生产环境中我们关注的是如何让用户更快地加载资源，涉及如何压缩资源、如何添加环境变量优化打包、如何最大限度地利用缓存等。 环境配置的封装生产环境的配置与开发环境有所不同，如何让Webpack可以按照不同环境采用不同的配置呢？一般来说有以下两种方式。 使用相同的配置文件 比如令Webpack不管在什么环境下打包都使用webpack.config.js，只是在构建开始前将当前所属环境作为一个变量传进去，然后在webpack.config.js中通过各种判断条件来决定具体使用哪个配置。 // package.json { ... &quot;scripts&quot;: { &quot;dev&quot;: &quot;ENV=development webpack-dev-server&quot;, &quot;build&quot;: &quot;ENV=production webpack&quot; } } // webpack.config.js const ENV = process.env.ENV const isProd = ENV === &#39;production&#39; module.exports = { output: { filename: isProd ? &#39;bundle@[chunkhash].js&#39; : &#39;bundle.js&#39; }, mode: ENV } 为不同环境创建各自的配置文件 比如，我们可以单独创建一个webpack.production.config.js，开发环境的则可以叫webpack.development.config.js。 // package.json { ... &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --config=webpack.development.config.js&quot;, &quot;build&quot;: &quot;webpack --config=webpack.production.config.js&quot; } } 但这种方法存在一个问题，即webpack.development.config.js和webpack.production.config.js肯定会有重复的部分，一改都要改，不利于维护。在这种情况下，可以将公共的配置提取出来，比如我们单独创建一个webpack.common.config.js。 module.exports = { entry: './src/index.js', // development 和 production 共有配置 } 然后让另外两个JS分别引用该文件，并添加上自身环境的配置即可。 开启 production 模式Webpack 4中直接加了一个mode配置项，让开发者可以通过它来直接切换打包模式。如： module.exports = { mode: 'production' } 这意味着当前处于生产环境模式，Webpack会自动添加许多适用于生产环境的配置项，减少了人为手动的工作。 大部分时候仅仅设置mode是不够的，下面我们继续介绍其他与生产环境相关的自定义配置。 环境变量通常我们需要为生产环境和本地环境添加不同的环境变量，在Webpack中可以使用DefinePlugin进行设置。 const webpack = require('webpack') module.exports = { entry: './app.js', output: { filename: 'bundle.js' }, mode: 'production', plugins: [ new webpack.DefinePlugin({ process.env.NODE_ENV: JSON.stringify('production') }) ] } 注：我们在一些值的外面加上了JSON.stringify，这是因为DefinePlugin在替换环境变量时对于字符串类型的值进行的是完全替换。假如不添加JSON.stringify的话，在替换后就会成为变量名，而非字符串值。因此对于字符串环境变量及包含字符串的对象都要加上JSON.stringify才行。 source mapsource map指的是将编译、打包、压缩后的代码映射回源代码的过程。 工作原理Webpack对于工程源代码的每一步处理都有可能会改变代码的位置、结构，甚至是所处文件，因此每一步都需要生成对应的source map。若我们启用了devtool配置项，source map就会跟随源代码一步步被传递，直到生成最后的map文件。这个文件默认就是打包后的文件名加上.map，如bundle.js.map。 当我们打开了浏览器的开发者工具时，map文件会同时被加载，这时浏览器会使用它来对打包后的bundle文件进行解析，分析出源代码的目录结构和内容。 配置JavaScript的source map的配置很简单，只要在webpack.config.js中添加devtool即可。 module.exports = { // ... devtool: 'source-map' } 对于CSS、SCSS、Less来说，则需要添加额外的source map配置项。 const path = require('path') module.exports = { // ... devtool: 'source-map', module: { rules: [ { test: /\\.scss$/, use: [ 'style-loader', { loader: 'css-loader', options: { sourceMap: true } }, { loader: 'sass-loader', options: { sourceMap: true } } ] }] } } Webpack支持多种source map的形式。除了配置为devtool：’source-map’以外，还可以根据不同的需求选择cheap-source-map、eval-source-map等。通常它们都是source map的一些简略版本，因为生成完整的source map会延长整体构建时间，如果对打包速度需求比较高的话，建议选择一个简化版的sourcemap。比如，在开发环境中，cheap-module-eval-source-map通常是一个不错的选择，属于打包速度和源码信息还原程度的一个良好折中。 在生产环境中由于我们会对代码进行压缩，而最常见的压缩插件UglifyjsWebpack-Plugin目前只支持完全的source-map，因此没有那么多选择，我们只能使用source-map、hidden-source-map、nosources-source-map这3者之一。下面介绍一下这3种sourcemap在安全性方面的不同。 安全有了source map也就意味着任何人通过浏览器的开发者工具都可以看到工程源码，对于安全性来说也是极大的隐患。那么如何才能在保持其功能的同时，防止暴露源码给用户呢？Webpack提供了hidden-source-map及nosources-source-map两种策略来提升source map的安全性。 hidden-source-map意味着Webpack仍然会产出完整的map文件，只不过不会在bundle文件中添加对于map文件的引用。这样一来，当打开浏览器的开发者工具时，我们是看不到map文件的，浏览器自然也无法对bundle进行解析。如果我们想要追溯源码，则要利用一些第三方服务，将map文件上传到那上面。目前最流行的解决方案是Sentry。 Sentry是一个错误跟踪平台，开发者接入后可以进行错误的收集和聚类，以便于更好地发现和解决线上问题。Sentry支持JavaScript的source map，我们可以通过它所提供的命令行工具或者Webpack插件来自动上传map文件。同时我们还要在工程代码中添加Sentry对应的工具包，每当JavaScript执行出错时就会上报给Sentry。Sentry在接收到错误后，就会去找对应的map文件进行源码解析，并给出源码中的错误栈。 另一种配置是nosources-source-map，它对于安全性的保护则没那么强，但是使用方式相对简单。打包部署之后，我们可以在浏览器开发者工具的Sources选项卡中看到源码的目录结构，但是文件的具体内容会被隐藏起来。对于错误来说，我们仍然可以在Console控制台中查看源代码的错误栈，或者console日志的准确行数。它对于追溯错误来说基本足够，并且其安全性相对于可以看到整个源码的source-map配置来说要略高一些。 资源压缩压缩 javascript压缩JavaScript大多数时候使用的工具有两个，一个是UglifyJS（Webpack 3已集成），另一个是terser（Webpack 4已集成）。 在Webpack 3中的话，开启压缩需调用webpack.optimize.UglifyJsPlugin。 // webpack version &lt; 4 const webpack = require('webpack') module.exports = { entry: './app.js', output: { filename: 'bundle.js' }, plugins: [ new webpack.optimize.UglifyJsPlugin() ] } 从Webpack 4之后，这项配置被移到了config.optimization.minimize。 // webpack version > 4 module.exports = { entry: './app.js', output: { filename: 'bundle.js' }, optimization: { minimize: true } } 压缩CSS压缩CSS文件的前提是使用extract-text-webpack-plugin或mini-css-extract-plugin将样式提取出来，接着使用optimize-css-assets-webpack-plugin来进行压缩，这个插件本质上使用的是压缩器cssnano，当然我们也可以通过其配置进行切换。 const ExtractTextPlugin = require('extract-text-webpack-plugin') const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin') module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } ] }, plugins: [new ExtractTextPlugin('style.css')], optimization: { minimizer: [new OptimizeCssAssetsPlugin({ assetNameRegExp: /\\.optimize\\.css$/g, cssProcessor: require('cssnano'), cssProcessorOptions: { discardComments: {removeAll: true}, canPrint: true } })] } } 缓存缓存是指重复利用浏览器已经获取过的资源。合理地使用缓存是提升客户端性能的一个关键因素。 资源 hash一个常用的方法是在每次打包的过程中对资源的内容计算一次hash，并作为版本号存放在文件名中，如bundle@2e0a691e769edb228e2.js。 module.exports = { entry: './app.js', output: { filename: 'bundle@[chunkhash].js', }, mode: 'production' } 输出动态 HTML接下来我们面临的问题是，资源名的改变也就意味着HTML中的引用路径的改变。每次更改后都要手动地去维护它是很困难的，理想的情况是在打包结束后自动把最新的资源名同步过去。使用html-webpack-plugin可以帮我们做到这一点。 const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { // ... plugins: [ new HtmlWebpackPlugin() ] } html-webpack-plugin会自动地将我们打包出来的资源名放入生成的index.html中，这样我们就不必手动地更新资源URL了。 bundle 体积监控和分析一个很有用的工具是webpack-bundle-analyzer，它能够帮助我们分析一个bundle的构成。使用方法也很简单，只要将其添加进plugins配置即可。 const Analyzer = require('webpack-bundle-analyzer').BundleAnalyzerPlugin module.exports = { // ... plugins: [ new Analyzer() ] }","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-Webpack系列之预处理器","slug":"Webpack-Webpack系列之样式处理","date":"2020-01-14T07:21:00.000Z","updated":"2020-02-07T13:50:51.364Z","comments":true,"path":"2020/01/14/webpack-webpack-xi-lie-zhi-yang-shi-chu-li/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-yang-shi-chu-li/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 样式处理分离样式文件Webpack社区有专门的插件：extract-text-webpack-plugin（适用于Webpack 4之前版本）和mini-css-extract-plugin（适用于Webpack 4及以上版本），它们就是专门用于提取样式到CSS文件的。 extract-text-webpack-pluginnpm i extract-text-webpack-plugin 在 webpack.config.js 中引入： const ExtractTextPlugin = require('extract-text-webpack-plugin') module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } ]}, plugins: [ new ExtractTextPlugin('bundle.css') ] } 内部的fallback属性用于指定当插件无法提取样式时所采用的loader。 use（extract方法里面的）用于指定在提取样式之前采用哪些loader来预先进行处理。 除此之外，还要在Webpack的plugins配置中添加该插件，并传入提取后的资源文件名。 多样式文件处理上面我们将bundle.css作为文件名传给了extract-text-webpack-plugin，但当工程有多个入口时就会发生重名问题。就像在前面的章节中我们配置动态的output.filename一样，这里我们也要对插件提取的CSS文件使用类似模板的命名方式。 const ExtractTextPlugin = require('extract-text-webpack-plugin') module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } ]}, plugins: [ new ExtractTextPlugin('[name].css') ] } mini-css-extract-plugin说到mini-css-extract-plugin的特性，最重要的就是它支持按需加载CSS，以前在使用extract-text-webpack-plugin的时候我们是做不到这一点的。 举个例子，a.js通过import()函数异步加载了b.js，b.js里面加载了style.css，那么style.css最终只能被同步加载（通过HTML的link标签）。但是现在mini-css-extract-plugin会单独打包出一个0.css（假设使用默认配置），这个CSS文件将由a.js通过动态插入link标签的方式加载。 在配置上mini-css-extract-plugin与extract-text-webpack-plugin有以下几点不同： loader规则设置的形式不同，并且mini-css-extract-plugin支持配置publicPath，用来指定异步CSS的加载路径。 不需要设置fallback。 在plugins设置中，除了指定同步加载的CSS资源名（filename），还要指定异步加载的CSS资源名（chunkFilename） const MiniCssExtractPlugin = require('mini-css-extract-plugin') module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: [ { loader: MiniCssExtractPlugin.loader, options: { publicPath: '../' } }, 'css-loader' ] } ]}, plugins: [ new MiniCssExtractPlugin({ filename: '[name].css', chunkFilename: '[id].css' }) ] } 样式预处理样式预处理指的是在开发中我们经常会使用一些样式预编译语言，如SCSS、Less等，在项目打包过程中再将这些预编译语言转换为CSS。 Sass 与 Scsssass-loader就是将SCSS语法编译为CSS，因此在使用时通常还要搭配css-loader和style-loader。类似于我们装babel-loader时还要安装babel-core，loader本身只是编译核心库与Webpack的连接器，因此这里我们除了sass-loader以外还要安装node-sass，node-sass是真正用来编译SCSS的，而sass-loader只是起到黏合的作用。 npm i sass-loader node-sass module.exports = { // ... module: { rules: [ { test: /\\.scss$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] } ] } } Lessnpm i less-loader less module.exports = { // ... module: { rules: [ { test: /\\.less/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] } ] } } PostCssPostCSS并不能算是一个CSS的预编译器，它只是一个编译插件的容器。它的工作模式是接收样式源代码并交由编译插件处理，最后输出CSS。 PostCss 与 Webpack使用postcss-loader可以轻松地将PostCSS与Webpack连接起来。使用npm进行安装。 npm i postcss-loader module.exports = { // ... module: { rules: [ { test: /\\.css/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;] } ] } } postcss-loader可以结合css-loader使用，也可以单独使用，也就是说不配置css-loader也可以达到相同的效果。唯一不同的是，单独使用postcss-loader时不建议使用CSS中的@import语句，否则会产生冗余代码。 除此之外，PostCSS要求必须有一个单独的配置文件。我们需要在项目的根目录下创建一个postcss.config.js。 module.exports = { // ... module: {} } 自动前缀Autoprefixer是一个样式工具，可以根据caniuse.com上的数据，自动决定是否要为某一特性添加厂商前缀，并且可以由开发者为其指定支持浏览器的范围。 npm i autoprefixer 在postcss.config.js中添加autoprefixer。 const autoprefixer = require(&#39;autoprefixer&#39;) module.exports = { // ... plugins: [ autoprefixer({ grid: true, browsers: [ &#39;&gt; 1%&#39;, &#39;last 3 versions&#39;, &#39;android 4.2&#39;, &#39;ie 8&#39; ] }) ] } stylelintstylelint是一个CSS的质量检测工具，就像eslint一样，我们可以为其添加各种规则，来统一项目的代码风格，确保代码质量。 npm i stylelint 在postcss.config.js中添加相应配置。 const autoprefixer = require(&#39;autoprefixer&#39;) module.exports = { // ... plugins: [ stylelint({ config: { rules: { &#39;declaration-no-important&#39;: true } } }) ] } 这里我们添加了declaration-no-important这样一条规则，当我们的代码中出现了“！important”时就会给出警告。 使用stylelint可以检测出代码中的样式问题（语法错误、重复的属性等），帮助我们写出更加安全并且风格更加一致的代码。 CssNextPostCSS可以与CSSNext结合使用，让我们在应用中使用最新的CSS语法特性。 npm i postcss-cssnext 在postcss.config.js中添加相应配置。 const postcssCssnext = require(&#39;postcss-cssnext&#39;) module.exports = { // ... plugins: [ postcssCssnext({ browsers: [ &#39;&gt; 1%&#39;, &#39;last 2 versions&#39;, ] }) ] } 指定好需要支持的浏览器之后，我们就可以顺畅地使用CSSNext的特性了。 Css ModulesCSS Modules是近年来比较流行的一种开发模式，其理念就是把CSS模块化，让CSS也拥有模块的特点: 每个CSS文件中的样式都拥有单独的作用域，不会和外界发生命名冲突。 对CSS进行依赖管理，可以通过相对路径引入CSS文件。 可以通过composes轻松复用其他CSS模块 使用CSS Modules不需要额外安装模块，只要开启css-loader中的modules配置项即可。 module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: [ 'style-loader', { loader: 'css-loader', options: { modules: true, localIdentName: '[name]__[local]__[hash:base64:5]' } } ] } ]}, } 这里比较值得一提的是localIdentName配置项，它用于指明CSS代码中的类名会如何来编译。 例： /* style.css */ .title { color: #fff; } 经过编译后可能将成为.styletitle1CFy6。 [name]指代的是模块名，这里被替换为style。 [local]指代的是原本的选择器标识符，这里被替换为title。 [hash：base64：5]指代的是一个5位的hash值，这个hash值是根据模块名和标识符计算的，因此不同模块中相同的标识符也不会造成样式冲突。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-Webpack系列之代码分片","slug":"Webpack-Webpack系列之代码分片","date":"2020-01-14T07:21:00.000Z","updated":"2020-02-08T14:40:41.145Z","comments":true,"path":"2020/01/14/webpack-webpack-xi-lie-zhi-dai-ma-fen-pian/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-dai-ma-fen-pian/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 代码分片代码分片（code splitting）是Webpack作为打包工具所特有的一项技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用户不必一次全部加载，而是按需加载。 代码分片可以有效降低首屏加载资源的大小，但同时也会带来新的问题，比如我们应该对哪些模块进行分片、分片后的资源如何管理等，这些也是需要关注的。 通过入口划分代码在Webpack中每个入口（entry）都将生成一个对应的资源文件，通过入口的配置我们可以进行一些简单有效的代码拆分。 对于Web应用来说通常会有一些库和工具是不常变动的，可以把它们放在一个单独的入口中，由该入口产生的资源不会经常更新，因此可以有效地利用客户端缓存，让用户不必在每次请求页面时都重新加载。如： // webpack.config.js entry: { app: &#39;./app.js&#39;, lib: [&#39;lib-a&#39;, &#39;lib-b&#39;, &#39;lib-c&#39;] } // index.html &lt;script src=&quot;dist/lib.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;dist/app.js&quot;&gt;&lt;/script&gt; 这种拆分方法主要适合于那些将接口绑定在全局对象上的库，因为业务代码中的模块无法直接引用库中的模块，二者属于不同的依赖树。 CommonsChunkPluginCommonsChunkPlugin是Webpack 4之前内部自带的插件（Webpack 4之后替换为了SplitChunks）。它可以将多个Chunk中公共的部分提取出来。公共模块的提取可以为项目带来几个收益： 开发过程中减少了重复模块打包，可以提升开发速度； 减小整体资源体积； 合理分片后的代码可以更有效地利用客户端缓存。 更改webpack.config.js，添加CommonsChunkPlugin。 const webpack = require('webpack') module.exports = { entry: { foo: './foo.js', bar: './bar.js' }, output: { filename: '[name].js' }, plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: 'commons', filename: 'commons.js' }) ] } name：用于指定公共chunk的名字。 filename：提取后的资源文件名。 最后，记得在页面中添加一个script标签来引入commons.js，并且注意，该JS一定要在其他JS之前引入。 提取 vendor虽然CommonsChunkPlugin主要用于提取多入口之间的公共模块，但这不代表对于单入口的应用就无法使用。我们仍然可以用它来提取第三方类库及业务中不常更新的模块，只需要单独为它们创建一个入口即可。 const webpack = require(&#39;webpack&#39;) module.exports = { entry: { app: &#39;./app.js&#39;, vendor: [&#39;react&#39;] }, output: { filename: &#39;[name].js&#39; }, plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: &#39;vendor&#39;, filename: &#39;vendor.js&#39; }) ] } // app.js import React from &#39;react&#39; document.write(&#39;app.js&#39;, React.version) 为了将react从app.js提取出来，我们在配置中加入了一个入口vendor，并使其只包含react，这样就把react变为了app和vendor这两个chunk所共有的模块 设置提取范围通过CommonsChunkPlugin中的chunks配置项可以规定从哪些入口中提取公共模块。 const webpack = require(&#39;webpack&#39;) module.exports = { entry: { a: &#39;./a.js&#39;, b: &#39;./b.js&#39;, c: &#39;./c.js&#39;, }, output: { filename: &#39;[name].js&#39; }, plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: &#39;common&#39;, filename: &#39;common.js&#39;, chunks: [&#39;a&#39;, &#39;b&#39;] }) ] } 我们在chunks中配置了a和b，这意味着只会从a.js和b.js中提取公共模块。 设置提取规则CommonsChunkPlugin的默认规则是只要一个模块被两个入口chunk所使用就会被提取出来，比如只要a和b用了react，react就会被提取出来。 然而现实情况是，有些时候我们不希望所有的公共模块都被提取出来，此时我们可以通过CommonsChunkPlugin的minChunks配置项来设置提取的规则，该配置项非常灵活，支持多种输入形式。 数字 minChunks可以接受一个数字，当设置minChunks为n时，只有该模块被n个入口同时引用才会进行提取。另外，这个阈值不会影响通过数组形式入口传入模块的提取。 const webpack = require(&#39;webpack&#39;) module.exports = { entry: { foo: &#39;./foo.js&#39;, bar: &#39;./bar.js&#39;, vendor: [&#39;react&#39;], }, output: { filename: &#39;[name].js&#39; }, plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: &#39;vendor&#39;, filename: &#39;vendor.js&#39;, minChunks: 3 }) ] } 我们令foo.js和bar.js共同引用一个util.js。 // foo.js import React from 'react' import './util' document.write('foo.js', React.version) // foo.js import React from 'react' import './util' document.write('bar.js', React.version) // util.js console.log('util') 如果实际打包应该可以发现，由于我们设置minChunks为3，util.js并不会被提取到vendor.js中，然而react并不受这个的影响，仍然会出现在vendor.js中。 Infinity 设置为无穷代表提取的阈值无限高，也就是说所有模块都不会被提取。 函数 minChunks支持传入一个函数，它可以让我们更细粒度地控制公共模块。Webpack打包过程中的每个模块都会经过这个函数的处理，当函数的返回值是true时进行提取。 module.exports = { plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: &#39;vendor&#39;, filename: &#39;vendor.js&#39;, minChunks: function(module, count) { // module.context 模块目录路径 if (module.context &amp;&amp; module.context.include(&#39;node_modules&#39;)) { return true } // module.resource 包含模块名的完整路径 if (module.resource &amp;&amp; module.resource.endsWith(&#39;util.js&#39;)) { return true } // count 为模块被引用的次数 if (count &gt; 5) { return true } } }) ] } 借助上面的配置，我们可以分别提取node_modules目录下的模块、名称为util.js的模块，以及被引用5次（不包含5次）以上的模块。 hash 与 长效缓存当我们使用该插件提取公共模块时，提取后的资源内部不仅仅是模块的代码，往往还包含Webpack的运行时（runtime）。Webpack的运行时指的是初始化环境的代码，如创建模块缓存对象、声明模块加载函数等。 将运行时的代码单独提取出来。请看下面这个例子： const webpack = require(&#39;webpack&#39;) module.exports = { entry: { app: &#39;./app.js&#39;, vendor: [&#39;react&#39;], }, output: { filename: &#39;[name].js&#39; }, plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: &#39;vendor&#39; }), new webpack.optimize.CommonsChunkOlugin({ name: &#39;manifest&#39; }), ] } 上面的配置中，通过添加了一个name为manifest的CommonsChunkPlugin来提取Webpack的运行时。 注：manifest的CommonsChunkPlugin必须出现在最后，否则Webpack将无法正常提取模块。 CommonsChunkPlugin 的不足在提取公共模块方面，CommonsChunkPlugin可以满足很多场景的需求，但是它也有一些欠缺的地方。 一个CommonsChunkPlugin只能提取一个vendor，假如我们想提取多个vendor则需要配置多个插件，这会增加很多重复的配置代码。 前面我们提到的manifest实际上会使浏览器多加载一个资源，这对于页面渲染速度是不友好的。 由于内部设计上的一些缺陷，CommonsChunkPlugin在提取公共模块的时候会破坏掉原有Chunk中模块的依赖关系，导致难以进行更多的优化。 optimization.SplitChunksoptimization.SplitChunks（简称SplitChunks）是Webpack 4为了改进CommonsChunk-Plugin而重新设计和实现的代码分片特性。 比如我们前面异步加载的例子，在换成Webpack 4的SplitChunks之后，就可以自动提取出react了。 module.exports = { entry: &#39;./foo.js&#39;, output: { filename: &#39;foo.js&#39;, publicPath: &#39;/dist/&#39; }, mode: &#39;development&#39;, optimization: { splitChunks: { chunks: &#39;all&#39; } } } // foo.js import React from &#39;react&#39; import(&#39;./bar.js&#39;) document.write(&#39;app.js&#39;, React.version) // bar.js import React from &#39;react&#39; document.write(&#39;bar.js&#39;, React.version) 此处Webpack 4的配置与之前相比有两点不同： 使用optimization.splitChunks替代了CommonsChunkPlugin，并指定了chunks的值为all，这个配置项的含义是，SplitChunks将会对所有的chunks生效（默认情况下，SplitChunks只对异步chunks生效，并且不需要配置）。 以下是SplitChunks默认情形下的提取条件： 提取后的chunk可被共享或者来自node_modules目录。 提取后的Javascript chunk体积大于30kB（压缩和gzip之前），CSS chunk体积大于50kB。 在按需加载过程中，并行请求的资源最大值小于等于5。按需加载指的是，通过动态插入script标签的方式加载脚本。 在首次加载时，并行请求的资源数最大值小于等于3。 默认的异步提取前面我们对SplitChunks添加了一个chunks：all的配置，这是为了提取foo.js和bar.js的公共模块。实际上SplitChunks不需要配置也能生效，但仅仅针对异步资源。 module.exports = { entry: &#39;./foo.js&#39;, output: { filename: &#39;foo.js&#39;, publicPath: &#39;/dist/&#39; }, mode: &#39;development&#39; } // foo.js import(&#39;./bar.js&#39;) document.write(&#39;app.js&#39;, React.version) // bar.js import React from &#39;react&#39; document.write(&#39;bar.js&#39;, React.version) 配置为了更好地了解SplitChunks是怎样工作的，我们来看一下它的默认配置。 optimization: { splitChunks: { chunks: &#39;async&#39;, minSize: { javascript: 30000, style: 50000 }, maxSize: 0, minChunks: 1, maxAsyncRequest3: 3, maxInitialRequests: 2, automaticNameDelimiter: &#39;~&#39;, name: true, cacheGroups: { vendors: { test: /[\\\\/]node_modules[\\\\/]/ }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true } } } } 匹配模式 通过chunks我们可以配置SplitChunks的工作模式。它有3个可选值，分别为async（默认）、initial和all。async即只提取异步chunk，initial则只对入口chunk生效（如果配置了initial则上面异步的例子将失效），all则是两种模式同时开启。 匹配条件 minSize、minChunks、maxAsyncRequests、maxInitialRequests都属于匹配条件。 命名 配置项name默认为true，它意味着SplitChunks可以根据cacheGroups和作用范围自动为新生成的chunk命名，并以automaticNameDelimiter分隔。 cacheGroups 可以理解成分离chunks时的规则。默认情况下有两种规则——vendors和default。vendors用于提取所有node_modules中符合条件的模块，default则作用于被多次引用的模块。我们可以对这些规则进行增加或者修改，如果想要禁用某种规则，也可以直接将其置为false。当一个模块同时符合多个cacheGroups时，则根据其中的priority配置项确定优先级。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-Webpack系列之资源输入输出","slug":"Webpack-Webpack系列之资源输入输出","date":"2020-01-14T07:21:00.000Z","updated":"2020-02-07T04:00:14.591Z","comments":true,"path":"2020/01/14/webpack-webpack-xi-lie-zhi-zi-yuan-shu-ru-shu-chu/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-zi-yuan-shu-ru-shu-chu/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 资源输入输出资源处理流程在一切流程的最开始，我们需要指定一个或多个入口（entry），也就是告诉Webpack具体从源码目录下的哪个文件开始打包。如果把工程中各个模块的依赖关系当作一棵树，那么入口就是这棵依赖树的根，这些存在依赖关系的模块会在打包时被封装为一个chunk。 chunk字面的意思是代码块，在Webpack中可以理解成被抽象和包装过后的一些模块。它就像一个装着很多文件的文件袋，里面的文件就是各个模块，Webpack在外面加了一层包裹，从而形成了chunk。根据具体配置不同，一个工程打包时可能会产生一个或多个chunk。 Webpack会从入口文件开始检索，并将具有依赖关系的模块生成一棵依赖树，最终得到一个chunk。由这个chunk得到的打包产物我们一般称之为bundle。 配置资源入口通过context和entry这两个配置项来共同决定入口文件的路径。在配置入口时，实际上做了两件事： 确定入口模块位置，告诉Webpack从哪里开始进行打包。 定义chunk name。如果工程只有一个入口，那么默认其chunk name为“main”；如果工程有多个入口，我们需要为每个入口定义chunk name，来作为该chunk的唯一标识。 contextcontext可以理解为资源入口的路径前缀，在配置时要求必须使用绝对路径的形式。 module.exports = { context: path.join(__dirname, './src/script'), entry: './index.js' } 配置context的主要目的是让entry的编写更加简洁，尤其是在多入口的情况下。context可以省略，默认值为当前工程的根目录。 entryentry的配置可以有多种形式：字符串、数组、对象、函数。可以根据不同的需求场景来选择。 字符串类型入口 直接传入文件路径： module.exports = { entry: './src/index' } 数组类型入口 传入一个数组的作用是将多个资源预先合并，在打包时Webpack会将数组中的最后一个元素作为实际的入口路径。如： module.exports = { entry: ['babel-polyfill', './src/index'] } 对象类型入口 如果想要定义多入口，则必须使用对象的形式。 module.exports = { entry: { foo: './src/foo', bar: './src/bar' } } 函数类型入口 用函数定义入口时，只要返回上面介绍的任何配置形式即可。 module.exports = { entry: () => ({ foo: './src/foo', bar: './src/bar' }) } output所有与出口相关的配置都集中在output对象里。 filenamefilename的作用是控制输出资源的文件名。 字符串形式 module.exports = { output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' } } 在多入口的场景中，我们需要为对应产生的每个bundle指定不同的名字，Webpack支持使用一种类似模板语言的形式动态地生成文件名。 // 多个入口生成不同的文件 module.exports = { output: { path: path.resolve(__dirname, 'dist'), filename: '[name].js' } } 路径中使用hash，每次构建都有一个不同的hash值，避免发布新版本使用浏览器缓存。 module.exports = { output: { path: path.resolve(__dirname, 'dist/[hash]'), filename: '[name].js' } } pathpath可以指定资源输出的位置，要求值必须为绝对路径。如： module.exports = { output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' } } publicPathpublicPath是一个非常重要的配置项，并且容易与path相混淆。从功能上来说，path用来指定资源的输出位置，而publicPath则用来指定资源的请求位置。让我们详细解释这两个定义。 输出位置：打包完成后资源产生的目录，一般将其指定为工程中的dist目录。 请求位置：由JS或CSS所请求的间接资源路径。页面中的资源分为两种，一种是由HTML页面直接请求的，比如通过script标签加载的JS；另一种是由JS或CSS请求的，如异步加载的JS、从CSS请求的图片字体等。publicPath的作用就是指定这部分间接资源的请求位置。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-Webpack系列之模块打包","slug":"Webpack-Webpack系列之模块打包","date":"2020-01-14T07:21:00.000Z","updated":"2020-02-07T03:57:52.343Z","comments":true,"path":"2020/01/14/webpack-webpack-xi-lie-zhi-mo-kuai-da-bao/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-mo-kuai-da-bao/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 模块打包多种不同的模块机制CommonjsCommonJS最初只为服务端而设计，直到有了Browserify——一个运行在Node.js环境下的模块打包工具，它可以将CommonJS模块打包为浏览器可以运行的单个文件。这意味着客户端的代码也可以遵循CommonJS标准来编写了。 CommonJS中规定每个文件是一个模块，所有的变量及函数只有自己能访问，对外是不可见的。 导出在CommonJS中，通过module.exports可以导出模块中的内容： module.exports = { name: \"calculate\" } CommonJS模块内部会有一个module对象用于存放当前模块的信息。 属性。为了书写方便，CommonJS也支持另一种简化的导出方式—直接使用exports: exports.name = \"caculate\" 另外，要注意导出语句不代表模块的末尾，在module.exports或exports后面的代码依旧会照常执行。 导入在CommonJS中使用require进行模块导入： const calculator = require('./caculate.js') const name = calculator.name 当我们require一个模块时会有两种情况： require的模块是第一次被加载。这时会首先执行该模块，然后导出内容。 require的模块曾被加载过。这时该模块的代码不会再次执行，而是直接导出上次执行后得到的结果。 模块会有一个module对象用来存放其信息，这个对象中有一个属性loaded用于记录该模块是否被加载过。它的值默认为false，当模块第一次被加载和执行过后会置为true，后面再次加载时检查到module.loaded为true，则不会再次执行模块代码。 ES6 ModuleES6 Module也是将每个文件作为一个模块，每个模块拥有自身的作用域，不同的是导入、导出语句。 ES6 Module会自动采用严格模式 – “use strict”。 导出在ES6 Module中使用export命令来导出模块。 export有两种形式： 命名导出 默认导出 export const name = \"calculate\" export const add = \"add\" const name = \"calculate\" const add = \"add\" export { name, add } 在使用命名导出时，可以通过as关键字对变量重命名。如： const name = \"calculate\" const add = \"add\" export { name, add as sum } 将export default 默认导出，我们可以理解为对外输出了一个名为default的变量，因此不需要像命名导出一样进行变量声明，直接导出值即可。 export default \"calculate\" export default class {...} export default function() { ... } 导入ES6 Module中使用import语法导入模块。 import { name } from './caculate.js' 与命名导出类似，我们可以通过as关键字可以对导入的变量重命名。如： import { name as caculate } from './caculate.js' 在导入多个变量时，我们还可以采用整体导入的方式。如： import * as caculate from './caculate.js' const name = caculate.name 对于默认导出来说，import后面直接跟变量名，并且这个名字可以自由指定（比如这里是myCalculator）。如： import myCalculator from './caculate.js' AMDAMD是英文Asynchronous Module Definition（异步模块定义）的缩写: define('getSum', ['calculate'], function(math) { return function(a, b) { console.log(calculate.add(a, b)) } }) 在AMD中使用define函数来定义模块，它可以接受3个参数: 第1个参数是当前模块的id，相当于模块名； 第2个参数是当前模块的依赖，比如上面我们定义的getSum模块需要引入calculator模块作为依赖； 第3个参数用来描述模块的导出值，可以是函数或对象。如果是函数则导出的是函数的返回值；如果是对象则直接导出对象本身。 和CommonJS类似，AMD也使用require函数来加载模块，只不过采用异步的形式。 require(['getSum'], function(getSum) { getSum(2, 3) }) require的第1个参数指定了加载的模块，第2个参数是当加载完成后执行的回调函数。 通过AMD这种形式定义模块的好处在于其模块加载是非阻塞性的，当执行到require函数时并不会停下来去执行被加载的模块，而是继续执行require后面的代码，这使得模块加载操作并不会阻塞浏览器。 模块打包原理Webpack 将项目中成百上千个有依赖关系的模块组织在一起，打包后将会成为如下的形式： // 立即执行匿名函数 (function(module) { // 模块缓存 var installedModules = {} // 实现 require function __webpack_require__(moduleId) { // ... } // 执行入口模块的加载 return __webpack_require__(__webpack_require__.s = 0) { // modules: 以 key-value 的形式存储所有被打包的模块 0: function (module, exports, __webpack_require__) { // 打包入口 module.exports = __webpack_require__(\"3qiv\") }, \"3qiv\": function (module, exports, __webpack_require__) { // 打包入口 module.exports = __webpack_require__(\"3qiv\") } } }) 上面的bundle分为以下几个部分： 最外层立即执行匿名函数。它用来包裹整个bundle，并构成自身的作用域。 installedModules对象。每个模块只在第一次被加载的时候执行，之后其导出值就被存储到这个对象里面，当再次被加载的时候直接从这里取值，而不会重新执行。 webpack_require函数。对模块加载的实现，在浏览器中可以通过调用webpack_require(module_id)来完成模块导入。 modules对象。工程中所有产生了依赖关系的模块都会以key-value的形式放在这里。key可以理解为一个模块的id，由数字或者一个很短的hash字符串构成；value则是由一个匿名函数包裹的模块实体，匿名函数的参数则赋予了每个模块导出和导入的能力。 bundle是如何在浏览器中执行的： 在最外层的匿名函数中会初始化浏览器执行环境，包括定义installedModules对象、webpack_require函数等，为模块的加载和执行做一些准备工作。 加载入口模块。每个bundle都有且只有一个入口模块，例如：index.js是入口模块，在浏览器中会从它开始执行。 执行模块代码。如果执行到了module.exports则记录下模块的导出值；如果中间遇到require函数（准确地说是webpack_require），则会暂时交出执行权，进入webpack_require函数体内进行加载其他模块的逻辑。 在webpack_require中会判断即将加载的模块是否存在于installedModules中。如果存在则直接取值，否则回到上一步，执行该模块的代码来获取导出值。 所有依赖的模块都已执行完毕，最后执行权又回到入口模块。当入口模块的代码执行到结尾，也就意味着整个bundle运行结束。 不难看出，第3步和第4步是一个递归的过程。Webpack为每个模块创造了一个可以导出和导入模块的环境，但本质上并没有修改代码的执行逻辑，因此代码执行的顺序与模块加载的顺序是完全一致的，这就是Webpack模块打包的奥秘。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-Webpack系列之预处理器","slug":"Webpack-Webpack系列之预处理器","date":"2020-01-14T07:21:00.000Z","updated":"2020-02-07T04:01:19.330Z","comments":true,"path":"2020/01/14/webpack-webpack-xi-lie-zhi-yu-chu-li-qi/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack-webpack-xi-lie-zhi-yu-chu-li-qi/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 预处理器（loader）每个loader本质上都是一个函数。在Webpack 4之前，函数的输入和输出都必须为字符串；在Webpack 4之后，loader也同时支持抽象语法树（AST）的传递，通过这种方法来减少重复的代码解析。用公式表达loader的本质则为以下形式： output=loader(input) 这里的input可能是工程源文件的字符串，也可能是上一个loader转化后的结果，包括转化后的结果（也是字符串类型）、source map，以及AST对象；output同样包含这几种信息，转化后的文件字符串、source map，以及AST。如果这是最后一个loader，结果将直接被送到Webpack进行后续处理，否则将作为下一个loader的输入向后传递。 loader 的配置Webpack本身只认识JavaScript，对于其他类型的资源必须预先定义一个或多个loader对其进行转译，输出为Webpack能够接收的形式再继续进行，因此loader做的实际上是一个预处理的工作。 module.exports = { module: { rules: [ { test: /\\.jsx?/, // 条件 use: &#39;babel-loader&#39; // 规则应用结果 } // 一个Object即一条规则 ] } } 与loader相关的配置都在module对象中，其中module.rules代表了模块的处理规则。每条规则内部可以包含很多配置项，这里我们只使用了最重要的两项—test和use。 test可接收一个正则表达式或者一个元素为正则表达式的数组，只有正则匹配上的模块才会使用这条规则。 use可接收一个数组，数组包含该规则所使用的loader。 链式 loader很多时候，在处理某一类资源时我们都需要使用多个loader。 module.exports = { module: { rules: [ { test: /\\.css?/, // 条件 use: [&#39;style-loader&#39;, &#39;css-loader&#39;] // 规则应用结果 } // 一个Object即一条规则 ] } } 把style-loader加到了css-loader前面，这是因为在Webpack打包时是按照数组从后往前的顺序将资源交给loader处理的，因此要把最后生效的放在前面。 loader optionswebpack为loader提供了多种匹配条件的配置方式： test: … 匹配特定条件 include: … 匹配特定路径 exclude: … 排除特定路径 and: [] 必须匹配数组中的所有条件 or: [] 匹配数组中的任意一个条件 not: [] 排除匹配数组中的所有条件 条件值类型： 字符串：必须以提供的字符串开始（绝对路径） 正则表达式 数组：至少包含一个条件的数组 对象：匹配所有属性值的条件 函数：返回true表示匹配 规则应用配置匹配规则后的应用，我们可以使用use字段： rules: [ { test: /\\.less/, use: [ &#39;style-loader&#39;, { loader: &#39;css-loader&#39;, options: { // ... } }, { loader: &#39;less-loader&#39;, options: { // ... } } ] } ] 使用options可以给对应的loader传递一些配置项。 对于上述的less规则应用配置，一个less模块文件可以经过多个loader的转换处理，执行顺序为从右到左。 如果多个rule匹配了同一个模块文件，loader的应用顺序应该如何处理？ rules: [ { test: /\\.js$/, loader: &quot;eslint-loader&quot;, }, { test: /\\.js$/, loader: &quot;babel-loader&quot;, } ] eslint-loader用于检查人工编写的代码，babel-loader用于转换代码。所以，eslint-loader应该在babel-loader之前执行，那么该如何保证执行顺序？ webpack为每一个匹配规则提供了enforce字段来配置当前rule得的loader类型。pre(前置) &gt; 行内 &gt; 普通 &gt; 后置(post)。 我们要确保eslint-loader在babel-loader之前执行，只需给rule规则项添加enforce字段，并设置其值为pre。 rules: [ { enforce: &#39;pre&#39;, test: /\\.js$/, loader: &quot;eslint-loader&quot;, }, { test: /\\.js$/, loader: &quot;babel-loader&quot;, } ] 常用 loader 介绍babel-loader babel-loader用来处理ES6+并将其编译为ES5。 npm i babel-loader @babel/core @babel/preset-env 各个模块的作用如下: babel-loader：它是使Babel与Webpack协同工作的模块。 @babel/core：顾名思义，它是Babel编译器的核心模块。 @babel/preset-env：它是Babel官方推荐的预置器，可根据用户设置的目标环境自动添加所需的插件和补丁来编译ES6+代码。 module.exports = { // ... module: { rules: [ { test: /\\.jsx?/, loader: &#39;babel-loader&#39; } ] } } ts-loaderts-loader与babel-loader的性质类似，它是用于连接Webpack与Typescript的模块。 npm i ts-loader typescript module.exports = { // ... module: { rules: [ { test: /\\.ts?/, loader: &#39;ts-loader&#39; } ] } } html-loaderhtml-loader用于将HTML文件转化为字符串并进行格式化，这使得我们可以把一个HTML片段通过JS加载进来。 npm i html-loader module.exports = { // ... module: { rules: [ { test: /\\.html?/, loader: &#39;html-loader&#39; } ] } } handlebars-loaderhandlebars-loader用于处理handlebars模板，在安装时要额外安装handlebars。 npm i handlebars-loader handlebars module.exports = { // ... module: { rules: [ { test: /\\.handlebars?/, loader: &#39;handlebars-loader&#39; } ] } } handlebars文件加载后得到的是一个函数，可以接收一个变量对象并返回最终的字符串。 file-loaderfile-loader用于打包文件类型的资源，并返回其publicPath。 npm i file-loader module.exports = { // ... module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: &#39;file-loader&#39; } ] } } url-loaderurl-loader与file-loader作用类似，唯一的不同在于用户可以设置一个文件大小的阈值，当大于该阈值时与file-loader一样返回publicPath，而小于该阈值时则返回文件base64形式编码。 npm i url-loader module.exports = { // ... module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: { loader: &#39;file-loader&#39;, options: { limit: 10240, name: &#39;[name].[ext]&#39;, publicPath: &#39;./assets-path/&#39; } } } ] } }","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"面试题-常见面试题系列之JS基础","slug":"面试题-常见面试题系列之JS基础","date":"2019-11-25T01:46:52.000Z","updated":"2019-11-25T20:02:59.098Z","comments":true,"path":"2019/11/25/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-js-ji-chu/","link":"","permalink":"http://qiandream.cn/2019/11/25/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-js-ji-chu/","excerpt":"","text":"导语本系列旨在整理 JS 常见面试题，帮助梳理 JS 基础知识点。 🌰 [‘1’, ‘2’, ‘3’].map(parseInt) 输出结果parseInt解析一个字符串参数，返回一个指定基数的整数。 const intValue = parseInt(string[, radix]); string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串。字符串开头的空白符会被忽略。 radix 一个介于 2~36之间的整数，表示上述字符串的基数，默认值为 10。 parseInt 返回一个整数或 NaN。 parseInt(100); // 100 parseInt(100, 10); // 1*10*10 + 0*10*1 + 0*10*0 = 100 parseInt(100, 2); // 1*2*2 + 0*2*1 + 0*2*0 = 4 在 radix 为 undefined ，或 radix 为 0 或没有指定的情况下，JS 作如下处理： string 以 ‘0x’ 或 ‘0X’ 开头，则 radix 为 16。 string 以 ‘0’ 开头，radix 为 8 或者 10，具体哪个基数由实现环境决定。 string 以其它任何值开头，则 radix 为 10。 map创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 var new_array = arr.map(function callback(currentValue[,index[, array]]) { // Return element for new_array }[, thisArg]) callback 回调函数需要三个参数，分别为 currentValue(数组中当前正在处理的元素的值)、index(数组中当前正在处理的元素的索引)、array(map 方法中被调用的数组)。 const arr = [1, 2, 3] arr.map(num => num * 2) // [2, 4, 6] [‘1’, ‘2’, ‘3’].map(parseInt) 输出对于每个迭代 map，parseInt() 传递两个参数：字符串和基数。所以实际执行的代码为： ['1', '2', '3'].map(parseInt((item, index) => parseInt(item, index)) 执行步骤为： parseInt('1', 0); // 1 (10 进制) parseInt('2', 1); // NaN radix(2-36) parseInt('3', 2); // NaN 不符合2进制位数取值(0-1) 所以： ['1', '2', '3'].map(parseInt) // [1, NaN, NaN] 🌰 什么是节流和防抖？区别？如何实现？防抖动作绑定事件，动作发生后一定时间内触发时间，在这段时间内如果该动作又发生，则重新等待一定时间再触发事件。 /** * 防抖 debounce 定时器 * @param fn {function} 回调函数 * @param wait {number} 时间间隔 * @author wangxiaobai */ export function debounce (fn, wait) { let timer = null; return () => { // 清除上次执行得定时器 if (timer) { clearTimeout(timer); } // 设立新定时器 timer = setTimeout(() => { fn.apply(this, arguments); }, wait); } } 节流动作绑定事件，动作发生后一定时间内触发事件，在这段时间内如果该动作又发生，则无视该动作，直到事件执行完后，才能重新触发。 /** * 节流 throttle 定时器 * @param fn {function} 回调函数 * @param wait {number} 时间间隔 * @author wangxiaobai */ export function throttle (fn, wait) { // 上一次函数的执行时间 let activeTime = 0; return () => { let currentTime = +new Date(); if (currentTime - activeTime > wait) { fn.apply(this, arguments); activeTime = currentTime; } } } 🌰 Set、Map、WeakSet、WeakMapSet一种叫做集合的数据结构，类似于数组，成员唯一且无序。 new Set([iterable]) const s = new Set(); [1, 2, 3, 4, 3, 2, 1].forEach(item => s.add(item)); for (let item of s) { console.log(item) // 1 2 3 4 } let arr = [1, 2, 3, 2, 1, 1, 1]; [... new Set(arr)]; // [1, 2, 3] Set 允许你存储任何类型的唯一值，无论是原始值还是对象引用。 向 Set 加入值的时候，不会发生类型转换，所以 5 和 ‘5’ 是两个不同的值。 在 Set 中，NaN 等于自身。 let set = new Set(); set.add(NaN); set.add(NaN); set; // {NaN} let set1 = new Set(); set1.add(5); set1.add('5'); set; // {5, '5'} Set 实例属性 constructor: 构造函数 size: 元素数量 let set = new Set([1, 2, 3, 2, 1]); console.log(set.size); // 3 Set 实例方法 操作方法： add(value) 新增 delete(value) 存在即删除集合中的 value has(value) 判断集合中是否存在 value clear() 清空集合 let set = new Set(); set.add(1).add(2).add(1); set.size; // 2 set.has(1); // true set.has(3); // false set.delete(1); set.has(1); // false set.clear(); set.size; // 0 Array.from 可以将 Set 结构转化为数组 const items = new Set([1, 2, 3, 1]); const array = Array.from(items); console.log(array); // [1, 2, 3] // 或 const arr = [...items] console.log(arr); // [1, 2, 3] 遍历方法： keys() 返回一个包含集合中所有键的迭代器 values() 返回一个包含集合中所有值的迭代器 entries() 返回一个包含集合中所有键值对的迭代器 forEach(callbackFn, thisArg) map(callbackFn, thisArg) filter(callbackFn, thisArg) let set = new Set([1, 2, 3]) console.log(set.keys()); // SetIterator {1, 2, 3} console.log(set.values()); // SetIterator {1, 2, 3} console.log(set.entries()); // SetIterator {1 => 1, 2 => 2, 3 => 3} set.forEach((value, key) => { console.log(key + ' : ' + value); }); // 1:1 2:2 3:3 set = new Set([...set].map(item => item * 2)); console.log(set); // {2, 4, 6} set = new Set([...set].filter(item => (item >= 4))); console.log(set); // {4, 6} 因此，Set 很容易实现两个数组的交集、并集、差集 let set1 = new Set([1, 2, 3]); let set2 = new Set([4, 3, 2]); let intersect = new Set([...set1].filter(value => set2.has(value))); let union = new Set([...set1, ...set2]); let difference = new Set([...set1].filter(value => !set2.has(value))); console.log(intersect); // {2, 3} console.log(union); // {1, 2, 3, 4} console.log(difference); // {1} WeakSet允许你将弱引用对象储存在一个集合中。 WeakSet 与 Set 的区别： WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以 WeakSet 中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的引用，如果没有其它的变量或属性引用这个对象值，则这个对象或被垃圾回收掉 属性： constructor: 构造函数 方法： add(value) 添加元素 value has(value) 判断是否包含 value delete(value) 删除 value var ws = new WeakSet(); var obj = {} var foo = {} ws.add(obj); ws.add(foo); ws.has(obj); // true ws.has(foo); // false ws.delete(obj); ws.has(obj); // false Map一种叫做字典的数据结构，以 [key, value] 的形式存储 const m = new Map(); const o = { p: 'haha' }; m.set(o, 'content'); m.get(o); // 'content' m.has(o); // true m.delete(o); m.has(o); // false 任何具有 Iterator 接口，每个成员都是一个双元素的数组的数据结构都可以当做 Map 构造函数的参数。 const map = new Map([ ['name', '张三'], ['title', 'Author'] ]); map.size; // 2 map.has('name'); // true map.get('name'); // \"张三\" map.has('title'); // true map.get('title'); // \"Author\" const set = new Set([ ['foo', 1], ['bar', 2] ]); const m1 = new Map(set); m1.get('foo'); // 1 const m2 = new Map([['baz', 3]]); const m3 = new Map(m2); m3.get('baz'); // 3 如果读取一个未知的键，则返回undefined。 new Map().get('asfddfsasadf'); // undefined 只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。 const map = new Map(); map.set(['a'], 555); map.get(['a']); // undefined Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 let map = new Map(); map.set(-0, 123); map.get(+0); // 123 map.set(true, 1); map.set('true', 2); map.get(true); // 1 map.set(undefined, 3); map.set(null, 4); map.get(undefined); // 3 map.set(NaN, 123); map.get(NaN); // 123 属性： constructor：构造函数 size: 字典中所包含的元素个数 const map = new Map([ ['name', 'An'], ['des', 'JS'] ]); map.size; // 2 操作方法： set(key, value) 添加新元素 get(key) 通过键查找特定的数值并返回 has(key) 判断字典中是否存在 key delete(key) 通过键 key 从字典中移除对应的数据 clear() 字典中所有元素删除 遍历方法： keys() 将字典中包含的所有键名以迭代器形式返回 values() 将字典中包含的所有数值以迭代器形式返回 entries() 返回所有成员的迭代器 forEach() 遍历字典的所有成员 const map = new Map([ ['name', 'An'], ['des', 'JS'] ]); console.log(map.entries()); // MapIterator {\"name\" => \"An\", \"des\" => \"JS\"} console.log(map.keys()); // MapIterator {\"name\", \"des\"} 与其它数据结构相互转换 Map 转 Array const map = new Map([[1, 1], [2, 2], [3, 3]]) console.log([...map]); // [[1, 1], [2, 2], [3, 3]] Array 转 map const map = new Map([[1, 1], [2, 2], [3, 3]]) console.log(map); // Map {1 => 1, 2 => 2, 3 => 3} Map 转 Object function mapToObj(map) { let obj = Object.create(null); for (let [key, value] of map) { obj[key] = value; } return obj } const map = new Map().set('name', 'An').set('des', 'JS'); mapToObj(map); // {name: \"An\", des: \"JS\"} Object 转 Map function objToMap(obj) { let map = new Map(); for (let key of obj.keys()) { map.set(key, obj[key]) } return map } objToMap({'name': 'An', 'des': 'JS'}) // Map {\"name\" => \"An\", \"des\" => \"JS\"} Map 转 JSON function mapToJson(map) { return JSON.stringify([...map]); } let map = new Map().set('name', 'An').set('des', 'JS'); mapToJson(map); // [[\"name\",\"An\"],[\"des\",\"JS\"]] JSON 转 Map function jsonToStrMap(jsonStr) { return objToMap(JSON.parse(jsonStr)); } jsonToStrMap('{\"name\": \"An\", \"des\": \"JS\"}'); // Map {\"name\" => \"An\", \"des\" => \"JS\"} WeakMapWeakMap 对象是一组键值对的集合，其中键是弱引用对象，而值可以是任意。 每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收。 属性： constructor: 构造函数 方法： has(key)：判断是否有 key 关联对象 get(key)：返回key关联对象（没有则则返回 undefined） set(key)：设置一组key关联对象 delete(key)：移除 key 的关联对象 总结 Set 成员唯一、无序 可以遍历 WeakSet 成员都是对象 成员都是弱引用，可以被垃圾回收机制回收 不能遍历 Map 本质是键值对的集合 可以遍历 WeakMap 只接受对象作为键名 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收机制回收 不能遍历","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://qiandream.cn/tags/面试题/"}]},{"title":"CSS-常见面试题系列之BFC","slug":"CSS-常见面试题系列之BFC","date":"2019-08-26T08:24:52.000Z","updated":"2019-08-29T08:28:46.000Z","comments":true,"path":"2019/08/26/css-chang-jian-mian-shi-ti-xi-lie-zhi-bfc/","link":"","permalink":"http://qiandream.cn/2019/08/26/css-chang-jian-mian-shi-ti-xi-lie-zhi-bfc/","excerpt":"","text":"导语 BFC (Block Formatting Context) 块级格式化上下文，页面的可视化 CSS 渲染的一部分，是一个独立的渲染区域，块内的子元素布局与块外的元素互不干扰。 BFC 解决的问题 浮动定位 消除外边距折叠 清除浮动 自适应多栏布局… BFC 的创建 body根元素 浮动: float 除 none 以外的值 绝对定位: position (absolute, fixed) overflow 值不为 visible 弹性布局或网格布局 BFC 的约束规则 属于同一个 BFC 中的两个相邻的 Box 的 margin 会发生折叠。 每个元素的左外边距与包含块的左边界相接触，即使浮动元素也是如此。 BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动子元素也参与计算 BFC 的应用防止 margin 重叠&lt;body> &lt;p>top&lt;/p> &lt;p>bottom&lt;/p> &lt;/body> &lt;style> p { width: 100px; height: 100px; background: yellow; line-height: 100px; margin: 10px; text-align: center } &lt;/style> 展示效果： 两个 box 中间的间距为 10px，而不是 20px，因为它们处于同一个 BFC 中(body)。 解决方案为给第二个 box 包一层 div，设置其 overflow 属性，使它们处于不同的 BFC。 &lt;body> &lt;p>top&lt;/p> &lt;div> &lt;p>bottom&lt;/p> &lt;/div> &lt;/body> &lt;style> p { width: 100px; height: 100px; background: yellow; line-height: 100px; margin: 10px; text-align: center } div { overflow: hidden; } &lt;/style> 展示效果： 让浮动内容与周围内容等高&lt;div class=\"box\"> &lt;div class=\"float\">浮动元素&lt;/div> &lt;p>未浮动元素&lt;/p> &lt;/div> &lt;style> .box { background-color: rgb(224, 206, 247); border: 5px solid rebeccapurple; } .float { float: left; width: 200px; height: 150px; background-color: white; border:1px solid black; padding: 10px; } &lt;/style> 展示效果： 由于浮动，使得浮动元素的高度高于旁边的元素，解决方式为使父 box 生成一个 BFC，如下： &lt;div class=\"box\"> &lt;div class=\"float\">浮动元素&lt;/div> &lt;p>未浮动元素&lt;/p> &lt;/div> &lt;style> .box { background-color: rgb(224, 206, 247); border: 5px solid rebeccapurple; overflow: auto; } .float { float: left; width: 200px; height: 150px; background-color: white; border:1px solid black; padding: 10px; } &lt;/style> 展示效果： 阻止元素被浮动元素覆盖&lt;div class=\"float\">我是一个左浮动的元素&lt;/div> &lt;div class=\"box\">我是一个没有设置浮动, 也没有触发 BFC 元素&lt;/div> &lt;style> .float { width: 100px; height: 100px; background: #eee; float: left; } .box { width: 200px; height: 200px; background: yellow; } &lt;/style> 展示效果： 第二个元素有部分被浮动元素覆盖，此时可触发第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden。 &lt;div class=\"float\">我是一个左浮动的元素&lt;/div> &lt;div class=\"box\">我是一个没有设置浮动, 也没有触发 BFC 元素&lt;/div> &lt;style> .float { width: 100px; height: 100px; background: #eee; float: left; } .box { overflow: hidden; width: 200px; height: 200px; background: yellow; } &lt;/style> 展示效果： 此方法可用来实现两列自适应布局 参考 BFC原理解析 10 分钟理解 BFC 原理","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://qiandream.cn/tags/CSS/"}]},{"title":"Vue-源码系列随读笔记之Array变化侦测","slug":"Vue-源码系列随读笔记之Array变化侦测","date":"2019-08-18T10:34:52.000Z","updated":"2019-08-17T17:13:30.468Z","comments":true,"path":"2019/08/18/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-array-bian-hua-zhen-ce/","link":"","permalink":"http://qiandream.cn/2019/08/18/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-array-bian-hua-zhen-ce/","excerpt":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档","text":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档 什么是变化侦测从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。 简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。 Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。 如何追踪变化首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。 function defineReactive (data, key, val) { Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { return val }, set: function(newVal) { if (val === newVal) { return } val = newVal } }) } 此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。 由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。 如何收集依赖思考以下问题： let globalObj = { text1: 'text1' }; let o1 = new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;div>`, data: globalObj }); let o2 = new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;div>`, data: globalObj }); 该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？ 对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。 即：在 getter 中收集依赖，在 setter 中触发依赖。 依赖收集到哪里（Dep） 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。 export default class Dep { constructor () { this.subs = [] // 观察者集合 } // 添加观察者 addSub (sub) { this.subs.push(sub) } // 移除观察者 removeSub (sub) { remove(this.subs, sub) } depend () { // 如果存在 Dep.target，则进行依赖收集操作 if (Dep.target) { this.addSub(Dep.target) } } notify () { const subs = this.subs.slice() // 避免污染原来的集合 for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() // 更新 } } } function remove(arr, item) { if (arr.length) { const index = arr.indexOf(item) if (index > -1) { return arr.splice(index, 1) } } } 改造 defineReactive function defineReactive (data, key, val) { let dep = new Dep() Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { dep.depend() return val }, set: function(newVal) { if (val === newVal) { return } val = newVal dep.notify() } }) } 什么是依赖当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。 然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。 收集谁？Watcher! 什么是 WatcherWatcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。 vm.$watch('a.b.c', function(newVal, oldVal) { // do something }) 这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。 把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。 export default class Watcher { // ... constructor ( vm: Component, // 组件实例 expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作 cb: Function // 被观察者发生变化后的回调 ) { this.vm = vm // Watcher有一个 vm 属性，表明它是属于哪个组件的 this.cb = cb // 回调 this.getter = parsePath(expOrFn) this.value = this.get() } get () { // 触发取值操作，进而触发属性的getter Dep.target = this let value = this.getter.call(this.vm, this.vm) Dep.target = null return value } update () { // 更新 const oldValue = this.value this.value = this.get() this.cb.call(this.vm, this.value, oldValue) } } 这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。 在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。 只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。 依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。 不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。 parsePath函数： const bailRE = /[^\\w.$]/ export function parsePath(path) { if (bailRE.test(path)) { return } const segments = path.split('.') return function(obj) { for (let i = 0; i &lt; segments.length; i++) { if (!obj) return obj = obj[segments[i]] } return obj } } 递归侦测所有Key前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化： export class Observer { constructor (value) { this.value = value if (!Array.isArray(value)) { this.walk(value) } } walk (obj) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive (obj, keys[i], obj[keys[i]]) } } } function defineReactive(data, key, val) { if (typeof val === 'object') { new Observer(val) } let dep = new Dep() Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { dep.depend() return val }, set: function(newVal) { if (val === newVal) { return } val = newVal dep.notify() } }) } Observer 类，用于将一个正常的 object 转换成被侦测的 object。 判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。 最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。 当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。 总结变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。 Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。 我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。 收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。 所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。 Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。 由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。 在 Vue 中，对象新增属性或删除属性都无法被侦测到。 Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。 当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。 当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。 Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://qiandream.cn/tags/Vue/"}]},{"title":"JS-执行上下文和执行上下文栈","slug":"JS-执行上下文和执行栈","date":"2019-07-26T07:18:52.000Z","updated":"2019-07-26T07:28:37.956Z","comments":true,"path":"2019/07/26/js-zhi-xing-shang-xia-wen-he-zhi-xing-zhan/","link":"","permalink":"http://qiandream.cn/2019/07/26/js-zhi-xing-shang-xia-wen-he-zhi-xing-zhan/","excerpt":"导语 执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文栈用于存储在代码执行期间创建的所有执行上下文。","text":"导语 执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文栈用于存储在代码执行期间创建的所有执行上下文。 理解执行上下文和执行上下文栈执行上下文的类型执行上下文总共有三种类型： 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 会指向这个全局对象。 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。 Eval 函数执行上下文：运行在 Eval 函数中的代码。 执行上下文栈接下来问题来了，我们写了那么多函数，如何管理创建的那么多执行上下文呢？ Javascript 创建了执行上下文栈，也叫调用栈，来管理在代码执行期间创建的所有执行上下文。 首次运行 Javascript 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。 根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从栈中 Pop 出，上下文控制权将会移到当前执行栈的下一个执行上下文。 var a = 'Hello World!'; function first() { console.log('Inside first function'); second(); console.log('Again inside first function'); } function second() { console.log('Inside second function'); } first(); console.log('Inside Global Execution Context'); 执行上下文的创建执行上下文分为两个阶段创建：1） 创建阶段 2）执行阶段 创建阶段 确定 this 的值，也被称为 This Binding LexicalEnvironment-词法环境组件被创建 VariableEnvironment-变量环境组件被创建 ExecutionContext = { ThisBinding: &lt;this value>, // 确定 this LexicalEnvironment: {...}, // 词法环境 VariableEnvironment: {...} // 变量环境 } This Binding 全局执行上下文中，this 指向全局对象，在浏览器中 this 的值指向 window 对象，而在 nodejs 中指向这个文件的 module 对象。 函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显示绑定、new 绑定等。 词法环境词法环境有两个组成部分： 环境记录：存储变量和函数声明的实际位置 对外部环境的引用：可以访问其外部词法环境 词法环境有两种类型： 全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window）及其关联的方法和属性以及任何用户自定义的全局变量， this 的值指向这个全局对象。 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境， GlobalExectionContext = { // 全局执行上下文 LexicalEnvironment: { // 词法环境 EnvironmentRecord: { // 环境记录 Type: \"Object\", // 全局环境 // 标识符绑定在这里 outer: &lt;null> // 对外部环境的引用 } } FunctionExectionContext = { // 函数执行上下文 LexicalEnvironment: { // 词法环境 EnvironmentRecord: { // 环境记录 Type: \"Declarative\", // 函数环境 // 标识符绑定在这里 // 对外部环境的引用 outer: &lt;Global or outer function environment reference> } } 变量环境 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。 在ES6中，词法环境和变量环境的区别在于前者用于存储函数声明和变量(let const)绑定，后者仅用于存储变量(var)绑定。 GlobalExectionContext = { ThisBinding: &lt;Global Object>, LexicalEnvironment: { EnvironmentRecord: { Type: \"Object\", // 标识符绑定在这里 a: &lt; uninitialized >, b: &lt; uninitialized >, multiply: &lt; func > } outer: &lt;null> }, VariableEnvironment: { EnvironmentRecord: { Type: \"Object\", // 标识符绑定在这里 c: undefined, } outer: &lt;null> } } FunctionExectionContext = { ThisBinding: &lt;Global Object>, LexicalEnvironment: { EnvironmentRecord: { Type: \"Declarative\", // 标识符绑定在这里 Arguments: {0: 20, 1: 30, length: 2}, }, outer: &lt;GlobalLexicalEnvironment> }, VariableEnvironment: { EnvironmentRecord: { Type: \"Declarative\", // 标识符绑定在这里 g: undefined }, outer: &lt;GlobalLexicalEnvironment> } } 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined (var 情况下) 或保持未初始化 (let、const 情况下)。所以这就是为什么可以在声明之前访问 var 定义的变量，如果在声明之前访问 let 和 const 定义的变量会提示引用错误的原因。这就是所谓的变量提升。 执行阶段 执行上下文的代码分为两个阶段进行处理： 进入执行上下文 代码执行 进入执行上下文此时的变量对象包括（如下顺序初始化）： 函数所有的形参：没有实参，属性值设为 undefined。 函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。 变量声明：如果变量名称与已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。 ```javascriptfunction foo(a) {var b = 2;function c() {}var d = function() {}; b = 3;} foo(1); ```javascript AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined } 形参 arguments 已经有值了，但是变量还是 undefined，只是初始化的值。 代码执行 这个阶段会顺序执行代码，并修改变量的值。 AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression \"d\" } 总结如下： 全局上下文的变量对象初始化是全局对象。 函数上下文的变量对象初始化只包括 arguments 对象。 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值。 在代码执行阶段，会再次修改变量对象的属性值。 深入执行上下文和执行上下文栈JS 是单线程的语言，执行顺序是顺序执行，但是 JS 引擎并不是一行一行地分析和执行代码，而是一段一段地分析和执行，先进行编译然后才是执行。 有如下两段代码，执行结果是一样的，但是两段代码究竟有什么不同？ var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f(); } checkscope(); var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f; } checkscope()(); 答案是执行上下文栈的变化不一样。 第一段代码： ECStack.push(&lt;checkscope> functionContext); ECStack.push(&lt;f> functionContext); ECStack.pop(); ECStack.pop(); 第二段代码： ECStack.push(&lt;checkscope> functionContext); ECStack.pop(); ECStack.push(&lt;f> functionContext); ECStack.pop(); 函数执行上下文在函数执行上下文中，用活动对象来表示变量对象。 活动对象和变量对象的区别在于： 变量对象是规范上或 JS 引擎上实现的，并不能在 JS 环境中直接访问。 当进入到一个执行上下文后，这个变量对象会被激活，所以叫活动对象，这时活动对象上的各种属性才能被访问。 调用函数时，会自动为其创建一个 arguments 对象，并初始化局部变量 arguments。所有作为参数传入的值都会成为 arguments 对象的数组元素。 参考 理解JavaScript 中的执行上下文和执行栈 JavaScript深入之执行上下文栈和变量对象","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"Node-NodeJS核心基础知识","slug":"Node-NodeJS核心基础知识","date":"2019-06-26T15:11:52.000Z","updated":"2019-07-07T11:26:33.333Z","comments":true,"path":"2019/06/26/node-nodejs-he-xin-ji-chu-zhi-shi/","link":"","permalink":"http://qiandream.cn/2019/06/26/node-nodejs-he-xin-ji-chu-zhi-shi/","excerpt":"导语 截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…","text":"导语 截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node… Nodejs 概述Nodejs 是基于 Chrome V8 引擎构建的，由事件循环分布 I/O 任务，最终工作线程会将任务放到线程池中执行，而事件循环等待执行结果就可以了。 Nodejs 是 Javascript 的运行时环境。 Nodejs 构建在 Chrome V8 这个著名的 Javascript 引擎上。 Nodejs 每个函数都是同步的，而 I/O 操作是异步的。 Nodejs 使用 npm 作为包管理器。 Nodejs 安装Nodejs 支持 macOS、Linux 以及 Windows 等多个主流操作系统。 3m 安装法 nvm 开源的 Nodejs 版本管理器 npm Nodejs 包管理端 nrm 解决 npm 镜像访问慢的问题。 nvm安装 nvm首先，在终端执行如下命令： $ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 意思是通过 curl 命令下载 install.sh 脚本并执行。执行完成后，重新打开终端窗口，执行 vi ~/.zshrc 把 nvm 命令的执行路径放到 ~/.zshrc 文件下： export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; . \"$NVM_DIR/nvm.sh\" 执行 source 命令，使系统环境变量生效： source ~/.zshrc 输入： nvm --version 0.33.1 查看可安装的 Nodejs 版本安装 Node 之前，需要了解通过 nvm 可以安装哪些版本的 Node。 nvm ls-remote LTS 版本是指长期支持版本，推荐给大部分用户使用，一般在生产环境中使用。 Current 版本是指当前正在开发的尝鲜版本，不完全版本，需要经过一段时间的测试、开发和修复 bug 等才能变为 LTS 版本，一般供开发者学习。 安装 Nodenvm install 10.15.3 通过 nvm 安装的 Node 位于用户目录下，而非系统目录下。 which node /Users/wangqian/.nvm/versions/node/v10.15.3/bin/node 默认使用某个 Node 版本来编译代码，需要手动指定一个 default 别名。 nvm alias default node default -> node (-> v10.15.3) 此时，输入 node -v，以后在终端的任何地方使用的默认版本都会是你设置的版本。 node -v v10.15.3 如何使用 nvm 切换 Node 版本？首先安装 Node 8.x nvm install 8 切换到 8.x 版本： nvm use 8 Now using node v8.16.0 (npm v6.4.1) node -v v8.16.0 如何知道本机通过 nvm 安装了哪些 Node 版本呢？ nvm ls -> v8.16.0 v10.15.3 default -> node (-> v10.15.3) node -> stable (-> v10.15.3) (default) stable -> 10.15 (-> v10.15.3) (default) iojs -> N/A (default) lts/* -> lts/dubnium (-> N/A) lts/argon -> v4.9.1 (-> N/A) lts/boron -> v6.17.1 (-> N/A) lts/carbon -> v8.16.0 lts/dubnium -> v10.16.0 (-> N/A) 若要经常切换 Node 版本，最痛苦的莫过于全局模块需要重新安装。针对这种情况，nvm 提供了一个很贴心的一键安装全局模块的 nvm reinstall-packages命令。 nvm reinstall-packages 6 nvm 默认远端下载地址是 https://nodejs.org/dist，如果想安装自定义的 Node 版本，可以指定 nvm 的远端下载地址。 NVM_NODEJS_ORG_MIRROR=https://nodejs.org/download/chakracore-nightly 对于一些正在测试的尝鲜版本，可以在下面的地址下载。 NVM_NODEJS_ORG_MIRROR=https://nodejs.org/download/test","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://qiandream.cn/tags/Node/"}]},{"title":"JS-this、call、apply","slug":"JS-this、call、apply","date":"2019-06-13T05:00:52.000Z","updated":"2019-06-16T09:51:28.472Z","comments":true,"path":"2019/06/13/js-this-call-apply/","link":"","permalink":"http://qiandream.cn/2019/06/13/js-this-call-apply/","excerpt":"导语 在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。","text":"导语 在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。 thisJavascript 中的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的。 this 的指向在具体实际应用中，this 的指向通常可分为以下4种: 作为对象的方法调用 作为普通函数调用 作为构造器调用 Function.prototype.call、Function.prototype.apply 作为对象的方法调用当函数作为对象的方法调用时，this 指向该对象： var obj = { a: 1, getA: function () { console.log(this.a) } } obj.getA() // 1 作为普通函数调用函数作为普通函数调用，此时的 this 总是指向全局对象。在浏览器中，这个全局对象是 window 对象。 var a = 1 var getName = function () { console.log(this.a) } getName() // 1 作为构造器调用当用 new 运算符调用函数时，该函数会返回一个对象。通常情况下，构造器里的 this 就指向返回的这个对象。 var MyClass = function () { this.name = 'sven' } var obj = new MyClass() console.log(obj.name) // 'sven' 如果构造器显式地返回了一个对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this。 var MyClass = function () { this.name = 'sven' return { name: 'wang' } } var obj = new MyClass() console.log(obj.name) // wang 如果构造器不显式地返回任何数据，或者返回一个非对象类型的数据，就不会造成上述问题。 var MyClass = function () { this.name = 'sven' return 'wang' } var obj = n console.log(obj.name) // 'sven' Function.prototype.call、Function.prototype.apply用 Function.prototype.call、Function.prototype.apply 可以动态改变传入函数的 this。 var obj1 = { name: 'wang', getName: function () { console.log(this.name) } } var obj2 = { name: 'zhang' } obj1.getName() obj1.getName.call(obj2) // 'wang' // 'zhang' 丢失的 this举个例子： var obj = { name: 'wang', getName: function () { console.log(this.name) } } obj.getName() getName = obj.getName getName() // 'wang' // undefined 当调用 obj.getName 时，此时 this 指向 obj 对象，所以输出 ‘wang’。 当用另外一个变量 getName 来引用 obj.getName，并且调用时，它是被当作普通函数来调用，此时 this 指向 window 对象，所以输出 undefined。 call 和 apply在实际开发中，特别是在一些函数式风格的代码编写中，call 和 apply 方法尤为重要。 区别call 和 apply 作用一模一样，区别在于传入参数形式的不同。 apply 接受两个参数，第一个参数指定了函数体内的 this 对象的指向，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。 call 传入的参数数量不固定，跟 apply 不同的是，第一个参数也是代表函数体内 this 对象的指向，从第二个参数开始，每个参数依此传入函数。 当使用 call 或者 apply 时，如果我们传入的第一个参数为 null，则函数体内的 this 会指向默认的宿主对象。 但如果在严格模式下，函数体内的 this 还是为 null。 call 和 apply 的用途下面将详细介绍 call 和 apply 在实际开发中的用途。 改变 this 指向var obj1 = { name: 'wang' } var obj2 = { name: 'zhang' } var name = 'qian' var getName = function () { console.log(this.name) } getName () // 'qian' getName.call(obj1) // 'wang' getName.call(obj2) // 'zhang' Function.prototype.bind大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向。即使没有原生的 Function.prototype.bind ，我们也可以自己来模拟： Function.prototype.bind = function (context) { let self = this // 保存原函数 console.log(this) return function () { // 返回一个新的函数 return self.apply(context, arguments) // 执行新的函数时，会把之前传入的 context 当作新函数体内的 this } } var obj = { name: 'seven' } var func = function () { console.log(this.name) }.bind(obj) func() 上述为一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一些，使得可以在 func 函数中预先填入一些参数： Function.prototype.bind = function () { console.log(arguments) var self = this, // 保存原函数 context = [].shift.call(arguments), // 需要绑定的 this 上下文 args = [].slice.call(arguments) // 剩余的参数转化为数组 console.log(context) console.log(args) return function () { // 返回一个新韩淑 return self.apply(context, [].concat(args, [].slice.call(arguments))) // 执行新的函数时，把之前传入的 context 当作新函数体内的 this，并且组合两次分别传入的参数，作为新函数的参数 } } var obj = { name: 'seven' } var func = function (a, b, c, d) { console.log(this.name) console.log([a, b, c, d]) }.bind(obj, 1, 2) func(3, 4) 借用其他对象的方法借用方法的第一种场景是”借用构造函数“，通过这种技术，可以实现一些类似继承的效果： var A = function (name) { this.name = name } var B = function () { A.apply(this, arguments) } B.prototype.getName = function () { return this.name } var b = new B('wang') console.log(b.getName()) // 'wang' 附： 函数的参数列表 arguments 是一个类数组对象，并不是真正的数组。 如果想在 arguments 中添加一个元素，通常会借用 Array.prototype.push 如果想把 arguments 转换为真正的数组，通常会借用 Array.prototype.slice 如果想截取 arguments 中的第一个元素，通常会借用 Array.prototype.shift","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"Vue-源码系列随读笔记之Object变化侦测","slug":"Vue-源码系列随读笔记之Object变化侦测","date":"2019-05-16T10:34:52.000Z","updated":"2019-08-17T17:08:47.848Z","comments":true,"path":"2019/05/16/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-object-bian-hua-zhen-ce/","link":"","permalink":"http://qiandream.cn/2019/05/16/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-object-bian-hua-zhen-ce/","excerpt":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档","text":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档 什么是变化侦测从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。 简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。 Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。 如何追踪变化首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。 function defineReactive (data, key, val) { Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { return val }, set: function(newVal) { if (val === newVal) { return } val = newVal } }) } 此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。 由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。 如何收集依赖思考以下问题： let globalObj = { text1: 'text1' }; let o1 = new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;div>`, data: globalObj }); let o2 = new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;div>`, data: globalObj }); 该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？ 对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。 即：在 getter 中收集依赖，在 setter 中触发依赖。 依赖收集到哪里（Dep） 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。 export default class Dep { constructor () { this.subs = [] // 观察者集合 } // 添加观察者 addSub (sub) { this.subs.push(sub) } // 移除观察者 removeSub (sub) { remove(this.subs, sub) } depend () { // 如果存在 Dep.target，则进行依赖收集操作 if (Dep.target) { this.addSub(Dep.target) } } notify () { const subs = this.subs.slice() // 避免污染原来的集合 for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() // 更新 } } } function remove(arr, item) { if (arr.length) { const index = arr.indexOf(item) if (index > -1) { return arr.splice(index, 1) } } } 改造 defineReactive function defineReactive (data, key, val) { let dep = new Dep() Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { dep.depend() return val }, set: function(newVal) { if (val === newVal) { return } val = newVal dep.notify() } }) } 什么是依赖当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。 然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。 收集谁？Watcher! 什么是 WatcherWatcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。 vm.$watch('a.b.c', function(newVal, oldVal) { // do something }) 这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。 把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。 export default class Watcher { // ... constructor ( vm: Component, // 组件实例 expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作 cb: Function // 被观察者发生变化后的回调 ) { this.vm = vm // Watcher有一个 vm 属性，表明它是属于哪个组件的 this.cb = cb // 回调 this.getter = parsePath(expOrFn) this.value = this.get() } get () { // 触发取值操作，进而触发属性的getter Dep.target = this let value = this.getter.call(this.vm, this.vm) Dep.target = null return value } update () { // 更新 const oldValue = this.value this.value = this.get() this.cb.call(this.vm, this.value, oldValue) } } 这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。 在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。 只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。 依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。 不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。 parsePath函数： const bailRE = /[^\\w.$]/ export function parsePath(path) { if (bailRE.test(path)) { return } const segments = path.split('.') return function(obj) { for (let i = 0; i &lt; segments.length; i++) { if (!obj) return obj = obj[segments[i]] } return obj } } 递归侦测所有Key前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化： export class Observer { constructor (value) { this.value = value if (!Array.isArray(value)) { this.walk(value) } } walk (obj) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive (obj, keys[i], obj[keys[i]]) } } } function defineReactive(data, key, val) { if (typeof val === 'object') { new Observer(val) } let dep = new Dep() Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { dep.depend() return val }, set: function(newVal) { if (val === newVal) { return } val = newVal dep.notify() } }) } Observer 类，用于将一个正常的 object 转换成被侦测的 object。 判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。 最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。 当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。 总结变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。 Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。 我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。 收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。 所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。 Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。 由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。 在 Vue 中，对象新增属性或删除属性都无法被侦测到。 Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。 当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。 当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。 Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://qiandream.cn/tags/Vue/"}]},{"title":"JS-数据结构与算法之链表","slug":"JS-数据结构与算法之链表","date":"2019-03-25T12:57:52.000Z","updated":"2019-03-25T12:24:33.483Z","comments":true,"path":"2019/03/25/js-shu-ju-jie-gou-yu-suan-fa-zhi-lian-biao/","link":"","permalink":"http://qiandream.cn/2019/03/25/js-shu-ju-jie-gou-yu-suan-fa-zhi-lian-biao/","excerpt":"导语 使用列表对数据进行排序，底层储存数据的数据结构是数组。然而，数组并不总是最优选择。","text":"导语 使用列表对数据进行排序，底层储存数据的数据结构是数组。然而，数组并不总是最优选择。 数组的缺点数组不总是组织数据的最佳数据结构，原因如下：在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再需要加入新的元素就会非常困难。 在数组中，添加和删除元素也很麻烦，需要将数组中的其它元素向前或向后移动，以反映数组刚刚进行了添加或删除操作。 如果你发现数组在实际使用时很慢，就可以考虑使用链表来替代它。除了对数据的随机访问，","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"JS-数据结构与算法之队列","slug":"JS-数据结构与算法之队列","date":"2019-03-16T12:57:52.000Z","updated":"2019-03-23T09:33:40.176Z","comments":true,"path":"2019/03/16/js-shu-ju-jie-gou-yu-suan-fa-zhi-dui-lie/","link":"","permalink":"http://qiandream.cn/2019/03/16/js-shu-ju-jie-gou-yu-suan-fa-zhi-dui-lie/","excerpt":"导语 队列是一种列表，不同的是，队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。","text":"导语 队列是一种列表，不同的是，队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。 对队列的操作队列的两种主要操作是：向队列中插入新元素和删除队列中的元素。插入操作也叫做入队，删除操作也叫做出队。入队操作在队尾插入新元素，出队操作删除队头的元素。 队列的另一项重要操作是读取队头的元素，这个操作叫 peek() 。该操作返回队头元素，但不把它从队列中删除。除了读取队头元素，我们还可以用 length 属性来知道队列中存储了多少元素，用 clear() 方法来清空队列中的元素。 用数组实现的队列使用数组来实现队列看起来顺理成章。数组的 push() 方法可以在数组末尾加入元素，shift() 方法则可以删除数组的第一个元素。 push() 方法将它的参数插入数组中第一个开放的位置，该位置总在数组的末尾，即使是个空数组也是如此。 准备开始实现 Queue 类，先从构造函数开始： function Queue () { this.dataStore = [] this.enqueue = enqueue this.dequeue = dequeue this.front = front this.back = back this.toString = toString this.empty = empty } enqueue() 方法向队尾添加一个元素 function enqueue (element) { this.dataStore.push(element) } dequeue() 方法删除队首的元素 function dequeue () { return this.dataStore.shift() } 使用如下的方法读取队首和队尾的元素 function front () { return this.dataStore[0] } function back () { return this.dataStore[this.dataStore.length -1] } toString() 方法显示队列内的所有元素 function toString () { var retStr = '' for (var i = 0; i &lt; this.dataStore.length; i++) { retStr += this.dataStore[i] + ' ' } return retStr } empty() 方法判断队列是否为空 function empty () { return this.dataStore.length === 0 } 使用队列：方块舞的舞伴分配问题男男女女来到舞池，他们按照自己的性别排成两队。当舞池中有地方空出来时，选两个队列中第一个人组成舞伴。他们身后的人各自向前移动一个位置，变成新的队首。当一对舞伴迈入舞池时，主持人会大声喊出他们的名字。当一队舞伴走出舞池，且两排队伍中有任意一队没人时，主持人也会把这个情况告诉大家。 为了模拟这种情况，我们把跳方块舞的男男女女的姓名储存在 dancers 变量中： var dancers = 'F Allison \\n M Frank \\n M Mason \\n M Clayton \\n F Cheryl \\n M Raymond \\n F Jennifer \\n M Bryan \\n M David \\n M Danny \\n F Aurora' 每个舞者的信息都被存储在一个 Dancer 对象中： function Dancer (name, sex) { this.name = name this.sex = sex } 下面我们需要一个函数，将舞者信息读到程序中： function getDancers (maleDancers, femaleDancers) { var names = dancers.split('\\n') for (var i = 0; i &lt; names.length; i++) { names[i] = names[i].trim() } for (var i = 0; i &lt; names.length; i++) { var dancer = names[i].split(' ') var sex = dancer[0] var name = dancer[1] if (sex === 'F') { femaleDancers.enqueue(new Dancer(name, sex)) } else { maleDancers.enqueue(new Dancer(name, sex)) } } } 舞者的姓名被从变量 dancers 中读入数组。然后 trim() 函数除去了每行字符串的空格。第二个循环将每行字符串按姓名和性别分成两部分存入一个数组。然后根据性别，将舞者加入不同的队列。 下一个函数将男性和女性组成舞伴，并且宣布配对结果。 function dance (females, males) { console.log('the dance partners are: ') let person while (!females.empty() &amp;&amp; !males.empty()) { person = females.dequeue() console.log('female dancer is ', person) person = males.dequeue() console.log('and male dancer is ', person) } } 使用队列对数据进行排序队列不仅用于执行现实生活中与排队有关的操作，还可以用于对数据进行排序。对于0 ~99 的数字，我们可以基于基数排序对数据扫描两次。第一次按个位上的数字进行排序，第二次按十位上的数字进行排序。每个数字根据对应位上的数值被分在不同的盒子上。假设有以下数字： 91, 46, 85, 15, 92, 35, 31, 22 经过基数排序第一次扫描之后，数字被分配到如下的盒子里： Bin 0: Bin 1: 91, 31 Bin 2: 92, 22 Bin 3: Bin 4: Bin 5: 85, 15, 35 Bin 6: 46 Bin 7: Bin 8: Bin 9: 根据盒子的顺序，第一次排序的结果如下： 91, 31, 92, 22, 85, 15, 35, 46 然后根据十位上的数值再次将上述排序的结果分配到不同的盒子里： Bin 0: Bin 1: 15 Bin 2: 22 Bin 3: 31, 35 Bin 4: 46 Bin 5: Bin 6: Bin 7: Bin 8: 85 Bin 9: 91, 92 最后，将盒子中的数字取出，组成一个新的列表，该列表即为排好序的数字： 15， 22， 31， 35， 46， 85， 91， 92 使用队列代表盒子，可以实现这个算法。我们需要九个队列，每个对应一个数字，将所有队列保存在一个数组中，使用取余和除法操作决定个位和十位。算法的剩余部分将数字加入相应的队列，根据个位数值对其重新排序，然后再根据十位上的数值进行排序，结果即为排好序的数字。 function Queue () { this.dataStore = [] this.enqueue = enqueue this.dequeue = dequeue this.front = front this.back = back this.toString = toString this.count = count this.empty = empty } function enqueue (element) { this.dataStore.push(element) } function dequeue () { return this.dataStore.shift() } function front () { return this.dataStore[0] } function back () { return this.dataStore[this.dataStore.length -1] } function toString () { var retStr = '' for (var i = 0; i &lt; this.dataStore.length; i++) { retStr += this.dataStore[i] + ' ' } return retStr } function count () { return this.dataStore.length } function empty () { return this.dataStore.length === 0 } //基数排序 var queues = [] //定义队列数组 var nums = [] //定义数字数组 //选十个0~99的随机数进行排序 for (var i = 0; i &lt; 10; i ++){ queues[i] = new Queue() nums[i] = Math.floor( Math.random() * 101 ) } //排序之前 console.log( 'before radix sort: ' + nums ) //基数排序 distribution(nums, queues , 10 , 1) collect(queues, nums) distribution(nums, queues , 10 , 10) collect(queues, nums) //排序之后 console.info('after radix sort: ' + nums) //根据相应的（个位和十位）数值，将数字分配到相应队列 function distribution (nums, queues, n, digit) { //digit表示个位或者十位的值 for(var i = 0; i &lt; n; i++){ if(digit == 1){ queues[nums[i] % 10].enqueue(nums[i]) }else{ queues[Math.floor(nums[i] / 10)].enqueue(nums[i]) } } console.log(queues.toString()) } //从队列中收集数字 function collect (queues, nums) { var i = 0 for (var digit = 0; digit &lt; 10 ; digit++ ){ while (!queues[digit].empty()){ nums[i++] = queues[digit].dequeue() } } } 优先队列一般情况下，从队列中删除元素，一定是最新入队的元素，但是也有一些使用队列的应用，在删除元素时不必遵循先进先出的约定。这种应用，需要使用一个叫做优先队列的数据结构来进行模拟。 从优先队列中删除元素时，需要考虑优先权的限制。 先来定义存储队列元素的对象，然后在构建我们的优先队列系统： function Patient (name, code) { this.name = name this.code = code } 变量 code 是一个整数，表示优先级。 现在需要重新定义 dequeue() 方法，使其删除队列中拥有最高优先级的元素。我们规定，优先码的值最小，代表优先级最高。新的 dequeue() 方法遍历队列的底层存储数组，从中找出优先码值最小的元素，然后使用数组的 splice() 方法删除优先级最高的元素。新的 dequeue() 方法定义如下所示： function dequeue () { var entry = 0 for (var i = 1; i &lt; this.dataStore.length; ++i) { if (this.dataStore[i].code &lt; this.dataStore[entry].code) { entry = i } } return this.dataStore.splice(entry, 1) } 优先队列的实现： function Queue () { this.dataStore = [] this.enqueue = enqueue this.dequeue = dequeue this.front = front this.back = back this.toString = toString this.count = count this.empty = empty } function enqueue (element) { this.dataStore.push(element) } function dequeue () { var entry = 0 for (var i = 1; i &lt; this.dataStore.length; ++i) { if (this.dataStore[i].code &lt; this.dataStore[entry].code) { entry = i } } return this.dataStore.splice(entry, 1) } function front () { return this.dataStore[0] } function back () { return this.dataStore[this.dataStore.length -1] } function toString () { var retStr = '' for (var i = 0; i &lt; this.dataStore.length; i++) { retStr += this.dataStore[i].name + ' code:' + this.dataStore[i].code + ' ' } return retStr } function count () { return this.dataStore.length } function empty () { return this.dataStore.length === 0 } function Patient (name, code) { this.name = name this.code = code } var p = new Patient('smith', 5) var ed = new Queue() ed.enqueue(p) p = new Patient('Jones', 4) ed.enqueue(p) p = new Patient('Wang', 6) ed.enqueue(p) p = new Patient('Qian', 1) ed.enqueue(p) p = new Patient('Brown', 1) ed.enqueue(p) var seen = ed.dequeue() console.log('Patient being treated: ' + seen[0].name) console.log('Patients watting to be seen:') console.log(ed.toString()) seen = ed.dequeue() console.log('Patient being treated: ' + seen[0].name) console.log('Patients watting to be seen:') console.log(ed.toString()) seen = ed.dequeue() console.log('Patient being treated: ' + seen[0].name) console.log('Patients watting to be seen:') console.log(ed.toString())","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"JS-数据结构与算法之栈","slug":"JS-数据结构与算法之栈","date":"2019-03-15T12:57:52.000Z","updated":"2019-03-18T12:55:26.303Z","comments":true,"path":"2019/03/15/js-shu-ju-jie-gou-yu-suan-fa-zhi-zhan/","link":"","permalink":"http://qiandream.cn/2019/03/15/js-shu-ju-jie-gou-yu-suan-fa-zhi-zhan/","excerpt":"导语 栈是和列表类似的一种数据结构，它可以用来解决计算机世界里的很多问题。","text":"导语 栈是和列表类似的一种数据结构，它可以用来解决计算机世界里的很多问题。 对栈的操作栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈被称为一种后入先出 (LIFO，last-in-first-out) 的数据结构。 由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，必须先拿掉上面的元素。 对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用 push() 方法，出栈使用 pop() 方法。 另一个常用的操作就是预览栈顶的元素。 pop() 方法虽然可以访问到栈顶的元素，但是该方法也将栈顶元素永久性地删除了。peek() 方法则只返回栈顶元素，而不删除它。 为了记录栈顶的位置，同时也为了哪里可以加入新元素，我们使用变量 top 。当向栈内压入元素时，该变量增大。当从栈内弹出元素时，该变量减小。 push()、pop()、peek() 是栈的3个主要方法，但是栈还有其它方法和属性。clear() 清除栈内所有元素，length 属性记录栈内元素的个数，empty 属性，用以表示栈内是否有元素。 栈的实现实现一个栈，首先是要决定存储数据的底层数据结构。这里，我们选用数组。 我们从实现以定义 Stack 类的构造函数开始： function Stack () { this.dataStore = [] this.top = 0 this.push = push this.pop = pop this.peek = peek this.clear = clear this.length = length } 我们用数组 dataStore 来保存栈内的元素，构造函数将其初始化为一个空数组。变量 top 记录栈顶位置，被构造函数初始化为 0 ，表示栈顶对应数组的起始位置 0 。如果有元素被压入栈内，该变量的值将随之变化。 push() 方法 – 当向栈内压入一个新元素时，需要将其保存在数组中变量 top 所对应的位置，然后将 top 值加 1，让其指向数组中下一个空位值。 function push (element) { this.dataStore[this.top++] = element } 这里需要注意 ++ 操作符的位置，它放在 this.top 的后面，这样新入栈的元素就会被放在 top 的当前值指向的位置，然后再将 top 的值加 1 ，指向下一个位置。 pop() 方法 – 返回栈顶元素，同时将变量 top 的值减 1 。 function pop () { return this.dataStore[--this.top] } peek() 方法 – 返回栈顶元素，即将变量 top 的值减 1 。 function peek () { return this.dataStore[this.top - 1] } 如果对一个空栈调用 peek() 方法，结果为 undefined 。 length() 方法 – 通过返回变量 top 值得方式来获取栈内存储了多少元素。 clear() – 将变量 top 的值设为 0 ，轻松清空一个栈。 function clear () { this.top = 0 } 使用 Stack 类在开发过程中，有一些问题特别适合用栈来解决： 数制间的相互转换可以利用栈实现一个数字从一种数制转换为另一种数制。假设想将数字 n 转换为以 b 为基数的数字，实现转换的算法如下(注：此算法只针对基数为2—9的情况)： (1) 最高位为 n % b，将此位压入栈。(2) 使用 n / b 代替 n 。(3) 重复步骤 1 和 2 ，直到 n 等于 0 ，且没有余数。(4) 持续将栈内元素弹出，直到栈为空，依次将这些元素排列，就得到转换后数字的字符串形式。 function mulBase (num, base) { var s = new Stack() do { s.push(num % base) num = Math.floor(num /= base) } while (num > 0) var converted = '' while (s.length() > 0) { converted += s.pop() } return converted } 回文回文是指这样一种现象：一个单词、短语或数字，从前往后写和从后往前写都是一样的。如：单词 ‘dad’ , ‘racecar’ 就是回文。 使用栈，可以轻松判断一个字符串是否是回文。我们将拿到的字符串的每个字符从左到右的顺序压入栈。当字符串中的字符都入栈后，栈内就保存了一个反转后的字符串，最后的字符在栈顶，第一个字符在栈底。 字符串完整压入栈内后，通过持续弹出栈中的每个字母就可以得到一个新字符串，该字符串刚好与原来的字符串顺序相反。我们只需比较这两个字符串即可，如果它们相等，就是一个回文。 function isPalindrome (word) { var s = new Stack() for (let i of word) { s.push(i) } var rWord = '' while (s.length() > 0) { rWord += s.pop() } return rWord == word } 递归演示为了演示如何用栈实现递归，考虑一下求阶乘函数的递归定义，首先看看 5 的阶乘是怎么定义的： function factorial (n) { if (n === 0) { return 1 } return n * factorial(n - 1) } 使用栈模拟递归的过程 function fact (n) { var s = new Stack() while (n > 1) { s.push(n--) } var product = 1 console.log(s.length()) while (s.length() > 0) { product *= s.pop() } return product }","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"Node-阿里云ECS部署","slug":"Node-阿里云ECS部署","date":"2018-11-27T04:19:00.000Z","updated":"2019-06-04T02:56:38.236Z","comments":true,"path":"2018/11/27/node-a-li-yun-ecs-bu-shu/","link":"","permalink":"http://qiandream.cn/2018/11/27/node-a-li-yun-ecs-bu-shu/","excerpt":"导语 双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？","text":"导语 双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？ 此教程仅供新手借鉴，多少有些缺陷，有问题还望各位大佬指正。 准备工作 一个域名 阿里云ECS(实例镜像：CentOS7.4) 如果使用Windows，推荐xshell。如果是Mac，推荐iTerm2 (注：因本人使用Mac，以下均已Mac为主) 终端连接服务器 打开iTerm2，输入连接命令ssh username@ip公网地址，回车，输入你在购买服务器时设置的密码。 密码输入正确，进入服务器。 cd / 进入根目录，创建一个空目录 mkdir soft，用来放我们的安装包。 安装Node下载node包。 wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz 下载完成后，进行压缩包解压。 tar -zxvf v8.9.4.tar.gz 进入解压好的目录并执行config配置命令。 cd node-v8.9.4 &amp;&amp; ./configure 执行编译及安装命令。 make &amp;&amp; make install 经过漫长的等待之后，一个node环境就安装好了。可以通过node -v 或者 npm -v来检查当前node/npm是否安装成功。 如果你需要升级node和npm版本，执行以下命令即可。 npm i -g n n stable 安装nrm和pm2nrm是一个管理npm源的插件，方便切换国内外以及私人npm库。 pm2是node服务器的守护进程，方便管理当前服务器上的所有服务。 这里说一下cnpm，如果安装依赖包很慢或者根本没进度，输入命令 npm install -g cnpm --registry=https://registry.npm.taobao.org 然后使用cnpm代替npm安装。 回到我们熟悉的soft目录。 nrm安装nrm。 npm install -g nrm 常用命令： nrm add name address 添加新的源 nrm use name 切换到源 nrm ls 查看所有可用的源 pm2安装pm2。 npm install -g pm2 常用命令： pm2 list 查看pm2守护服务 pm2 start index.js 启动一个pm2守护进程命令 pm2 restart id/name 重启一个pm2守护进程命令 pm2 delete id/name 删除一个正在使用的进程 pm2 delete all 删除所有正在使用的进程 pm2 monit 查看pm2的消耗 安装mysql卸载已有的mysql。 rpm -qa|grep -i mysql yum remove &#39;mysql&#39; 下载mysql源。 // 5.7.24 wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm 安装下载的源。 rpm -ivh mysql57-community-release-el7-7.noarch.rpm 下载安装mysql。 yum install mysql-server yum install mysql-devel yum install mysql 启动mysql。 service mysqld start 常用命令： service mysqld status 查看mysql当前的状态 service mysqld stop 停止mysql service mysqld restart 重启mysql service mysqld start 启动mysql 如果遇到错误：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket /var/lib/mysql/mysql.sock’，请在tmp下创建一个软连接： ln -s /tmp/mysql.sock /var/lib/mysql 打开my.cnf并修改。 vi /etc/my.cnf 重启数据库。 service mysqld restart 登录(默认root是没有密码的)。 mysql -u root 这时出现ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)，登录root帐号需要密码，现在我们没有设置密码，哪来的密码。 于是我们开始忘记密码的操作 第一步，在/etc/my.cnf文件中添加skip-grant-tables第二步，重启mysql，service mysqld restart第三步，登录mysql，mysql -u root第四步，修改密码： mysql&gt;use mysql; mysql&gt;update mysql.user set authentication_string=password(&#39;your password&#39;) where user=&#39;root&#39;; mysql&gt;flush privileges; mysql&gt;exit; 第五步，恢复/etc/my.cnf，将skip-grant-tables删除或者注释掉第六步，重启mysql，service mysqld restart 分配用户 host指定该用户在哪个主机上可以登陆，此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录;也可以指定某台机器可以远程登录。 CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;; CREATE USER &#39;test&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39;; 给创建的用户权限 privileges 用户的操作权限,如SELECT，INSERT，UPDATE等.如果要授予所的权限则使用ALL databasename 数据库名 tablename 表名,如果要授予该用户对所有数据库和表的相应操作权限则可用表示, 如.*. GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39; 安装RedisRedis是一个非常好用的数据仓库，既可以做nosql数据库，也可以做缓存数据库。 下载安装包。 wget http://download.redis.io/releases/redis-4.0.6.tar.gz 解压并进入解压之后的文件夹。 tar -zxvf redis-4.0.6.tar.gz &amp;&amp;cd redis-4.0.6 编译并安装。 make &amp;&amp; make install 启动redis服务。 redis-server redis.conf 此时我们发现，不能再输入任何命令，因为redis-server已经占用了这个命令行客户端。我们需要再打开一个命令行工具并连接服务器。 使用redis客户端连接Redis服务，执行Redis文件夹下的redis-cli文件redis-cli，输入几个命令测试一下简单的set/get： 关掉客户端，redis服务也会停止。这时，我们就需要修改redis.conf文件，将daemonizede的值改为yes。 再次运行Redis的启动命令redis-server redis.conf，这次就不会占用命令行了，可以继续操作其他的，Redis服务也不会停止。 nginxnginx在转发请求，负载均衡等方面非常有用。它可以将几个不同的服务集中在一个80端口下，根据域名或者请求路径来区分。 在安装nginx之前，先要安装几个依赖插件。 yum install -y pcre pcre-devel yum install -y zlib zlib-devel 安装openssl。 yum install -y openssl openssl-devel 下载nginx包。 wget https://nginx.org/download/nginx-1.15.6.tar.gz 解压并进入解压好的目录。 tar -zxvf nginx-1.15.6.tar.gz &amp;&amp; cd nginx-1.15.6 执行配置命令。 ./configure 编译并安装。 make &amp;&amp; make install 查看安装结果。 whereis nginx 跳转到安装好的nginx目录下，进入sbin目录。 cd /usr/local/nginx/sbin 启动nginx。 ./nginx 常用命令： ./nginx 启动nginx ./nginx -s stop 停止nginx ./nginx -s quit 退出nginx ./nginx -s reload 重启nginx 安装GitcentOS上没有安装git，有需要的话，我们可以自己手动安装一下。 yum install git git --version 使用pm2启动项目在本地搭建并测试好node项目，上传到GitHub。然后git clone一下。 配置ECS安全组规则，暴露3000接口。 如果项目中使用数据库，运行之前要先建立好数据库，然后再运行项目，登录数据库执行create database dabasename; git clone https://github.com/*** cd *** cnpm i pm2 start index.js 注：项目监听3000端口，如果顺利的话，项目已经运行起来了。 可以使用pm2 list查看进程列表，使用pm2 log打印日志。 Linux常用操作指令列表 命令 说明 ssh username@ip 连接服务器 cd path 跳转到路径对应的目录下 rm filename 删除文件 rm -rf path 删除目录及目录下的所有文件 ls [-a] 查看当前目录下的文件和目录(-a：查看所有文件，包括隐藏文件) ll 查看当前目录下的文件详情(文件权限) pwd 查看当前路径的完整路径 which name 默认位置查找该名字 mkdir dirname 创建空目录 cat path 查看文件内容 cp origin target 复制一个文件到另一个地方 mv origin target 移动一个文件到另一个地方 ps -aux 显示当前进程 kill -9 processid 结束进程 tar -zxvf filename 解压文件 tar -zcvf filename 压缩文件 vi path 进入文件编辑模式 vi编辑文件，按下i进入编辑模式 vi退出文件，esc+:wq或esc+:x保存退出 vi退出文件，esc+:q或esc+:q!强制退出","categories":[{"name":"后端","slug":"后端","permalink":"http://qiandream.cn/categories/后端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://qiandream.cn/tags/Node/"}]},{"title":"JS-深拷贝与浅拷贝","slug":"JS-深拷贝与浅拷贝","date":"2018-10-11T10:11:52.000Z","updated":"2018-12-11T14:03:41.509Z","comments":true,"path":"2018/10/11/js-shen-kao-bei-yu-qian-kao-bei/","link":"","permalink":"http://qiandream.cn/2018/10/11/js-shen-kao-bei-yu-qian-kao-bei/","excerpt":"导语 当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。","text":"导语 当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。 实例🌰： var a = {x: 10, y: 10} var b = a b.x = 100 b.y = 100 打印一下a和b的值： console.log(a) // {x: 100, y: 200} console.log(b) // {x: 100, y: 200} 发现改变b的值，同时也改了a的值。 🌰： var a = 10 var b = a b = 20 打印一下a和b的值： console.log(a) // 10 console.log(b) // 20 ??? b的值改变并没有引起a的值改变。 值类型 vs 引用类型在JS中，变量传递方式分为值类型和引用类型。值类型包括String，Number，Null，Boolean，Undefined。引用类型包括Object类的所有，如Date，Array，Function。 在参数传递方式上，值类型是按值传递。引用类型是按共享传递(指向同一个内存地址，两者引用同一个值，当一者改变值，另一者也改变)。 JS这样设计的原因在于：按值传递的类型，复制一份存入栈内存，这类类型一般不会占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值，保证过大的对象等不会因为不停复制内容而造成内存的浪费。 深拷贝和浅拷贝最根本的区别在于是否真正获取了一个对象的拷贝实体，而不只是引用。 浅拷贝的实现方式直接赋值🌰： let obj = {username: &#39;kobe&#39;, age: 39, sex: {option1: &#39;男&#39;, option2: &#39;女&#39;}} let obj1 = obj obj1.sex.option1 = &#39;不男不女&#39; // 修改复制的对象会影响原对象 打印obj1的值 console.log(obj1) // {username: &#39;kobe&#39;, age: 39, sex: {option1: &#39;不男不女&#39;, option2: &#39;女&#39;}} Object.assign🌰： let obj = { username: &#39;kobe&#39; }; let obj1 = Object.assign(obj) obj1.username = &#39;wang&#39; 打印obj的值 console.log(obj) // { username: &quot;wang&quot; } Array.prototype.concat🌰： let arr = [1, 3, { username: &#39;kobe&#39; }] let arr2=arr.concat() arr2[2].username = &#39;wang&#39; 打印arr的值 console.log(arr) // [1, 3, { username: &quot;wade&quot; }] Array.prototype.slice🌰： let arr = [1, 3, { username: &#39;kobe&#39; }] let arr2=arr.slice() arr2[2].username = &#39;wang&#39; 打印arr的值 console.log(arr) // [1, 3, { username: &quot;wade&quot; }] Array.prototype.concat vs Array.prototype.slice关于Array的concat和slice补充说明：Array的concat和slice方法不改变原始数组，只是返回了一个浅复制原数组中的元素的一个新数组。 原数组中的元素会按照下述规则拷贝： 如果该元素是个引用类型，slice或者concat会拷贝这个引用到新的数组里，两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新数组和原数组中的这个元素都会发生改变。 如果该元素是个值类型，slice或者concat会复制一份这些值到新数组里。在别的数组里修改这些值，并不会影响另一个数组。 🌰： let arr = [1, 3, { username: &#39;kobe&#39; }]; let arr3 = arr.slice(); arr3[1] = 2 console.log(arr, arr3) 打印arr和arr3的值 console.log(arr, arr3) // ---result // [1, 3, { username: &quot;kobe&quot; }] // [1, 2, { username: &quot;kobe&quot; }] 深拷贝的实现方式Object.assignObject.assign可以进行一层深度拷贝 🌰： var obj = { name: &#39;wang&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj1 = Object.assign({}, obj1) obj1.age = 24 console.log(obj, obj1) 打印obj和obj1的值 console.log(obj, obj1) // ----result // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { } } // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { }, age: 24 } 然而。。。。。 🌰： var obj = { name: &#39;wang&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj1 = Object.assign({}, obj1) obj1.test4.age = 24 打印obj和obj1的值 console.log(obj, obj1) // ----result // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { age: 24 } } // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { age: 24 } } JSON.parse(JSON.stringfy(obj))说到深拷贝，你肯定会想到JSON.parse(JSON.stringfy(obj))。 🌰： var obj = { name: &#39;wang&#39;, test: { name: &#39;test&#39; } }; var obj1 = JSON.parse(JSON.stringify(obj)) obj1.test.name = 24 打印obj和obj1的值 console.log(obj, obj1) // ----result // { name: &quot;wang&quot;, test: { name: &quot;test&quot; } } // { name: &quot;wang&quot;, test: { name: 24 } } 然而。。。。 🌰： var obj = { name: &#39;wang&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj1 = JSON.parse(JSON.stringify(obj)) 打印obj和obj1的值 console.log(obj, obj1) // ---result // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { } } // { name: &quot;wang&quot;, test1: null, test4: { } } ???test2和test3不见了。。。。。 JSON.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个JSON字符串，不能接受函数。 手写递归方法function deepClone(obj) { let result let toString = Object.prototype.toString if (toString.call(obj) === &#39;[Object Array]&#39;) { result = [] for (var i =0; i&lt;obj.length; i++) { result[i] = deepClone(obj[i]) } } else if (toString.call(obj) === &#39;[Object Object]&#39;) { result = {} for (var key in obj) { if (obj.hasOwnProperty(key)) { result[key] = deepClone(obj[key]) } } } else { return obj } return result } 🌰：调用函数并打印结果 var obj = { name: &#39;wang&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj1 = deepClone(obj) console.log(obj, obj21) // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: Object { } } // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: Object { } } jQuery实现🌰： var obj1 = { name: &#39;wang&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj2 = $.extend(true, {}, obj1) lodash实现🌰： var obj1 = { name: &#39;wclimb&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj2 = _.cloneDeep(obj1)","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]}]}