{"meta":{"title":"W | 个人博客 | web前端","subtitle":"wangxiaobai","description":"前端","author":"wangxiaobai","url":"http://qiandream.cn"},"pages":[{"title":"categories","date":"2018-04-11T08:28:54.000Z","updated":"2018-04-11T08:29:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://qiandream.cn/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-02-07T14:06:57.630Z","comments":true,"path":"friends/index.html","permalink":"http://qiandream.cn/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-11T08:28:32.000Z","updated":"2018-04-11T08:28:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://qiandream.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode-006-合并两个有序链表","slug":"LeetCode/Leetcode-007-删除排序数组中的重复项","date":"2020-05-09T12:01:52.000Z","updated":"2020-05-11T16:59:17.993Z","comments":true,"path":"2020/05/09/leetcode/leetcode-007-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/","link":"","permalink":"http://qiandream.cn/2020/05/09/leetcode/leetcode-007-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/","excerpt":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。","text":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 前言 难度：简单 设计知识：数组 题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 题目内容： 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 解题解法 - 遍历、splice/** * @param {number[]} nums * @return {number} */ var removeDuplicates = function(nums) { for (let i = 0; i &lt; nums.length; i++) { if (nums[i] === nums[i+1]) { nums.splice(i, 1) --i } } return nums.length }; 执行测试 输入： [1,1,2] 输出： 2 预期结果： 2 解题思路： 遍历数组，比较当前元素和下一个元素，如果两个元素相等，则移除元素，并处理当前索引(因为元素移除，当前索引值需要减一个值)，继续遍历，直到结束，返回数组长度。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://qiandream.cn/categories/数据结构与算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://qiandream.cn/tags/LeetCode/"}]},{"title":"LeetCode-006-合并两个有序链表","slug":"LeetCode/Leetcode-006-合并两个有序链表","date":"2020-05-09T12:01:52.000Z","updated":"2020-05-11T16:59:24.801Z","comments":true,"path":"2020/05/09/leetcode/leetcode-006-he-bing-liang-ge-you-xu-lian-biao/","link":"","permalink":"http://qiandream.cn/2020/05/09/leetcode/leetcode-006-he-bing-liang-ge-you-xu-lian-biao/","excerpt":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。","text":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 前言 难度：简单 设计知识：链表 题目地址：https://leetcode-cn.com/problems/merge-two-sorted-lists 题目内容： 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题解法 - 递归（链表数据结构、边界）/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ const mergeTwoLists = function (l1, l2) { if (l1 === null) { return l2; } if (l2 === null) { return l1; } if (l1.val &lt;= l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }; 执行测试 输入： [1,2,4] [1,3,4] 输出： [1,1,2,3,4,4] 预期结果： [1,1,2,3,4,4] 解题思路： 使用递归来解题，将两个链表头部较小的一个与剩下的元素合并，并返回排好序的链表头，当两条链表中的一条为空时终止递归。 时间复杂度：O(M+N) 空间复杂度：O(M+N)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://qiandream.cn/categories/数据结构与算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://qiandream.cn/tags/LeetCode/"}]},{"title":"LeetCode-005-有效的括号","slug":"LeetCode/LeetCode-005-有效的括号","date":"2020-05-08T12:01:52.000Z","updated":"2020-05-08T14:45:44.585Z","comments":true,"path":"2020/05/08/leetcode/leetcode-005-you-xiao-de-gua-hao/","link":"","permalink":"http://qiandream.cn/2020/05/08/leetcode/leetcode-005-you-xiao-de-gua-hao/","excerpt":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。","text":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 前言 难度：简单 设计知识：数组、栈 题目地址：https://leetcode-cn.com/problems/valid-parentheses/ 题目内容： 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot; 输出: true 示例 2: 输入: &quot;()[]{}&quot; 输出: true 示例 3: 输入: &quot;(]&quot; 输出: false 示例 4: 输入: &quot;([)]&quot; 输出: false 示例 5: 输入: &quot;{[]}&quot; 输出: true 解题解法 - 栈/** * @param {string} s * @return {boolean} */ var isValid = function(s) { const stack = [] const mapper = { '(': ')', '{': '}', '[': ']' } for (let item of s) { if (['(', '{', '['].indexOf(item) > -1) { stack.push(item) } else { let peak = stack.pop(); if (item !== mapper[peak]) { return false } } } if (stack.length > 0) return false return true }; 执行测试 输入： &quot;()[]{}&quot; 输出： true 预期结果： true 解题思路： 使用栈，遍历输入字符串 如果当前字符为左半边括号时，则将其压入栈中 如果遇到右半边括号时，分类讨论： 1）如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环 2）若此时栈为空，则直接返回 false 3）若不为对应的左半边括号，反之返回 false","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://qiandream.cn/categories/数据结构与算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://qiandream.cn/tags/LeetCode/"}]},{"title":"JS设计模式-构造器模式","slug":"设计模式/构造器模式","date":"2020-05-01T03:54:52.000Z","updated":"2020-05-08T17:10:33.667Z","comments":true,"path":"2020/05/01/she-ji-mo-shi/gou-zao-qi-mo-shi/","link":"","permalink":"http://qiandream.cn/2020/05/01/she-ji-mo-shi/gou-zao-qi-mo-shi/","excerpt":"导语 使用构造函数初始化对象，抽象了每个实例的变与不变。","text":"导语 使用构造函数初始化对象，抽象了每个实例的变与不变。 设计模式的核心操作是去观察你整个逻辑里面的变与不变，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。 真实场景思考：公司员工信息录入系统，每个员工有姓名、年龄、工种，大约有500名员工。 代码实现创建一个 User 构造函数： function User(name , age, career) { this.name = name this.age = age this.career = career } 接下来要做的事情，就是让程序自动地去读取数据库里面一行行的员工信息，然后把拿到的姓名、年龄等字段塞进User函数里，进行一个简单的调用： const user = new User(name, age, career) 思考在创建一个user过程中，谁变了，谁不变？ 很明显，变的是每个user的姓名、年龄、工种这些值，这是用户的个性，不变的是每个员工都具备姓名、年龄、工种这些属性，这是用户的共性。 那么构造器做了什么？ 构造器是不是将 name、age、career 赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了共性的不变，同时将 name、age、career 各自的取值操作开放，确保了个性的灵活？ 在使用构造器模式的时候，我们本质上是去抽象了每个对象实例的变与不变。 参考：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiandream.cn/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiandream.cn/tags/设计模式/"}]},{"title":"JS设计模式-中介者模式","slug":"设计模式/中介者模式","date":"2020-04-15T03:54:52.000Z","updated":"2020-04-23T06:51:50.749Z","comments":true,"path":"2020/04/15/she-ji-mo-shi/zhong-jie-zhe-mo-shi/","link":"","permalink":"http://qiandream.cn/2020/04/15/she-ji-mo-shi/zhong-jie-zhe-mo-shi/","excerpt":"导语 通过一个中介者对象，其它所有相关对象都通过该中介者对象来通信，而不是相互引用，当其中一个对象发生变化时，只需要通知中介者对象即可。通过中介者模式可以解除对象之间的紧耦合关系。","text":"导语 通过一个中介者对象，其它所有相关对象都通过该中介者对象来通信，而不是相互引用，当其中一个对象发生变化时，只需要通知中介者对象即可。通过中介者模式可以解除对象之间的紧耦合关系。 真实场景思考：例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。 代码实现先通过一张 loading 图占位，然后通过异步的方式去加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。 let goods = { //手机库存 'red|32G': 3, 'red|64G': 1, 'blue|32G': 7, 'blue|32G': 6, }; //中介者 const mediator = (function() { let colorSelect = document.getElementById('colorSelect'); let memorySelect = document.getElementById('memorySelect'); let numSelect = document.getElementById('numSelect'); return { changed: function(obj) { switch(obj){ case colorSelect: //TODO break; case memorySelect: //TODO break; case numSelect: //TODO break; } } } })(); colorSelect.onchange = function() { mediator.changed(this); }; memorySelect.onchange = function() { mediator.changed(this); }; numSelect.onchange = function() { mediator.changed(this); }; 参考：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiandream.cn/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiandream.cn/tags/设计模式/"}]},{"title":"JS设计模式-策略模式","slug":"设计模式/策略模式","date":"2020-04-15T03:54:52.000Z","updated":"2020-04-17T04:13:28.617Z","comments":true,"path":"2020/04/15/she-ji-mo-shi/ce-lue-mo-shi/","link":"","permalink":"http://qiandream.cn/2020/04/15/she-ji-mo-shi/ce-lue-mo-shi/","excerpt":"导语 定义一系列算法，将它们一个个封装起来，并使它们可以相互替换。","text":"导语 定义一系列算法，将它们一个个封装起来，并使它们可以相互替换。 真实场景思考：很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放。例如：绩效为 S 的人年终奖有 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，绩效为 B 的人年终奖有 2 倍工资。假设财务要求我们提供一段代码，来方便他们计算员工的年终奖。 最初代码实现我们可以编写一个 calculateBonus 函数来计算每个人的奖金额数，函数需要接受两个参数：员工的工资数额和他的绩效考核等级。 const calculateBonus = function(performanceLevel, salary) { if (performanceLevel === 'S') { return salary * 4; } if (performanceLevel === 'A') { return salary * 3; } if (performanceLevel === 'B') { return salary * 2; } } 可以发现，这段代码十分简单，但存在显而易见的缺点。 函数体庞大，包含很多if-else语句 缺乏弹性，如果新增等级 C，要修改函数内部实现 复用性差 组合函数实现一般我们最容易想到就是使用组合函数来重构代码，把各种算法封装到一个小小的函数里。 const performanceS = function(salary) { return salary * 4; } const performanceA = function(salary) { return salary * 3; } const performanceB = function(salary) { return salary * 2; } const calculateBonus = function(performanceLevel, salary) { if (performanceLevel === 'S') { return performanceS(salary) } if (performanceLevel === 'A') { return performanceS(salary) } if (performanceLevel === 'B') { return performanceS(salary) } } 目前，我们的程序得到了一定的改善，但这种改善非常有限，我们依然没有解决最重要的问题：calculateBonus函数有可能越来越庞大，而且在系统变化的时候缺乏弹性。 策略模式实现策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。 一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context,Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。 let strategies = { 'S': function(salary) { return salary * 4; }, 'A': function(salary) { return salary * 3; }, 'B': function(salary) { return salary * 2; } } const calculateBonus = function(performanceLevel, salary) { return strategies[performanceLevel](salary); } 参考：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiandream.cn/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiandream.cn/tags/设计模式/"}]},{"title":"JS设计模式-代理模式","slug":"设计模式/代理模式","date":"2020-04-15T03:54:52.000Z","updated":"2020-04-23T06:40:31.990Z","comments":true,"path":"2020/04/15/she-ji-mo-shi/dai-li-mo-shi/","link":"","permalink":"http://qiandream.cn/2020/04/15/she-ji-mo-shi/dai-li-mo-shi/","excerpt":"导语 为一个对象提供一个代用品或占位符，以便控制对它的访问。","text":"导语 为一个对象提供一个代用品或占位符，以便控制对它的访问。 真实场景思考：虚拟代理实现图片懒加载 代码实现先通过一张 loading 图占位，然后通过异步的方式去加载图片，等图片加载好了再把完成的图片加载到 img 标签里面。 const imgFunc = (function() { let imgNode = document.createElement('img'); document.body.appendChild(imgNode); return { setSrc: function(src) { imgNode.src = src; } } })(); const proxyImg = (function() { let img = new Image(); img.onload = function() { imgFunc.setSrc(this.src); } return { setSrc: function(src) { imgFunc.setSrc('./loading.gif'); img.src = src } } })(); proxyImg.setSrc('./pic.pmg') 使用代理模式实现图片懒加载的优点还有符合单一职责原则。减少一个类或方法的粒度和耦合度。 参考：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiandream.cn/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiandream.cn/tags/设计模式/"}]},{"title":"数据结构-栈","slug":"数据结构/数据结构-栈","date":"2020-04-14T10:44:52.000Z","updated":"2020-04-14T14:22:07.873Z","comments":true,"path":"2020/04/14/shu-ju-jie-gou/shu-ju-jie-gou-zhan/","link":"","permalink":"http://qiandream.cn/2020/04/14/shu-ju-jie-gou/shu-ju-jie-gou-zhan/","excerpt":"导语 栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。","text":"导语 栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。 基于数组的栈我们将创建一个类来表示栈，需要一种数据结构来保存栈里的元素。可以选择数组。数组允许我们在任何位置添加或删除元素。由于栈遵循LIFO原则，需要对元素的插入和删除功能进行限制。 class Stack { constructor() { this.items = []; } // 新增元素到栈顶 push(element) { this.items.push(element); } // 移除栈顶元素,同时返回被移除的元素 pop() { return this.items.pop(); } // 返回栈顶元素 peek() { return this.items[this.items.length - 1]; } // 是否为空栈 isEmpty() { return this.items.length === 0; } // 返回栈里的元素个数 size() { return this.items.length; } // 清空栈元素 clear() { this.items = [] } } 创建一个 Stack 类最简单的方式是使用一个数组来存储其元素。在处理大量数据的时候，我们同样需要评估如何操作数据是最高效的。在使用数组时，大部分方法的时间复杂度是O(n)。 基于对象的栈我们将创建一个基于对象来存储栈里的元素的类来表示栈，这里新增一个 count 来表示栈的元素个数。 class Stack { constructor() { this.count = 0; this.items = {}; } // 新增元素到栈顶 push(element) { this.items[this.count] = element; this.count++; } // 移除栈顶元素,同时返回被移除的元素 pop() { // 首先判断是否为空 if (this.isEmpty()) { return undefined } this.count--; const result = this.items[this.count]; delete this.items[this.count]; return result; } // 返回栈顶元素 peek() { if (this.isEmpty()) { return undefined; } return this.items[this.count - 1]; } // 是否为空栈 isEmpty() { return this.count === 0; } // 返回栈里的元素个数 size() { return this.count; } // 清空栈元素 clear() { this.count = 0; this.items = {}; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://qiandream.cn/categories/数据结构与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://qiandream.cn/tags/数据结构/"}]},{"title":"JS设计模式-单例模式","slug":"设计模式/单例模式","date":"2020-04-14T03:54:52.000Z","updated":"2020-04-14T04:46:25.202Z","comments":true,"path":"2020/04/14/she-ji-mo-shi/dan-li-mo-shi/","link":"","permalink":"http://qiandream.cn/2020/04/14/she-ji-mo-shi/dan-li-mo-shi/","excerpt":"导语 保证一个类只有一个实例，并提供一个访问它的全局访问点。","text":"导语 保证一个类只有一个实例，并提供一个访问它的全局访问点。 单例模式的实现思路思考：如何才能保证一个类仅有一个实例？ 通常，当我们创建一个类后，可以通过 new 关键字调用构造函数进而生成任意的实例。 class SingleObj { show() { console.log(&#39;我是一个单例对象&#39;) } } const s1 = new SingleObj() const s2 = new SingleObj() // false console.log(s1 === s2) new 一个 s1，new 一个 s2，很明显 s1 和 s2 之间没有任何联系，而单例模式想要做到的是，无论实例化多少次，只返回第一次创建的那个唯一的实例。 要做到这一点，就需要构造函数具备判断自己是否已经创建过一个实例的能力。 写一个静态方法判断逻辑 class SingleObj { show() { console.log('我是一个单例对象') } static getInstance() { // 判断是否已经new过1个实例 if (!SingleObj.instance) { // 若这个唯一的实例不存在，那么先创建它 SingleObj.instance = new SingleObj() } // 如果这个唯一的实例已经存在，则直接返回 return SingleObj.instance } } const s1 = SingleObj.getInstance() const s2 = SingleObj.getInstance() // true s1 === s2 闭包 SingleObj.getInstance = (function() { let instance = null return function() { if (!instance) { instance = new SingleObj() } return instance } })() 可以看出，在 getInstance 方法的判断和拦截下，我们不管调用多少次，SingleObj 都只会给我们返回一个实例，s1 和 s2 现在都指向这个唯一的实例。 常见面试题实现 Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。 思路： 考察单例模式的实现思路，只实例化一次。 静态方法版 class Storage { static getInstance() { if (!Storage.instance) { Storage.instance = new Storage() } return Storage.instance } getItem (key) { localStorage.getItem(key) } setItem (key, value) { localStorage.setItem(key, value) } } 闭包版 function StorageBase() {} StorageBase.prototype.getItem = function (key) { localStorage.getItem(key) } StorageBase.prototype.setItem = function (key, value) { localStorage.setItem(key, value) } const Storage = (function() { let instance = null if (!instance) { instance = new StorageBase() } return instance })() 实现一个全局唯一的Modal弹框 万变不离其踪，依然考察单例模式。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;单例模式弹框&lt;/title&gt; &lt;/head&gt; &lt;style&gt; #modal { height: 200px; width: 200px; line-height: 200px; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); border: 1px solid black; text-align: center; } &lt;/style&gt; &lt;body&gt; &lt;button id=&#39;open&#39;&gt;打开弹框&lt;/button&gt; &lt;button id=&#39;close&#39;&gt;关闭弹框&lt;/button&gt; &lt;/body&gt; &lt;script&gt; // 核心逻辑，这里采用了闭包思路来实现单例模式 const Modal = (function() { let modal = null return function() { if(!modal) { modal = document.createElement(&#39;div&#39;) modal.innerHTML = &#39;我是一个全局唯一的Modal&#39; modal.style.display = &#39;none&#39; document.body.appendChild(modal) } return modal } })() // 点击打开按钮展示模态框 document.getElementById(&#39;open&#39;).addEventListener(&#39;click&#39;, function() { // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理 const modal = new Modal() modal.style.display = &#39;block&#39; }) // 点击关闭按钮隐藏模态框 document.getElementById(&#39;close&#39;).addEventListener(&#39;click&#39;, function() { const modal = new Modal() if(modal) { modal.style.display = &#39;none&#39; } }) &lt;/script&gt; &lt;/html&gt; 参考：","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiandream.cn/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://qiandream.cn/tags/设计模式/"}]},{"title":"剑指offer-01-替换字符串","slug":"剑指offer/剑指offer-01-替换字符串","date":"2020-04-10T10:44:52.000Z","updated":"2020-04-10T10:55:52.790Z","comments":true,"path":"2020/04/10/jian-zhi-offer/jian-zhi-offer-01-ti-huan-zi-fu-chuan/","link":"","permalink":"http://qiandream.cn/2020/04/10/jian-zhi-offer/jian-zhi-offer-01-ti-huan-zi-fu-chuan/","excerpt":"导语 本系列为 剑指offer 刷题系列，旨在夯实 JavaScript基础，了解常见算法。","text":"导语 本系列为 剑指offer 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 前言 难度：简单 设计知识：正则表达式、数组遍历 题目内容： 请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。 例如输入“We are happy.”，则输出“We%20are%20happy.”。 解题解法 - 正则表达式/** * @param {String} str */ function replaceEmpty(str) { return str.replace(/ /g, '%20'); } 执行测试 输入： replaceEmpty(&#39;we are family&#39;) 输出： &quot;we%20are%20family&quot; 预期结果： &quot;we%20are%20family&quot; 解题思路： 直接使用正则表达式全局替换 String.prototype.replace: 返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者是一个正则表达式，替换值可以是一个字符串或者是一个每次匹配都要调用的回调函数。 str.replace(regexp|substr, newSubStr|function) regexp (pattern) 一个RegExp 对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。 substr (pattern) 一个将被 newSubStr 替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。 newSubStr (replacement) 用于替换掉第一个参数在原字符串中的匹配部分的字符串。 function (replacement) 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。 返回值： 一个部分或全部匹配由替代模式所取代的新的字符串。 描述： 该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。 在进行全局的搜索替换时，正则表达式需包含 g 标志。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://qiandream.cn/categories/数据结构与算法/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://qiandream.cn/tags/剑指offer/"}]},{"title":"LeetCode-004-罗马数字转整数","slug":"LeetCode/Leetcode-004-罗马数字转整数","date":"2020-04-10T10:11:52.000Z","updated":"2020-04-10T09:53:28.189Z","comments":true,"path":"2020/04/10/leetcode/leetcode-004-luo-ma-shu-zi-zhuan-zheng-shu/","link":"","permalink":"http://qiandream.cn/2020/04/10/leetcode/leetcode-004-luo-ma-shu-zi-zhuan-zheng-shu/","excerpt":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。","text":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 前言 难度：简单 设计知识：数组、数学 题目地址：https://leetcode-cn.com/problems/roman-to-integer/ 题目内容： 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3 示例 2: 输入: &quot;IV&quot; 输出: 4 示例 3: 输入: &quot;IX&quot; 输出: 9 示例 4: 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题解法 - 转字符串、数组遍历，区分正常情况与特殊情况/** * @param {string} s * @return {number} */ var romanToInt = function(s) { /** * 特殊情况 * IV === 4 * IX === 9 * XL === 40 * XC === 90 * CD === 400 * CM === 900 * 正常情况 * I === 1 * V === 5 * X === 10 * L === 50 * C === 100 * D === 500 * M === 1000 */ let arr = s.split('') let result = 0 for (let i = 0; i &lt; arr.length; i++) { if (arr[i] === 'I' &amp;&amp; arr[i + 1] === 'V') { result += 4 i = i + 1 } else if (arr[i] === 'I' &amp;&amp; arr[i + 1] === 'X') { result += 9 i = i + 1 } else if (arr[i] === 'X' &amp;&amp; arr[i + 1] === 'L') { result += 40 i = i + 1 } else if (arr[i] === 'X' &amp;&amp; arr[i + 1] === 'C') { result += 90 i = i + 1 } else if (arr[i] === 'C' &amp;&amp; arr[i + 1] === 'D') { result += 400 i = i + 1 } else if (arr[i] === 'C' &amp;&amp; arr[i + 1] === 'M') { result += 900 i = i + 1 } else if (arr[i] === 'I') { result += 1 } else if (arr[i] === 'V') { result += 5 } else if (arr[i] === 'X') { result += 10 } else if (arr[i] === 'L') { result += 50 } else if (arr[i] === 'C') { result += 100 } else if (arr[i] === 'D') { result += 500 } else if (arr[i] === 'M') { result += 1000 } } return result }; 执行测试 输入： MCMXCIV 输出： 1994 预期结果： 1994 解题思路：转换为字符串、数组 split(): 字符串分割为数组","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://qiandream.cn/categories/数据结构与算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://qiandream.cn/tags/LeetCode/"}]},{"title":"JavaScript-原型原型链","slug":"JavaScript/JavaScript-原型原型链","date":"2020-04-03T09:10:52.000Z","updated":"2020-04-03T09:20:11.886Z","comments":true,"path":"2020/04/03/javascript/javascript-yuan-xing-yuan-xing-lian/","link":"","permalink":"http://qiandream.cn/2020/04/03/javascript/javascript-yuan-xing-yuan-xing-lian/","excerpt":"导语 JavaScript 中的 原型和原型链是面试中常考的点，本文旨在分析原型和原型链是什么。","text":"导语 JavaScript 中的 原型和原型链是面试中常考的点，本文旨在分析原型和原型链是什么。 原型对象JavaScript 通过 new 一个构造函数生成一个对象实例，但是每个对象实例的属性和方法并不是共享的，为了各个对象实例可以共享一些属性和方法，要设计一个对象专门用来存储对象共享的属性，那么我们叫它「原型对象」。 在 JS 所有对象中，只要是对象，都会有一个内置属性叫做proto，而且这个属性是系统自动生成的，只要你创建一个对象，这个对象就有这个属性。这个proto属性指向的是原型对象。 构造函数的 prototype 属性指向原型对象，原型对象的 constructor 属性指回构造函数。 原型链每个对象都一个 proto 指向原型对象，原型对象也有一个 proto 指向它的原型对象，直到原型链的顶端 null。 总结： 所有的实例的 proto 都指向该构造函数的原型对象（prototype）。 所有的函数（包括构造函数）是 Function() 的实例，所以所有函数的 proto 的都指向 Function() 的原型对象。 所有的原型对象（包括 Function 的原型对象）都是 Object 的实例，所以 proto 都指向 Object （构造函数）的原型对象。而 Object 构造函数的 proto 指向 null。 Function 构造函数本身就是 Function 的实例，所以 proto 指向 Function 的原型对象。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"","slug":"HTTP/TCP-四次挥手","date":"2020-04-02T08:24:30.882Z","updated":"2020-04-02T08:24:30.882Z","comments":true,"path":"2020/04/02/http/tcp-si-ci-hui-shou/","link":"","permalink":"http://qiandream.cn/2020/04/02/http/tcp-si-ci-hui-shou/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"TCP-三次握手","slug":"HTTP/TCP-三次握手","date":"2020-04-01T10:10:52.000Z","updated":"2020-04-02T08:24:54.857Z","comments":true,"path":"2020/04/01/http/tcp-san-ci-wo-shou/","link":"","permalink":"http://qiandream.cn/2020/04/01/http/tcp-san-ci-wo-shou/","excerpt":"导语 建立 TCP 连接前，客户端和服务端需要通过三次握手来确认对方的接受和传送能力是否正常","text":"导语 建立 TCP 连接前，客户端和服务端需要通过三次握手来确认对方的接受和传送能力是否正常 客户端向服务器发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，确保双方的接收和发送能力正常。 起始状态：客户端处于 closed 状态，服务端处于 listen 状态。 第一次握手：客户端给服务端发送一个 SYN 报文，并指明自己的初始化序列号（ISN） Seq = X，此时客户端处于 SYN_Send 状态。 第二次握手：服务端收到客户端的 SYN 报文后，会以自己的 SYN 报文作为应答，并且也指定了自己的初始化序列号（ISN） Seq = Y，同时会把客户端的 Seq X + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。 第三次握手：客户端回传一个 Seq Y + 1 作为 ACK 的值，Seq = Z 的数据包，代表握手结束，此时客户端处于 established 状态。 服务器收到 ACK 报文之后，也处于 established 状态，此时，双方建立起了连接。 （SYN：代表 TCP 连接 Seq：序列号 ACK：确认号） 为什么需要3次握手为了防止已经失效的连接请求报文突然又传送到了服务器，因为产生错误。 ISN 是固定的吗三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。 如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 什么是半连接队列服务器第一次收到客户端的 SYN 之后，此时会处于 SYN_RCVD 状态，此时双方还没有建立起连接，服务器会把这种状态的请求连接放在一个队列里，这种队列称为半连接队列。 服务器与客户端三次握手完成建立起的连接会放在全连接队列里。 如果队列满了，就可能会出现丢包现象。 这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ....","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://qiandream.cn/tags/HTTP/"}]},{"title":"JavaScript-基础之this","slug":"浏览器/Browser-浏览器渲染原理","date":"2020-03-17T03:10:52.000Z","updated":"2020-04-02T07:30:12.718Z","comments":true,"path":"2020/03/17/liu-lan-qi/browser-liu-lan-qi-xuan-ran-yuan-li/","link":"","permalink":"http://qiandream.cn/2020/03/17/liu-lan-qi/browser-liu-lan-qi-xuan-ran-yuan-li/","excerpt":"导语 本系列旨在总结浏览器相关知识，本篇围绕浏览器渲染原理展开。","text":"导语 本系列旨在总结浏览器相关知识，本篇围绕浏览器渲染原理展开。 浏览器的主要组成部分讲解浏览器渲染之前，先主要了解浏览器有哪些组成部分。 用户界面：包括地址栏、前进/后退按钮，书签菜单等。 浏览器引擎：在用户界面和渲染引擎之间传送指令。 渲染引擎：负责显示请求的内容。如：解析 HTML 和 CSS，并将解析后的内容显示在屏幕上。 网络：用于网络调用，比如 HTTP 请求。 用户界面后端：用于绘制基本的窗口小部件，如组合框和窗口等。 JS 解释器：用于解析和执行 JS 代码。 数据存储：这是持久层，用于浏览器在硬盘上保存各种数据。 常见的浏览器内核 浏览器 内核（渲染引擎） JS 引擎 Chrome Blink（28~） Webkit V8 Safari Webkit JavaScriptCore FireFox Gecko SpiderMonkey Edge EdgeHTML Chakra IE Trident Chakra 什么是 DOMDOM（Document Object Model 文档对象模型），是对 HTML 文档结构化的表述，允许程序和脚本动态的访问和更新文档的内容、结构和样式。服务器返回给浏览器渲染引擎的HTML的文件字节流是无法直接被浏览器渲染引擎理解的，要转化为浏览器渲染引擎可以理解的内部结构，这个结构就是 DOM。 浏览器接受 HTML 文件并转换为 DOM 树从服务器返回给浏览器渲染引擎的 HTML 文件字节流，第一步要经过渲染引擎中的 HTML 解析器。它实现了将 HTML 字节流转换为 DOM 树结构。HTML 文件字节流返回的过程中，HTML 解析器就一直在解析（边加载边解析）。 阶段一：在网络中传输的内容都是 0 和 1 这些字节数据，当浏览器接收到这些字节数据后，会将这些字节数据转换为字符串，就是我们平时写的代码。 阶段二：当数据转换为字符串后，浏览器会先将这些字符串通过分词器转化为 Token(标记)，Token 分为 Tag Token 和文本 TOken。 标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。 阶段三：将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。 HTML 解析器维护了一个 Token 栈，这个栈的目的就是用来计算节点间的父子关系，再上一个阶段生成的 Token 会被顺序压到这个栈中。 HTML 解析器开始工作时，会默认创建一个根为 document 的空 DOM 结构，同时将一个 StartTag document 的 Token 压入栈底。 如果压入到栈中的是 StartTagToken，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将这个 DOM 节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的 DOM 节点。 如果是文本 Token，那么会生成一个文本节点，然后把这个文本 Dom 节点加入到 DOM 树中（注:文本Token不需入栈），它的 父节点就是当前栈顶 Token 所对应的 DOM 节点。 如果分词器解析出来的是 EndTag 标签，比如例子中的 EndTag div，HTML 解析器会查看 Token栈顶的元素是否是 StartTag div，如果是，就将 StartTag div从栈中弹出，边上该 div 元素解析完成。 最后按照上面的规则，分词器一路解析下来，就形成了这个简单的 DOM 树。 浏览器接受 CSS 文件并转换为 CSSOM 树转换 CSS 到 CSSOM 树的过程和上一小节的过程极其相似。 浏览器如何解析 CSS 选择器浏览器会【从右向左】解析 CSS 选择器。 以下段 CSS 为例： .mode-nav h3 span {font-size: 16px;} 我们对应的DOM Tree如下： 若从左向右匹配：过程是： 从 .mod-nav 开始，遍历子节点 header 和子节点 div 然后各自向子节点遍历。在右侧 div 的分支中 最后遍历到叶子节点 a ，发现不符合规则，需要回溯到 ul 节点，再遍历下一个 li-a，一颗DOM树的节点动不动上千，这种效率很低 若从右向左匹配： 先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3 由 h3再向上寻找 class=mod-nav 的节点 最后找到根元素 html 则结束这个分支的遍历 后者匹配性能更好，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）；而从左向右的匹配规则的性能都浪费在了失败的查找上面。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"Webpack-生产环境配置","slug":"Webpack/Webpack-Webpack系列之生产环境配置","date":"2020-01-14T07:21:00.000Z","updated":"2020-04-02T08:04:25.338Z","comments":true,"path":"2020/01/14/webpack/webpack-webpack-xi-lie-zhi-sheng-chan-huan-jing-pei-zhi/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-sheng-chan-huan-jing-pei-zhi/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 生产环境配置在生产环境中我们关注的是如何让用户更快地加载资源，涉及如何压缩资源、如何添加环境变量优化打包、如何最大限度地利用缓存等。 环境配置的封装生产环境的配置与开发环境有所不同，如何让Webpack可以按照不同环境采用不同的配置呢？一般来说有以下两种方式。 使用相同的配置文件 比如令Webpack不管在什么环境下打包都使用webpack.config.js，只是在构建开始前将当前所属环境作为一个变量传进去，然后在webpack.config.js中通过各种判断条件来决定具体使用哪个配置。 // package.json { ... &quot;scripts&quot;: { &quot;dev&quot;: &quot;ENV=development webpack-dev-server&quot;, &quot;build&quot;: &quot;ENV=production webpack&quot; } } // webpack.config.js const ENV = process.env.ENV const isProd = ENV === &#39;production&#39; module.exports = { output: { filename: isProd ? &#39;bundle@[chunkhash].js&#39; : &#39;bundle.js&#39; }, mode: ENV } 为不同环境创建各自的配置文件 比如，我们可以单独创建一个webpack.production.config.js，开发环境的则可以叫webpack.development.config.js。 // package.json { ... &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --config=webpack.development.config.js&quot;, &quot;build&quot;: &quot;webpack --config=webpack.production.config.js&quot; } } 但这种方法存在一个问题，即webpack.development.config.js和webpack.production.config.js肯定会有重复的部分，一改都要改，不利于维护。在这种情况下，可以将公共的配置提取出来，比如我们单独创建一个webpack.common.config.js。 module.exports = { entry: './src/index.js', // development 和 production 共有配置 } 然后让另外两个JS分别引用该文件，并添加上自身环境的配置即可。 开启 production 模式Webpack 4中直接加了一个mode配置项，让开发者可以通过它来直接切换打包模式。如： module.exports = { mode: 'production' } 这意味着当前处于生产环境模式，Webpack会自动添加许多适用于生产环境的配置项，减少了人为手动的工作。 大部分时候仅仅设置mode是不够的，下面我们继续介绍其他与生产环境相关的自定义配置。 环境变量通常我们需要为生产环境和本地环境添加不同的环境变量，在Webpack中可以使用DefinePlugin进行设置。 const webpack = require('webpack') module.exports = { entry: './app.js', output: { filename: 'bundle.js' }, mode: 'production', plugins: [ new webpack.DefinePlugin({ process.env.NODE_ENV: JSON.stringify('production') }) ] } 注：我们在一些值的外面加上了JSON.stringify，这是因为DefinePlugin在替换环境变量时对于字符串类型的值进行的是完全替换。假如不添加JSON.stringify的话，在替换后就会成为变量名，而非字符串值。因此对于字符串环境变量及包含字符串的对象都要加上JSON.stringify才行。 source mapsource map指的是将编译、打包、压缩后的代码映射回源代码的过程。 工作原理Webpack对于工程源代码的每一步处理都有可能会改变代码的位置、结构，甚至是所处文件，因此每一步都需要生成对应的source map。若我们启用了devtool配置项，source map就会跟随源代码一步步被传递，直到生成最后的map文件。这个文件默认就是打包后的文件名加上.map，如bundle.js.map。 当我们打开了浏览器的开发者工具时，map文件会同时被加载，这时浏览器会使用它来对打包后的bundle文件进行解析，分析出源代码的目录结构和内容。 配置JavaScript的source map的配置很简单，只要在webpack.config.js中添加devtool即可。 module.exports = { // ... devtool: 'source-map' } 对于CSS、SCSS、Less来说，则需要添加额外的source map配置项。 const path = require('path') module.exports = { // ... devtool: 'source-map', module: { rules: [ { test: /\\.scss$/, use: [ 'style-loader', { loader: 'css-loader', options: { sourceMap: true } }, { loader: 'sass-loader', options: { sourceMap: true } } ] }] } } Webpack支持多种source map的形式。除了配置为devtool：’source-map’以外，还可以根据不同的需求选择cheap-source-map、eval-source-map等。通常它们都是source map的一些简略版本，因为生成完整的source map会延长整体构建时间，如果对打包速度需求比较高的话，建议选择一个简化版的sourcemap。比如，在开发环境中，cheap-module-eval-source-map通常是一个不错的选择，属于打包速度和源码信息还原程度的一个良好折中。 在生产环境中由于我们会对代码进行压缩，而最常见的压缩插件UglifyjsWebpack-Plugin目前只支持完全的source-map，因此没有那么多选择，我们只能使用source-map、hidden-source-map、nosources-source-map这3者之一。下面介绍一下这3种sourcemap在安全性方面的不同。 安全有了source map也就意味着任何人通过浏览器的开发者工具都可以看到工程源码，对于安全性来说也是极大的隐患。那么如何才能在保持其功能的同时，防止暴露源码给用户呢？Webpack提供了hidden-source-map及nosources-source-map两种策略来提升source map的安全性。 hidden-source-map意味着Webpack仍然会产出完整的map文件，只不过不会在bundle文件中添加对于map文件的引用。这样一来，当打开浏览器的开发者工具时，我们是看不到map文件的，浏览器自然也无法对bundle进行解析。如果我们想要追溯源码，则要利用一些第三方服务，将map文件上传到那上面。目前最流行的解决方案是Sentry。 Sentry是一个错误跟踪平台，开发者接入后可以进行错误的收集和聚类，以便于更好地发现和解决线上问题。Sentry支持JavaScript的source map，我们可以通过它所提供的命令行工具或者Webpack插件来自动上传map文件。同时我们还要在工程代码中添加Sentry对应的工具包，每当JavaScript执行出错时就会上报给Sentry。Sentry在接收到错误后，就会去找对应的map文件进行源码解析，并给出源码中的错误栈。 另一种配置是nosources-source-map，它对于安全性的保护则没那么强，但是使用方式相对简单。打包部署之后，我们可以在浏览器开发者工具的Sources选项卡中看到源码的目录结构，但是文件的具体内容会被隐藏起来。对于错误来说，我们仍然可以在Console控制台中查看源代码的错误栈，或者console日志的准确行数。它对于追溯错误来说基本足够，并且其安全性相对于可以看到整个源码的source-map配置来说要略高一些。 资源压缩压缩 javascript压缩JavaScript大多数时候使用的工具有两个，一个是UglifyJS（Webpack 3已集成），另一个是terser（Webpack 4已集成）。 在Webpack 3中的话，开启压缩需调用webpack.optimize.UglifyJsPlugin。 // webpack version &lt; 4 const webpack = require('webpack') module.exports = { entry: './app.js', output: { filename: 'bundle.js' }, plugins: [ new webpack.optimize.UglifyJsPlugin() ] } 从Webpack 4之后，这项配置被移到了config.optimization.minimize。 // webpack version > 4 module.exports = { entry: './app.js', output: { filename: 'bundle.js' }, optimization: { minimize: true } } 压缩CSS压缩CSS文件的前提是使用extract-text-webpack-plugin或mini-css-extract-plugin将样式提取出来，接着使用optimize-css-assets-webpack-plugin来进行压缩，这个插件本质上使用的是压缩器cssnano，当然我们也可以通过其配置进行切换。 const ExtractTextPlugin = require('extract-text-webpack-plugin') const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin') module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } ] }, plugins: [new ExtractTextPlugin('style.css')], optimization: { minimizer: [new OptimizeCssAssetsPlugin({ assetNameRegExp: /\\.optimize\\.css$/g, cssProcessor: require('cssnano'), cssProcessorOptions: { discardComments: {removeAll: true}, canPrint: true } })] } } 缓存缓存是指重复利用浏览器已经获取过的资源。合理地使用缓存是提升客户端性能的一个关键因素。 资源 hash一个常用的方法是在每次打包的过程中对资源的内容计算一次hash，并作为版本号存放在文件名中，如bundle@2e0a691e769edb228e2.js。 module.exports = { entry: './app.js', output: { filename: 'bundle@[chunkhash].js', }, mode: 'production' } 输出动态 HTML接下来我们面临的问题是，资源名的改变也就意味着HTML中的引用路径的改变。每次更改后都要手动地去维护它是很困难的，理想的情况是在打包结束后自动把最新的资源名同步过去。使用html-webpack-plugin可以帮我们做到这一点。 const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { // ... plugins: [ new HtmlWebpackPlugin() ] } html-webpack-plugin会自动地将我们打包出来的资源名放入生成的index.html中，这样我们就不必手动地更新资源URL了。 bundle 体积监控和分析一个很有用的工具是webpack-bundle-analyzer，它能够帮助我们分析一个bundle的构成。使用方法也很简单，只要将其添加进plugins配置即可。 const Analyzer = require('webpack-bundle-analyzer').BundleAnalyzerPlugin module.exports = { // ... plugins: [ new Analyzer() ] }","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-模块打包","slug":"Webpack/Webpack-Webpack系列之模块打包","date":"2020-01-14T07:21:00.000Z","updated":"2020-04-02T08:04:17.094Z","comments":true,"path":"2020/01/14/webpack/webpack-webpack-xi-lie-zhi-mo-kuai-da-bao/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-mo-kuai-da-bao/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 模块打包多种不同的模块机制CommonjsCommonJS最初只为服务端而设计，直到有了Browserify——一个运行在Node.js环境下的模块打包工具，它可以将CommonJS模块打包为浏览器可以运行的单个文件。这意味着客户端的代码也可以遵循CommonJS标准来编写了。 CommonJS中规定每个文件是一个模块，所有的变量及函数只有自己能访问，对外是不可见的。 导出在CommonJS中，通过module.exports可以导出模块中的内容： module.exports = { name: \"calculate\" } CommonJS模块内部会有一个module对象用于存放当前模块的信息。 属性。为了书写方便，CommonJS也支持另一种简化的导出方式—直接使用exports: exports.name = \"caculate\" 另外，要注意导出语句不代表模块的末尾，在module.exports或exports后面的代码依旧会照常执行。 导入在CommonJS中使用require进行模块导入： const calculator = require('./caculate.js') const name = calculator.name 当我们require一个模块时会有两种情况： require的模块是第一次被加载。这时会首先执行该模块，然后导出内容。 require的模块曾被加载过。这时该模块的代码不会再次执行，而是直接导出上次执行后得到的结果。 模块会有一个module对象用来存放其信息，这个对象中有一个属性loaded用于记录该模块是否被加载过。它的值默认为false，当模块第一次被加载和执行过后会置为true，后面再次加载时检查到module.loaded为true，则不会再次执行模块代码。 ES6 ModuleES6 Module也是将每个文件作为一个模块，每个模块拥有自身的作用域，不同的是导入、导出语句。 ES6 Module会自动采用严格模式 – “use strict”。 导出在ES6 Module中使用export命令来导出模块。 export有两种形式： 命名导出 默认导出 export const name = \"calculate\" export const add = \"add\" const name = \"calculate\" const add = \"add\" export { name, add } 在使用命名导出时，可以通过as关键字对变量重命名。如： const name = \"calculate\" const add = \"add\" export { name, add as sum } 将export default 默认导出，我们可以理解为对外输出了一个名为default的变量，因此不需要像命名导出一样进行变量声明，直接导出值即可。 export default \"calculate\" export default class {...} export default function() { ... } 导入ES6 Module中使用import语法导入模块。 import { name } from './caculate.js' 与命名导出类似，我们可以通过as关键字可以对导入的变量重命名。如： import { name as caculate } from './caculate.js' 在导入多个变量时，我们还可以采用整体导入的方式。如： import * as caculate from './caculate.js' const name = caculate.name 对于默认导出来说，import后面直接跟变量名，并且这个名字可以自由指定（比如这里是myCalculator）。如： import myCalculator from './caculate.js' AMDAMD是英文Asynchronous Module Definition（异步模块定义）的缩写: define('getSum', ['calculate'], function(math) { return function(a, b) { console.log(calculate.add(a, b)) } }) 在AMD中使用define函数来定义模块，它可以接受3个参数: 第1个参数是当前模块的id，相当于模块名； 第2个参数是当前模块的依赖，比如上面我们定义的getSum模块需要引入calculator模块作为依赖； 第3个参数用来描述模块的导出值，可以是函数或对象。如果是函数则导出的是函数的返回值；如果是对象则直接导出对象本身。 和CommonJS类似，AMD也使用require函数来加载模块，只不过采用异步的形式。 require(['getSum'], function(getSum) { getSum(2, 3) }) require的第1个参数指定了加载的模块，第2个参数是当加载完成后执行的回调函数。 通过AMD这种形式定义模块的好处在于其模块加载是非阻塞性的，当执行到require函数时并不会停下来去执行被加载的模块，而是继续执行require后面的代码，这使得模块加载操作并不会阻塞浏览器。 模块打包原理Webpack 将项目中成百上千个有依赖关系的模块组织在一起，打包后将会成为如下的形式： // 立即执行匿名函数 (function(module) { // 模块缓存 var installedModules = {} // 实现 require function __webpack_require__(moduleId) { // ... } // 执行入口模块的加载 return __webpack_require__(__webpack_require__.s = 0) { // modules: 以 key-value 的形式存储所有被打包的模块 0: function (module, exports, __webpack_require__) { // 打包入口 module.exports = __webpack_require__(\"3qiv\") }, \"3qiv\": function (module, exports, __webpack_require__) { // 打包入口 module.exports = __webpack_require__(\"3qiv\") } } }) 上面的bundle分为以下几个部分： 最外层立即执行匿名函数。它用来包裹整个bundle，并构成自身的作用域。 installedModules对象。每个模块只在第一次被加载的时候执行，之后其导出值就被存储到这个对象里面，当再次被加载的时候直接从这里取值，而不会重新执行。 webpack_require函数。对模块加载的实现，在浏览器中可以通过调用webpack_require(module_id)来完成模块导入。 modules对象。工程中所有产生了依赖关系的模块都会以key-value的形式放在这里。key可以理解为一个模块的id，由数字或者一个很短的hash字符串构成；value则是由一个匿名函数包裹的模块实体，匿名函数的参数则赋予了每个模块导出和导入的能力。 bundle是如何在浏览器中执行的： 在最外层的匿名函数中会初始化浏览器执行环境，包括定义installedModules对象、webpack_require函数等，为模块的加载和执行做一些准备工作。 加载入口模块。每个bundle都有且只有一个入口模块，例如：index.js是入口模块，在浏览器中会从它开始执行。 执行模块代码。如果执行到了module.exports则记录下模块的导出值；如果中间遇到require函数（准确地说是webpack_require），则会暂时交出执行权，进入webpack_require函数体内进行加载其他模块的逻辑。 在webpack_require中会判断即将加载的模块是否存在于installedModules中。如果存在则直接取值，否则回到上一步，执行该模块的代码来获取导出值。 所有依赖的模块都已执行完毕，最后执行权又回到入口模块。当入口模块的代码执行到结尾，也就意味着整个bundle运行结束。 不难看出，第3步和第4步是一个递归的过程。Webpack为每个模块创造了一个可以导出和导入模块的环境，但本质上并没有修改代码的执行逻辑，因此代码执行的顺序与模块加载的顺序是完全一致的，这就是Webpack模块打包的奥秘。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-预处理器","slug":"Webpack/Webpack-Webpack系列之样式处理","date":"2020-01-14T07:21:00.000Z","updated":"2020-04-02T08:04:11.365Z","comments":true,"path":"2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yang-shi-chu-li/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yang-shi-chu-li/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 样式处理分离样式文件Webpack社区有专门的插件：extract-text-webpack-plugin（适用于Webpack 4之前版本）和mini-css-extract-plugin（适用于Webpack 4及以上版本），它们就是专门用于提取样式到CSS文件的。 extract-text-webpack-pluginnpm i extract-text-webpack-plugin 在 webpack.config.js 中引入： const ExtractTextPlugin = require('extract-text-webpack-plugin') module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } ]}, plugins: [ new ExtractTextPlugin('bundle.css') ] } 内部的fallback属性用于指定当插件无法提取样式时所采用的loader。 use（extract方法里面的）用于指定在提取样式之前采用哪些loader来预先进行处理。 除此之外，还要在Webpack的plugins配置中添加该插件，并传入提取后的资源文件名。 多样式文件处理上面我们将bundle.css作为文件名传给了extract-text-webpack-plugin，但当工程有多个入口时就会发生重名问题。就像在前面的章节中我们配置动态的output.filename一样，这里我们也要对插件提取的CSS文件使用类似模板的命名方式。 const ExtractTextPlugin = require('extract-text-webpack-plugin') module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } ]}, plugins: [ new ExtractTextPlugin('[name].css') ] } mini-css-extract-plugin说到mini-css-extract-plugin的特性，最重要的就是它支持按需加载CSS，以前在使用extract-text-webpack-plugin的时候我们是做不到这一点的。 举个例子，a.js通过import()函数异步加载了b.js，b.js里面加载了style.css，那么style.css最终只能被同步加载（通过HTML的link标签）。但是现在mini-css-extract-plugin会单独打包出一个0.css（假设使用默认配置），这个CSS文件将由a.js通过动态插入link标签的方式加载。 在配置上mini-css-extract-plugin与extract-text-webpack-plugin有以下几点不同： loader规则设置的形式不同，并且mini-css-extract-plugin支持配置publicPath，用来指定异步CSS的加载路径。 不需要设置fallback。 在plugins设置中，除了指定同步加载的CSS资源名（filename），还要指定异步加载的CSS资源名（chunkFilename） const MiniCssExtractPlugin = require('mini-css-extract-plugin') module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: [ { loader: MiniCssExtractPlugin.loader, options: { publicPath: '../' } }, 'css-loader' ] } ]}, plugins: [ new MiniCssExtractPlugin({ filename: '[name].css', chunkFilename: '[id].css' }) ] } 样式预处理样式预处理指的是在开发中我们经常会使用一些样式预编译语言，如SCSS、Less等，在项目打包过程中再将这些预编译语言转换为CSS。 Sass 与 Scsssass-loader就是将SCSS语法编译为CSS，因此在使用时通常还要搭配css-loader和style-loader。类似于我们装babel-loader时还要安装babel-core，loader本身只是编译核心库与Webpack的连接器，因此这里我们除了sass-loader以外还要安装node-sass，node-sass是真正用来编译SCSS的，而sass-loader只是起到黏合的作用。 npm i sass-loader node-sass module.exports = { // ... module: { rules: [ { test: /\\.scss$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;] } ] } } Lessnpm i less-loader less module.exports = { // ... module: { rules: [ { test: /\\.less/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] } ] } } PostCssPostCSS并不能算是一个CSS的预编译器，它只是一个编译插件的容器。它的工作模式是接收样式源代码并交由编译插件处理，最后输出CSS。 PostCss 与 Webpack使用postcss-loader可以轻松地将PostCSS与Webpack连接起来。使用npm进行安装。 npm i postcss-loader module.exports = { // ... module: { rules: [ { test: /\\.css/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;postcss-loader&#39;] } ] } } postcss-loader可以结合css-loader使用，也可以单独使用，也就是说不配置css-loader也可以达到相同的效果。唯一不同的是，单独使用postcss-loader时不建议使用CSS中的@import语句，否则会产生冗余代码。 除此之外，PostCSS要求必须有一个单独的配置文件。我们需要在项目的根目录下创建一个postcss.config.js。 module.exports = { // ... module: {} } 自动前缀Autoprefixer是一个样式工具，可以根据caniuse.com上的数据，自动决定是否要为某一特性添加厂商前缀，并且可以由开发者为其指定支持浏览器的范围。 npm i autoprefixer 在postcss.config.js中添加autoprefixer。 const autoprefixer = require(&#39;autoprefixer&#39;) module.exports = { // ... plugins: [ autoprefixer({ grid: true, browsers: [ &#39;&gt; 1%&#39;, &#39;last 3 versions&#39;, &#39;android 4.2&#39;, &#39;ie 8&#39; ] }) ] } stylelintstylelint是一个CSS的质量检测工具，就像eslint一样，我们可以为其添加各种规则，来统一项目的代码风格，确保代码质量。 npm i stylelint 在postcss.config.js中添加相应配置。 const autoprefixer = require(&#39;autoprefixer&#39;) module.exports = { // ... plugins: [ stylelint({ config: { rules: { &#39;declaration-no-important&#39;: true } } }) ] } 这里我们添加了declaration-no-important这样一条规则，当我们的代码中出现了“！important”时就会给出警告。 使用stylelint可以检测出代码中的样式问题（语法错误、重复的属性等），帮助我们写出更加安全并且风格更加一致的代码。 CssNextPostCSS可以与CSSNext结合使用，让我们在应用中使用最新的CSS语法特性。 npm i postcss-cssnext 在postcss.config.js中添加相应配置。 const postcssCssnext = require(&#39;postcss-cssnext&#39;) module.exports = { // ... plugins: [ postcssCssnext({ browsers: [ &#39;&gt; 1%&#39;, &#39;last 2 versions&#39;, ] }) ] } 指定好需要支持的浏览器之后，我们就可以顺畅地使用CSSNext的特性了。 Css ModulesCSS Modules是近年来比较流行的一种开发模式，其理念就是把CSS模块化，让CSS也拥有模块的特点: 每个CSS文件中的样式都拥有单独的作用域，不会和外界发生命名冲突。 对CSS进行依赖管理，可以通过相对路径引入CSS文件。 可以通过composes轻松复用其他CSS模块 使用CSS Modules不需要额外安装模块，只要开启css-loader中的modules配置项即可。 module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: [ 'style-loader', { loader: 'css-loader', options: { modules: true, localIdentName: '[name]__[local]__[hash:base64:5]' } } ] } ]}, } 这里比较值得一提的是localIdentName配置项，它用于指明CSS代码中的类名会如何来编译。 例： /* style.css */ .title { color: #fff; } 经过编译后可能将成为.styletitle1CFy6。 [name]指代的是模块名，这里被替换为style。 [local]指代的是原本的选择器标识符，这里被替换为title。 [hash：base64：5]指代的是一个5位的hash值，这个hash值是根据模块名和标识符计算的，因此不同模块中相同的标识符也不会造成样式冲突。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-代码分片","slug":"Webpack/Webpack-Webpack系列之代码分片","date":"2020-01-14T07:21:00.000Z","updated":"2020-04-02T08:04:05.975Z","comments":true,"path":"2020/01/14/webpack/webpack-webpack-xi-lie-zhi-dai-ma-fen-pian/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-dai-ma-fen-pian/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 代码分片代码分片（code splitting）是Webpack作为打包工具所特有的一项技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用户不必一次全部加载，而是按需加载。 代码分片可以有效降低首屏加载资源的大小，但同时也会带来新的问题，比如我们应该对哪些模块进行分片、分片后的资源如何管理等，这些也是需要关注的。 通过入口划分代码在Webpack中每个入口（entry）都将生成一个对应的资源文件，通过入口的配置我们可以进行一些简单有效的代码拆分。 对于Web应用来说通常会有一些库和工具是不常变动的，可以把它们放在一个单独的入口中，由该入口产生的资源不会经常更新，因此可以有效地利用客户端缓存，让用户不必在每次请求页面时都重新加载。如： // webpack.config.js entry: { app: &#39;./app.js&#39;, lib: [&#39;lib-a&#39;, &#39;lib-b&#39;, &#39;lib-c&#39;] } // index.html &lt;script src=&quot;dist/lib.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;dist/app.js&quot;&gt;&lt;/script&gt; 这种拆分方法主要适合于那些将接口绑定在全局对象上的库，因为业务代码中的模块无法直接引用库中的模块，二者属于不同的依赖树。 CommonsChunkPluginCommonsChunkPlugin是Webpack 4之前内部自带的插件（Webpack 4之后替换为了SplitChunks）。它可以将多个Chunk中公共的部分提取出来。公共模块的提取可以为项目带来几个收益： 开发过程中减少了重复模块打包，可以提升开发速度； 减小整体资源体积； 合理分片后的代码可以更有效地利用客户端缓存。 更改webpack.config.js，添加CommonsChunkPlugin。 const webpack = require('webpack') module.exports = { entry: { foo: './foo.js', bar: './bar.js' }, output: { filename: '[name].js' }, plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: 'commons', filename: 'commons.js' }) ] } name：用于指定公共chunk的名字。 filename：提取后的资源文件名。 最后，记得在页面中添加一个script标签来引入commons.js，并且注意，该JS一定要在其他JS之前引入。 提取 vendor虽然CommonsChunkPlugin主要用于提取多入口之间的公共模块，但这不代表对于单入口的应用就无法使用。我们仍然可以用它来提取第三方类库及业务中不常更新的模块，只需要单独为它们创建一个入口即可。 const webpack = require(&#39;webpack&#39;) module.exports = { entry: { app: &#39;./app.js&#39;, vendor: [&#39;react&#39;] }, output: { filename: &#39;[name].js&#39; }, plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: &#39;vendor&#39;, filename: &#39;vendor.js&#39; }) ] } // app.js import React from &#39;react&#39; document.write(&#39;app.js&#39;, React.version) 为了将react从app.js提取出来，我们在配置中加入了一个入口vendor，并使其只包含react，这样就把react变为了app和vendor这两个chunk所共有的模块 设置提取范围通过CommonsChunkPlugin中的chunks配置项可以规定从哪些入口中提取公共模块。 const webpack = require(&#39;webpack&#39;) module.exports = { entry: { a: &#39;./a.js&#39;, b: &#39;./b.js&#39;, c: &#39;./c.js&#39;, }, output: { filename: &#39;[name].js&#39; }, plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: &#39;common&#39;, filename: &#39;common.js&#39;, chunks: [&#39;a&#39;, &#39;b&#39;] }) ] } 我们在chunks中配置了a和b，这意味着只会从a.js和b.js中提取公共模块。 设置提取规则CommonsChunkPlugin的默认规则是只要一个模块被两个入口chunk所使用就会被提取出来，比如只要a和b用了react，react就会被提取出来。 然而现实情况是，有些时候我们不希望所有的公共模块都被提取出来，此时我们可以通过CommonsChunkPlugin的minChunks配置项来设置提取的规则，该配置项非常灵活，支持多种输入形式。 数字 minChunks可以接受一个数字，当设置minChunks为n时，只有该模块被n个入口同时引用才会进行提取。另外，这个阈值不会影响通过数组形式入口传入模块的提取。 const webpack = require(&#39;webpack&#39;) module.exports = { entry: { foo: &#39;./foo.js&#39;, bar: &#39;./bar.js&#39;, vendor: [&#39;react&#39;], }, output: { filename: &#39;[name].js&#39; }, plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: &#39;vendor&#39;, filename: &#39;vendor.js&#39;, minChunks: 3 }) ] } 我们令foo.js和bar.js共同引用一个util.js。 // foo.js import React from 'react' import './util' document.write('foo.js', React.version) // foo.js import React from 'react' import './util' document.write('bar.js', React.version) // util.js console.log('util') 如果实际打包应该可以发现，由于我们设置minChunks为3，util.js并不会被提取到vendor.js中，然而react并不受这个的影响，仍然会出现在vendor.js中。 Infinity 设置为无穷代表提取的阈值无限高，也就是说所有模块都不会被提取。 函数 minChunks支持传入一个函数，它可以让我们更细粒度地控制公共模块。Webpack打包过程中的每个模块都会经过这个函数的处理，当函数的返回值是true时进行提取。 module.exports = { plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: &#39;vendor&#39;, filename: &#39;vendor.js&#39;, minChunks: function(module, count) { // module.context 模块目录路径 if (module.context &amp;&amp; module.context.include(&#39;node_modules&#39;)) { return true } // module.resource 包含模块名的完整路径 if (module.resource &amp;&amp; module.resource.endsWith(&#39;util.js&#39;)) { return true } // count 为模块被引用的次数 if (count &gt; 5) { return true } } }) ] } 借助上面的配置，我们可以分别提取node_modules目录下的模块、名称为util.js的模块，以及被引用5次（不包含5次）以上的模块。 hash 与 长效缓存当我们使用该插件提取公共模块时，提取后的资源内部不仅仅是模块的代码，往往还包含Webpack的运行时（runtime）。Webpack的运行时指的是初始化环境的代码，如创建模块缓存对象、声明模块加载函数等。 将运行时的代码单独提取出来。请看下面这个例子： const webpack = require(&#39;webpack&#39;) module.exports = { entry: { app: &#39;./app.js&#39;, vendor: [&#39;react&#39;], }, output: { filename: &#39;[name].js&#39; }, plugins: [ new webpack.optimize.CommonsChunkOlugin({ name: &#39;vendor&#39; }), new webpack.optimize.CommonsChunkOlugin({ name: &#39;manifest&#39; }), ] } 上面的配置中，通过添加了一个name为manifest的CommonsChunkPlugin来提取Webpack的运行时。 注：manifest的CommonsChunkPlugin必须出现在最后，否则Webpack将无法正常提取模块。 CommonsChunkPlugin 的不足在提取公共模块方面，CommonsChunkPlugin可以满足很多场景的需求，但是它也有一些欠缺的地方。 一个CommonsChunkPlugin只能提取一个vendor，假如我们想提取多个vendor则需要配置多个插件，这会增加很多重复的配置代码。 前面我们提到的manifest实际上会使浏览器多加载一个资源，这对于页面渲染速度是不友好的。 由于内部设计上的一些缺陷，CommonsChunkPlugin在提取公共模块的时候会破坏掉原有Chunk中模块的依赖关系，导致难以进行更多的优化。 optimization.SplitChunksoptimization.SplitChunks（简称SplitChunks）是Webpack 4为了改进CommonsChunk-Plugin而重新设计和实现的代码分片特性。 比如我们前面异步加载的例子，在换成Webpack 4的SplitChunks之后，就可以自动提取出react了。 module.exports = { entry: &#39;./foo.js&#39;, output: { filename: &#39;foo.js&#39;, publicPath: &#39;/dist/&#39; }, mode: &#39;development&#39;, optimization: { splitChunks: { chunks: &#39;all&#39; } } } // foo.js import React from &#39;react&#39; import(&#39;./bar.js&#39;) document.write(&#39;app.js&#39;, React.version) // bar.js import React from &#39;react&#39; document.write(&#39;bar.js&#39;, React.version) 此处Webpack 4的配置与之前相比有两点不同： 使用optimization.splitChunks替代了CommonsChunkPlugin，并指定了chunks的值为all，这个配置项的含义是，SplitChunks将会对所有的chunks生效（默认情况下，SplitChunks只对异步chunks生效，并且不需要配置）。 以下是SplitChunks默认情形下的提取条件： 提取后的chunk可被共享或者来自node_modules目录。 提取后的Javascript chunk体积大于30kB（压缩和gzip之前），CSS chunk体积大于50kB。 在按需加载过程中，并行请求的资源最大值小于等于5。按需加载指的是，通过动态插入script标签的方式加载脚本。 在首次加载时，并行请求的资源数最大值小于等于3。 默认的异步提取前面我们对SplitChunks添加了一个chunks：all的配置，这是为了提取foo.js和bar.js的公共模块。实际上SplitChunks不需要配置也能生效，但仅仅针对异步资源。 module.exports = { entry: &#39;./foo.js&#39;, output: { filename: &#39;foo.js&#39;, publicPath: &#39;/dist/&#39; }, mode: &#39;development&#39; } // foo.js import(&#39;./bar.js&#39;) document.write(&#39;app.js&#39;, React.version) // bar.js import React from &#39;react&#39; document.write(&#39;bar.js&#39;, React.version) 配置为了更好地了解SplitChunks是怎样工作的，我们来看一下它的默认配置。 optimization: { splitChunks: { chunks: &#39;async&#39;, minSize: { javascript: 30000, style: 50000 }, maxSize: 0, minChunks: 1, maxAsyncRequest3: 3, maxInitialRequests: 2, automaticNameDelimiter: &#39;~&#39;, name: true, cacheGroups: { vendors: { test: /[\\\\/]node_modules[\\\\/]/ }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true } } } } 匹配模式 通过chunks我们可以配置SplitChunks的工作模式。它有3个可选值，分别为async（默认）、initial和all。async即只提取异步chunk，initial则只对入口chunk生效（如果配置了initial则上面异步的例子将失效），all则是两种模式同时开启。 匹配条件 minSize、minChunks、maxAsyncRequests、maxInitialRequests都属于匹配条件。 命名 配置项name默认为true，它意味着SplitChunks可以根据cacheGroups和作用范围自动为新生成的chunk命名，并以automaticNameDelimiter分隔。 cacheGroups 可以理解成分离chunks时的规则。默认情况下有两种规则——vendors和default。vendors用于提取所有node_modules中符合条件的模块，default则作用于被多次引用的模块。我们可以对这些规则进行增加或者修改，如果想要禁用某种规则，也可以直接将其置为false。当一个模块同时符合多个cacheGroups时，则根据其中的priority配置项确定优先级。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-预处理器","slug":"Webpack/Webpack-Webpack系列之预处理器","date":"2020-01-14T07:21:00.000Z","updated":"2020-04-02T08:04:41.965Z","comments":true,"path":"2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yu-chu-li-qi/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-yu-chu-li-qi/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 预处理器（loader）每个loader本质上都是一个函数。在Webpack 4之前，函数的输入和输出都必须为字符串；在Webpack 4之后，loader也同时支持抽象语法树（AST）的传递，通过这种方法来减少重复的代码解析。用公式表达loader的本质则为以下形式： output=loader(input) 这里的input可能是工程源文件的字符串，也可能是上一个loader转化后的结果，包括转化后的结果（也是字符串类型）、source map，以及AST对象；output同样包含这几种信息，转化后的文件字符串、source map，以及AST。如果这是最后一个loader，结果将直接被送到Webpack进行后续处理，否则将作为下一个loader的输入向后传递。 loader 的配置Webpack本身只认识JavaScript，对于其他类型的资源必须预先定义一个或多个loader对其进行转译，输出为Webpack能够接收的形式再继续进行，因此loader做的实际上是一个预处理的工作。 module.exports = { module: { rules: [ { test: /\\.jsx?/, // 条件 use: &#39;babel-loader&#39; // 规则应用结果 } // 一个Object即一条规则 ] } } 与loader相关的配置都在module对象中，其中module.rules代表了模块的处理规则。每条规则内部可以包含很多配置项，这里我们只使用了最重要的两项—test和use。 test可接收一个正则表达式或者一个元素为正则表达式的数组，只有正则匹配上的模块才会使用这条规则。 use可接收一个数组，数组包含该规则所使用的loader。 链式 loader很多时候，在处理某一类资源时我们都需要使用多个loader。 module.exports = { module: { rules: [ { test: /\\.css?/, // 条件 use: [&#39;style-loader&#39;, &#39;css-loader&#39;] // 规则应用结果 } // 一个Object即一条规则 ] } } 把style-loader加到了css-loader前面，这是因为在Webpack打包时是按照数组从后往前的顺序将资源交给loader处理的，因此要把最后生效的放在前面。 loader optionswebpack为loader提供了多种匹配条件的配置方式： test: … 匹配特定条件 include: … 匹配特定路径 exclude: … 排除特定路径 and: [] 必须匹配数组中的所有条件 or: [] 匹配数组中的任意一个条件 not: [] 排除匹配数组中的所有条件 条件值类型： 字符串：必须以提供的字符串开始（绝对路径） 正则表达式 数组：至少包含一个条件的数组 对象：匹配所有属性值的条件 函数：返回true表示匹配 规则应用配置匹配规则后的应用，我们可以使用use字段： rules: [ { test: /\\.less/, use: [ &#39;style-loader&#39;, { loader: &#39;css-loader&#39;, options: { // ... } }, { loader: &#39;less-loader&#39;, options: { // ... } } ] } ] 使用options可以给对应的loader传递一些配置项。 对于上述的less规则应用配置，一个less模块文件可以经过多个loader的转换处理，执行顺序为从右到左。 如果多个rule匹配了同一个模块文件，loader的应用顺序应该如何处理？ rules: [ { test: /\\.js$/, loader: &quot;eslint-loader&quot;, }, { test: /\\.js$/, loader: &quot;babel-loader&quot;, } ] eslint-loader用于检查人工编写的代码，babel-loader用于转换代码。所以，eslint-loader应该在babel-loader之前执行，那么该如何保证执行顺序？ webpack为每一个匹配规则提供了enforce字段来配置当前rule得的loader类型。pre(前置) &gt; 行内 &gt; 普通 &gt; 后置(post)。 我们要确保eslint-loader在babel-loader之前执行，只需给rule规则项添加enforce字段，并设置其值为pre。 rules: [ { enforce: &#39;pre&#39;, test: /\\.js$/, loader: &quot;eslint-loader&quot;, }, { test: /\\.js$/, loader: &quot;babel-loader&quot;, } ] 常用 loader 介绍babel-loader babel-loader用来处理ES6+并将其编译为ES5。 npm i babel-loader @babel/core @babel/preset-env 各个模块的作用如下: babel-loader：它是使Babel与Webpack协同工作的模块。 @babel/core：顾名思义，它是Babel编译器的核心模块。 @babel/preset-env：它是Babel官方推荐的预置器，可根据用户设置的目标环境自动添加所需的插件和补丁来编译ES6+代码。 module.exports = { // ... module: { rules: [ { test: /\\.jsx?/, loader: &#39;babel-loader&#39; } ] } } ts-loaderts-loader与babel-loader的性质类似，它是用于连接Webpack与Typescript的模块。 npm i ts-loader typescript module.exports = { // ... module: { rules: [ { test: /\\.ts?/, loader: &#39;ts-loader&#39; } ] } } html-loaderhtml-loader用于将HTML文件转化为字符串并进行格式化，这使得我们可以把一个HTML片段通过JS加载进来。 npm i html-loader module.exports = { // ... module: { rules: [ { test: /\\.html?/, loader: &#39;html-loader&#39; } ] } } handlebars-loaderhandlebars-loader用于处理handlebars模板，在安装时要额外安装handlebars。 npm i handlebars-loader handlebars module.exports = { // ... module: { rules: [ { test: /\\.handlebars?/, loader: &#39;handlebars-loader&#39; } ] } } handlebars文件加载后得到的是一个函数，可以接收一个变量对象并返回最终的字符串。 file-loaderfile-loader用于打包文件类型的资源，并返回其publicPath。 npm i file-loader module.exports = { // ... module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: &#39;file-loader&#39; } ] } } url-loaderurl-loader与file-loader作用类似，唯一的不同在于用户可以设置一个文件大小的阈值，当大于该阈值时与file-loader一样返回publicPath，而小于该阈值时则返回文件base64形式编码。 npm i url-loader module.exports = { // ... module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: { loader: &#39;file-loader&#39;, options: { limit: 10240, name: &#39;[name].[ext]&#39;, publicPath: &#39;./assets-path/&#39; } } } ] } }","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-资源输入输出","slug":"Webpack/Webpack-Webpack系列之资源输入输出","date":"2020-01-14T07:21:00.000Z","updated":"2020-04-02T08:04:36.439Z","comments":true,"path":"2020/01/14/webpack/webpack-webpack-xi-lie-zhi-zi-yuan-shu-ru-shu-chu/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-zi-yuan-shu-ru-shu-chu/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 资源输入输出资源处理流程在一切流程的最开始，我们需要指定一个或多个入口（entry），也就是告诉Webpack具体从源码目录下的哪个文件开始打包。如果把工程中各个模块的依赖关系当作一棵树，那么入口就是这棵依赖树的根，这些存在依赖关系的模块会在打包时被封装为一个chunk。 chunk字面的意思是代码块，在Webpack中可以理解成被抽象和包装过后的一些模块。它就像一个装着很多文件的文件袋，里面的文件就是各个模块，Webpack在外面加了一层包裹，从而形成了chunk。根据具体配置不同，一个工程打包时可能会产生一个或多个chunk。 Webpack会从入口文件开始检索，并将具有依赖关系的模块生成一棵依赖树，最终得到一个chunk。由这个chunk得到的打包产物我们一般称之为bundle。 配置资源入口通过context和entry这两个配置项来共同决定入口文件的路径。在配置入口时，实际上做了两件事： 确定入口模块位置，告诉Webpack从哪里开始进行打包。 定义chunk name。如果工程只有一个入口，那么默认其chunk name为“main”；如果工程有多个入口，我们需要为每个入口定义chunk name，来作为该chunk的唯一标识。 contextcontext可以理解为资源入口的路径前缀，在配置时要求必须使用绝对路径的形式。 module.exports = { context: path.join(__dirname, './src/script'), entry: './index.js' } 配置context的主要目的是让entry的编写更加简洁，尤其是在多入口的情况下。context可以省略，默认值为当前工程的根目录。 entryentry的配置可以有多种形式：字符串、数组、对象、函数。可以根据不同的需求场景来选择。 字符串类型入口 直接传入文件路径： module.exports = { entry: './src/index' } 数组类型入口 传入一个数组的作用是将多个资源预先合并，在打包时Webpack会将数组中的最后一个元素作为实际的入口路径。如： module.exports = { entry: ['babel-polyfill', './src/index'] } 对象类型入口 如果想要定义多入口，则必须使用对象的形式。 module.exports = { entry: { foo: './src/foo', bar: './src/bar' } } 函数类型入口 用函数定义入口时，只要返回上面介绍的任何配置形式即可。 module.exports = { entry: () => ({ foo: './src/foo', bar: './src/bar' }) } output所有与出口相关的配置都集中在output对象里。 filenamefilename的作用是控制输出资源的文件名。 字符串形式 module.exports = { output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' } } 在多入口的场景中，我们需要为对应产生的每个bundle指定不同的名字，Webpack支持使用一种类似模板语言的形式动态地生成文件名。 // 多个入口生成不同的文件 module.exports = { output: { path: path.resolve(__dirname, 'dist'), filename: '[name].js' } } 路径中使用hash，每次构建都有一个不同的hash值，避免发布新版本使用浏览器缓存。 module.exports = { output: { path: path.resolve(__dirname, 'dist/[hash]'), filename: '[name].js' } } pathpath可以指定资源输出的位置，要求值必须为绝对路径。如： module.exports = { output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' } } publicPathpublicPath是一个非常重要的配置项，并且容易与path相混淆。从功能上来说，path用来指定资源的输出位置，而publicPath则用来指定资源的请求位置。让我们详细解释这两个定义。 输出位置：打包完成后资源产生的目录，一般将其指定为工程中的dist目录。 请求位置：由JS或CSS所请求的间接资源路径。页面中的资源分为两种，一种是由HTML页面直接请求的，比如通过script标签加载的JS；另一种是由JS或CSS请求的，如异步加载的JS、从CSS请求的图片字体等。publicPath的作用就是指定这部分间接资源的请求位置。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"Webpack-简介","slug":"Webpack/Webpack-Webpack系列之简介","date":"2020-01-14T07:21:00.000Z","updated":"2020-04-02T08:04:30.698Z","comments":true,"path":"2020/01/14/webpack/webpack-webpack-xi-lie-zhi-jian-jie/","link":"","permalink":"http://qiandream.cn/2020/01/14/webpack/webpack-webpack-xi-lie-zhi-jian-jie/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 Webpack 简介Webpack是什么Webpack是一个开源的JavaScript模块打包工具，其最核心的功能是解决模块之间的依赖，把各个模块按照特定的规则和顺序组织在一起，最终合并为一个JS文件（有时会有多个，这里讨论的只是最基本的情况）。 模块打包工具模块打包工具（module bundler）的任务就是解决模块间的依赖，使其打包后的结果能运行在浏览器上。它的工作方式主要分为两种 将存在依赖关系的模块按照特定规则合并为单个JS文件，一次全部加载进页面中。 在页面初始时加载一个入口模块，其他模块异步地进行加载。 Webpack 优势 默认支持多种模块标准，包括AMD、CommonJS，以及最新的ES6模块。 完备的代码分割（code splitting）解决方案，首屏只加载重要的部分。 可以处理各种类型的资源。除了JavaScript以外，Webpack还可以处理样式、模板，甚至图片等。 拥有庞大的社区支持。 安装使用npm或者yarn来安装webpack 全局安装$ npm i webpack webpack-cli -g or $ yarn -g add webpack webpack-cli 等待安装完毕，就可以全局执行webpack命令了。注：webpack-cli在4.x版本之后不再作为webpack的依赖了，我们使用时需要单独安装。 局部安装在项目中，我们更推荐将webpack作为项目的开发依赖来安装使用，这样可以指定项目中使用的webpack版本。 $ npm i webpack webpack-cli -D or $ yarn add webpack webpack-cli -D 等待安装完毕，webpack会出现在项目的package.json文件中，我们添加一个npm scripts: &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack --mode production&quot; }, &quot;devDependencies&quot;: { &quot;webpack&quot;: &quot;^4.1.1&quot;, &quot;webpack-cli&quot;: &quot;^2.0.12&quot;, } webpack-dev-serverwebpack-dev-server可以看作一个服务者，它的主要工作就是接收浏览器的请求，然后将资源返回。当服务启动时，会先让Webpack进行模块打包并将资源准备好（在示例中就是bundle.js）。当webpack-dev-server接收到浏览器的资源请求时，它会首先进行URL地址校验。如果该地址是资源服务地址（上面配置的publicPath），就会从Webpack的打包结果中寻找该资源并返回给浏览器。反之，如果请求地址不属于资源服务地址，则直接读取硬盘中的源文件并将其返回。 $ npm i webpack-dev-server -D 为了便捷地启动webpack-dev-server，我们在package.json中添加一个dev指令： \"scripts\": { \"build\": \"webpack\", \"dev\": \"webpack-dev-server\" } 最后，我们还需要对webpack-dev-server进行配置。编辑webpack.config.js如下： module.exports = { entry: \"./src/index.js\", output: { filename: \"./bundle.js\" }, mode: \"development\", devServer: { publicPath: \"/dist\" } } 这里有一点需要注意。直接用Webpack开发和使用webpack-dev-server有一个很大的区别，前者每次都会生成budnle.js，而webpack-dev-server只是将打包结果放在内存中，并不会写入实际的bundle.js，在每次webpack-dev-server接收到请求时都只是将内存中的打包结果返回给浏览器。 webpack-dev-server还有一项很便捷的特性就是live-reloading（自动刷新）。 注：关于内容自动更新，webpack-dev-server 与 hot-module-replacement（模块热替换）的区别在于：前者会刷新浏览器，后者不需要刷新浏览器就能获得更新之后的内容。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qiandream.cn/tags/Webpack/"}]},{"title":"JavaScript-闭包","slug":"JavaScript/JavaScript-闭包","date":"2020-01-08T06:26:52.000Z","updated":"2020-04-03T09:04:31.493Z","comments":true,"path":"2020/01/08/javascript/javascript-bi-bao/","link":"","permalink":"http://qiandream.cn/2020/01/08/javascript/javascript-bi-bao/","excerpt":"导语 闭包，面试中的重难点，要从很多方面讲起。","text":"导语 闭包，面试中的重难点，要从很多方面讲起。 什么是作用域规定函数和变量的可使用范围叫做作用域。 function foo() { let a = 1 } 声明一个函数，创建一个私用作用域。其它函数不能直接访问私有作用域 foo 的变量 a。一个函数就是一个作用域。 什么是作用域链每个函数都会有一个作用域，查找变量或函数时，由局部作用域到全局作用域依次查找，这些作用域的集合就称为作用域链。 let a = 1 function fn() { function fn1() { function fn2() { let c = 3; console.log(a); } // 执行 fn2 fn2(); } // 执行 fn1 fn1(); } // 执行函数 fn(); 在 fn2 作用域中打印 a，首先在自己所在作用域搜索，如果没有就向上级作用域搜索，直到搜索到全局作用域，a = 1，找到了打印出值。整个搜索的过程，就是基于作用域链搜索的。 什么是闭包闭包是指有权访问另一个函数作用域中的变量的函数。 闭包产生的本职就是当前环境中存在指向父级作用域的引用。 function foo() { let a = 2 function bar() { console.log(a); } return bar } let x = foo() x() // 2 闭包有哪些表现形式？ 返回一个函数，如上例 函数作为参数传递 function foo() { let a = 2 function baz() { console.log(a); } bar(baz) } function bar(fn) { fn() } foo() // 2 定时器，ajax 请求，事件监听等，只要使用了回调函数，实际上就是在使用闭包 IIFE (立即执行函数表达式) 创建了闭包 如何解决下面的循环输出问题？for(var i = 1; i &lt;= 5; i ++){ setTimeout(function timer(){ console.log(i) }, 0) } 上面全部输出 6，如何输出 1，2，3，4，5？ 解决方法： IIFE，传入此时的 i 变量到定时器中 for(var i = 1; i &lt;= 5; i ++){ (function (j) {setTimeout(function timer(){ console.log(i) }, 0)})(j) } 给定时器传入第三个参数 for(var i = 1; i &lt;= 5; i ++){ setTimeout(function timer(){ console.log(i) }, 0, i) } 使用 ES6 中的 let for(let i = 1; i &lt;= 5; i ++){ setTimeout(function timer(){ console.log(i) }, 0) }","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"JavaScript-this","slug":"JavaScript/JavaScript-this","date":"2020-01-07T10:10:52.000Z","updated":"2020-04-03T09:03:31.687Z","comments":true,"path":"2020/01/07/javascript/javascript-this/","link":"","permalink":"http://qiandream.cn/2020/01/07/javascript/javascript-this/","excerpt":"导语 JavaScript 中的 this 就是一个对象，本文旨在分析各种情况下 this 的指向问题。","text":"导语 JavaScript 中的 this 就是一个对象，本文旨在分析各种情况下 this 的指向问题。 this 就是一个对象，不同情况下，this 的指向不同，主要有以下几种情况： 直接调用，指向全局对象 window function foo() { console.log(this) } foo() // window 对象调用，指向该对象 var obj = { name: 'a', foo: function() { console.log(this.name) } } obj.foo() // 'a' new 方式，指向新创建的对象 function Foo(name) { this.name = name console.log(this) } var wangxiaobai = new Foo('wangxiaobai') // 'wangxiaobai' 箭头函数的 this 由于箭头函数没有单独的 this 值，箭头函数的 this 与其声明所在的上下文相同(取决于包裹箭头函数的第一个普通函数的 this)，并且不会改变。 const obj = { a:()=>{ console.log(this); } } // 对象调用箭头函数 obj.a(); // window 如何改变 this 的指向我们可以通过 call、apply、bind 改变 this 的指向： var obj = { name: 'wangxiaobai' } function foo() { console.log(this) } // 通过 call 改变 this 指向 foo.call(obj); // obj // 通过 apply 改变 this 指向 foo.apply(obj); // obj // 通过 bind 改变 this 指向 foo.bind(obj)() 总结一下三者的共同点和不同点。 共同点： 三者都能改变 this 的指向，且第一个传递的参数都是 this 指向的对象 三者都采用的后续传参的形式 不同点： call 的传参是单个传递，apply 的传参是数组形式，bind 没有明确规定。 call 和 apply 函数的执行是直接执行，bind 函数会返回一个函数，然后想要调用的时候才会执行。 最后，当多个规则同时出现时，根据优先级来决定 this 最终指向哪里。 new &gt; 显示绑定(call, apply, bind) &gt; 对象绑定 &gt; 隐式绑定","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"JavaScript-new","slug":"JavaScript/JavaScript-new","date":"2020-01-07T10:10:52.000Z","updated":"2020-04-03T09:03:25.202Z","comments":true,"path":"2020/01/07/javascript/javascript-new/","link":"","permalink":"http://qiandream.cn/2020/01/07/javascript/javascript-new/","excerpt":"导语 new 关键字，首先想到的是 new 一个实例对象。","text":"导语 new 关键字，首先想到的是 new 一个实例对象。 new 内部发生了什么new 的过程包括以下四个阶段： 创建一个新对象 这个新对象的 proto 属性指向构造函数的 prototype 属性 将这个新对象绑定到此函数的 this 上 如果这个函数没有返回其它对象，就返回这个新对象 手动实现一个 new 操作符// 创建一个新对象 // 链接到原型链 // 绑定 this // 返回对象 function create(Con, ...args) { let obj = {} obj.__proto__ = Con.prototype let result = Con.apply(obj, args) return result instanceof Object ? result : obj } 有几种创建对象的方式最常用的常见对象的两种方式： 对象字面量 new 构造函数 其它创建对象的方式： Object.create Object.create(proto, [propertiesObject]) proto: 新创建对象的原型对象 为创建的新对象设置属性和值 字面量相对于 new 创建对象有哪些优势 代码量少，易阅读 new / 字面量 与 Object.create(null)创建对象的区别？ new / 字面量创建的对象的原型指向 Object.prototype，会继承 Object 属性和方法 Object.create(null) 创建的对象，其原型指向 null，null 作为原型链的顶端，没有继承任何属性和方法。 对象字面量运行速度快，可以在解析时被优化。new 一个对象，解析器需要顺着作用域链从当前作用域开始查找，如果在当前作用域找到名为 Object() 的函数就执行，如果一直没找到，就会顺着作用链继续查找，直到找到为止。 Object() 构造函数可以接收参数，通过这个参数可以把实例的创建过程委托给其它内置构造函数，并返回另外一个对象实例。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"JavaScript-数据类型转换","slug":"JavaScript/JavaScript-数据类型转换","date":"2020-01-05T11:30:52.000Z","updated":"2020-04-03T09:05:07.233Z","comments":true,"path":"2020/01/05/javascript/javascript-shu-ju-lei-xing-zhuan-huan/","link":"","permalink":"http://qiandream.cn/2020/01/05/javascript/javascript-shu-ju-lei-xing-zhuan-huan/","excerpt":"导语 类型转换分为显式类型转换和隐式类型转换，每种转换又分为原始类型转换和对象类型转换。","text":"导语 类型转换分为显式类型转换和隐式类型转换，每种转换又分为原始类型转换和对象类型转换。 显式类型转换显式类型转换就是我们所说的强制类型转换 其它数据类型转字符串(对象除外) 数据类型 字符串类型 数字 转化为数字对应的字符串 true ‘true’ false ‘false’ null ‘null’ undefined ‘undefined’ [] ‘’ [‘Q’, ‘X’] ‘Q,X’ function(){} ‘function(){}’ String(123); // \"123\" String(true); // \"true\" String(null); // \"null\" String(undefined);// \"undefined\" String([1,2]) // \"1,2\" String({}); // \"[object Object]\" 其它类型转换为数字(对象除外) 数据类型 数字类型 字符串 1)数字转换为对应的数字 2）其它转换为 NaN ‘’ 0 true 1 false 0 null 0 undefined NaN [] 0 [9] 9 存在一个元素且为数字转数字； [‘a’, ‘b’] NaN function(){} NaN Number(20); // 10 Number('20'); // 10 Number(null); // 0 Number(''); // 0 Number(true); // 1 Number(false); // 0 Number([]); // 0 Number([1,2,3]); // NaN Number('20a'); // NaN Number(undefined); // NaN 其它数据类型转换为布尔类型(包括对象)除几个特殊值：0、’’、false、null、undefined、NaN转换为 Boolean 为 false，其它类型值均为 true（包括对象）。 对象转原始类型(字符串和数字)对象到字符串和字符串到对象的转换是通过调用待转对象的一个方法来完成的，一个麻烦的事实是，JavaScript 对象有两个不同的方法来进行转换。 所有对象继承了两个转换方法： 1）toString()，它的作用是返回一个反映这个对象的字符串。 对象类的 toString() 返回一个字符串：’[object, Object]’ 数组类的 toString() 将每个数组元素转换为字符串，并在元素之间添加逗号后合并成字符串 函数类的 toString() 返回这个函数的实现定义的表示方式 日期类的 toString() 返回一个可读的日期和时间字符串 正则表达式的 toString() 返回这个正则表达式直接量的字符串 ({x: 1, y: 2}).toString() // '[object, Object]' [1, 2].toString() // '1,2' (function() {}).toString() // 'function() {}' (/\\d+/).toString() // '/\\\\d/' new Date(2010,0,1).toString() // 'Fri Jan 012010 00:00:00 GMT-0800(PST)' 2) valueOf()，如果存在原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的 valueOf() 方法简单的返回对象本身（日期对象除外）。 ({x: 1, y: 2}).valueOf() // {x: 1, y: 2} [1, 2].valueOf() // [1, 2] (function() {}).valueOf() // function() {} (/\\d+/).valueOf() // /\\\\d/ new Date(2010,0,1).valueOf() // 1262275200000 对象转换为字符串对象转换为字符串经历了以下步骤： 如果对象具有 toString() 方法，则调用这个方法。如果它返回一个原始值，将这个值转换为字符串并返回。 如果对象没有 toString() 方法，或者这个方法不返回一个原始值，则调用 valueOf() 方法，如果它返回一个原始值，将这个值转换为字符串并返回。 如果两者都不成功，抛出类型错误。 对象转换为数字对象转换为数字经历了以下步骤： 如果对象具有 valueOf() 方法，则调用这个方法。如果它返回一个原始值，将这个值转换为数字并返回。 否则，如果对象具有 toString() 方法，则调用 toString() 方法，如果它返回一个原始值，将这个值转换为数字并返回。 如果两者都不成功，抛出类型错误。 四则运算隐式类型转化是不需要认为的强制类型转化，javaScript 自动将类型转化为需要的类型，所以称之为隐式类型转换。 加法运算加法运算符是在运行时决定，到底是执行相加，还是执行连接。 如果双方都不是字符串： Boolean + Boolean 会转换为数字相加 Boolean + Number 布尔类型会转换为数字相加 Object + Number Object型调用 valueOf，如果不是 String、Boolean或者 Number类型，则继续调用 toString()转化为字符串。 true + true // 2 1 + true // 2 [1] + 3 // '13' 字符串和字符串以及字符串和非字符串相加都会进行拼接。 1 + 'b' // ‘1b’ false + 'b' // ‘falseb’ 其它运算其它算数运算符(减乘除)，所有运算数一律转换为数值，再进行相应的运算。 1 * '2' // 2 1 * [] // 0 逻辑运算符逻辑运算符包括两种情况：条件判断和赋值操作。 条件判断 &amp;&amp;：所有条件为真，整体才为真 ||：其中任一条件为真，整体就为真 true &amp;&amp; true // true true &amp;&amp; false // false true || true // true true || false // true 赋值操作 A &amp;&amp; B 首先看 A 的真假，A 为假，返回 A 的值，A 为真则返回 B 的值（不管B是什么） console.log(0 &amp;&amp; 1) // 0 console.log(1 &amp;&amp; 2) // 2 A || B 首先看 A 的真假，A 为真，返回 A 的值，A 为假则返回 B 的值（不管B是什么） console.log(0 || 1) // 1 console.log(1 || 2) // 1 比较远算符比较运算符在逻辑语句中使用，以判定变量或值是否相等。 == 和 === 的区别？ 对于 === 来说，是严格意义上的相等，会比较两个操作符的类型和值。 如果 X 和 Y 类型不同，则返回 false 如果 X 和 Y 类型相同，则根据下方表格进一步判断 条件 例子 返回值 undefined === undefined undefined === undefined true null === null null === null true String === String ‘a’ === ‘a’‘a’ === ‘aa’ truefalse Boolean === Boolean true === truefalse === false truefalse Symbol === Symbol 相同的 Symbol 返回 true不相同的 Symbol 返回 true Number === Number其中一个为 NaN，返回falseX 和 Y 值相等，返回 true 0 和 -0，返回 true NaN === NaNNaN === 13===30 === -0 falsefalsetruetrue 对于 ==来说，是非严格意义上的相等，先判断两个操作符的类型是否相等，如果类型不同，则先进行类型转换，然后再判断值是否相等。 如果 X 和 Y 的类型相同，返回 X == Y 的比较结果； 如果 X 和 Y 的类型不同，根据下方表格进一步判断; 条件 例子 返回值 null == undefined null == undefined true String == Number，String 转 Number ‘2’ == 2 true Boolean == Number，Boolean 转 Number true == 1 true Object == String,Number,Symbol，将 Object 转化为原始类型再比较值大小n [1] == 1[1] == ‘1’ truetrue 其他返回 false false 参考文档：","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"JavaScript-数据类型存储形式","slug":"JavaScript/JavaScript-数据类型存储形式","date":"2020-01-05T03:37:52.000Z","updated":"2020-04-03T09:05:26.889Z","comments":true,"path":"2020/01/05/javascript/javascript-shu-ju-lei-xing-cun-chu-xing-shi/","link":"","permalink":"http://qiandream.cn/2020/01/05/javascript/javascript-shu-ju-lei-xing-cun-chu-xing-shi/","excerpt":"导语 JavaScript 数据类型分为原始类型和引用类型（对象类型），两种类型在内存中有不同的存储形式。","text":"导语 JavaScript 数据类型分为原始类型和引用类型（对象类型），两种类型在内存中有不同的存储形式。 栈（stack）和堆（Heap），是两种基本的数据结构。 栈在内存中是自动分配内存空间，堆在内存中是动态分配内存空间，不一定会自动释放。 一般我们在项目中将对象类型手动置为 null，减少无用内存消耗。 原始类型和对象类型分别在内存中的存在形式如下图： 原始类型是按值形式存放在栈中的数据段，内存空间可以自由分配，同时按值直接访问。 引用类型在栈中保存的是这个对象在堆内存中的引用地址，值保存在堆内存中。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"JavaScript-数据类型","slug":"JavaScript/JavaScript-数据类型","date":"2020-01-04T03:30:52.000Z","updated":"2020-04-03T09:04:19.027Z","comments":true,"path":"2020/01/04/javascript/javascript-shu-ju-lei-xing/","link":"","permalink":"http://qiandream.cn/2020/01/04/javascript/javascript-shu-ju-lei-xing/","excerpt":"导语 JavaScript 数据类型分为原始类型和引用类型（对象类型）。","text":"导语 JavaScript 数据类型分为原始类型和引用类型（对象类型）。 原始类型在 JavaScript 中，存在 6 种原始类型： string number boolean undefined symbol null 原始类型存储的都是值，是没有函数可以调用的。 引用类型引用类型统称为 Object 类型，如果细分的话，常用的有以下几个： Object Function Array Date Error RegExp","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"LeetCode-003-回文数","slug":"LeetCode/LeetCode-003-回文数","date":"2020-01-03T10:11:52.000Z","updated":"2020-04-10T10:00:16.138Z","comments":true,"path":"2020/01/03/leetcode/leetcode-003-hui-wen-shu/","link":"","permalink":"http://qiandream.cn/2020/01/03/leetcode/leetcode-003-hui-wen-shu/","excerpt":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。","text":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 前言 难度：简单 设计知识：字符串、数组、数学 题目地址：https://leetcode-cn.com/problems/roman-to-integer/ 题目内容： 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 解题解法 - 数组操作/** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { let Arr = String(x).split('') for (let i = 0; i &lt; Arr.length / 2; i++) { let j = Arr.length - (i+1) if (Arr[i] !== Arr[j]) { return false } } return true }; 执行测试 输入： 121 输出： true 预期结果： true 解题思路：转换为字符串、数组，交叉对比 split(): 字符串分割为数组","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://qiandream.cn/categories/数据结构与算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://qiandream.cn/tags/LeetCode/"}]},{"title":"JavaScript-深浅拷贝","slug":"JavaScript/JavaScript-深浅拷贝","date":"2020-01-03T03:27:52.000Z","updated":"2020-04-03T09:04:43.510Z","comments":true,"path":"2020/01/03/javascript/javascript-shen-qian-kao-bei/","link":"","permalink":"http://qiandream.cn/2020/01/03/javascript/javascript-shen-qian-kao-bei/","excerpt":"导语 类型判断在 Web 开发中有非常广泛的作用，简单的有判断数字、字符串，复杂的有判断数组还是对象等。 导语 当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。","text":"导语 类型判断在 Web 开发中有非常广泛的作用，简单的有判断数字、字符串，复杂的有判断数组还是对象等。 导语 当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。 实例🌰： var a = {x: 10, y: 10} var b = a b.x = 100 b.y = 100 打印一下a和b的值： console.log(a) // {x: 100, y: 200} console.log(b) // {x: 100, y: 200} 发现改变b的值，同时也改了a的值。 🌰： var a = 10 var b = a b = 20 打印一下a和b的值： console.log(a) // 10 console.log(b) // 20 ??? b的值改变并没有引起a的值改变。 值类型 vs 引用类型在JS中，变量传递方式分为值类型和引用类型。值类型包括String，Number，Null，Boolean，Undefined。引用类型包括Object类的所有，如Date，Array，Function。 在参数传递方式上，值类型是按值传递。引用类型是按共享传递(指向同一个内存地址，两者引用同一个值，当一者改变值，另一者也改变)。 JS这样设计的原因在于：按值传递的类型，复制一份存入栈内存，这类类型一般不会占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值，保证过大的对象等不会因为不停复制内容而造成内存的浪费。 深拷贝和浅拷贝最根本的区别在于是否真正获取了一个对象的拷贝实体，而不只是引用。 浅拷贝的实现方式直接赋值🌰： let obj = {username: &#39;kobe&#39;, age: 39, sex: {option1: &#39;男&#39;, option2: &#39;女&#39;}} let obj1 = obj obj1.sex.option1 = &#39;不男不女&#39; // 修改复制的对象会影响原对象 打印obj1的值 console.log(obj1) // {username: &#39;kobe&#39;, age: 39, sex: {option1: &#39;不男不女&#39;, option2: &#39;女&#39;}} Object.assign🌰： let obj = { username: &#39;kobe&#39; }; let obj1 = Object.assign(obj) obj1.username = &#39;wang&#39; 打印obj的值 console.log(obj) // { username: &quot;wang&quot; } Array.prototype.concat🌰： let arr = [1, 3, { username: &#39;kobe&#39; }] let arr2=arr.concat() arr2[2].username = &#39;wang&#39; 打印arr的值 console.log(arr) // [1, 3, { username: &quot;wade&quot; }] Array.prototype.slice🌰： let arr = [1, 3, { username: &#39;kobe&#39; }] let arr2=arr.slice() arr2[2].username = &#39;wang&#39; 打印arr的值 console.log(arr) // [1, 3, { username: &quot;wade&quot; }] Array.prototype.concat vs Array.prototype.slice关于Array的concat和slice补充说明：Array的concat和slice方法不改变原始数组，只是返回了一个浅复制原数组中的元素的一个新数组。 原数组中的元素会按照下述规则拷贝： 如果该元素是个引用类型，slice或者concat会拷贝这个引用到新的数组里，两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新数组和原数组中的这个元素都会发生改变。 如果该元素是个值类型，slice或者concat会复制一份这些值到新数组里。在别的数组里修改这些值，并不会影响另一个数组。 🌰： let arr = [1, 3, { username: &#39;kobe&#39; }]; let arr3 = arr.slice(); arr3[1] = 2 console.log(arr, arr3) 打印arr和arr3的值 console.log(arr, arr3) // ---result // [1, 3, { username: &quot;kobe&quot; }] // [1, 2, { username: &quot;kobe&quot; }] 深拷贝的实现方式Object.assignObject.assign可以进行一层深度拷贝 🌰： var obj = { name: &#39;wang&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj1 = Object.assign({}, obj1) obj1.age = 24 console.log(obj, obj1) 打印obj和obj1的值 console.log(obj, obj1) // ----result // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { } } // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { }, age: 24 } 然而。。。。。 🌰： var obj = { name: &#39;wang&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj1 = Object.assign({}, obj1) obj1.test4.age = 24 打印obj和obj1的值 console.log(obj, obj1) // ----result // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { age: 24 } } // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { age: 24 } } JSON.parse(JSON.stringfy(obj))说到深拷贝，你肯定会想到JSON.parse(JSON.stringfy(obj))。 🌰： var obj = { name: &#39;wang&#39;, test: { name: &#39;test&#39; } }; var obj1 = JSON.parse(JSON.stringify(obj)) obj1.test.name = 24 打印obj和obj1的值 console.log(obj, obj1) // ----result // { name: &quot;wang&quot;, test: { name: &quot;test&quot; } } // { name: &quot;wang&quot;, test: { name: 24 } } 然而。。。。 🌰： var obj = { name: &#39;wang&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj1 = JSON.parse(JSON.stringify(obj)) 打印obj和obj1的值 console.log(obj, obj1) // ---result // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: { } } // { name: &quot;wang&quot;, test1: null, test4: { } } ???test2和test3不见了。。。。。 JSON.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个JSON字符串，不能接受函数。 手写递归方法function deepClone(obj) { let result let toString = Object.prototype.toString if (toString.call(obj) === &#39;[Object Array]&#39;) { result = [] for (var i =0; i&lt;obj.length; i++) { result[i] = deepClone(obj[i]) } } else if (toString.call(obj) === &#39;[Object Object]&#39;) { result = {} for (var key in obj) { if (obj.hasOwnProperty(key)) { result[key] = deepClone(obj[key]) } } } else { return obj } return result } 🌰：调用函数并打印结果 var obj = { name: &#39;wang&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj1 = deepClone(obj) console.log(obj, obj21) // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: Object { } } // { name: &quot;wang&quot;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: Object { } } jQuery实现🌰： var obj1 = { name: &#39;wang&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj2 = $.extend(true, {}, obj1) lodash实现🌰： var obj1 = { name: &#39;wclimb&#39;, test1: null, test2: undefined, test3: function(){alert(1)}, test4: {} }; var obj2 = _.cloneDeep(obj1)","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"LeetCode-002-整数反转","slug":"LeetCode/LeetCode-002-整数反转","date":"2020-01-02T10:11:52.000Z","updated":"2020-04-02T07:26:30.246Z","comments":true,"path":"2020/01/02/leetcode/leetcode-002-zheng-shu-fan-zhuan/","link":"","permalink":"http://qiandream.cn/2020/01/02/leetcode/leetcode-002-zheng-shu-fan-zhuan/","excerpt":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。","text":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 前言 难度：简单 设计知识：数组 题目地址：https://leetcode-cn.com/problems/reverse-integer/ 题目内容： 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解题解法 - 转字符串、数组反转/** * @param {number} x * @return {number} */ var reverse = function(x) { // 转换为整数 let num = Math.abs(x) // 转换为字符串 let string = String(num) // 字符串反转 let result = Number(string.split('').reverse().join('')) if (result &lt; Math.pow(2, -31) || result > Math.pow(2, 31) -1) { return 0 } if (x &lt; 0) { return -result } return result }; 执行测试 输入： 123 输出： 321 预期结果： 321 解题思路：转换为字符串、数组 String: 将其他值转换为字符串 Number: 将其他值转换为数字值 Math: JS 内置对象 split(): 字符串分割为数组 reverse(): 数组翻转 join(): 数组转换为字符串","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://qiandream.cn/categories/数据结构与算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://qiandream.cn/tags/LeetCode/"}]},{"title":"面试题-常见面试题系列之CSS基础","slug":"面试题-常见面试题系列之CSS基础","date":"2020-01-02T06:46:52.000Z","updated":"2020-02-17T06:09:49.694Z","comments":true,"path":"2020/01/02/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-css-ji-chu/","link":"","permalink":"http://qiandream.cn/2020/01/02/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-css-ji-chu/","excerpt":"","text":"导语本系列旨在整理 CSS 考点的非重难点，帮助梳理 HTML 高频面试题。 CSS选择器的优先级是怎样的？CSS 选择器的优先级是：内联选择器 &gt; id 选择器 &gt; 类选择器 &gt; 标签选择器 到具体的计算层面，优先级是由 A、B、C、D 的值来决定的，其中它们的值计算规则如下： A 的值等于1的前提是存在内联样式，否则 A = 0 B 的值等于 ID 选择器出现的次数 C 的值等于类选择器和属性选择器和伪类出现的总次数 D 的值等于标签选择器和伪元素出现的总次数 例如下面的选择器，它不存在内联样式，所以 A = 0，不存在 id 选择器，B = 0，存在一个类选择器 C = 1，存在三个标签选择器 D = 3，那么最终结果为：{0, 0, 1, 3} ul ol li .red { ... } link 和 @import 的区别？ link 属于 XHTML 标签，而 @import 是 CSS 提供的。 页面被加载时，link 会同时加载。而 @import 会到页面被加载完在加载。 link 方式的样式权重高于 @import 的权重。 有哪些方式（CSS）可以隐藏页面元素？ opacity: 0：本质是将元素的透明度降为 0，就看起来隐藏了，但是依然占据空间且可以交互。 visibility: hidden：与上一个方法类似的效果，占据空间，但是不可以交互了。 overflow: hidden：隐藏元素溢出的部分，占据空间且不可交互。 display: none：彻底隐藏元素，元素从文档流中消失，既不占据空间，也不交互，也不影响布局。 z-index: -9999：将层级放到底部。 transform: scale(0, 0)：平面变换，将元素缩放为 0，但是依然占据空间，不可交互。 em/px/rem 的区别？ px：绝对单位，页面按精确像素展示。 em：相对单位，基准点为父元素字体的大小。 rem：相对单位，基准点为根节点 html 的字体大小。 块级元素水平居中的方法？ margin: 0 auto; .center { width: 200px; height: 200px; margin: 0 auto; } flex 布局。 .center { display: flex; justify-content: center; } table 方法。 .center { display: table; margin: 0 auto; } CSS 有几种定位方式？ static：正常文档流定位。块级元素从上到下纵向排列，行级元素从左到右横向排列。 relative：相对布局。相对于正常文档流的位置。 absolute：绝对布局。 fixed：相对于屏幕视口的位置来指定元素位置。 sticky：粘性定位。近似效果就是 ios 通讯录滚动时候的【顶屁股】。 如何理解 z-index？控制重叠元素的垂直叠加顺序，默认元素的 z-index 为 0，而 z-index 只能影响设置了 position 值的元素。 如何理解层叠上下文？是什么？假定用户正面向网页，而 HTML 元素沿着其相对于用的一条虚构的 Z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。 如何产生？触发以下条件则会产生层叠上下文： 根元素 z-index 值不为 ‘auto’ 的相对/绝对定位 一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex opacity 属性值小于 1 的元素 transform 属性值不为 “none”的元素 mix-blend-mode 属性值不为 “normal”的元素 filter值不为“none”的元素 perspective值不为“none”的元素 isolation 属性被设置为 “isolate”的元素 position: fixed 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值 -webkit-overflow-scrolling 属性被设置 “touch”的元素 清除浮动有哪些方法？ 空 div 方法： Clearfix 方法： clearfix 类方法 overflow: hidden; ovrflow: auto; BFC 你对 css sprites 的理解，好处是什么？理解css sprites – 雪碧图，css 图像合成技术，开发人员往往将小图标合在一起，通过 background-image、background-position、background-size等属性定位到要使用的小图标。 优点 提前加载资源 减少 HTTP 请求书 缺点 维护成本高 加载速度优势在 http2 开启后荡然无存 你对媒体查询的理解？是什么媒体查询，添加自 CSS3，允许内容的呈现针对一个特定范围的输出设备而进行裁剪，而不必改变内容自身，非常适合 web 网页应对不同型号的设备而做出对应的响应适配。 如何使用媒体查询包含一个可选的媒体类型和满足 CSS3 规范的条件下，包含零个或多个表达式，这些表达式描述了媒体类型，最终会被解析为 true 或 false。 &lt;link rel=\"stylesheet\" href=\"example.css\" media=\"(max-width: 800px)\"> &lt;style> @media (max-width: 600px) { .fact_sidebar { display: none; } } &lt;/style> 你对盒模型的理解？当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型，将所有元素表示为一个个矩形的盒子，CSS 决定这些盒子的大小，位置及属性等。 盒模型由 content、padding、border、margin组成。 标准盒模型和怪异盒模型有什么区别？标准盒模型中，我们定义的元素的 width 为盒模型中 content 的宽度值，定义的 height 为盒模型中 content 的高度值。 因此，标准盒模型下： 元素的宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right 怪异盒模型中，我们定义的元素的 width 并不是 content 的宽度，而是 border-left + padding-left + width + padding-right + border-right 的总和，height 同理。 虽然现代浏览器默认使用W3C的标准盒模型，但是在不少情况下怪异盒模型更好用，于是W3C在css3中加入box-sizing。 谈谈对 BFC 的理解？块级格式化上下文，一块独立的渲染区域，BFC 内部的元素与外部的元素互相隔离。 BFC 触发条件： 根元素 position: fixed/absolute overflow 不为 visible float 不为 none display 的值为 inline-block、table-cell、table-caption BFC 的作用： 防止 margin 发生重叠 防止元素塌陷 两栏布局，防止文字环绕 为什么有时用 translate 来改变位置而不是定位？translate 改变位置时，元素依然占据其原始空间，不会触发浏览器重新布局或重绘，只会触发复合。 伪类和伪元素的区别是什么？伪类：以 (:) 为前缀，添加到一个选择器末尾的关键字，当你希望样式在特别状态下才被呈现到指定的元素时，你可以在元素的选择器后加上对应的伪类。 伪元素：用于创建一些不在文档树中的元素，并为其添加样式。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://qiandream.cn/tags/面试题/"}]},{"title":"JS-数据类型判断","slug":"JavaScript/JavaScript-数据类型判断","date":"2020-01-02T02:27:52.000Z","updated":"2020-04-03T07:32:57.620Z","comments":true,"path":"2020/01/02/javascript/javascript-shu-ju-lei-xing-pan-duan/","link":"","permalink":"http://qiandream.cn/2020/01/02/javascript/javascript-shu-ju-lei-xing-pan-duan/","excerpt":"导语 类型判断在 Web 开发中有非常广泛的作用，简单的有判断数字、字符串，复杂的有判断数组还是对象等。","text":"导语 类型判断在 Web 开发中有非常广泛的作用，简单的有判断数字、字符串，复杂的有判断数组还是对象等。 typeoftypeof 是一元操作符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。 除了 null 类型和 object 类型不能准确判断外，其它数据类型都可以返回正确的类型。 typeof undefined // 'undefined typeof '10' // 'string' typeof 10 // 'number' typeof false // 'boolean' typeof Symbol() // 'symbol' typeof Function // 'function' typeof null // 'object' typeof [] // 'object' typeof {} // 'object' Object.prototype.toString当 toString 方法被调用的时候，下面的步骤会被执行： 如果 this 值是 undefined，就返回 [object Undefined] 如果 this 的值是 null，就返回 [object Null] 让 O 成为 ToObject(this) 的结果 让 class 成为 O 的内部属性 [[Class]] 的值 最后返回由 “[object “ 和 class 和 “]” 三个部分组成的字符串 Object.prototype.toString.call(1) // \"[object Number]\" Object.prototype.toString.call('123') // \"[object String]\" Object.prototype.toString.call(true) // \"[object Boolean]\" Object.prototype.toString.call(undefined) // \"[object Undefined]\" Object.prototype.toString.call(null) // \"[object Null]\" Object.prototype.toString.call({a: 1}) // \"[object Object]\" Object.prototype.toString.call([1, 2]) // \"[object Array]\" Object.prototype.toString.call(new Date()) // \"[object Date]\" Object.prototype.toString.call(new Error()) // \"[object Error]\" Object.prototype.toString.call(/a/g) // \"[object RegExp]\" Object.prototype.toString.call(function a() {}) // \"[object Function]\" Object.prototype.toString.call(Symbol()) // \"[object Symbol]\" Object.prototype.toString.call(new Set()) // \"[object Set]\" Object.prototype.toString.call(new Map()) // \"[object Map]\" Object.prototype.toString.call(new Math) // \"[object Math]\" Object.prototype.toString.call(new JSON) // \"[object JSON]\" instanceofinstanceof 运算符用来判断一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 var a = [] console.log(a instanceof Array) // true class A { } console.log(A instanceof Function) // true","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"JavaScript-数组去重","slug":"JavaScript/JavaScript-数组去重","date":"2020-01-01T12:57:52.000Z","updated":"2020-04-03T09:04:48.567Z","comments":true,"path":"2020/01/01/javascript/javascript-shu-zu-qu-chong/","link":"","permalink":"http://qiandream.cn/2020/01/01/javascript/javascript-shu-zu-qu-chong/","excerpt":"导语 数组去重方法老生常谈，本文主要总结常见的数组去重方法。","text":"导语 数组去重方法老生常谈，本文主要总结常见的数组去重方法。 🌰 array = [1, ‘1’, 1, ‘1’] 双层循环function unique(array) { let result = [] for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) { for (var j = 0, resultLen = result.length; j &lt; resultLen; j++) { if (array[i] === result[j]) { break } } if (j === resultLen) { result.push(array[i]) } } return result } console.log(unique([1, 1, '1', '1'])) 使用循环嵌套，最外层循环 array，里面循环 result，如果 array[i] 的值跟 result[j] 的值相等，就跳出循环，如果都不等于，说明元素是唯一的，这时候 j 的值就会等于 result 的长度，根据这个特点进行判断，将值添加进 result。 indexOf可以使用 indexOf 来简化内层循环： function unique(array) { let result = [] for (var i = 0, arrayLen = array.length; i &lt; arrayLen; i++) { let current = array[i] if (result.indexOf(current) === -1) { result.push(current) } } return result } console.log(unique([1, 1, '1', '1'])) filter可以使用 filter 的方法： function unique(array) { var res = array.filter(function(item, index, array){ return array.indexOf(item) === index; }) return res; } console.log(unique([1, 2, 1, 1, '1'])); Object 键值对这种方法是利用一个空的 Object 对象，我们把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。 function unique(array) { var obj = {}; return array.filter(function(item, index, array){ return obj.hasOwnProperty(item) ? false : (obj[item] = true) }) } console.log(unique([1, 2, 1, 1, '1'])); // [1, 2] 我们可以发现，是有问题的，因为 1 和 ‘1’ 是不同的，但是这种方法会判断为同一个值，这是因为对象的键值只能是字符串，所以我们可以使用 typeof item + item 拼成字符串作为 key 值来避免这个问题： function unique(array) { var obj = {}; return array.filter(function(item, index, array){ return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) }) } console.log(unique([1, 2, 1, 1, '1'])); // [1, 2, \"1\"] ES6Setfunction unique(array) { return Array.from(new Set(array)) } console.log(unique([1, 2, 1, 1, '1'])); // [1, 2, \"1\"] function unique(array) { return [...new Set(array)] } console.log(unique([1, 2, 1, 1, '1']));","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://qiandream.cn/tags/JavaScript/"}]},{"title":"LeetCode-001-两数之和","slug":"LeetCode/Leetcode-001-两数之和","date":"2020-01-01T10:11:52.000Z","updated":"2020-05-08T11:37:27.472Z","comments":true,"path":"2020/01/01/leetcode/leetcode-001-liang-shu-zhi-he/","link":"","permalink":"http://qiandream.cn/2020/01/01/leetcode/leetcode-001-liang-shu-zhi-he/","excerpt":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。","text":"导语 本系列为 LeetCode 刷题系列，旨在夯实 JavaScript基础，了解常见算法。 前言 难度：简单 设计知识：数组、哈希表 题目地址：https://leetcode-cn.com/problems/two-sum/ 题目内容： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解题解法 - for()/** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { for (let i = 0; i &lt; nums.length; i++) { for (let j = i+1; j &lt; nums.length; j++) { if (target - nums[i] === nums[j]) { return [i, j] } } } }; 执行测试 输入： [2,7,11,15] 9 输出： [0,1] 预期结果： [0,1] 解题思路：使用双重 for 循环，不过这样时间复杂度为 O(N^2)，空间复杂度为 O(1)，时间复杂度较高，我们要想办法进行优化。 解法 - Map/** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let map = new Map() for (let i = 0; i &lt; nums.length; i++) { let diff = target - nums[i] if (map.has(diff)) { return [map.get(diff), i] } map.set(nums[i], i) } }; 执行测试 输入： [2,7,11,15] 9 输出： [0,1] 预期结果： [0,1] 我们可以增加一个 Map 记录已经遍历过的数字及其对应的索引值。这样当遍历一个新数字的时候去 Map 里查询，target 与该数的差值是否已经在前面的数字中出现过。如果出现过，那么已经得出答案，就不必再往下执行了。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://qiandream.cn/categories/数据结构与算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://qiandream.cn/tags/LeetCode/"}]},{"title":"面试题-常见面试题系列之JS基础","slug":"面试题-常见面试题系列之HTML基础","date":"2020-01-01T01:46:52.000Z","updated":"2020-02-13T06:44:06.238Z","comments":true,"path":"2020/01/01/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-html-ji-chu/","link":"","permalink":"http://qiandream.cn/2020/01/01/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-html-ji-chu/","excerpt":"","text":"导语本系列旨在整理 HTML 考点的非重难点，帮助梳理 HTML 高频面试题。 doctype 的作用是什么？doctype 是 html5 标准的网页声明，必须声明在 html 文档的第一行。规定了浏览器的解析器以何种渲染模式来解析文档，不同的渲染模式会影响到浏览器对 css 甚至 js 脚本的解析。 解析模式有： BackCompat: 怪异模式，浏览器使用自己的怪异模式解析文档（默认值）。 CSS1Compat: 标准模式，浏览器使用 W3C 的标准解析文档。 近乎标准模式：IE8 有一种介乎于上述两者之间的近乎标准的模式。 这三者的区别是什么？ 标准模式：页面会按照 HTML 与 CSS 的定义渲染。 怪异模式：页面会模拟更旧的浏览器的行为。 近乎标准模式： 会实施一种表单元格尺寸的怪异行为。 HTML、XHTML、XML 有什么区别？ HTML (超文本标记语言)：在 html4 之前，HTML 先有实现再有标准，导致 html 非常混乱。 XML (可扩展标记语言)：主要用于存储数据和结构，可扩展。 XHTML (可扩展超文本标记语言)：基于上面两者而来，W3C 为了解决 html 混乱问题而生，并基于此诞生了 HTML5。 什么是 data- 属性？html 的数据属性，用于将数据存储在标准的 html 元素中作为额为信息，可以用 js 访问并操作它。 &lt;article id=\"electriccars\" data-columns=\"3\" data-index-number=\"12321\" data-parent=\"cars\"> &lt;/article> 前端框架出现后，这种方法已经不流行了 你对 HTML 语义化的理解？语义化指运用恰当语义的 html 标签，使页面具有良好的结构与定义。 语义化的好处： 开发者友好：增强了可读性，开发者可以清晰地看出网页的结构。 机器友好：便于搜索引擎的爬虫爬取有效的信息。 HTML4 与 HTML5 的不同之处？ 文档类型声明 (&lt;!DOCTYPE&gt;) 仅有一型：&lt;!DOCTYPE HTML&gt;。 新的解析顺序：不再基于 SGML。 新的元素：section、video、progress、nav、meter、time、footer、header、summary、source等。 input 元素的新类型：date、email、url等。 全域属性：id、tabindex、repeat 等。 新的全域属性：contenteditable, contextmenu, draggable, dropzone, hidden, spellcheck。 移除元素：acronym, applet, basefont, big, center, dir, font, frame, frameset, isindex, noframes, strike。 有哪些常用的 meta 标签？meta 标签用于描述一个 html 文档的元信息，如：作者、日期和时间等。 charset：用于描述 html 文档的编码形式。 &lt;meta charset=\"UTF-8\"> viewport：控制视口的大小和比例。 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"> http-equiv：相当于 http 的文件头作用。 &lt;meta http-equiv=\"expires\" content=\"Web, 20 Jun 2020 22:28:00 GMT\"> app-mobile-web-app-status-bar-style：自定义苹果工具栏的颜色。 &lt;meta name=\"app-mobile-web-app-status-bar-style\" content=\"black-translucent\"> href 和 src 的区别？ src：指向外部资源，指向的内容会下载并嵌入到文档中当前标签所在的位置。当浏览器解析到该元素时，会暂停其它资源的下载和处理，直到当前资源加载、编译、执行完毕。 href：指向网络资源所在位置，用来建立和当前元素或文档之间的连接，当浏览器识别到它所指向的文件时，则会并行下载资源。 img 的 srcset 作用是什么？使用 img 的 两个新属性 srcset 和 sizes 来提供更多额外的资源图像和提示，帮助浏览器选择一个正确的资源。 srcset 定义了我们允许浏览器选择的图像集以及每个图像的大小。 sizes 定义了一组媒体条件，并指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。 有了这些属性，浏览器会： 查看设备宽度 检查 sizes 哪个媒体条件为真 查看给予该媒体查询的槽大小 加载 srcset 中引用的最接近所选的槽的大小的图像 &lt;img src=\"clock-demo-thumb-200.png\" alt=\"Clock\" srcset=\"clock-demo-thumb-200.png 200w, clock-demo-thumb-400.png 400w\" sizes=\"(min-width: 600px) 200px, 50vw\"> 还有哪一个标签能起到和 srcset 类似作用？ 元素通过包含零个或多个 元素和一个 元素来为不同的显示、设备场景提供图像版本。浏览器会选择最匹配的子 元素，如果没有匹配的，就会选择 元素的 src 属性中的 url。 &lt;picture> &lt;source srcset=\"/media/examples/surfer-240-200.jpg\" media=\"(min-width: 800px)\"> &lt;img src=\"/media/examples/painted-hand-298-332.jpg\" /> &lt;/picture> script 标签中 defer 和 async 的区别？ defer：异步加载脚本，等待文档被解析完毕后执行。 async：异步加载脚本，加载完毕后立即执行。 有几种前端存储方式？cookie、localStorage、sessionStorage、indexedDB 这些方式的区别？ cookie：优点是兼容性好，请求头自带 cookie 方便。缺点是大小只有4k，自动请求头加入 cookie 浪费流量，每个 domain 限制20 个 cookie。 localStorage：优点是操作方便，永久性存储，大小为 5M，缺点是只能手动删除。 sessionStorage：与 localStorage 基本类似。区别是当页面关闭后会清理。不能在所有同源窗口中被共享。 indexedDB：标准的数据库存储方案，是 NoSQL 数据库，用键值对进行存储，可快速读取。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://qiandream.cn/tags/面试题/"}]},{"title":"面试题-常见面试题系列之JS基础","slug":"面试题-常见面试题系列之JS基础","date":"2019-11-25T01:46:52.000Z","updated":"2019-11-25T20:02:59.098Z","comments":true,"path":"2019/11/25/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-js-ji-chu/","link":"","permalink":"http://qiandream.cn/2019/11/25/mian-shi-ti-chang-jian-mian-shi-ti-xi-lie-zhi-js-ji-chu/","excerpt":"","text":"导语本系列旨在整理 JS 常见面试题，帮助梳理 JS 基础知识点。 🌰 [‘1’, ‘2’, ‘3’].map(parseInt) 输出结果parseInt解析一个字符串参数，返回一个指定基数的整数。 const intValue = parseInt(string[, radix]); string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串。字符串开头的空白符会被忽略。 radix 一个介于 2~36之间的整数，表示上述字符串的基数，默认值为 10。 parseInt 返回一个整数或 NaN。 parseInt(100); // 100 parseInt(100, 10); // 1*10*10 + 0*10*1 + 0*10*0 = 100 parseInt(100, 2); // 1*2*2 + 0*2*1 + 0*2*0 = 4 在 radix 为 undefined ，或 radix 为 0 或没有指定的情况下，JS 作如下处理： string 以 ‘0x’ 或 ‘0X’ 开头，则 radix 为 16。 string 以 ‘0’ 开头，radix 为 8 或者 10，具体哪个基数由实现环境决定。 string 以其它任何值开头，则 radix 为 10。 map创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 var new_array = arr.map(function callback(currentValue[,index[, array]]) { // Return element for new_array }[, thisArg]) callback 回调函数需要三个参数，分别为 currentValue(数组中当前正在处理的元素的值)、index(数组中当前正在处理的元素的索引)、array(map 方法中被调用的数组)。 const arr = [1, 2, 3] arr.map(num => num * 2) // [2, 4, 6] [‘1’, ‘2’, ‘3’].map(parseInt) 输出对于每个迭代 map，parseInt() 传递两个参数：字符串和基数。所以实际执行的代码为： ['1', '2', '3'].map(parseInt((item, index) => parseInt(item, index)) 执行步骤为： parseInt('1', 0); // 1 (10 进制) parseInt('2', 1); // NaN radix(2-36) parseInt('3', 2); // NaN 不符合2进制位数取值(0-1) 所以： ['1', '2', '3'].map(parseInt) // [1, NaN, NaN] 🌰 什么是节流和防抖？区别？如何实现？防抖动作绑定事件，动作发生后一定时间内触发时间，在这段时间内如果该动作又发生，则重新等待一定时间再触发事件。 /** * 防抖 debounce 定时器 * @param fn {function} 回调函数 * @param wait {number} 时间间隔 * @author wangxiaobai */ export function debounce (fn, wait) { let timer = null; return () => { // 清除上次执行得定时器 if (timer) { clearTimeout(timer); } // 设立新定时器 timer = setTimeout(() => { fn.apply(this, arguments); }, wait); } } 节流动作绑定事件，动作发生后一定时间内触发事件，在这段时间内如果该动作又发生，则无视该动作，直到事件执行完后，才能重新触发。 /** * 节流 throttle 定时器 * @param fn {function} 回调函数 * @param wait {number} 时间间隔 * @author wangxiaobai */ export function throttle (fn, wait) { // 上一次函数的执行时间 let activeTime = 0; return () => { let currentTime = +new Date(); if (currentTime - activeTime > wait) { fn.apply(this, arguments); activeTime = currentTime; } } } 🌰 Set、Map、WeakSet、WeakMapSet一种叫做集合的数据结构，类似于数组，成员唯一且无序。 new Set([iterable]) const s = new Set(); [1, 2, 3, 4, 3, 2, 1].forEach(item => s.add(item)); for (let item of s) { console.log(item) // 1 2 3 4 } let arr = [1, 2, 3, 2, 1, 1, 1]; [... new Set(arr)]; // [1, 2, 3] Set 允许你存储任何类型的唯一值，无论是原始值还是对象引用。 向 Set 加入值的时候，不会发生类型转换，所以 5 和 ‘5’ 是两个不同的值。 在 Set 中，NaN 等于自身。 let set = new Set(); set.add(NaN); set.add(NaN); set; // {NaN} let set1 = new Set(); set1.add(5); set1.add('5'); set; // {5, '5'} Set 实例属性 constructor: 构造函数 size: 元素数量 let set = new Set([1, 2, 3, 2, 1]); console.log(set.size); // 3 Set 实例方法 操作方法： add(value) 新增 delete(value) 存在即删除集合中的 value has(value) 判断集合中是否存在 value clear() 清空集合 let set = new Set(); set.add(1).add(2).add(1); set.size; // 2 set.has(1); // true set.has(3); // false set.delete(1); set.has(1); // false set.clear(); set.size; // 0 Array.from 可以将 Set 结构转化为数组 const items = new Set([1, 2, 3, 1]); const array = Array.from(items); console.log(array); // [1, 2, 3] // 或 const arr = [...items] console.log(arr); // [1, 2, 3] 遍历方法： keys() 返回一个包含集合中所有键的迭代器 values() 返回一个包含集合中所有值的迭代器 entries() 返回一个包含集合中所有键值对的迭代器 forEach(callbackFn, thisArg) map(callbackFn, thisArg) filter(callbackFn, thisArg) let set = new Set([1, 2, 3]) console.log(set.keys()); // SetIterator {1, 2, 3} console.log(set.values()); // SetIterator {1, 2, 3} console.log(set.entries()); // SetIterator {1 => 1, 2 => 2, 3 => 3} set.forEach((value, key) => { console.log(key + ' : ' + value); }); // 1:1 2:2 3:3 set = new Set([...set].map(item => item * 2)); console.log(set); // {2, 4, 6} set = new Set([...set].filter(item => (item >= 4))); console.log(set); // {4, 6} 因此，Set 很容易实现两个数组的交集、并集、差集 let set1 = new Set([1, 2, 3]); let set2 = new Set([4, 3, 2]); let intersect = new Set([...set1].filter(value => set2.has(value))); let union = new Set([...set1, ...set2]); let difference = new Set([...set1].filter(value => !set2.has(value))); console.log(intersect); // {2, 3} console.log(union); // {1, 2, 3, 4} console.log(difference); // {1} WeakSet允许你将弱引用对象储存在一个集合中。 WeakSet 与 Set 的区别： WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以 WeakSet 中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的引用，如果没有其它的变量或属性引用这个对象值，则这个对象或被垃圾回收掉 属性： constructor: 构造函数 方法： add(value) 添加元素 value has(value) 判断是否包含 value delete(value) 删除 value var ws = new WeakSet(); var obj = {} var foo = {} ws.add(obj); ws.add(foo); ws.has(obj); // true ws.has(foo); // false ws.delete(obj); ws.has(obj); // false Map一种叫做字典的数据结构，以 [key, value] 的形式存储 const m = new Map(); const o = { p: 'haha' }; m.set(o, 'content'); m.get(o); // 'content' m.has(o); // true m.delete(o); m.has(o); // false 任何具有 Iterator 接口，每个成员都是一个双元素的数组的数据结构都可以当做 Map 构造函数的参数。 const map = new Map([ ['name', '张三'], ['title', 'Author'] ]); map.size; // 2 map.has('name'); // true map.get('name'); // \"张三\" map.has('title'); // true map.get('title'); // \"Author\" const set = new Set([ ['foo', 1], ['bar', 2] ]); const m1 = new Map(set); m1.get('foo'); // 1 const m2 = new Map([['baz', 3]]); const m3 = new Map(m2); m3.get('baz'); // 3 如果读取一个未知的键，则返回undefined。 new Map().get('asfddfsasadf'); // undefined 只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。 const map = new Map(); map.set(['a'], 555); map.get(['a']); // undefined Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 let map = new Map(); map.set(-0, 123); map.get(+0); // 123 map.set(true, 1); map.set('true', 2); map.get(true); // 1 map.set(undefined, 3); map.set(null, 4); map.get(undefined); // 3 map.set(NaN, 123); map.get(NaN); // 123 属性： constructor：构造函数 size: 字典中所包含的元素个数 const map = new Map([ ['name', 'An'], ['des', 'JS'] ]); map.size; // 2 操作方法： set(key, value) 添加新元素 get(key) 通过键查找特定的数值并返回 has(key) 判断字典中是否存在 key delete(key) 通过键 key 从字典中移除对应的数据 clear() 字典中所有元素删除 遍历方法： keys() 将字典中包含的所有键名以迭代器形式返回 values() 将字典中包含的所有数值以迭代器形式返回 entries() 返回所有成员的迭代器 forEach() 遍历字典的所有成员 const map = new Map([ ['name', 'An'], ['des', 'JS'] ]); console.log(map.entries()); // MapIterator {\"name\" => \"An\", \"des\" => \"JS\"} console.log(map.keys()); // MapIterator {\"name\", \"des\"} 与其它数据结构相互转换 Map 转 Array const map = new Map([[1, 1], [2, 2], [3, 3]]) console.log([...map]); // [[1, 1], [2, 2], [3, 3]] Array 转 map const map = new Map([[1, 1], [2, 2], [3, 3]]) console.log(map); // Map {1 => 1, 2 => 2, 3 => 3} Map 转 Object function mapToObj(map) { let obj = Object.create(null); for (let [key, value] of map) { obj[key] = value; } return obj } const map = new Map().set('name', 'An').set('des', 'JS'); mapToObj(map); // {name: \"An\", des: \"JS\"} Object 转 Map function objToMap(obj) { let map = new Map(); for (let key of obj.keys()) { map.set(key, obj[key]) } return map } objToMap({'name': 'An', 'des': 'JS'}) // Map {\"name\" => \"An\", \"des\" => \"JS\"} Map 转 JSON function mapToJson(map) { return JSON.stringify([...map]); } let map = new Map().set('name', 'An').set('des', 'JS'); mapToJson(map); // [[\"name\",\"An\"],[\"des\",\"JS\"]] JSON 转 Map function jsonToStrMap(jsonStr) { return objToMap(JSON.parse(jsonStr)); } jsonToStrMap('{\"name\": \"An\", \"des\": \"JS\"}'); // Map {\"name\" => \"An\", \"des\" => \"JS\"} WeakMapWeakMap 对象是一组键值对的集合，其中键是弱引用对象，而值可以是任意。 每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收。 属性： constructor: 构造函数 方法： has(key)：判断是否有 key 关联对象 get(key)：返回key关联对象（没有则则返回 undefined） set(key)：设置一组key关联对象 delete(key)：移除 key 的关联对象 总结 Set 成员唯一、无序 可以遍历 WeakSet 成员都是对象 成员都是弱引用，可以被垃圾回收机制回收 不能遍历 Map 本质是键值对的集合 可以遍历 WeakMap 只接受对象作为键名 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收机制回收 不能遍历","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://qiandream.cn/tags/面试题/"}]},{"title":"Vue-源码系列随读笔记之Array变化侦测","slug":"Vue/Vue-源码系列随读笔记之Array变化侦测","date":"2019-08-18T10:34:52.000Z","updated":"2019-08-17T17:13:30.468Z","comments":true,"path":"2019/08/18/vue/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-array-bian-hua-zhen-ce/","link":"","permalink":"http://qiandream.cn/2019/08/18/vue/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-array-bian-hua-zhen-ce/","excerpt":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档","text":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档 什么是变化侦测从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。 简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。 Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。 如何追踪变化首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。 function defineReactive (data, key, val) { Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { return val }, set: function(newVal) { if (val === newVal) { return } val = newVal } }) } 此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。 由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。 如何收集依赖思考以下问题： let globalObj = { text1: 'text1' }; let o1 = new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;div>`, data: globalObj }); let o2 = new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;div>`, data: globalObj }); 该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？ 对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。 即：在 getter 中收集依赖，在 setter 中触发依赖。 依赖收集到哪里（Dep） 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。 export default class Dep { constructor () { this.subs = [] // 观察者集合 } // 添加观察者 addSub (sub) { this.subs.push(sub) } // 移除观察者 removeSub (sub) { remove(this.subs, sub) } depend () { // 如果存在 Dep.target，则进行依赖收集操作 if (Dep.target) { this.addSub(Dep.target) } } notify () { const subs = this.subs.slice() // 避免污染原来的集合 for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() // 更新 } } } function remove(arr, item) { if (arr.length) { const index = arr.indexOf(item) if (index > -1) { return arr.splice(index, 1) } } } 改造 defineReactive function defineReactive (data, key, val) { let dep = new Dep() Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { dep.depend() return val }, set: function(newVal) { if (val === newVal) { return } val = newVal dep.notify() } }) } 什么是依赖当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。 然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。 收集谁？Watcher! 什么是 WatcherWatcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。 vm.$watch('a.b.c', function(newVal, oldVal) { // do something }) 这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。 把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。 export default class Watcher { // ... constructor ( vm: Component, // 组件实例 expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作 cb: Function // 被观察者发生变化后的回调 ) { this.vm = vm // Watcher有一个 vm 属性，表明它是属于哪个组件的 this.cb = cb // 回调 this.getter = parsePath(expOrFn) this.value = this.get() } get () { // 触发取值操作，进而触发属性的getter Dep.target = this let value = this.getter.call(this.vm, this.vm) Dep.target = null return value } update () { // 更新 const oldValue = this.value this.value = this.get() this.cb.call(this.vm, this.value, oldValue) } } 这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。 在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。 只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。 依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。 不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。 parsePath函数： const bailRE = /[^\\w.$]/ export function parsePath(path) { if (bailRE.test(path)) { return } const segments = path.split('.') return function(obj) { for (let i = 0; i &lt; segments.length; i++) { if (!obj) return obj = obj[segments[i]] } return obj } } 递归侦测所有Key前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化： export class Observer { constructor (value) { this.value = value if (!Array.isArray(value)) { this.walk(value) } } walk (obj) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive (obj, keys[i], obj[keys[i]]) } } } function defineReactive(data, key, val) { if (typeof val === 'object') { new Observer(val) } let dep = new Dep() Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { dep.depend() return val }, set: function(newVal) { if (val === newVal) { return } val = newVal dep.notify() } }) } Observer 类，用于将一个正常的 object 转换成被侦测的 object。 判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。 最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。 当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。 总结变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。 Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。 我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。 收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。 所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。 Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。 由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。 在 Vue 中，对象新增属性或删除属性都无法被侦测到。 Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。 当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。 当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。 Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://qiandream.cn/tags/Vue/"}]},{"title":"Node-NodeJS核心基础知识","slug":"Node/Node-NodeJS核心基础知识","date":"2019-06-26T15:11:52.000Z","updated":"2020-04-02T07:29:16.015Z","comments":true,"path":"2019/06/26/node/node-nodejs-he-xin-ji-chu-zhi-shi/","link":"","permalink":"http://qiandream.cn/2019/06/26/node/node-nodejs-he-xin-ji-chu-zhi-shi/","excerpt":"导语 截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…","text":"导语 截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node… Nodejs 概述Nodejs 是基于 Chrome V8 引擎构建的，由事件循环分布 I/O 任务，最终工作线程会将任务放到线程池中执行，而事件循环等待执行结果就可以了。 Nodejs 是 Javascript 的运行时环境。 Nodejs 构建在 Chrome V8 这个著名的 Javascript 引擎上。 Nodejs 每个函数都是同步的，而 I/O 操作是异步的。 Nodejs 使用 npm 作为包管理器。 Nodejs 安装Nodejs 支持 macOS、Linux 以及 Windows 等多个主流操作系统。 3m 安装法 nvm 开源的 Nodejs 版本管理器 npm Nodejs 包管理端 nrm 解决 npm 镜像访问慢的问题。 nvm安装 nvm首先，在终端执行如下命令： $ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 意思是通过 curl 命令下载 install.sh 脚本并执行。执行完成后，重新打开终端窗口，执行 vi ~/.zshrc 把 nvm 命令的执行路径放到 ~/.zshrc 文件下： export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; . \"$NVM_DIR/nvm.sh\" 执行 source 命令，使系统环境变量生效： source ~/.zshrc 输入： nvm --version 0.33.1 查看可安装的 Nodejs 版本安装 Node 之前，需要了解通过 nvm 可以安装哪些版本的 Node。 nvm ls-remote LTS 版本是指长期支持版本，推荐给大部分用户使用，一般在生产环境中使用。 Current 版本是指当前正在开发的尝鲜版本，不完全版本，需要经过一段时间的测试、开发和修复 bug 等才能变为 LTS 版本，一般供开发者学习。 安装 Nodenvm install 10.15.3 通过 nvm 安装的 Node 位于用户目录下，而非系统目录下。 which node /Users/wangqian/.nvm/versions/node/v10.15.3/bin/node 默认使用某个 Node 版本来编译代码，需要手动指定一个 default 别名。 nvm alias default node default -> node (-> v10.15.3) 此时，输入 node -v，以后在终端的任何地方使用的默认版本都会是你设置的版本。 node -v v10.15.3 如何使用 nvm 切换 Node 版本？首先安装 Node 8.x nvm install 8 切换到 8.x 版本： nvm use 8 Now using node v8.16.0 (npm v6.4.1) node -v v8.16.0 如何知道本机通过 nvm 安装了哪些 Node 版本呢？ nvm ls -> v8.16.0 v10.15.3 default -> node (-> v10.15.3) node -> stable (-> v10.15.3) (default) stable -> 10.15 (-> v10.15.3) (default) iojs -> N/A (default) lts/* -> lts/dubnium (-> N/A) lts/argon -> v4.9.1 (-> N/A) lts/boron -> v6.17.1 (-> N/A) lts/carbon -> v8.16.0 lts/dubnium -> v10.16.0 (-> N/A) 若要经常切换 Node 版本，最痛苦的莫过于全局模块需要重新安装。针对这种情况，nvm 提供了一个很贴心的一键安装全局模块的 nvm reinstall-packages命令。 nvm reinstall-packages 6 nvm 默认远端下载地址是 https://nodejs.org/dist，如果想安装自定义的 Node 版本，可以指定 nvm 的远端下载地址。 NVM_NODEJS_ORG_MIRROR=https://nodejs.org/download/chakracore-nightly 对于一些正在测试的尝鲜版本，可以在下面的地址下载。 NVM_NODEJS_ORG_MIRROR=https://nodejs.org/download/test","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://qiandream.cn/tags/Node/"}]},{"title":"Vue-源码系列随读笔记之Object变化侦测","slug":"Vue/Vue-源码系列随读笔记之Object变化侦测","date":"2019-05-16T10:34:52.000Z","updated":"2019-08-17T17:08:47.848Z","comments":true,"path":"2019/05/16/vue/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-object-bian-hua-zhen-ce/","link":"","permalink":"http://qiandream.cn/2019/05/16/vue/vue-yuan-ma-xi-lie-sui-du-bi-ji-zhi-object-bian-hua-zhen-ce/","excerpt":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档","text":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档 什么是变化侦测从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。 简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。 Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。 如何追踪变化首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。 function defineReactive (data, key, val) { Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { return val }, set: function(newVal) { if (val === newVal) { return } val = newVal } }) } 此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。 由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。 如何收集依赖思考以下问题： let globalObj = { text1: 'text1' }; let o1 = new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;div>`, data: globalObj }); let o2 = new Vue({ template: `&lt;div> &lt;span>{{text1}}&lt;/span> &lt;div>`, data: globalObj }); 该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？ 对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。 即：在 getter 中收集依赖，在 setter 中触发依赖。 依赖收集到哪里（Dep） 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。 export default class Dep { constructor () { this.subs = [] // 观察者集合 } // 添加观察者 addSub (sub) { this.subs.push(sub) } // 移除观察者 removeSub (sub) { remove(this.subs, sub) } depend () { // 如果存在 Dep.target，则进行依赖收集操作 if (Dep.target) { this.addSub(Dep.target) } } notify () { const subs = this.subs.slice() // 避免污染原来的集合 for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() // 更新 } } } function remove(arr, item) { if (arr.length) { const index = arr.indexOf(item) if (index > -1) { return arr.splice(index, 1) } } } 改造 defineReactive function defineReactive (data, key, val) { let dep = new Dep() Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { dep.depend() return val }, set: function(newVal) { if (val === newVal) { return } val = newVal dep.notify() } }) } 什么是依赖当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。 然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。 收集谁？Watcher! 什么是 WatcherWatcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。 vm.$watch('a.b.c', function(newVal, oldVal) { // do something }) 这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。 把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。 export default class Watcher { // ... constructor ( vm: Component, // 组件实例 expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作 cb: Function // 被观察者发生变化后的回调 ) { this.vm = vm // Watcher有一个 vm 属性，表明它是属于哪个组件的 this.cb = cb // 回调 this.getter = parsePath(expOrFn) this.value = this.get() } get () { // 触发取值操作，进而触发属性的getter Dep.target = this let value = this.getter.call(this.vm, this.vm) Dep.target = null return value } update () { // 更新 const oldValue = this.value this.value = this.get() this.cb.call(this.vm, this.value, oldValue) } } 这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。 在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。 只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。 依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。 不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。 parsePath函数： const bailRE = /[^\\w.$]/ export function parsePath(path) { if (bailRE.test(path)) { return } const segments = path.split('.') return function(obj) { for (let i = 0; i &lt; segments.length; i++) { if (!obj) return obj = obj[segments[i]] } return obj } } 递归侦测所有Key前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化： export class Observer { constructor (value) { this.value = value if (!Array.isArray(value)) { this.walk(value) } } walk (obj) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive (obj, keys[i], obj[keys[i]]) } } } function defineReactive(data, key, val) { if (typeof val === 'object') { new Observer(val) } let dep = new Dep() Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { dep.depend() return val }, set: function(newVal) { if (val === newVal) { return } val = newVal dep.notify() } }) } Observer 类，用于将一个正常的 object 转换成被侦测的 object。 判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。 最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。 当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。 总结变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。 Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。 我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。 收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。 所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。 Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。 由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。 在 Vue 中，对象新增属性或删除属性都无法被侦测到。 Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。 当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。 当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。 Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。","categories":[{"name":"前端","slug":"前端","permalink":"http://qiandream.cn/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://qiandream.cn/tags/Vue/"}]},{"title":"Node-阿里云ECS部署","slug":"Node/Node-阿里云ECS部署","date":"2018-11-27T04:19:00.000Z","updated":"2020-04-02T07:29:24.028Z","comments":true,"path":"2018/11/27/node/node-a-li-yun-ecs-bu-shu/","link":"","permalink":"http://qiandream.cn/2018/11/27/node/node-a-li-yun-ecs-bu-shu/","excerpt":"导语 双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？","text":"导语 双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？ 此教程仅供新手借鉴，多少有些缺陷，有问题还望各位大佬指正。 准备工作 一个域名 阿里云ECS(实例镜像：CentOS7.4) 如果使用Windows，推荐xshell。如果是Mac，推荐iTerm2 (注：因本人使用Mac，以下均已Mac为主) 终端连接服务器 打开iTerm2，输入连接命令ssh username@ip公网地址，回车，输入你在购买服务器时设置的密码。 密码输入正确，进入服务器。 cd / 进入根目录，创建一个空目录 mkdir soft，用来放我们的安装包。 安装Node下载node包。 wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz 下载完成后，进行压缩包解压。 tar -zxvf v8.9.4.tar.gz 进入解压好的目录并执行config配置命令。 cd node-v8.9.4 &amp;&amp; ./configure 执行编译及安装命令。 make &amp;&amp; make install 经过漫长的等待之后，一个node环境就安装好了。可以通过node -v 或者 npm -v来检查当前node/npm是否安装成功。 如果你需要升级node和npm版本，执行以下命令即可。 npm i -g n n stable 安装nrm和pm2nrm是一个管理npm源的插件，方便切换国内外以及私人npm库。 pm2是node服务器的守护进程，方便管理当前服务器上的所有服务。 这里说一下cnpm，如果安装依赖包很慢或者根本没进度，输入命令 npm install -g cnpm --registry=https://registry.npm.taobao.org 然后使用cnpm代替npm安装。 回到我们熟悉的soft目录。 nrm安装nrm。 npm install -g nrm 常用命令： nrm add name address 添加新的源 nrm use name 切换到源 nrm ls 查看所有可用的源 pm2安装pm2。 npm install -g pm2 常用命令： pm2 list 查看pm2守护服务 pm2 start index.js 启动一个pm2守护进程命令 pm2 restart id/name 重启一个pm2守护进程命令 pm2 delete id/name 删除一个正在使用的进程 pm2 delete all 删除所有正在使用的进程 pm2 monit 查看pm2的消耗 安装mysql卸载已有的mysql。 rpm -qa|grep -i mysql yum remove &#39;mysql&#39; 下载mysql源。 // 5.7.24 wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm 安装下载的源。 rpm -ivh mysql57-community-release-el7-7.noarch.rpm 下载安装mysql。 yum install mysql-server yum install mysql-devel yum install mysql 启动mysql。 service mysqld start 常用命令： service mysqld status 查看mysql当前的状态 service mysqld stop 停止mysql service mysqld restart 重启mysql service mysqld start 启动mysql 如果遇到错误：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket /var/lib/mysql/mysql.sock’，请在tmp下创建一个软连接： ln -s /tmp/mysql.sock /var/lib/mysql 打开my.cnf并修改。 vi /etc/my.cnf 重启数据库。 service mysqld restart 登录(默认root是没有密码的)。 mysql -u root 这时出现ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)，登录root帐号需要密码，现在我们没有设置密码，哪来的密码。 于是我们开始忘记密码的操作 第一步，在/etc/my.cnf文件中添加skip-grant-tables第二步，重启mysql，service mysqld restart第三步，登录mysql，mysql -u root第四步，修改密码： mysql&gt;use mysql; mysql&gt;update mysql.user set authentication_string=password(&#39;your password&#39;) where user=&#39;root&#39;; mysql&gt;flush privileges; mysql&gt;exit; 第五步，恢复/etc/my.cnf，将skip-grant-tables删除或者注释掉第六步，重启mysql，service mysqld restart 分配用户 host指定该用户在哪个主机上可以登陆，此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录;也可以指定某台机器可以远程登录。 CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;; CREATE USER &#39;test&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39;; 给创建的用户权限 privileges 用户的操作权限,如SELECT，INSERT，UPDATE等.如果要授予所的权限则使用ALL databasename 数据库名 tablename 表名,如果要授予该用户对所有数据库和表的相应操作权限则可用表示, 如.*. GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39; 安装RedisRedis是一个非常好用的数据仓库，既可以做nosql数据库，也可以做缓存数据库。 下载安装包。 wget http://download.redis.io/releases/redis-4.0.6.tar.gz 解压并进入解压之后的文件夹。 tar -zxvf redis-4.0.6.tar.gz &amp;&amp;cd redis-4.0.6 编译并安装。 make &amp;&amp; make install 启动redis服务。 redis-server redis.conf 此时我们发现，不能再输入任何命令，因为redis-server已经占用了这个命令行客户端。我们需要再打开一个命令行工具并连接服务器。 使用redis客户端连接Redis服务，执行Redis文件夹下的redis-cli文件redis-cli，输入几个命令测试一下简单的set/get： 关掉客户端，redis服务也会停止。这时，我们就需要修改redis.conf文件，将daemonizede的值改为yes。 再次运行Redis的启动命令redis-server redis.conf，这次就不会占用命令行了，可以继续操作其他的，Redis服务也不会停止。 nginxnginx在转发请求，负载均衡等方面非常有用。它可以将几个不同的服务集中在一个80端口下，根据域名或者请求路径来区分。 在安装nginx之前，先要安装几个依赖插件。 yum install -y pcre pcre-devel yum install -y zlib zlib-devel 安装openssl。 yum install -y openssl openssl-devel 下载nginx包。 wget https://nginx.org/download/nginx-1.15.6.tar.gz 解压并进入解压好的目录。 tar -zxvf nginx-1.15.6.tar.gz &amp;&amp; cd nginx-1.15.6 执行配置命令。 ./configure 编译并安装。 make &amp;&amp; make install 查看安装结果。 whereis nginx 跳转到安装好的nginx目录下，进入sbin目录。 cd /usr/local/nginx/sbin 启动nginx。 ./nginx 常用命令： ./nginx 启动nginx ./nginx -s stop 停止nginx ./nginx -s quit 退出nginx ./nginx -s reload 重启nginx 安装GitcentOS上没有安装git，有需要的话，我们可以自己手动安装一下。 yum install git git --version 使用pm2启动项目在本地搭建并测试好node项目，上传到GitHub。然后git clone一下。 配置ECS安全组规则，暴露3000接口。 如果项目中使用数据库，运行之前要先建立好数据库，然后再运行项目，登录数据库执行create database dabasename; git clone https://github.com/*** cd *** cnpm i pm2 start index.js 注：项目监听3000端口，如果顺利的话，项目已经运行起来了。 可以使用pm2 list查看进程列表，使用pm2 log打印日志。 Linux常用操作指令列表 命令 说明 ssh username@ip 连接服务器 cd path 跳转到路径对应的目录下 rm filename 删除文件 rm -rf path 删除目录及目录下的所有文件 ls [-a] 查看当前目录下的文件和目录(-a：查看所有文件，包括隐藏文件) ll 查看当前目录下的文件详情(文件权限) pwd 查看当前路径的完整路径 which name 默认位置查找该名字 mkdir dirname 创建空目录 cat path 查看文件内容 cp origin target 复制一个文件到另一个地方 mv origin target 移动一个文件到另一个地方 ps -aux 显示当前进程 kill -9 processid 结束进程 tar -zxvf filename 解压文件 tar -zcvf filename 压缩文件 vi path 进入文件编辑模式 vi编辑文件，按下i进入编辑模式 vi退出文件，esc+:wq或esc+:x保存退出 vi退出文件，esc+:q或esc+:q!强制退出","categories":[{"name":"后端","slug":"后端","permalink":"http://qiandream.cn/categories/后端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://qiandream.cn/tags/Node/"}]}]}