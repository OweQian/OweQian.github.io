{"meta":{"title":"W | 个人博客 | web前端","subtitle":null,"description":"前端","author":"wangxiaobai","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-04-11T08:28:54.000Z","updated":"2018-04-11T08:29:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-11T08:28:32.000Z","updated":"2018-04-11T08:28:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS-执行上下文和执行上下文栈","slug":"JS-执行上下文和执行栈","date":"2019-07-26T07:18:52.000Z","updated":"2019-07-26T07:28:37.956Z","comments":true,"path":"2019/07/26/JS-执行上下文和执行栈/","link":"","permalink":"http://yoursite.com/2019/07/26/JS-执行上下文和执行栈/","excerpt":"导语 执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文栈用于存储在代码执行期间创建的所有执行上下文。","text":"导语 执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文栈用于存储在代码执行期间创建的所有执行上下文。 理解执行上下文和执行上下文栈执行上下文的类型执行上下文总共有三种类型： 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 会指向这个全局对象。 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。 Eval 函数执行上下文：运行在 Eval 函数中的代码。 执行上下文栈接下来问题来了，我们写了那么多函数，如何管理创建的那么多执行上下文呢？ Javascript 创建了执行上下文栈，也叫调用栈，来管理在代码执行期间创建的所有执行上下文。 首次运行 Javascript 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。 根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从栈中 Pop 出，上下文控制权将会移到当前执行栈的下一个执行上下文。 1234567891011121314var a = 'Hello World!';function first() &#123; console.log('Inside first function'); second(); console.log('Again inside first function'); &#125;function second() &#123; console.log('Inside second function'); &#125;first(); console.log('Inside Global Execution Context'); 执行上下文的创建执行上下文分为两个阶段创建：1） 创建阶段 2）执行阶段 创建阶段 确定 this 的值，也被称为 This Binding LexicalEnvironment-词法环境组件被创建 VariableEnvironment-变量环境组件被创建 12345ExecutionContext = &#123; ThisBinding: &lt;this value&gt;, // 确定 this LexicalEnvironment: &#123;...&#125;, // 词法环境 VariableEnvironment: &#123;...&#125; // 变量环境&#125; This Binding 全局执行上下文中，this 指向全局对象，在浏览器中 this 的值指向 window 对象，而在 nodejs 中指向这个文件的 module 对象。 函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显示绑定、new 绑定等。 词法环境词法环境有两个组成部分： 环境记录：存储变量和函数声明的实际位置 对外部环境的引用：可以访问其外部词法环境 词法环境有两种类型： 全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window）及其关联的方法和属性以及任何用户自定义的全局变量， this 的值指向这个全局对象。 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境， 1234567891011121314151617GlobalExectionContext = &#123; // 全局执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: \"Object\", // 全局环境 // 标识符绑定在这里 outer: &lt;null&gt; // 对外部环境的引用 &#125; &#125;FunctionExectionContext = &#123; // 函数执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: \"Declarative\", // 函数环境 // 标识符绑定在这里 // 对外部环境的引用 outer: &lt;Global or outer function environment reference&gt; &#125; &#125; 变量环境 变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。 在ES6中，词法环境和变量环境的区别在于前者用于存储函数声明和变量(let const)绑定，后者仅用于存储变量(var)绑定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647GlobalExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: \"Object\", // 标识符绑定在这里 a: &lt; uninitialized &gt;, b: &lt; uninitialized &gt;, multiply: &lt; func &gt; &#125; outer: &lt;null&gt; &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: \"Object\", // 标识符绑定在这里 c: undefined, &#125; outer: &lt;null&gt; &#125; &#125;FunctionExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: \"Declarative\", // 标识符绑定在这里 Arguments: &#123;0: 20, 1: 30, length: 2&#125;, &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: \"Declarative\", // 标识符绑定在这里 g: undefined &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125; &#125; 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined (var 情况下) 或保持未初始化 (let、const 情况下)。所以这就是为什么可以在声明之前访问 var 定义的变量，如果在声明之前访问 let 和 const 定义的变量会提示引用错误的原因。这就是所谓的变量提升。 执行阶段 执行上下文的代码分为两个阶段进行处理： 进入执行上下文 代码执行 进入执行上下文此时的变量对象包括（如下顺序初始化）： 函数所有的形参：没有实参，属性值设为 undefined。 函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。 变量声明：如果变量名称与已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。 123456789function foo(a) &#123; var b = 2; function c() &#123;&#125; var d = function() &#123;&#125;; b = 3;&#125;foo(1); 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, c: reference to function c()&#123;&#125;, d: undefined&#125; 形参 arguments 已经有值了，但是变量还是 undefined，只是初始化的值。 代码执行 这个阶段会顺序执行代码，并修改变量的值。 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference to function c()&#123;&#125;, d: reference to FunctionExpression \"d\"&#125; 总结如下： 全局上下文的变量对象初始化是全局对象。 函数上下文的变量对象初始化只包括 arguments 对象。 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值。 在代码执行阶段，会再次修改变量对象的属性值。 深入执行上下文和执行上下文栈JS 是单线程的语言，执行顺序是顺序执行，但是 JS 引擎并不是一行一行地分析和执行代码，而是一段一段地分析和执行，先进行编译然后才是执行。 有如下两段代码，执行结果是一样的，但是两段代码究竟有什么不同？ 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 答案是执行上下文栈的变化不一样。 第一段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop(); 第二段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 函数执行上下文在函数执行上下文中，用活动对象来表示变量对象。 活动对象和变量对象的区别在于： 变量对象是规范上或 JS 引擎上实现的，并不能在 JS 环境中直接访问。 当进入到一个执行上下文后，这个变量对象会被激活，所以叫活动对象，这时活动对象上的各种属性才能被访问。 调用函数时，会自动为其创建一个 arguments 对象，并初始化局部变量 arguments。所有作为参数传入的值都会成为 arguments 对象的数组元素。 参考 理解JavaScript 中的执行上下文和执行栈 JavaScript深入之执行上下文栈和变量对象","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Node-NodeJS核心基础知识","slug":"Node-NodeJS核心基础知识","date":"2019-06-26T15:11:52.000Z","updated":"2019-07-07T11:26:33.333Z","comments":true,"path":"2019/06/26/Node-NodeJS核心基础知识/","link":"","permalink":"http://yoursite.com/2019/06/26/Node-NodeJS核心基础知识/","excerpt":"导语 截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node…","text":"导语 截止今天，像谷歌、亚马逊等全球 Top 10 互联网大公司，都早已入坑 Node… Nodejs 概述Nodejs 是基于 Chrome V8 引擎构建的，由事件循环分布 I/O 任务，最终工作线程会将任务放到线程池中执行，而事件循环等待执行结果就可以了。 Nodejs 是 Javascript 的运行时环境。 Nodejs 构建在 Chrome V8 这个著名的 Javascript 引擎上。 Nodejs 每个函数都是同步的，而 I/O 操作是异步的。 Nodejs 使用 npm 作为包管理器。 Nodejs 安装Nodejs 支持 macOS、Linux 以及 Windows 等多个主流操作系统。 3m 安装法 nvm 开源的 Nodejs 版本管理器 npm Nodejs 包管理端 nrm 解决 npm 镜像访问慢的问题。 nvm安装 nvm首先，在终端执行如下命令： 1$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 意思是通过 curl 命令下载 install.sh 脚本并执行。执行完成后，重新打开终端窗口，执行 1vi ~/.zshrc 把 nvm 命令的执行路径放到 ~/.zshrc 文件下： 12export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; . \"$NVM_DIR/nvm.sh\" 执行 source 命令，使系统环境变量生效： 1source ~/.zshrc 输入： 123nvm --version0.33.1 查看可安装的 Nodejs 版本安装 Node 之前，需要了解通过 nvm 可以安装哪些版本的 Node。 1nvm ls-remote LTS 版本是指长期支持版本，推荐给大部分用户使用，一般在生产环境中使用。 Current 版本是指当前正在开发的尝鲜版本，不完全版本，需要经过一段时间的测试、开发和修复 bug 等才能变为 LTS 版本，一般供开发者学习。 安装 Node1nvm install 10.15.3 通过 nvm 安装的 Node 位于用户目录下，而非系统目录下。 12which node/Users/wangqian/.nvm/versions/node/v10.15.3/bin/node 默认使用某个 Node 版本来编译代码，需要手动指定一个 default 别名。 12nvm alias default nodedefault -&gt; node (-&gt; v10.15.3) 此时，输入 node -v，以后在终端的任何地方使用的默认版本都会是你设置的版本。 12node -vv10.15.3 如何使用 nvm 切换 Node 版本？首先安装 Node 8.x 1nvm install 8 切换到 8.x 版本： 1234nvm use 8Now using node v8.16.0 (npm v6.4.1)node -vv8.16.0 如何知道本机通过 nvm 安装了哪些 Node 版本呢？ 123456789101112nvm ls-&gt; v8.16.0 v10.15.3default -&gt; node (-&gt; v10.15.3)node -&gt; stable (-&gt; v10.15.3) (default)stable -&gt; 10.15 (-&gt; v10.15.3) (default)iojs -&gt; N/A (default)lts/* -&gt; lts/dubnium (-&gt; N/A)lts/argon -&gt; v4.9.1 (-&gt; N/A)lts/boron -&gt; v6.17.1 (-&gt; N/A)lts/carbon -&gt; v8.16.0lts/dubnium -&gt; v10.16.0 (-&gt; N/A) 若要经常切换 Node 版本，最痛苦的莫过于全局模块需要重新安装。针对这种情况，nvm 提供了一个很贴心的一键安装全局模块的 nvm reinstall-packages命令。 1nvm reinstall-packages 6 nvm 默认远端下载地址是 https://nodejs.org/dist，如果想安装自定义的 Node 版本，可以指定 nvm 的远端下载地址。 1NVM_NODEJS_ORG_MIRROR=https://nodejs.org/download/chakracore-nightly 对于一些正在测试的尝鲜版本，可以在下面的地址下载。 1NVM_NODEJS_ORG_MIRROR=https://nodejs.org/download/test","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"JS-this、call、apply","slug":"JS-this、call、apply","date":"2019-06-13T05:00:52.000Z","updated":"2019-06-16T09:51:28.472Z","comments":true,"path":"2019/06/13/JS-this、call、apply/","link":"","permalink":"http://yoursite.com/2019/06/13/JS-this、call、apply/","excerpt":"导语 在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。","text":"导语 在 Javascript 编程中，this、Function.prototype.call、Function.prototype.apply 有着广泛的运用，理解它们的用法至关重要。 thisJavascript 中的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的。 this 的指向在具体实际应用中，this 的指向通常可分为以下4种: 作为对象的方法调用 作为普通函数调用 作为构造器调用 Function.prototype.call、Function.prototype.apply 作为对象的方法调用当函数作为对象的方法调用时，this 指向该对象： 12345678910var obj = &#123; a: 1, getA: function () &#123; console.log(this.a) &#125;&#125;obj.getA()// 1 作为普通函数调用函数作为普通函数调用，此时的 this 总是指向全局对象。在浏览器中，这个全局对象是 window 对象。 12345678var a = 1var getName = function () &#123; console.log(this.a)&#125;getName()// 1 作为构造器调用当用 new 运算符调用函数时，该函数会返回一个对象。通常情况下，构造器里的 this 就指向返回的这个对象。 1234567var MyClass = function () &#123; this.name = 'sven'&#125;var obj = new MyClass()console.log(obj.name)// 'sven' 如果构造器显式地返回了一个对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this。 12345678910var MyClass = function () &#123; this.name = 'sven' return &#123; name: 'wang' &#125;&#125;var obj = new MyClass()console.log(obj.name)// wang 如果构造器不显式地返回任何数据，或者返回一个非对象类型的数据，就不会造成上述问题。 12345678var MyClass = function () &#123; this.name = 'sven' return 'wang'&#125;var obj = nconsole.log(obj.name)// 'sven' Function.prototype.call、Function.prototype.apply用 Function.prototype.call、Function.prototype.apply 可以动态改变传入函数的 this。 12345678910111213141516var obj1 = &#123; name: 'wang', getName: function () &#123; console.log(this.name) &#125;&#125;var obj2 = &#123; name: 'zhang'&#125;obj1.getName()obj1.getName.call(obj2)// 'wang'// 'zhang' 丢失的 this举个例子： 12345678910111213var obj = &#123; name: 'wang', getName: function () &#123; console.log(this.name) &#125;&#125;obj.getName()getName = obj.getNamegetName()// 'wang'// undefined 当调用 obj.getName 时，此时 this 指向 obj 对象，所以输出 ‘wang’。 当用另外一个变量 getName 来引用 obj.getName，并且调用时，它是被当作普通函数来调用，此时 this 指向 window 对象，所以输出 undefined。 call 和 apply在实际开发中，特别是在一些函数式风格的代码编写中，call 和 apply 方法尤为重要。 区别call 和 apply 作用一模一样，区别在于传入参数形式的不同。 apply 接受两个参数，第一个参数指定了函数体内的 this 对象的指向，第二个参数为一个带下标的集合，可以为数组，也可以为类数组。 call 传入的参数数量不固定，跟 apply 不同的是，第一个参数也是代表函数体内 this 对象的指向，从第二个参数开始，每个参数依此传入函数。 当使用 call 或者 apply 时，如果我们传入的第一个参数为 null，则函数体内的 this 会指向默认的宿主对象。 但如果在严格模式下，函数体内的 this 还是为 null。 call 和 apply 的用途下面将详细介绍 call 和 apply 在实际开发中的用途。 改变 this 指向1234567891011121314151617var obj1 = &#123; name: 'wang'&#125;var obj2 = &#123; name: 'zhang'&#125;var name = 'qian'var getName = function () &#123; console.log(this.name)&#125;getName () // 'qian'getName.call(obj1) // 'wang'getName.call(obj2) // 'zhang' Function.prototype.bind大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向。即使没有原生的 Function.prototype.bind ，我们也可以自己来模拟： 1234567891011121314151617Function.prototype.bind = function (context) &#123; let self = this // 保存原函数 console.log(this) return function () &#123; // 返回一个新的函数 return self.apply(context, arguments) // 执行新的函数时，会把之前传入的 context 当作新函数体内的 this &#125;&#125;var obj = &#123; name: 'seven'&#125;var func = function () &#123; console.log(this.name)&#125;.bind(obj)func() 上述为一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一些，使得可以在 func 函数中预先填入一些参数： 123456789101112131415161718192021Function.prototype.bind = function () &#123; console.log(arguments) var self = this, // 保存原函数 context = [].shift.call(arguments), // 需要绑定的 this 上下文 args = [].slice.call(arguments) // 剩余的参数转化为数组 console.log(context) console.log(args) return function () &#123; // 返回一个新韩淑 return self.apply(context, [].concat(args, [].slice.call(arguments))) // 执行新的函数时，把之前传入的 context 当作新函数体内的 this，并且组合两次分别传入的参数，作为新函数的参数 &#125;&#125;var obj = &#123; name: 'seven'&#125;var func = function (a, b, c, d) &#123; console.log(this.name) console.log([a, b, c, d])&#125;.bind(obj, 1, 2)func(3, 4) 借用其他对象的方法借用方法的第一种场景是”借用构造函数“，通过这种技术，可以实现一些类似继承的效果： 123456789101112131415var A = function (name) &#123; this.name = name&#125;var B = function () &#123; A.apply(this, arguments)&#125;B.prototype.getName = function () &#123; return this.name&#125;var b = new B('wang')console.log(b.getName()) // 'wang' 附： 函数的参数列表 arguments 是一个类数组对象，并不是真正的数组。 如果想在 arguments 中添加一个元素，通常会借用 Array.prototype.push 如果想把 arguments 转换为真正的数组，通常会借用 Array.prototype.slice 如果想截取 arguments 中的第一个元素，通常会借用 Array.prototype.shift","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS-事件的节流(throttle)和防抖(debounce)","slug":"JS-事件的节流(throttle)和防抖(debounce)","date":"2019-05-31T07:13:52.000Z","updated":"2019-06-04T03:00:18.031Z","comments":true,"path":"2019/05/31/JS-事件的节流(throttle)和防抖(debounce)/","link":"","permalink":"http://yoursite.com/2019/05/31/JS-事件的节流(throttle)和防抖(debounce)/","excerpt":"导语 窗口的resize、scroll、mousemove、mouseover等事件被频繁触发时，其对应的回调函数也会被频繁触发而导致页面抖动甚至卡顿。","text":"导语 窗口的resize、scroll、mousemove、mouseover等事件被频繁触发时，其对应的回调函数也会被频繁触发而导致页面抖动甚至卡顿。 为了规避这种情况，我们需要一些手段来控制事件被触发的频率。此时，事件节流(throttle)和事件防抖(debounce)出现了。 节流和防抖的本质这两个东西都以“闭包”的形式存在。 它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，来判断是否执行回调函数，以此来控制事件的触发频率。 节流-throttle函数节流指某个函数在一定时间间隔内 ( 例如 3 秒 ) 只执行一次，在这 3 秒内无视后来产生的函数调用请求，也不会延长事件间隔。3 秒间隔结束后第一次遇到新的函数调用会触发执行，然后在新的 3 秒内依旧无视后来产生的函数调用请求，以此类推。 实现方案有以下两种： 第一种是用时间戳来判断是否已到执行时间，记录上次执行的时间戳，然后每次触发事件执行回调，回调中判断当前时间戳距离上次执行时间戳的间隔是否已经到达时间差，如果是则执行，并更新上次执行的时间戳，如此循环。 第二种是使用定时器，比如当 scroll 事件刚触发时，打印一个 hello word ，然后设置个 1000ms 的定时器，此后每次触发 scroll 事件回调，如果已经存在定时器，则回调不执行方法，直到定时器触发，handler 被清除，然后重新设置定时器。 理解了大致思路，我们用第一种方法实现一个 throttle: 12345678910111213141516171819/** * 节流 throttle 时间戳 * @param fn &#123;function&#125; 回调函数 * @param wait &#123;number&#125; 时间间隔 * @author wangxiaobai * @date 2019/5/30 */export function throttle (fn, wait) &#123; // 上一次函数执行的时间 let previous = 0 return function (...args) &#123; let now = +new Date() // 本次触发事件 if (now - previous &gt; wait) &#123; previous = now // 执行fn fn.apply(this, args) &#125; &#125;&#125; 防抖-debounce函数防抖指某个函数在一定时间间隔内 ( 例如 3 秒 ) 只执行一次，在这 3 秒内无视先前产生的函数调用请求，也不会延长事件间隔。3 秒间隔结束后第一次遇到新的函数调用暂时不会触发执行，然后在新的 3 秒内依旧无视先前产生的函数调用请求，以此类推。 实现方案： 使用定时器，比如当 scroll 事件刚触发时，首先清除掉旧计时器，然后设立新的计时器，等待3 秒，打印一个 hello word，此后每次触发 scroll 事件回调，如果已经存在定时器，则清除掉旧计时器，然后重新设置定时器。 理解了大致思路，我们用第一种方法实现一个 debounce: 1234567891011121314151617181920/** * 防抖 debounce 定时器 * @param fn &#123;function&#125; 回调函数 * @param wait &#123;number&#125; 时间间隔 * @author wangxiaobai * @date 2019/5/30 */export function debounce (fn, wait) &#123; let timer = null return function (...args) &#123; // 清除上次执行得定时器 if (timer) &#123; clearTimeout(timer) &#125; // 设立新定时器 timer = setTimeout(() =&gt; &#123; fn.apply(this, args) &#125;, wait) &#125;&#125; throttle 和 debounce 不仅是我们日常开发中的常用优质代码片段，更是前端面试中不可不知的高频考点。“看懂了代码”、“理解了过程”在本节都是不够的，重要的是把它写到自己的项目里去，亲自体验一把节流和防抖带来的性能提升。 参考 前端性能优化原理与实践 深入浅出节流函数throttle","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Vue-源码系列随读笔记之Object变化侦测","slug":"Vue-源码系列随读笔记之Object变化侦测","date":"2019-05-16T10:34:52.000Z","updated":"2019-08-17T17:08:47.848Z","comments":true,"path":"2019/05/16/Vue-源码系列随读笔记之Object变化侦测/","link":"","permalink":"http://yoursite.com/2019/05/16/Vue-源码系列随读笔记之Object变化侦测/","excerpt":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档","text":"导语 Vue最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JS对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见问题 —官方文档 什么是变化侦测从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地重新渲染。响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。 简单来说，变化侦测的作用就是侦测数据的变化，当数据变化时，会通知视图进行相应的更新。 Vue.js 2.0 引入了虚拟 DOM，收集每一个状态所绑定的依赖 (组件实例) ，当状态改变后，会通知到组件，组件内部再使用虚拟 DOM 进行对比。 如何追踪变化首先，在 JS 中，通过 Object.defineProperty 侦测对象变化，这也是响应式最根本的依赖。 123456789101112131415function defineReactive (data, key, val) &#123; Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; return val &#125;, set: function(newVal) &#123; if (val === newVal) &#123; return &#125; val = newVal &#125; &#125;)&#125; 此处用 defineReactive 对 Object.defineProperty 进行封装，其作用是定义一个响应式数据，在函数中对对象进行变化追踪。封装好之后，每当从 data 的 key 中读取数据时，getter 函数被触发；每当在 data 的 key 中设置新数据时， setter 函数就会执行。 由此可见，Object.defineProperty 是对已有属性进行的劫持操作，所以 Vue 才要求事先将需要用到的数据定义在 data 中，同时也无法响应对象属性的添加和删除。被劫持的属性会有相应的 get、set 方法。 如何收集依赖思考以下问题： 12345678910111213141516171819let globalObj = &#123; text1: 'text1'&#125;;let o1 = new Vue(&#123; template: `&lt;div&gt; &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; &lt;div&gt;`, data: globalObj&#125;);let o2 = new Vue(&#123; template: `&lt;div&gt; &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; &lt;div&gt;`, data: globalObj&#125;); 该模板中有两个vm实例使用了text1，当它发生变化时，如何向使用了它的地方发送通知来更新视图？ 对于上述的问题，我的回答是，先收集依赖，即把用到了数据 text1 的地方收集起来，然后当属性发生变化时，把之前收集好的依赖循环触发更新一遍。 即：在 getter 中收集依赖，在 setter 中触发依赖。 依赖收集到哪里（Dep） 每个 key 都有一个数组，用来存储当前 key 的依赖。我们把依赖收集的代码封装成一个 Dep 类，用它来专门帮助我们管理依赖。使用它，我们可以收集依赖、删除依赖、向依赖发送通知等。 123456789101112131415161718192021222324252627282930313233343536export default class Dep &#123; constructor () &#123; this.subs = [] // 观察者集合 &#125; // 添加观察者 addSub (sub) &#123; this.subs.push(sub) &#125; // 移除观察者 removeSub (sub) &#123; remove(this.subs, sub) &#125; depend () &#123; // 如果存在 Dep.target，则进行依赖收集操作 if (Dep.target) &#123; this.addSub(Dep.target) &#125; &#125; notify () &#123; const subs = this.subs.slice() // 避免污染原来的集合 for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() // 更新 &#125; &#125;&#125;function remove(arr, item) &#123; if (arr.length) &#123; const index = arr.indexOf(item) if (index &gt; -1) &#123; return arr.splice(index, 1) &#125; &#125;&#125; 改造 defineReactive 123456789101112131415161718function defineReactive (data, key, val) &#123; let dep = new Dep() Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; dep.depend() return val &#125;, set: function(newVal) &#123; if (val === newVal) &#123; return &#125; val = newVal dep.notify() &#125; &#125;)&#125; 什么是依赖当属性发生变化时，我们要通知用到数据的地方，用到数据的地方有很多，有可能是模板、也可能是用户写的函数等等，这时需要抽象出一个能集中处理这些情况的类。 然后，我们在依赖收集阶段只收集这个封装好的类的实例进来啊，通知也只通知它一个，然后，它在负责通知其它地方。 收集谁？Watcher! 什么是 WatcherWatcher 是一个中介的角色，数据发生变化时通知它，它再通知其它地方。 123vm.$watch('a.b.c', function(newVal, oldVal) &#123; // do something&#125;) 这段代码表示当 data.a.b.c 属性发生变化时，触发第二个参数中的函数。 把这个 watcher 实例添加到 data.a.b.c 属性的 Dep 中去就行了。然后，当 data.a.b.c 的值发生变化时，通知 watcher。接着，watcher 在执行参数中的回调函数。 1234567891011121314151617181920212223242526export default class Watcher &#123; // ... constructor ( vm: Component, // 组件实例 expOrFn: string | Function, // 要观察的表达式，函数，或者字符串，只要能触发取值操作 cb: Function // 被观察者发生变化后的回调 ) &#123; this.vm = vm // Watcher有一个 vm 属性，表明它是属于哪个组件的 this.cb = cb // 回调 this.getter = parsePath(expOrFn) this.value = this.get() &#125; get () &#123; // 触发取值操作，进而触发属性的getter Dep.target = this let value = this.getter.call(this.vm, this.vm) Dep.target = null return value &#125; update () &#123; // 更新 const oldValue = this.value this.value = this.get() this.cb.call(this.vm, this.value, oldValue) &#125;&#125; 这段代码可以将自己主动添加到 data.a.b.c 的 Dep 中。 在 get 方法中先把 Dep.target 设置成了 this，也就是当前 watcher 实例，然后再读一下 data.a.b.c 的值，这就会触发 getter，触发了 getter，就会触发收集依赖的逻辑。 只要现在 Dep.target 赋一个 this，然后再读一下值，去触发 getter，就可以把 this 主动添加到 keypath 的 Dep 中。 依赖注入到 Dep 中后，每当 data.a.b.c 的值发生变化时，就会让依赖列表中所有的依赖循环触发 update 方法。 不管用户执行的是 vm.$watch(‘a.b.c’, (value, oldValue) =&gt; {})，还是模板中的 data，都是通过 watcher 来通知自己是否需要变化。 parsePath函数： 123456789101112131415const bailRE = /[^\\w.$]/export function parsePath(path) &#123; if (bailRE.test(path)) &#123; return &#125; const segments = path.split('.') return function(obj) &#123; for (let i = 0; i &lt; segments.length; i++) &#123; if (!obj) return obj = obj[segments[i]] &#125; return obj &#125;&#125; 递归侦测所有Key前面的实例代码只能侦测数据中的一个属性，我们希望把数据中的所有属性都侦测到，所以要封装一个Observer类。Observer的作用是将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式，然后去追踪它们的变化： 123456789101112131415161718192021222324252627282930313233343536export class Observer &#123; constructor (value) &#123; this.value = value if (!Array.isArray(value)) &#123; this.walk(value) &#125; &#125; walk (obj) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive (obj, keys[i], obj[keys[i]]) &#125; &#125;&#125;function defineReactive(data, key, val) &#123; if (typeof val === 'object') &#123; new Observer(val) &#125; let dep = new Dep() Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; dep.depend() return val &#125;, set: function(newVal) &#123; if (val === newVal) &#123; return &#125; val = newVal dep.notify() &#125; &#125;)&#125; Observer 类，用于将一个正常的 object 转换成被侦测的 object。 判断数据的类型，只有 Object 类型的数据才会调用 walk 将每一个属性转换成 getter/setter 的形式来侦测变化。 最后，在 defineReactive 中新增 new Observer(val) 来递归子属性，这样我们就可以把 data 中的所有属性转换成 getter/setter 的形式来侦测变化。 当 data 中的属性发生变化时，与属性对应的依赖就会接收到通知。 总结变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。 Object 可以通过 Object.defineProperty 将属性转换成 getter/setter 的形式来追踪变化，读取数据时会触发 getter，修改数据时会触发 setter。 我们需要在 getter 中收集有哪些依赖使用了数据。当 setter 被触发时，去通知 getter 中收集的依赖数据发生了变化。 收集依赖需要为依赖找一个存储的地方，为此创建了 Dep，它用来收集依赖、删除依赖、向依赖发送消息等。 所谓的依赖，其实就是 Watcher。把 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。 Watcher 的原理是先把自己设置到全局唯一的指定位置 (Dep.target)，然后读取这个数据。因为读取了这个数据，因此会触发这个数据的 getter 。接着，在 getter 中就会从全局唯一的位置读取正在读取数据的 Watcher，并把这个 Watcher 收集到 Dep 中去。通过这样的方式，Watcher 可以主动去订阅任意一个数据的变化。 由此，我们创建了 Observer 类，它的作用就是把一个 object 中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测 object 中所有数据的变化。 在 Vue 中，对象新增属性或删除属性都无法被侦测到。 Object 通过 Observer 转换成了 getter/setter 的形式来追踪变化。 当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到 Dep 中。 当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖发送通知。 Watcher 接收到通知后，会像外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数等。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"JS-数据结构与算法之链表","slug":"JS-数据结构与算法之链表","date":"2019-03-25T12:57:52.000Z","updated":"2019-03-25T12:24:33.483Z","comments":true,"path":"2019/03/25/JS-数据结构与算法之链表/","link":"","permalink":"http://yoursite.com/2019/03/25/JS-数据结构与算法之链表/","excerpt":"导语 使用列表对数据进行排序，底层储存数据的数据结构是数组。然而，数组并不总是最优选择。","text":"导语 使用列表对数据进行排序，底层储存数据的数据结构是数组。然而，数组并不总是最优选择。 数组的缺点数组不总是组织数据的最佳数据结构，原因如下：在很多编程语言中，数组的长度是固定的，所以当数组已被数据填满时，再需要加入新的元素就会非常困难。 在数组中，添加和删除元素也很麻烦，需要将数组中的其它元素向前或向后移动，以反映数组刚刚进行了添加或删除操作。 如果你发现数组在实际使用时很慢，就可以考虑使用链表来替代它。除了对数据的随机访问，","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS-数据结构与算法之队列","slug":"JS-数据结构与算法之队列","date":"2019-03-16T12:57:52.000Z","updated":"2019-03-23T09:33:40.176Z","comments":true,"path":"2019/03/16/JS-数据结构与算法之队列/","link":"","permalink":"http://yoursite.com/2019/03/16/JS-数据结构与算法之队列/","excerpt":"导语 队列是一种列表，不同的是，队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。","text":"导语 队列是一种列表，不同的是，队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出。 对队列的操作队列的两种主要操作是：向队列中插入新元素和删除队列中的元素。插入操作也叫做入队，删除操作也叫做出队。入队操作在队尾插入新元素，出队操作删除队头的元素。 队列的另一项重要操作是读取队头的元素，这个操作叫 peek() 。该操作返回队头元素，但不把它从队列中删除。除了读取队头元素，我们还可以用 length 属性来知道队列中存储了多少元素，用 clear() 方法来清空队列中的元素。 用数组实现的队列使用数组来实现队列看起来顺理成章。数组的 push() 方法可以在数组末尾加入元素，shift() 方法则可以删除数组的第一个元素。 push() 方法将它的参数插入数组中第一个开放的位置，该位置总在数组的末尾，即使是个空数组也是如此。 准备开始实现 Queue 类，先从构造函数开始： 123456789function Queue () &#123; this.dataStore = [] this.enqueue = enqueue this.dequeue = dequeue this.front = front this.back = back this.toString = toString this.empty = empty&#125; enqueue() 方法向队尾添加一个元素 123function enqueue (element) &#123; this.dataStore.push(element)&#125; dequeue() 方法删除队首的元素 123function dequeue () &#123; return this.dataStore.shift()&#125; 使用如下的方法读取队首和队尾的元素 1234567function front () &#123; return this.dataStore[0]&#125;function back () &#123; return this.dataStore[this.dataStore.length -1]&#125; toString() 方法显示队列内的所有元素 1234567function toString () &#123; var retStr = '' for (var i = 0; i &lt; this.dataStore.length; i++) &#123; retStr += this.dataStore[i] + ' ' &#125; return retStr&#125; empty() 方法判断队列是否为空 123function empty () &#123; return this.dataStore.length === 0&#125; 使用队列：方块舞的舞伴分配问题男男女女来到舞池，他们按照自己的性别排成两队。当舞池中有地方空出来时，选两个队列中第一个人组成舞伴。他们身后的人各自向前移动一个位置，变成新的队首。当一对舞伴迈入舞池时，主持人会大声喊出他们的名字。当一队舞伴走出舞池，且两排队伍中有任意一队没人时，主持人也会把这个情况告诉大家。 为了模拟这种情况，我们把跳方块舞的男男女女的姓名储存在 dancers 变量中： 1var dancers = 'F Allison \\n M Frank \\n M Mason \\n M Clayton \\n F Cheryl \\n M Raymond \\n F Jennifer \\n M Bryan \\n M David \\n M Danny \\n F Aurora' 每个舞者的信息都被存储在一个 Dancer 对象中： 1234function Dancer (name, sex) &#123; this.name = name this.sex = sex&#125; 下面我们需要一个函数，将舞者信息读到程序中： 12345678910111213141516function getDancers (maleDancers, femaleDancers) &#123; var names = dancers.split('\\n') for (var i = 0; i &lt; names.length; i++) &#123; names[i] = names[i].trim() &#125; for (var i = 0; i &lt; names.length; i++) &#123; var dancer = names[i].split(' ') var sex = dancer[0] var name = dancer[1] if (sex === 'F') &#123; femaleDancers.enqueue(new Dancer(name, sex)) &#125; else &#123; maleDancers.enqueue(new Dancer(name, sex)) &#125; &#125;&#125; 舞者的姓名被从变量 dancers 中读入数组。然后 trim() 函数除去了每行字符串的空格。第二个循环将每行字符串按姓名和性别分成两部分存入一个数组。然后根据性别，将舞者加入不同的队列。 下一个函数将男性和女性组成舞伴，并且宣布配对结果。 12345678910function dance (females, males) &#123; console.log('the dance partners are: ') let person while (!females.empty() &amp;&amp; !males.empty()) &#123; person = females.dequeue() console.log('female dancer is ', person) person = males.dequeue() console.log('and male dancer is ', person) &#125;&#125; 使用队列对数据进行排序队列不仅用于执行现实生活中与排队有关的操作，还可以用于对数据进行排序。对于0 ~99 的数字，我们可以基于基数排序对数据扫描两次。第一次按个位上的数字进行排序，第二次按十位上的数字进行排序。每个数字根据对应位上的数值被分在不同的盒子上。假设有以下数字： 191, 46, 85, 15, 92, 35, 31, 22 经过基数排序第一次扫描之后，数字被分配到如下的盒子里： 12345678910Bin 0:Bin 1: 91, 31Bin 2: 92, 22Bin 3:Bin 4:Bin 5: 85, 15, 35Bin 6: 46Bin 7:Bin 8:Bin 9: 根据盒子的顺序，第一次排序的结果如下： 191, 31, 92, 22, 85, 15, 35, 46 然后根据十位上的数值再次将上述排序的结果分配到不同的盒子里： 12345678910Bin 0:Bin 1: 15Bin 2: 22Bin 3: 31, 35Bin 4: 46Bin 5: Bin 6: Bin 7: Bin 8: 85Bin 9: 91, 92 最后，将盒子中的数字取出，组成一个新的列表，该列表即为排好序的数字： 115， 22， 31， 35， 46， 85， 91， 92 使用队列代表盒子，可以实现这个算法。我们需要九个队列，每个对应一个数字，将所有队列保存在一个数组中，使用取余和除法操作决定个位和十位。算法的剩余部分将数字加入相应的队列，根据个位数值对其重新排序，然后再根据十位上的数值进行排序，结果即为排好序的数字。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function Queue () &#123; this.dataStore = [] this.enqueue = enqueue this.dequeue = dequeue this.front = front this.back = back this.toString = toString this.count = count this.empty = empty&#125;function enqueue (element) &#123; this.dataStore.push(element)&#125;function dequeue () &#123; return this.dataStore.shift()&#125;function front () &#123; return this.dataStore[0]&#125;function back () &#123; return this.dataStore[this.dataStore.length -1]&#125;function toString () &#123; var retStr = '' for (var i = 0; i &lt; this.dataStore.length; i++) &#123; retStr += this.dataStore[i] + ' ' &#125; return retStr&#125;function count () &#123; return this.dataStore.length&#125;function empty () &#123; return this.dataStore.length === 0&#125;//基数排序var queues = [] //定义队列数组var nums = [] //定义数字数组//选十个0~99的随机数进行排序for (var i = 0; i &lt; 10; i ++)&#123; queues[i] = new Queue() nums[i] = Math.floor( Math.random() * 101 )&#125;//排序之前console.log( 'before radix sort: ' + nums )//基数排序distribution(nums, queues , 10 , 1)collect(queues, nums)distribution(nums, queues , 10 , 10)collect(queues, nums)//排序之后console.info('after radix sort: ' + nums)//根据相应的（个位和十位）数值，将数字分配到相应队列function distribution (nums, queues, n, digit) &#123; //digit表示个位或者十位的值 for(var i = 0; i &lt; n; i++)&#123; if(digit == 1)&#123; queues[nums[i] % 10].enqueue(nums[i]) &#125;else&#123; queues[Math.floor(nums[i] / 10)].enqueue(nums[i]) &#125; &#125; console.log(queues.toString())&#125;//从队列中收集数字function collect (queues, nums) &#123; var i = 0 for (var digit = 0; digit &lt; 10 ; digit++ )&#123; while (!queues[digit].empty())&#123; nums[i++] = queues[digit].dequeue() &#125; &#125;&#125; 优先队列一般情况下，从队列中删除元素，一定是最新入队的元素，但是也有一些使用队列的应用，在删除元素时不必遵循先进先出的约定。这种应用，需要使用一个叫做优先队列的数据结构来进行模拟。 从优先队列中删除元素时，需要考虑优先权的限制。 先来定义存储队列元素的对象，然后在构建我们的优先队列系统： 1234function Patient (name, code) &#123; this.name = name this.code = code&#125; 变量 code 是一个整数，表示优先级。 现在需要重新定义 dequeue() 方法，使其删除队列中拥有最高优先级的元素。我们规定，优先码的值最小，代表优先级最高。新的 dequeue() 方法遍历队列的底层存储数组，从中找出优先码值最小的元素，然后使用数组的 splice() 方法删除优先级最高的元素。新的 dequeue() 方法定义如下所示： 123456789function dequeue () &#123; var entry = 0 for (var i = 1; i &lt; this.dataStore.length; ++i) &#123; if (this.dataStore[i].code &lt; this.dataStore[entry].code) &#123; entry = i &#125; &#125; return this.dataStore.splice(entry, 1)&#125; 优先队列的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function Queue () &#123; this.dataStore = [] this.enqueue = enqueue this.dequeue = dequeue this.front = front this.back = back this.toString = toString this.count = count this.empty = empty&#125;function enqueue (element) &#123; this.dataStore.push(element)&#125;function dequeue () &#123; var entry = 0 for (var i = 1; i &lt; this.dataStore.length; ++i) &#123; if (this.dataStore[i].code &lt; this.dataStore[entry].code) &#123; entry = i &#125; &#125; return this.dataStore.splice(entry, 1)&#125;function front () &#123; return this.dataStore[0]&#125;function back () &#123; return this.dataStore[this.dataStore.length -1]&#125;function toString () &#123; var retStr = '' for (var i = 0; i &lt; this.dataStore.length; i++) &#123; retStr += this.dataStore[i].name + ' code:' + this.dataStore[i].code + ' ' &#125; return retStr&#125;function count () &#123; return this.dataStore.length&#125;function empty () &#123; return this.dataStore.length === 0&#125;function Patient (name, code) &#123; this.name = name this.code = code&#125;var p = new Patient('smith', 5)var ed = new Queue()ed.enqueue(p)p = new Patient('Jones', 4)ed.enqueue(p)p = new Patient('Wang', 6)ed.enqueue(p)p = new Patient('Qian', 1)ed.enqueue(p)p = new Patient('Brown', 1)ed.enqueue(p)var seen = ed.dequeue()console.log('Patient being treated: ' + seen[0].name)console.log('Patients watting to be seen:')console.log(ed.toString())seen = ed.dequeue()console.log('Patient being treated: ' + seen[0].name)console.log('Patients watting to be seen:')console.log(ed.toString())seen = ed.dequeue()console.log('Patient being treated: ' + seen[0].name)console.log('Patients watting to be seen:')console.log(ed.toString())","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS-数据结构与算法之栈","slug":"JS-数据结构与算法之栈","date":"2019-03-15T12:57:52.000Z","updated":"2019-03-18T12:55:26.303Z","comments":true,"path":"2019/03/15/JS-数据结构与算法之栈/","link":"","permalink":"http://yoursite.com/2019/03/15/JS-数据结构与算法之栈/","excerpt":"导语 栈是和列表类似的一种数据结构，它可以用来解决计算机世界里的很多问题。","text":"导语 栈是和列表类似的一种数据结构，它可以用来解决计算机世界里的很多问题。 对栈的操作栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈被称为一种后入先出 (LIFO，last-in-first-out) 的数据结构。 由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，必须先拿掉上面的元素。 对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用 push() 方法，出栈使用 pop() 方法。 另一个常用的操作就是预览栈顶的元素。 pop() 方法虽然可以访问到栈顶的元素，但是该方法也将栈顶元素永久性地删除了。peek() 方法则只返回栈顶元素，而不删除它。 为了记录栈顶的位置，同时也为了哪里可以加入新元素，我们使用变量 top 。当向栈内压入元素时，该变量增大。当从栈内弹出元素时，该变量减小。 push()、pop()、peek() 是栈的3个主要方法，但是栈还有其它方法和属性。clear() 清除栈内所有元素，length 属性记录栈内元素的个数，empty 属性，用以表示栈内是否有元素。 栈的实现实现一个栈，首先是要决定存储数据的底层数据结构。这里，我们选用数组。 我们从实现以定义 Stack 类的构造函数开始： 123456789function Stack () &#123; this.dataStore = [] this.top = 0 this.push = push this.pop = pop this.peek = peek this.clear = clear this.length = length&#125; 我们用数组 dataStore 来保存栈内的元素，构造函数将其初始化为一个空数组。变量 top 记录栈顶位置，被构造函数初始化为 0 ，表示栈顶对应数组的起始位置 0 。如果有元素被压入栈内，该变量的值将随之变化。 push() 方法 – 当向栈内压入一个新元素时，需要将其保存在数组中变量 top 所对应的位置，然后将 top 值加 1，让其指向数组中下一个空位值。 123function push (element) &#123; this.dataStore[this.top++] = element&#125; 这里需要注意 ++ 操作符的位置，它放在 this.top 的后面，这样新入栈的元素就会被放在 top 的当前值指向的位置，然后再将 top 的值加 1 ，指向下一个位置。 pop() 方法 – 返回栈顶元素，同时将变量 top 的值减 1 。 123function pop () &#123; return this.dataStore[--this.top]&#125; peek() 方法 – 返回栈顶元素，即将变量 top 的值减 1 。 123function peek () &#123; return this.dataStore[this.top - 1]&#125; 如果对一个空栈调用 peek() 方法，结果为 undefined 。 length() 方法 – 通过返回变量 top 值得方式来获取栈内存储了多少元素。 clear() – 将变量 top 的值设为 0 ，轻松清空一个栈。 123function clear () &#123; this.top = 0&#125; 使用 Stack 类在开发过程中，有一些问题特别适合用栈来解决： 数制间的相互转换可以利用栈实现一个数字从一种数制转换为另一种数制。假设想将数字 n 转换为以 b 为基数的数字，实现转换的算法如下(注：此算法只针对基数为2—9的情况)： (1) 最高位为 n % b，将此位压入栈。(2) 使用 n / b 代替 n 。(3) 重复步骤 1 和 2 ，直到 n 等于 0 ，且没有余数。(4) 持续将栈内元素弹出，直到栈为空，依次将这些元素排列，就得到转换后数字的字符串形式。 123456789101112function mulBase (num, base) &#123; var s = new Stack() do &#123; s.push(num % base) num = Math.floor(num /= base) &#125; while (num &gt; 0) var converted = '' while (s.length() &gt; 0) &#123; converted += s.pop() &#125; return converted&#125; 回文回文是指这样一种现象：一个单词、短语或数字，从前往后写和从后往前写都是一样的。如：单词 ‘dad’ , ‘racecar’ 就是回文。 使用栈，可以轻松判断一个字符串是否是回文。我们将拿到的字符串的每个字符从左到右的顺序压入栈。当字符串中的字符都入栈后，栈内就保存了一个反转后的字符串，最后的字符在栈顶，第一个字符在栈底。 字符串完整压入栈内后，通过持续弹出栈中的每个字母就可以得到一个新字符串，该字符串刚好与原来的字符串顺序相反。我们只需比较这两个字符串即可，如果它们相等，就是一个回文。 1234567891011function isPalindrome (word) &#123; var s = new Stack() for (let i of word) &#123; s.push(i) &#125; var rWord = '' while (s.length() &gt; 0) &#123; rWord += s.pop() &#125; return rWord == word&#125; 递归演示为了演示如何用栈实现递归，考虑一下求阶乘函数的递归定义，首先看看 5 的阶乘是怎么定义的： 123456function factorial (n) &#123; if (n === 0) &#123; return 1 &#125; return n * factorial(n - 1)&#125; 使用栈模拟递归的过程 123456789101112function fact (n) &#123; var s = new Stack() while (n &gt; 1) &#123; s.push(n--) &#125; var product = 1 console.log(s.length()) while (s.length() &gt; 0) &#123; product *= s.pop() &#125; return product&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Node-阿里云ECS部署","slug":"Node-阿里云ECS部署","date":"2018-11-27T04:19:00.000Z","updated":"2019-06-04T02:56:38.236Z","comments":true,"path":"2018/11/27/Node-阿里云ECS部署/","link":"","permalink":"http://yoursite.com/2018/11/27/Node-阿里云ECS部署/","excerpt":"导语 双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？","text":"导语 双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？ 此教程仅供新手借鉴，多少有些缺陷，有问题还望各位大佬指正。 准备工作 一个域名 阿里云ECS(实例镜像：CentOS7.4) 如果使用Windows，推荐xshell。如果是Mac，推荐iTerm2 (注：因本人使用Mac，以下均已Mac为主) 终端连接服务器 打开iTerm2，输入连接命令ssh username@ip公网地址，回车，输入你在购买服务器时设置的密码。 密码输入正确，进入服务器。 cd / 进入根目录，创建一个空目录 mkdir soft，用来放我们的安装包。 安装Node下载node包。 1wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz 下载完成后，进行压缩包解压。 1tar -zxvf v8.9.4.tar.gz 进入解压好的目录并执行config配置命令。 1cd node-v8.9.4 &amp;&amp; ./configure 执行编译及安装命令。 1make &amp;&amp; make install 经过漫长的等待之后，一个node环境就安装好了。可以通过node -v 或者 npm -v来检查当前node/npm是否安装成功。 如果你需要升级node和npm版本，执行以下命令即可。 12npm i -g nn stable 安装nrm和pm2nrm是一个管理npm源的插件，方便切换国内外以及私人npm库。 pm2是node服务器的守护进程，方便管理当前服务器上的所有服务。 这里说一下cnpm，如果安装依赖包很慢或者根本没进度，输入命令 1npm install -g cnpm --registry=https://registry.npm.taobao.org 然后使用cnpm代替npm安装。 回到我们熟悉的soft目录。 nrm安装nrm。 1npm install -g nrm 常用命令： nrm add name address 添加新的源 nrm use name 切换到源 nrm ls 查看所有可用的源 pm2安装pm2。 1npm install -g pm2 常用命令： pm2 list 查看pm2守护服务 pm2 start index.js 启动一个pm2守护进程命令 pm2 restart id/name 重启一个pm2守护进程命令 pm2 delete id/name 删除一个正在使用的进程 pm2 delete all 删除所有正在使用的进程 pm2 monit 查看pm2的消耗 安装mysql卸载已有的mysql。 12rpm -qa|grep -i mysqlyum remove &apos;mysql&apos; 下载mysql源。 12// 5.7.24wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm 安装下载的源。 1rpm -ivh mysql57-community-release-el7-7.noarch.rpm 下载安装mysql。 123yum install mysql-serveryum install mysql-develyum install mysql 启动mysql。 1service mysqld start 常用命令： service mysqld status 查看mysql当前的状态 service mysqld stop 停止mysql service mysqld restart 重启mysql service mysqld start 启动mysql 如果遇到错误：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket /var/lib/mysql/mysql.sock’，请在tmp下创建一个软连接： 1ln -s /tmp/mysql.sock /var/lib/mysql 打开my.cnf并修改。 1vi /etc/my.cnf 重启数据库。 1service mysqld restart 登录(默认root是没有密码的)。 1mysql -u root 这时出现ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)，登录root帐号需要密码，现在我们没有设置密码，哪来的密码。 于是我们开始忘记密码的操作 第一步，在/etc/my.cnf文件中添加skip-grant-tables第二步，重启mysql，service mysqld restart第三步，登录mysql，mysql -u root第四步，修改密码： 1234mysql&gt;use mysql;mysql&gt;update mysql.user set authentication_string=password(&apos;your password&apos;) where user=&apos;root&apos;;mysql&gt;flush privileges;mysql&gt;exit; 第五步，恢复/etc/my.cnf，将skip-grant-tables删除或者注释掉第六步，重启mysql，service mysqld restart 分配用户 host指定该用户在哪个主机上可以登陆，此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录;也可以指定某台机器可以远程登录。 12CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;CREATE USER &apos;test&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;; 给创建的用户权限 privileges 用户的操作权限,如SELECT，INSERT，UPDATE等.如果要授予所的权限则使用ALL databasename 数据库名 tablename 表名,如果要授予该用户对所有数据库和表的相应操作权限则可用表示, 如.*. 1GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; 安装RedisRedis是一个非常好用的数据仓库，既可以做nosql数据库，也可以做缓存数据库。 下载安装包。 1wget http://download.redis.io/releases/redis-4.0.6.tar.gz 解压并进入解压之后的文件夹。 1tar -zxvf redis-4.0.6.tar.gz &amp;&amp;cd redis-4.0.6 编译并安装。 1make &amp;&amp; make install 启动redis服务。 1redis-server redis.conf 此时我们发现，不能再输入任何命令，因为redis-server已经占用了这个命令行客户端。我们需要再打开一个命令行工具并连接服务器。 使用redis客户端连接Redis服务，执行Redis文件夹下的redis-cli文件redis-cli，输入几个命令测试一下简单的set/get： 关掉客户端，redis服务也会停止。这时，我们就需要修改redis.conf文件，将daemonizede的值改为yes。 再次运行Redis的启动命令redis-server redis.conf，这次就不会占用命令行了，可以继续操作其他的，Redis服务也不会停止。 nginxnginx在转发请求，负载均衡等方面非常有用。它可以将几个不同的服务集中在一个80端口下，根据域名或者请求路径来区分。 在安装nginx之前，先要安装几个依赖插件。 12yum install -y pcre pcre-develyum install -y zlib zlib-devel 安装openssl。 1yum install -y openssl openssl-devel 下载nginx包。 1wget https://nginx.org/download/nginx-1.15.6.tar.gz 解压并进入解压好的目录。 1tar -zxvf nginx-1.15.6.tar.gz &amp;&amp; cd nginx-1.15.6 执行配置命令。 1./configure 编译并安装。 1make &amp;&amp; make install 查看安装结果。 1whereis nginx 跳转到安装好的nginx目录下，进入sbin目录。 1cd /usr/local/nginx/sbin 启动nginx。 1./nginx 常用命令： ./nginx 启动nginx ./nginx -s stop 停止nginx ./nginx -s quit 退出nginx ./nginx -s reload 重启nginx 安装GitcentOS上没有安装git，有需要的话，我们可以自己手动安装一下。 12yum install gitgit --version 使用pm2启动项目在本地搭建并测试好node项目，上传到GitHub。然后git clone一下。 配置ECS安全组规则，暴露3000接口。 如果项目中使用数据库，运行之前要先建立好数据库，然后再运行项目，登录数据库执行create database dabasename; 1234git clone https://github.com/***cd ***cnpm ipm2 start index.js 注：项目监听3000端口，如果顺利的话，项目已经运行起来了。 可以使用pm2 list查看进程列表，使用pm2 log打印日志。 Linux常用操作指令列表 命令 说明 ssh username@ip 连接服务器 cd path 跳转到路径对应的目录下 rm filename 删除文件 rm -rf path 删除目录及目录下的所有文件 ls [-a] 查看当前目录下的文件和目录(-a：查看所有文件，包括隐藏文件) ll 查看当前目录下的文件详情(文件权限) pwd 查看当前路径的完整路径 which name 默认位置查找该名字 mkdir dirname 创建空目录 cat path 查看文件内容 cp origin target 复制一个文件到另一个地方 mv origin target 移动一个文件到另一个地方 ps -aux 显示当前进程 kill -9 processid 结束进程 tar -zxvf filename 解压文件 tar -zcvf filename 压缩文件 vi path 进入文件编辑模式 vi编辑文件，按下i进入编辑模式 vi退出文件，esc+:wq或esc+:x保存退出 vi退出文件，esc+:q或esc+:q!强制退出","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"JS-深拷贝与浅拷贝","slug":"JS-深拷贝与浅拷贝","date":"2018-10-11T10:11:52.000Z","updated":"2018-12-11T14:03:41.509Z","comments":true,"path":"2018/10/11/JS-深拷贝与浅拷贝/","link":"","permalink":"http://yoursite.com/2018/10/11/JS-深拷贝与浅拷贝/","excerpt":"导语 当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。","text":"导语 当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。 实例🌰： 1234var a = &#123;x: 10, y: 10&#125;var b = ab.x = 100b.y = 100 打印一下a和b的值： 12console.log(a) // &#123;x: 100, y: 200&#125;console.log(b) // &#123;x: 100, y: 200&#125; 发现改变b的值，同时也改了a的值。 🌰： 123var a = 10var b = ab = 20 打印一下a和b的值： 12console.log(a) // 10console.log(b) // 20 ??? b的值改变并没有引起a的值改变。 值类型 vs 引用类型在JS中，变量传递方式分为值类型和引用类型。值类型包括String，Number，Null，Boolean，Undefined。引用类型包括Object类的所有，如Date，Array，Function。 在参数传递方式上，值类型是按值传递。引用类型是按共享传递(指向同一个内存地址，两者引用同一个值，当一者改变值，另一者也改变)。 JS这样设计的原因在于：按值传递的类型，复制一份存入栈内存，这类类型一般不会占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值，保证过大的对象等不会因为不停复制内容而造成内存的浪费。 深拷贝和浅拷贝最根本的区别在于是否真正获取了一个对象的拷贝实体，而不只是引用。 浅拷贝的实现方式直接赋值🌰： 123let obj = &#123;username: &apos;kobe&apos;, age: 39, sex: &#123;option1: &apos;男&apos;, option2: &apos;女&apos;&#125;&#125;let obj1 = objobj1.sex.option1 = &apos;不男不女&apos; // 修改复制的对象会影响原对象 打印obj1的值 1console.log(obj1) // &#123;username: &apos;kobe&apos;, age: 39, sex: &#123;option1: &apos;不男不女&apos;, option2: &apos;女&apos;&#125;&#125; Object.assign🌰： 12345let obj = &#123; username: &apos;kobe&apos;&#125;;let obj1 = Object.assign(obj)obj1.username = &apos;wang&apos; 打印obj的值 1console.log(obj) // &#123; username: &quot;wang&quot; &#125; Array.prototype.concat🌰： 12345let arr = [1, 3, &#123; username: &apos;kobe&apos;&#125;]let arr2=arr.concat()arr2[2].username = &apos;wang&apos; 打印arr的值 1console.log(arr) // [1, 3, &#123; username: &quot;wade&quot; &#125;] Array.prototype.slice🌰： 12345let arr = [1, 3, &#123; username: &apos;kobe&apos;&#125;]let arr2=arr.slice()arr2[2].username = &apos;wang&apos; 打印arr的值 1console.log(arr) // [1, 3, &#123; username: &quot;wade&quot; &#125;] Array.prototype.concat vs Array.prototype.slice关于Array的concat和slice补充说明：Array的concat和slice方法不改变原始数组，只是返回了一个浅复制原数组中的元素的一个新数组。 原数组中的元素会按照下述规则拷贝： 如果该元素是个引用类型，slice或者concat会拷贝这个引用到新的数组里，两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新数组和原数组中的这个元素都会发生改变。 如果该元素是个值类型，slice或者concat会复制一份这些值到新数组里。在别的数组里修改这些值，并不会影响另一个数组。 🌰： 123456let arr = [1, 3, &#123; username: &apos;kobe&apos;&#125;];let arr3 = arr.slice();arr3[1] = 2console.log(arr, arr3) 打印arr和arr3的值 1234console.log(arr, arr3)// ---result// [1, 3, &#123; username: &quot;kobe&quot; &#125;]// [1, 2, &#123; username: &quot;kobe&quot; &#125;] 深拷贝的实现方式Object.assignObject.assign可以进行一层深度拷贝 🌰： 12345678910var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = Object.assign(&#123;&#125;, obj1)obj1.age = 24console.log(obj, obj1) 打印obj和obj1的值 1234console.log(obj, obj1)// ----result// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; &#125;, age: 24 &#125; 然而。。。。。 🌰： 123456789var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = Object.assign(&#123;&#125;, obj1)obj1.test4.age = 24 打印obj和obj1的值 1234console.log(obj, obj1)// ----result// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; age: 24 &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; age: 24 &#125; &#125; JSON.parse(JSON.stringfy(obj))说到深拷贝，你肯定会想到JSON.parse(JSON.stringfy(obj))。 🌰： 12345678var obj = &#123; name: &apos;wang&apos;, test: &#123; name: &apos;test&apos; &#125; &#125;;var obj1 = JSON.parse(JSON.stringify(obj))obj1.test.name = 24 打印obj和obj1的值 1234console.log(obj, obj1)// ----result// &#123; name: &quot;wang&quot;, test: &#123; name: &quot;test&quot; &#125; &#125;// &#123; name: &quot;wang&quot;, test: &#123; name: 24 &#125; &#125; 然而。。。。 🌰： 12345678var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = JSON.parse(JSON.stringify(obj)) 打印obj和obj1的值 1234console.log(obj, obj1)// ---result// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test4: &#123; &#125; &#125; ???test2和test3不见了。。。。。 JSON.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个JSON字符串，不能接受函数。 手写递归方法1234567891011121314151617181920function deepClone(obj) &#123; let result let toString = Object.prototype.toString if (toString.call(obj) === &apos;[Object Array]&apos;) &#123; result = [] for (var i =0; i&lt;obj.length; i++) &#123; result[i] = deepClone(obj[i]) &#125; &#125; else if (toString.call(obj) === &apos;[Object Object]&apos;) &#123; result = &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; result[key] = deepClone(obj[key]) &#125; &#125; &#125; else &#123; return obj &#125; return result&#125; 🌰：调用函数并打印结果 1234567891011var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = deepClone(obj)console.log(obj, obj21)// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: Object &#123; &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: Object &#123; &#125; &#125; jQuery实现🌰： 12345678var obj1 = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = $.extend(true, &#123;&#125;, obj1) lodash实现🌰： 12345678var obj1 = &#123; name: &apos;wclimb&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = _.cloneDeep(obj1)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Webpack-基础使用","slug":"Webpack-基础使用","date":"2018-09-25T07:15:00.000Z","updated":"2018-12-11T14:03:41.515Z","comments":true,"path":"2018/09/25/Webpack-基础使用/","link":"","permalink":"http://yoursite.com/2018/09/25/Webpack-基础使用/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 安装使用npm或者yarn来安装webpack 全局安装12345$ npm i webpack webpack-cli -gor$ yarn -g add webpack webpack-cli 等待安装完毕，就可以全局执行webpack命令了。注：webpack-cli在4.x版本之后不再作为webpack的依赖了，我们使用时需要单独安装。 局部安装在项目中，我们更推荐将webpack作为项目的开发依赖来安装使用，这样可以指定项目中使用的webpack版本。 12345$ npm i webpack webpack-cli -Dor$ yarn add webpack webpack-cli -D 等待安装完毕，webpack会出现在项目的package.json文件中，我们添加一个npm scripts: 1234567&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --mode production&quot;&#125;,&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.1.1&quot;, &quot;webpack-cli&quot;: &quot;^2.0.12&quot;,&#125; 项目根目录新建./src/index.js，任意写JS代码，保存，执行npm run build或者yarn build命令，我们会发现项目根目录下新增了一个dist目录，里面存放了webpack构建好的main.js文件。 webpack4.x可以零配置就开始构建，但有时我们的项目需要更多的功能。 基本概念先放一张经典图： 入口如上图左上角的.js，这个.js就是多个代码模块的入口，也是webpack构建的入口。webpack会读取这个文件，并从它开始解析依赖，然后进行打包。 在我们的项目中，如果是单页应用，那么可能入口只有一个。如果是多页应用，那么经常是一个页面对应一个构建入口。 用法：entry 单个入口语法12345678910// 简写module.exports = &#123; entry: &apos;./src/index&apos;&#125;module.exports = &#123; entry: &#123; main: &apos;./src/index&apos; &#125;&#125; 多个入口语法123456module.exports = &#123; entry: &#123; foo: &apos;./src/foo&apos;, bar: &apos;./src/bar&apos; &#125;&#125; 输出输出即指webpack最终构建出来的静态文件，构建结果的文件名，路径等都是可以配置的。 用法：output 12345678910111213141516171819202122module.exports = &#123; output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125;// 多个入口生成不同的文件module.exports = &#123; output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].js&apos; &#125;&#125;// 路径中使用hash，每次构建都有一个不同的hash值，避免发布新版本使用浏览器缓存module.exports = &#123; output: &#123; path: path.resolve(__dirname, &apos;dist/[hash]&apos;), filename: &apos;[name].js&apos; &#125;&#125; loaderloader，我们可以理解为一个转换器，负责把某种文件格式的内容转换成webpack可以支持打包的模块。 默认情况下，webpack会默认把所有依赖打包成JS文件，如果入口文件依赖一个.pug模块文件或者.scss样式文件，那么我们就需要相应的loader来把不同格式的文件转换为JavaScript，以便打包后在浏览器运行。 用法：module.rules 12345678910111213module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.jsx?/, // 条件 include: [ path.resolve(__dirname, &apos;src&apos;) ], // 条件 use: &apos;babel-loader&apos; // 规则应用结果 &#125; // 一个Object即一条规则 ] &#125;&#125; loader匹配规则中最重要的两个因素：匹配条件和匹配规则后的应用。 规则条件配置匹配条件通常使用请求资源文件的绝对路径来进行匹配，官方文档成为resource。 上述代码中的test和include都用于匹配resource路径，是resource.test和resource.include的简写。你也可以这样写： 123456789101112131415module.exports = &#123; // ... rules: [ &#123; resource: &#123; // resource 的匹配条件 test: /\\.jsx?/, include: [ path.resolve(__dirname, &apos;src&apos;), ] &#125;, use: &apos;babel-loader&apos; &#125;, // ... ],&#125; webpack为loader提供了多种匹配条件的配置方式： test: … 匹配特定条件 include: … 匹配特定路径 exclude: … 排除特定路径 and: [] 必须匹配数组中的所有条件 or: [] 匹配数组中的任意一个条件 not: [] 排除匹配数组中的所有条件 条件值类型： 字符串：必须以提供的字符串开始（绝对路径） 正则表达式 数组：至少包含一个条件的数组 对象：匹配所有属性值的条件 函数：返回true表示匹配 规则应用配置匹配规则后的应用，我们可以使用use字段： 1234567891011121314151617181920rules: [ &#123; test: /\\.less/, use: [ &apos;style-loader&apos;, &#123; loader: &apos;css-loader&apos;, options: &#123; // ... &#125; &#125;, &#123; loader: &apos;less-loader&apos;, options: &#123; // ... &#125; &#125; ] &#125;] 使用options可以给对应的loader传递一些配置项。 对于上述的less规则应用配置，一个less模块文件可以经过多个loader的转换处理，执行顺序为从右到左。 如果多个rule匹配了同一个模块文件，loader的应用顺序应该如何处理？ 12345678910rules: [ &#123; test: /\\.js$/, loader: &quot;eslint-loader&quot;, &#125;, &#123; test: /\\.js$/, loader: &quot;babel-loader&quot;, &#125;] eslint-loader用于检查人工编写的代码，babel-loader用于转换代码。所以，eslint-loader应该在babel-loader之前执行，那么该如何保证执行顺序？ webpack为每一个匹配规则提供了enforce字段来配置当前rule得的loader类型。pre(前置) &gt; 行内 &gt; 普通 &gt; 后置(post)。 我们要确保eslint-loader在babel-loader之前执行，只需给rule规则项添加enforce字段，并设置其值为pre。 1234567891011rules: [ &#123; enforce: &apos;pre&apos;, test: /\\.js$/, loader: &quot;eslint-loader&quot;, &#125;, &#123; test: /\\.js$/, loader: &quot;babel-loader&quot;, &#125;] 常用rule配置项CSS123456789101112131415161718192021const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: &apos;css-loader&apos;, &#125;) &#125; ] &#125;, plugins: [ // 引入插件，配置文件名，这里同样可以使用 [hash] new ExtractTextPlugin(&apos;[name].css&apos;), ],&#125; css-loader：负责解析CSS代码，主要处理CSS中的依赖，🌰：@import、url()等。 style-loader：将css-loader解析的结果转变为JS代码，运行时动态插入style标签来让CSS生效。 预处理器12345678910111213141516171819module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.less/, // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [&apos;css-loader&apos;, &apos;less-loader&apos;], &#125;) &#125; ] &#125;, plugins: [ // 引入插件，配置文件名，这里同样可以使用 [hash] new ExtractTextPlugin(&apos;[name].css&apos;) ]&#125; 图片webpack无法处理图片格式，我们选择file-loader，它不仅可以处理图片格式，还可用于处理其它很多类型的文件。直接输出文件，将构建后的文件路径返回。 1234567891011module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: &apos;file-loader&apos; &#125; ] &#125;&#125; BabelBabel是一个让我们能够使用ES6、ES7等新标准来编写JS的编译工具。 1234567891011module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.jsx?/, loader: &apos;babel-loader&apos; &#125; ] &#125;&#125; plugin插件是webpack的支柱功能，在于解决loader无法实现的其他事情。 用法：plugin 12345const UglifyPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)module.exports = &#123; plugins: [new UglifyPlugin()]&#125; 常见webpack plugin使用HtmlWebpackPluginwebpack默认从作为入口的JS文件进行构建，但通常一个前端项目都是从一个页面(HTML)出发的。通常我们会创建一个HTML文件，使用script标签直接引入构建好的js文件。 1&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt; 然而，问题来了，如果我们的文件名或者路径变化，每次构建完成后，我们要手动去修改HTML文件中的js路径? 如果能将HTML引用路径和我们的webpack构建结果关联起来就好了。 html-webpack-plugin就可以帮我们解决这个问题。 12345npm i html-webpack-plugin -Doryarn add html-webpack-plugin -D 然后在webpack配置中，将html-webpack-plugin添加到plugins列表中： 12345678const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(), ],&#125; 配置好之后，构建时html-webpack-plugin会为我们创建一个HTML文件，其中会引用构建出来的JS文件。 我们还可以在html-webpack-plugin中传递我们自己写好的HTML模板： 1234567891011const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(&#123; filename: &quot;index.html&quot;, template: &quot;assets/index.html&quot; &#125;), ],&#125; DefinePluginDefinePlugin是webpack的内置插件，可以通过webpack.DefinePlugin直接引用。 主要用于创建一些在编译时可以配置的全局变量。 12345678910111213module.exports = &#123; // ... plugins: [ new webpack.DefinePlugin(&#123; VERSION: JSON.stringfy(&apos;v1.1.0&apos;), // const VERSION = &apos;v1.1.0&apos; TWO: &apos;1 + 1&apos;, // const TWO = 2 BROWSER_SUPPORT: true, // const BROWSER_SUPPORT = &apos;true&apos; CONSTANTS: &#123; APP_VERSION: JSON.stringfy(&apos;1.1.1&apos;) &#125; // const CONSTANTS = &#123; APP_VERSION: &apos;1.1.1&apos;&#125; &#125;) ]&#125; 配置好之后，我们就可以在应用代码中，访问配置好的变量了。 1console.log(VERSION) 有关配置的值，简述一下配置规则： 如果配置的值为字符串，那么整个字符串会被当做代码片段来执行，其结果将作为最终配置的值。 如果配置的值不是字符串，也不是对象字面量，那么该值会被转换为一个字符串。 如果配置的值是一个对象字面量，那么该对象的所有key会以同样的方式去定义。 CopyWebpackPlugin通常我们会把源码和资源文件放在项目的src目录下，构建完成后会有一个dist目录，我们会直接拿dist目录中的所有文件来发布。有些文件没有经过webpack处理，但是我们希望它们也能出现在dist目录下，这时，我们就可以使用CopyWebpackPlugin来处理。 12345678910const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new CopyWebpackPlugin([ &#123; from: &apos;src/*.txt&apos;, to: &apos;dist/*.txt&apos; &#125; // from: 配置来源；to: 配置目标 ]) ]&#125; ExtractTextWebpackPlugin通常CSS经过相应的loader处理后，会转换为JS，和index.js一起打包。如果需要单独把CSS文件分离出来，就需要使用extract-text-webpack-plugin插件。 1234567891011121314151617181920const ExtractTextWebpackPlugin = require(&apos;extract-text-webpack-plugin&apos;)module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: &apos;css-loader&apos; &#125;) &#125; ] &#125;, plugins: [ // style.css 作为单独分离出来的文件名 new ExtractTextWebpackPlugin(&apos;style.css&apos;) ]&#125; 它还可以为每一个入口创建单独分离的文件，所以，最好这样配置： 123plugins: [ new ExtractTextPlugin(&apos;[name].css&apos;),] ProvidePluginProvidePlugin是webpack的内置插件，可以通过webpack.ProvidePlugin直接引用。 主要用于自动加载模块，不必到处import或require 1234567891011new webpack.ProvidePlugin(&#123; identifier: &apos;module&apos;, // ...&#125;)ornew webpack.ProvidePlugin(&#123; identifier: [&apos;module&apos;, &apos;property&apos;], // 即引用 module 下的 property，类似 import &#123; property &#125; from &apos;module&apos; // ...&#125;) 任何时候，当identifier被当作未赋值的变量时，module就会自动被加载，并且identifier会被这个module输出的内容所赋值。 注：如果是ES的default export，那么你需要指定模块的default属性：identifier: [‘module’, ‘default’]。 IgnorePluginIgnorePlugin是webpack的内置插件，可以通过webpack.IgnorePlugin直接引用。 主要用于忽略某些特定的模块，让webpack不把这些指定的模块打包进去。 配置参数：匹配引入模块路径的正则表达式，匹配模块的上下文。 123456module.exports = &#123; // ... plugins: [ new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) ]&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]}]}