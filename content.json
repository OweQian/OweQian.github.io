{"meta":{"title":"W | 个人博客 | web前端","subtitle":null,"description":"前端","author":"wangxiaobai","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-04-11T08:28:54.000Z","updated":"2018-04-11T08:29:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-11T08:28:32.000Z","updated":"2018-04-11T08:28:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）","slug":"Vue- 手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）","date":"2018-04-12T12:06:52.000Z","updated":"2018-06-15T06:32:37.000Z","comments":true,"path":"2018/04/12/Vue- 手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）/","link":"","permalink":"http://yoursite.com/2018/04/12/Vue- 手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）/","excerpt":"导语 说好的总结终于来了，本篇文章主要来说说在开始写实际业务代码之前的一些准备工作，这里不会教你Webpack的基础配置，热更新原理等，有需求的请自行 Google。","text":"导语 说好的总结终于来了，本篇文章主要来说说在开始写实际业务代码之前的一些准备工作，这里不会教你Webpack的基础配置，热更新原理等，有需求的请自行 Google。 完整项目地址：公路收费云平台 系类文章一：手摸手，带你用Vue构建公路收费云平台 系列一（基础篇） 系类文章二：手摸手，带你用Vue构建公路收费云平台 系列二（登录权限篇） 系类文章三：手摸手，带你用Vue构建公路收费云平台 系列三（实战篇） 系类文章四：手摸手，带你用Vue构建公路收费云平台 系列四（挖坑填坑篇） 前端技术选型在三大框架中选择了VUE，因为自己对这个框架更为熟悉，同时，VUE在国内的生态环境已经相当成熟，各类组件库，插件库都比较丰富。搭配上vue-router和vuex组成vue全家桶，在UI框架上选择了专门针对pc端的ElementUI，ajax库选择了vue-resource，css预编译使用scss，js语言使用了支持 async function 的ES7，搭配babel编译成生产环境可运行的ES5。打包工具使用webpack。 前端框架： vue 路由管理： vue-router 状态管理： vuex、sessionStorage、localStorage UI框架： ElementUI Ajax库： vue-resource JS语言： ES6、ES7、babel CSS预编译语言： scss 打包工具： webpack 图表：echarts ESLint CSS 预处理： SASS 功能模块 目录结构12345678910111213141516171819202122232425262728293031├── build // 构建相关 ├── config // 配置相关├── dist // 编译后静态文件├── documents // api ui等相关文档 ├── node_modules // 依赖相关├── src // 源代码│ ├── api // 所有请求│ ├── api-elk // elk所有请求│ ├── assets // 主题 字体等静态资源│ ├── components // 全局公用组件│ ├── directive // 全局指令│ ├── filtres // 全局 filter│ ├── http // 全局拦截器│ ├── mixin // mixin│ ├── pages // pages│ ├── router // 路由│ ├── storage // localStorage, sessionStorage│ ├── store // 全局 store管理│ ├── styles // 全局样式│ ├── svg // svg│ ├── config.js // appConfig│ ├── main.js // 入口 加载组件 初始化等│ ├── resources.js // api resources│ ├── utils.js // 全局公用方法├── static // 第三方不打包资源├── .babelrc // babel-loader 配置├── .editorconfig // 编辑器格式化代码配置├── .eslintrc.js // eslint 配置项├── .gitignore // git 忽略项├── index.html // html模板└── package.json // package.json 简单介绍一下src： api 和 pages随着业务的不断迭代，模块会越来越多，所以我们建议根据业务模块来划分pages和api，使之一一对应，从而方便维护。如下图： components这里的components放置的都是全局公用的一些组件，如自定义卡片组件，日期选择组件等。一些页面级的组件建议还是放在各自的pages文件夹下，方便管理。如图： router当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样写大大减少了初始页面 js 的大小并且能更好的利用游览器的缓存。 我们选择结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。 12345678&#123; path: &apos;/login&apos;, name: &apos;login&apos;, component: (resolve) =&gt; require([&apos;../../pages/Login.vue&apos;], resolve), meta: &#123; auth: false &#125;&#125; storage出于某些方面的考虑，我们在项目中用到了Window.sessionStorage和Window.localStorage，在这里关于其原理及相应语法不再进行介绍，有需求的请自行 Google。 stylesSass(Scss)号称是世界上最成熟、稳定和强大的专业级CSS扩展语言，通过Sass(Scss)来改变前端工程师，提高效率，降低成本。在这里，我们建议将颜色、屏幕分比率常用值等这些反复使用的css属性值定义成变量，与项目其它常规样式分开，便于维护。 svg项目中涉及到一些小图标，我们统一采用svg图形格式。在这里推荐vue-svg-icon—-一个 vue的可变彩色 svg 图标方案。 1&lt;icon name=&quot;chameleon&quot; :scale=&quot;20&quot;&gt;&lt;/icon&gt; store个人建议不要为了用 vuex 而用 vuex。就拿收费云来说，它虽然比较庞大，几十个业务模块，几十种权限，但业务之间的耦合度是很低的，所以没有必要使用 vuex 来存储data，每个页面里存放自己的 data 就行。当然有些数据还是需要用 vuex 来统一管理的，如登录token，用户信息等，还是用vuex管理更加的方便，具体当然还是要结合自己的业务场景的。总之还是那句话，不要为了用vuex而用vuex！ webpack这里是用vue-cli的webpack-template为基础模板构建的，如果你对这个有什么疑惑请自行Google，相关的配置介绍其他文章已经介绍地很详细了，这里将不再展开。 开发环境 生产环境 cors cors proxy nginx alias当项目逐渐变大之后，文件与文件之间的直接引用关系会很复杂，这时候就需要使用alias了。 1234567resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &#125;&#125; 12// 使用import dataPicker from &apos;@/components/base-date-picker&apos; ESLint不管是多人合作还是个人项目，代码规范是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性，简单介绍一下我们的.eslintrc。 123456789101112131415161718192021222324252627282930module.exports = &#123; root: true, // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style parserOptions: &#123; parser: &apos;babel-eslint&apos; &#125;, extends: [ // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules. &apos;plugin:vue/essential&apos;, // https://github.com/standard/standard/blob/master/docs/RULES-en.md &apos;standard&apos; ], env: &#123; browser: true, &#125;, plugins: [ &apos;vue&apos; ], rules: &#123; &apos;eol-last&apos;: 0, &apos;arrow-parens&apos;: 0, // allow debugger during development &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? 2 : 0, &quot;no-new&quot;: 0, &quot;no-useless-escape&quot;: 0, &quot;spaced-comment&quot;: [&quot;error&quot;, &quot;always&quot;, &#123; &quot;exceptions&quot;: [&quot;-&quot;] &#125;], &quot;space-before-function-paren&quot;: 0 &#125;&#125; 前后端交互在平时的开发中，交流占据了我们很大一部分时间。但如果前后端有一个好的协作方式的话能节省很多时间。我们的开发流程是前后端一起开会讨论项目，之后后端根据需求，首先定义数据格式和api，然后 mock api 生成好文档，我们前端才开始对接接口。 如果后端不肯来帮你mock数据的话，前端自己来mock也是很简单的。你可以了解下eoLinker，通过eoLinker的Mock API，随机生成虚拟数据接口，让前端在脱离后端的情况下独立进行测试，帮助你实现由文档驱动的敏捷开发。 跨域问题前后端交互不可避免的就会遇到跨域问题，在这里推荐两种跨域解决方案。 最推荐的常用方式就是cors全称为 Cross Origin Resource Sharing（跨域资源共享）。这玩意对应前端来说和平时发请求写法上没有任何区别，工作量基本都在后端这里。每一次请求浏览器必须先以 OPTIONS 请求方式发送一个预请求，从而获知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。推荐的原因是只要第一次配好了，之后不管有多少接口和项目复用就可以了，一劳永逸的解决了跨域问题，而且不管是开发环境还是测试环境都能方便的使用。 但总有后端觉得麻烦不想这么搞。那前端也是有解决方案的，在开发环境下可使用webpack 的 proxy，使用也是很方便的，看一下文档就会使用了。但这种方法在生成环境中是不适用的，在生产环境中需要使用Nginx反向代理。不管是 proxy 和 nginx 的原理都是一样的通过搭建一个中转服务器来转发请求规避跨域的问题。 封装HTTP请求在讨论与后端数据交互的选型中，我们选择了vue-resource，它是一个非常轻量的用于处理HTTP请求的插件，提供了两种方式来处理HTTP请求：使用Vue.http或this.$http 使用Vue.resource或this.$resource。 主要特点如下： 体积小：压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。 支持主流的浏览器：除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。 支持Promise API和URI Templates**：Promise对象用于异步计算。URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。 支持拦截器：拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import Vue from &apos;vue&apos;import &#123; HOST &#125; from &apos;../config&apos;import store from &apos;../store&apos;import router from &apos;../router&apos;import VueResource from &apos;vue-resource&apos;import &#123; Message &#125; from &apos;element-ui&apos;Vue.use(VueResource)// 设置全局 api ROOTVue.http.options.root = HOST// request 请求拦截Vue.http.interceptors.push((request, next) =&gt; &#123; // if logged in, add the token to the header if (store.state.token) &#123; // // 越权请求拦截 // if (store.state.permission) &#123; // let path = `$&#123;request.url&#125;`.replace(HOST, &apos;&apos;) // let perName = `$&#123;request.method&#125;,$&#123;path&#125;` // console.error(&apos;perName&apos;, perName) // if (store.state.permission.hasOwnProperty(perName)) &#123; // if (!store.state.permission[perName]) &#123; // this.$message(&#123; // message: &apos;无访问权限，请联系企业管理员&apos;, // type: &apos;warning&apos; // &#125;) // &#125; // &#125; // &#125; request.headers.set(&apos;Authorization&apos;, `JWT $&#123;store.state.token&#125;`) &#125; next()&#125;)// response 拦截Vue.http.interceptors.push((request, next) =&gt; &#123; next((response) =&gt; &#123; // don&apos;t handle for login page if (store.state.route.path === &apos;/login&apos;) &#123; return &#125; if (response.status === 403) &#123; store.commit(&apos;LOG_OUT&apos;) router.push(&#123;path: &apos;/login&apos;, query: &#123;redirect: store.state.route.fullPath&#125;&#125;) &#125; if (response.status === 401 ) &#123; store.commit(&apos;LOG_OUT&apos;) router.push(&#123;path: &apos;/login&apos;, query: &#123;redirect: store.state.route.fullPath&#125;&#125;) &#125; if (response.status === 500) &#123; Message.error(&#123; dangerouslyUseHTMLString: true, message: `服务器错误&lt;div&gt;$&#123;response.url&#125;&lt;/div&gt;` &#125;) &#125; &#125;)&#125;) 占坑 系类文章一：手摸手，带你用Vue构建公路收费云平台 系列一（基础篇） 系类文章二：手摸手，带你用Vue构建公路收费云平台 系列二（登录权限篇） 系类文章三：手摸手，带你用Vue构建公路收费云平台 系列三（实战篇） 系类文章四：手摸手，带你用Vue构建公路收费云平台 系列四（挖坑填坑篇）","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Babel-如何写好.babelrc?","slug":"Babel-如何写好.babelrc？","date":"2018-04-12T06:06:52.000Z","updated":"2018-06-10T14:17:42.000Z","comments":true,"path":"2018/04/12/Babel-如何写好.babelrc？/","link":"","permalink":"http://yoursite.com/2018/04/12/Babel-如何写好.babelrc？/","excerpt":"导语 Babel-The compiler for writing next generation Javascript. 下一代JavaScript 语法的编译器。","text":"导语 Babel-The compiler for writing next generation Javascript. 下一代JavaScript 语法的编译器。 什么是Babel？作为前端开发，由于浏览器的版本和兼容性等问题，很多JS的新的方法都不能使用，等到可以大胆使用的时候，可能已经过去很久。Babel就因此而生，它可以让你放心使用大部分的JS的新的标准的方法，然后编译成兼容绝大多数的主流浏览器的代码。 在升级到Babel6.X版本之后，所有的插件都是可插拔的，这也意味着你安装了Babel之后，是不能工作的，需要配置对应的.babelrc文件才能发挥完整的作用。 预设（presets）使用时需要安装对应的插件，对应babel-preset-xxx。例如下配置，需要npm i babel-preset-es2015。 123&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; env123&#123; &quot;presets&quot;: [&quot;env&quot;, options]&#125; 新增选项，有以下options选择。targets: {[string]: number}，默认{}需要支持的环境，可选例如：chrome，edge，firefox，safari等，甚至可以指定版本，如node：6.5。也使用node：current代表使用当前的版本。 browsers: array | string，默认[]浏览器列表，使用的是browserslist，可选例如：last 2 versions, &gt; 5%。 loose: boolean，默认false是否使用宽松模式，如果设置为true，plugins里的插件如果允许，都会采用宽松模式。 debug: boolean，默认false编译是否会去掉console.log。 whitelist: array，默认[]设置一直引入的plugins列表。es2015/es2016/es2017/latest 123&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; es2015使用es2015，简单翻译如下，更多细节可以参看文档。 check-es2015-constants // 检验const常量是否被重新赋值。 transform-es2015-arrow-functions // 编译箭头函数。 transform-es2015-block-scoped-functions // 函数声明在作用域内。 transform-es2015-block-scoping // 编译const和let。 transform-es2015-classes // 编译class。 transform-es2015-computed-properties // 编译计算对象属性。 transform-es2015-destructuring // 编译解构赋值。 transform-es2015-duplicate-keys // 编译对象中重复的key，其实是转换成计算对象属性。 transform-es2015-for-of // 编译for…of。 transform-es2015-function-name // 将function.name语义应用于所有的function。 transform-es2015-literals // 编译整数(8进制/16进制)和unicode。 transform-es2015-modules-commonjs // 将modules编译成commonjs。 transform-es2015-object-super // 编译super。 transform-es2015-parameters // 编译参数，包括默认参数，不定参数和解构参数。 transform-es2015-shorthand-properties // 编译属性缩写。 transform-es2015-spread // 编译展开运算符。 transform-es2015-sticky-regex // 正则添加sticky属性。 transform-es2015-template-literals // 编译模版字符串。 transform-es2015-typeof-symbol // 编译Symbol类型。 transform-es2015-unicode-regex // 正则添加unicode模式。 transform-regenerator // 编译generator函数。 es2016使用es2016，更多细节可以参看文档。 transform-exponentiation-operator // 编译幂运算符 es2017使用es2017的相关插件，更多细节可以参看文档。 syntax-trailing-function-commas // function最后一个参数允许使用逗号。 transform-async-to-generator // 把async函数转化成generator函数。 latestlatest是一个特殊的presets，包括了es2015，es2016，es2017的插件（目前为止，以后有es2018也会包括进去）。 reactreact是一个比较特别的官方推荐的presets，大概是因为比较火吧。加入了flow，jsx等语法，具体可以看文档。 stage-x(stage-0/1/2/3/4)stage-x和上面的es2015等有些类似，但是它是按照JavaScript的提案阶段区分的，一共有5个阶段。而数字越小，阶段越靠后，存在依赖关系。也就是说stage-0是包括stage-1的，以此类推。 stage-4已完成的提案，与年度发布的release有关，包含2015年到明年正式发布的内容。例如，现在是2016年，stage-4应该是包括es2015，es2016，es2017。经过测试，babel-preset-stage-4这个npm包是不存在的，如果你单纯的需要stage-4的相关方法，需要引入es2015~es2017的presets。 stage-3除了stage-4的内容，还包括以下插件，更多细节请看文档。 transform-object-rest-spread // 编译对象的解构赋值和不定参数。 transform-async-generator-functions // 将async generator function和for await编译为es2015的generator。 stage-2除了stage-3的内容，还包括以下插件，更多细节请看文档。 transform-class-properties // 编译静态属性(es2015)和属性初始化语法声明的属性(es2016)。 stage-1除了stage-2的内容，还包括以下插件，更多细节请看文档。 transform-class-constructor-call // 编译class中的constructor，在Babel7中会被移除。 transform-export-extensions // 编译额外的export语法，如export * as ns from “mod”。 stage-0除了stage-1的内容，还包括以下插件，更多细节请看文档。 transform-do-expressions // 编译do表达式。 transform-function-bind // 编译bind运算符，也就是::。 插件(plugins)其实看了上面的应该也明白了，presets，也就是一堆plugins的预设，起到方便的作用。如果你不采用presets，完全可以单独引入某个功能，比如以下的设置就会引入编译箭头函数的功能。 123&#123; &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]&#125; 还有一些方法是presets中不提供的，这时候就需要单独引入了，介绍几个常见的插件。 transform-runtime123&#123; &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]&#125; 主要有以下options选择。 helpers: boolean // 默认为true，使用babel的helper函数。 polyfill: boolean // 默认为true，使用babel的polyfill，但不能完全取代bebel-polyfill。 regenerator: boolean // 默认为true，使用babel的regenerator。 noduleName: string // 默认babel-runtime，使用对应module处理。 options一般不用自己设置，使用默认的即可。这个插件的作用主要是： 解决编译中产生的重复的工具函数，减小代码体积 非实例方法的poly-fill，如Object.assign，但是实例方法不支持，如”foobar”.includes(“foo”)，这时候需要单独引入babel-polyfill。 更多细节参见文档。 transform-remove-console123&#123; &quot;plugins&quot;: [&quot;transform-remove-console&quot;]&#125; 使用这个插件，编译后的代码都会移除console.*，妈妈再也不用担心线上代码有多余的console.log了。当然很多时候，我们如果使用webpack，会在webpack中配置。 这也告诉我们，Babel不仅仅是编译代码的工具，还能对代码进行压缩，也许有一天，你不再需要代码压缩的插件了，因为你有了Babel！ 自定义预设或插件Babel支持自定义的预设(presets)或插件(plugins)。如果你的插件在npm上，可以直接采用这种方式”plugins”: [“babel-plugin-myPlugin”]，当然，你也可以缩写，它和”plugins”: [“myPlugin”]是等价的。此外，你还可以采用本地的相对路径引入插件，比如”plugins”: [“./node_modules/asdf/plugin”]。 presets同理。 plugins/presets排序也许你会问，plugins和presets编译，也许会有相同的功能，或者有联系的功能，按照怎么的顺序进行编译？答案是会按照一定的顺序。 具体而言，plugins优先于presets进行编译。 plugins按照数组的index增序(从数组第一个到最后一个)进行编译。 presets按照数组的index倒序(从数组最后一个到第一个)进行编译。因为作者认为大部分会把presets写成[“es2015”, “stage-0”]。具体细节可以看这个。 总结12345678910111213&#123; \"presets\": [ [\"env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125; &#125;], \"stage-2\" ], \"plugins\": [\"transform-runtime\", \"transform-vue-jsx\"], \"comments\": false&#125; 强烈推荐使用transform-runtime。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6---Airbnb JavaScript（ES6）代码规范","slug":"ES6---Airbnb JavaScript（ES6）代码规范","date":"2018-04-11T08:06:52.000Z","updated":"2018-04-11T15:14:50.000Z","comments":true,"path":"2018/04/11/ES6---Airbnb JavaScript（ES6）代码规范/","link":"","permalink":"http://yoursite.com/2018/04/11/ES6---Airbnb JavaScript（ES6）代码规范/","excerpt":"导语 本文摘自—Airbnb JavaScript（ES6）代码规范。","text":"导语 本文摘自—Airbnb JavaScript（ES6）代码规范。 声明变量的新姿势用let不用varES6之前我们使用var声明一个变量，但是它有很多弊病： 无块级作用域变量，很容易声明全局变量。 变量提升。 可重复声明。 12345678910var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10a[7](); // 10a[8](); // 10a[9](); // 10 所以，你有什么理由不用let? 某些场景，const比let更好const和let的唯一区别就是，const不可以被更改，所以当声明变量的时候，尤其是在声明容易被更改的全局变量的时候，尽量使用const。 更好的代码语义化，一眼看到就是常量。 另一个原因是因为JavaScript 编译器对const的优化要比let好，多使用const，有利于提高程序的运行效率。 所有的函数都应该设置为常量。 动态字符串不要使用“双引号”，一律用单引号或反引号。 12345678// lowconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// bestconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 解构赋值的骚操作变量赋值在用到数组成员对变量赋值时，尽量使用解构赋值。 12345678const arr = [1, 2, 3, 4];// lowconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数传对象函数的参数如果是对象的成员，优先使用解构赋值。 123456789// lowfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 1234567891011// lowfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 关于对象的细节逗号单行定义的对象结尾不要逗号： 12345// lowconst a = &#123; k1: v1, k2: v2, &#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;; 多行定义的对象要保留逗号：： 1234567891011// lowconst b = &#123; k1: v1, k2: v2&#125;;// goodconst b = &#123; k1: v1, k2: v2,&#125;; 一次性初始化完全不要声明之后又给对象添加新属性： 1234567// lowconst a = &#123;&#125;;a.x = 3;// goodconst a = &#123; x: null &#125;;a.x = 3; 如果一定非要加请使用Object.assign： 12const a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;); 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义： 12345678910111213/ lowconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,[getKey(&apos;enabled&apos;)]: true,&#125;; 在简洁一点1234567891011121314151617181920212223var ref = &apos;some value&apos;;// lowconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组扩展运算符…使用扩展运算符（…）拷贝数组： 1234567891011// 还在用for i 你就太low了const len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// cool !const itemsCopy = [...items]; Array.form（）用 Array.from 方法，将类似数组的对象转为数组： 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 函数箭头函数=&gt;立即执行函数可以写成箭头函数的形式： 123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 尽量写箭头函数使你的代码看起来简洁优雅： 1234567// low[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// cool ![1, 2, 3].map(x =&gt; x * x); 别再用arguments（类数组）了！使用 rest 运算符（…）代替，rest 运算符可以提供一个真正的数组。 12345678910// lowfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 传参时试试设置默认值123456789// lowfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Object？Map！简单的键值对优先Map如果只是简单的key: value结构，建议优先使用Map，因为Map提供方便的遍历机制。 12345678910111213let map = new Map(arr);// 遍历key值for (let key of map.keys()) &#123; console.log(key);&#125;// 遍历value值for (let value of map.values()) &#123; console.log(value);&#125;// 遍历key和value值for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; class语法123456789101112131415161718192021// lowfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 模块化引入模块使用import取代require，因为Module是Javascript模块的标准写法。 1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 输出模块使用export输出变量，拒绝module.exports: 123456789import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 输出单个值，使用export default。 输出多个值，使用export。 export default与普通的export不要同时使用。 编码规范模块输出一个函数，首字母应该小写： 1234function getData() &#123;&#125;export default getData;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Markdown---入门指南","slug":"markdown-入门指南","date":"2017-10-12T08:06:52.000Z","updated":"2018-04-11T15:14:45.000Z","comments":true,"path":"2017/10/12/markdown-入门指南/","link":"","permalink":"http://yoursite.com/2017/10/12/markdown-入门指南/","excerpt":"导语 Markdown 是一种轻量级的「标记语言」，语法十分简单，常用的标记符号不超过十个。","text":"导语 Markdown 是一种轻量级的「标记语言」，语法十分简单，常用的标记符号不超过十个。 Markdown 语法的简要规则标题在Markdown中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 1234567# 一级标题## 二级标题### 三级标题... 以此类推，总共六级标题，建议在 # 号后加空格。 列表列表分为有序列表和无序列表。在Markdown下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要与文字之间加上一个空格。 123456789#### 无序列表* 1* 2* 3#### 有序列表1. 12. 23. 3 引用如果你需要引用一小段别处的句子，那么就要用引用的格式 例如这样 只需要在文本前加入 &gt; 这种尖括号即可 1&gt; 例如这样 图片与链接插入链接与插入图片的语法很相似，区别在一个 ！号。 12图片为： ![]()链接为： []() 粗体与斜体Markdown 的粗体与斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的写法。 12*我是斜体***我是粗体** 表格语法为： 123| Table | Are | Cool || --- | --- | --- || col 3 is | right | $3000 | 效果为： Table Are Cool col 3 is right $3000 代码框如果你是个程序猿，需要在文章里优雅的引用代码框， 在Markdown下实现也非常简单，只需要用两个`把中间的代码包裹起来即可。 1`&lt;b&gt;Markdown&lt;/b&gt;` 使用 tab 键即可缩进。 分割线分割线的语法只需要三个 * 号。 1***","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}]}