{"meta":{"title":"W | 个人博客 | web前端","subtitle":null,"description":"前端","author":"wangxiaobai","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-04-11T08:28:32.000Z","updated":"2018-04-11T08:28:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-11T08:28:54.000Z","updated":"2018-04-11T08:29:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"小程序-全栈开发(mpvue+koa2+mysql)","slug":"小程序-全栈开发(mpvue+koa2+mysql)","date":"2018-08-12T08:06:52.000Z","updated":"2018-10-08T07:17:22.149Z","comments":true,"path":"2018/08/12/小程序-全栈开发(mpvue+koa2+mysql)/","link":"","permalink":"http://yoursite.com/2018/08/12/小程序-全栈开发(mpvue+koa2+mysql)/","excerpt":"导语 接触小程序并做了一些项目之后，又开始了Vue的旅程，受其核心思想的影响，对数据/状态管理、组件化、跨平台等都有较高的追求，mpvue 是一个使用 Vue.js开发小程序的前端框架，由此开始了mpvue踩坑之旅，想在提高代码可读性的同时，也增加一点Vue.js的开发体验。","text":"导语 接触小程序并做了一些项目之后，又开始了Vue的旅程，受其核心思想的影响，对数据/状态管理、组件化、跨平台等都有较高的追求，mpvue 是一个使用 Vue.js开发小程序的前端框架，由此开始了mpvue踩坑之旅，想在提高代码可读性的同时，也增加一点Vue.js的开发体验。 技术栈 前端： 微信小程序、mpvue、 eslint、sass、ES6、ES7后端：koa2、Koa-Router、Knex、腾讯云Wafer2数据库：Mysql数据库可视化工具：Navicate Premium 小程序介绍一个功能简单的小程序，包含了个人中心、图书列表、个人评论列表三个tab页，后端的数据定义、分类、和存取等，各有其色。 成果分享个人中心： 个人中心： 图书列表： 图书详情： 评论列表： 脑图 初始化项目*全局安装vue-cli $npm install –global vue-cli *创建基于mpvue-quickstart模板的新项目，一路回车。 $vue init mpvue/mpvue-quickstart koa-wx *安装依赖 $cd koa-wx $npm install $npm run dev 项目目录123456789101112131415161718192021222324252627282930313233343536373839404142├── build // 构建相关 ├── config // 配置相关├── dist // 编译后静态文件 ├── node_modules // 依赖相关├── server // 服务端源代码│ ├── controllers │ ├── middlewares │ ├── node_modules │ ├── routes │ ├── tools │ ├── .eslintrc.js │ ├── .eslintrc.json │ ├── app.js │ ├── config.js │ ├── nodemon.json │ ├── package.json │ ├── process.prod.json │ ├── qcloud.js │ ├── README.md │ ├── tools.md ├── src // 前端源代码│ ├── components │ ├── config │ ├── mock │ ├── pages │ ├── styles │ ├── utils │ ├── App.vue │ ├── main.js │ ├── store.js │ ├── weui.css ├── static ├── .babelrc ├── .editorconfig ├── .eslintignore ├── .eslintrc.js ├── .postcssrc.js ├── index.html └── package.json └── package-lock.json └── project.config.json └── README.md 搭建后端本地开发环境打开 server/config.js添加以下配置： 123456789101112const CONF = &#123; // 其他配置 ... serverHost: &apos;localhost&apos;, tunnelServerUrl: &apos;&apos;, tunnelSignatureKey: &apos;27fb7d1c161b7ca52d73cce0f1d833f9f5b5ec89&apos;, // 腾讯云相关配置可以查看云 API 秘钥控制台：https://console.cloud.tencent.com/capi qcloudAppId: &apos;您的腾讯云 AppID&apos;, qcloudSecretId: &apos;您的腾讯云 SecretId&apos;, qcloudSecretKey: &apos;您的腾讯云 SecretKey&apos;, wxMessageToken: &apos;weixinmsgtoken&apos;, networkTimeout: 30000&#125; 并修改 MySQL 相关的配置为本地的 MySQL 数据库。 12345678mysql: &#123; host: &apos;localhost&apos;, port: 3306, user: &apos;root&apos;, db: &apos;cAuth&apos;, pass: &apos;******&apos;, char: &apos;utf8mb4&apos; &#125;, *切换到服务端代码目录$cd server *安装依赖$npm install *安装全局依赖$npm install -g nodemon $npm run dev 初始化数据库 - 打开 terminal 输入如下命令： $node tools/initdb.js 进入Mysql选中刚才创建的数据库，输入 show tables; 可以看到初始化时创建了一个名叫 cSessionInfo 的表。说明本地环境已经搭建成功。 部署到腾讯云环境当本地本地开发出一版时，可以部署到腾讯云的开发环境，这样就可以在线上访问该项目。 首先修改项目根目录的 project.config.json 文件，添加： 1&quot;qcloudRoot&quot;: &quot;./server/&quot;, 然后将本地开发时添加到 server/config.js 的配置删除，在 mysql.pass 那里填上自己的 APPID。 接着进入小程序开发工具，点击右上角的 腾讯云，上传测试代码，弹出如图选项。第一次部署如下选择，之后再次上传选择 智能上传 即可。部署成功会有提示。 ###上传前端代码 在小程序开发工具右上角找到 上传 选项，填写版本信息，上传后进入开发者控制台，开发管理页面，将该小程序设置为体验版本。 然后在用户身份 ==&gt; 成员管理中，添加项目成员，配置权限，这样好友也可以体验该小程序了。 项目地址：https://github.com/wangqian2017/mpvue-koa2","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"Vue-cli配置环境变量[转]","slug":"Vue-cli配置环境变量[转]","date":"2018-07-09T14:19:00.000Z","updated":"2018-07-10T14:34:58.000Z","comments":true,"path":"2018/07/09/Vue-cli配置环境变量[转]/","link":"","permalink":"http://yoursite.com/2018/07/09/Vue-cli配置环境变量[转]/","excerpt":"导语 vue-cli环境下，默认已经配置了一个NODE_ENV的环境变量，有时我们可能觉得光是只有一个开发环境和生产环境还不够，比如我们还想来一个测试坏境，这时候就需要自己定义了。","text":"导语 vue-cli环境下，默认已经配置了一个NODE_ENV的环境变量，有时我们可能觉得光是只有一个开发环境和生产环境还不够，比如我们还想来一个测试坏境，这时候就需要自己定义了。 在实际项目开发中，经常会碰到需要环境变量的情景，在vue-cli的环境下，默认已经配置了一个NODE_ENV的环境变量，当npm run dev的时候这个是development， 当npm run build 的时候这个是production.用过vue-cli开发的通常对这个都不陌生，用这个最多的基本就是我们配置ajax请求的域名头了。 123if (process.env.NODE_ENV === &apos;production&apos;) &#123; axios.defaults.baseURL = &apos;http://customer.medsci.cn&apos;&#125; 通常会有测试服务器和正式服务器环境之分，我们请求的域名也得区分，所以通过proces.env.NODE_ENV来区分环境变量，通过这个能够全局访问的参数，我们可以处理很多需要环境处理不同的操作。 上面的process.env.NODE_ENV是vue-cli默认配置的，有时候我们可能觉得光是只有一个开发环境和生产环境还不够，比如我们还想来一个测试坏境，这时候就需要自己定义了。以下以windows坏境为例，mac环境类似。 首先可以安装cross-env 1npm install cross-env --save-dev vue-cli的配置本质就是webpack的配置，当我们运行npm run dev 的时候，其实执行的是package.json 中的scripts 的dev中 ，即build/dev-server.js 这里面一系列的配置启动整个服务。 我们只想加一个环境变量，可以复制一份，在dev下加一个devtest命令: 1&quot;devtest&quot;: &quot;cross-env TESTING=true node build/dev-server.js&quot; 这样我们就可以通过npm run devtest也能启动整个服务了，注意上面的命令，我们加了一个TESTING=true ，这个就是加入的环境变量，TESTING:true， 通过上面的devtest的配置，我们可以运行npm run devtest像nppm run dev那样运行起来整个程序，不过我们发现，此时在项目中我们获取不到process.env.TESTING这个变量，这是为什么呢，如果是直接用webpack是可以的，经过查看，是在vue-cli的一系列配置文件中，已经写死了这些，不过我们可以改动加上在根目录 config下，有dev.env.js和prod.env.js，这两个文件就是关键了，我们在NODE_ENV下面加一行TESTING:process.env.TESTING。 123456module.exports = &#123; NODE_ENV: &apos;&quot;production&quot;&apos;， TESTING: process.env.TESTING&#125; 这时我们就能全局访问process.env.TESTING变量了，当我们npm run dev的时候，这个是undefined，当npm run devtest的时候是true， 同理我们可以添加一个npm run test命令， 与npm run build命令对应，加入打包测试的环境变量。vue-cli的配置本质还是webpack的配置， 普通的webpack配置也可以采用此方法。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"ES6-ES6的几个小技巧[转]","slug":"ES6-ES6的几个小技巧[转]","date":"2018-07-04T14:52:00.000Z","updated":"2018-07-04T15:39:03.000Z","comments":true,"path":"2018/07/04/ES6-ES6的几个小技巧[转]/","link":"","permalink":"http://yoursite.com/2018/07/04/ES6-ES6的几个小技巧[转]/","excerpt":"导语 EcmaScript 2015 (即 ES6) 已经发布两年多了，它的很多新功能都可以被技巧性的使用。这篇文章把一些小技巧列出来，希望能对你有用。","text":"导语 EcmaScript 2015 (即 ES6) 已经发布两年多了，它的很多新功能都可以被技巧性的使用。这篇文章把一些小技巧列出来，希望能对你有用。 强制参数ES6 提供了默认参数的概念，当函数的参数未传入或者传入值为 undefined 时，会应用参数的默认值。默认值可以是个表达式，所以我们可以将默认值设置为一个执行函数，如果该参数没有传值，就会执行我们的默认函数： 12345const required = () =&gt; &#123;throw new Error(&apos;Missing parameter&apos;)&#125;;//The below function will throw an error if either &quot;a&quot; or &quot;b&quot; is missing.const add = (a = required(), b = required()) =&gt; a + b;add(1, 2) //3add(1) // Error: Missing parameter. 强大的reducereduce 是一个多才多艺的数组方法，请跟随我看一下。 使用 reduce 替代 map + filter设想你有这么个需求：要把数组中的值进行计算后再滤掉一些值，然后输出新数组。很显然我们一般使用 map 和 filter 方法组合来达到这个目的，但这也意味着你需要迭代这个数组两次。来看看我们如何使用 reduce 只迭代数组一次，来完成同样的结果。下面这个例子我们需要把数组中的值乘 2 ，并返回大于 50 的值： 12345678910const numbers = [10, 20, 30, 40];const doubledOver50 = numbers.reduce((finalList, num) =&gt; &#123;num = num * 2; //double each number (i.e. map)//filter number &gt; 50if (num &gt; 50) &#123; finalList.push(num);&#125; return finalList;&#125;, []);doubledOver50; // [60, 80] 使用 reduce 检测括号是否对齐封闭下面这个例子我们用 reduce 来检测一段 string 中的括号是否前后对应封闭。思路是定义一个名为 counter 的变量，它的初始值为 0 ，然后迭代字符串，迭代过程中碰到(就加 1，碰到)就减 1，如果括号前后对应的话，最终couter的值会是 0。 12345678910111213141516171819//Returns 0 if balanced.const isParensBalanced = (str) =&gt; &#123; return str.split(&apos;&apos;).reduce((counter, char) =&gt; &#123; if(counter &lt; 0) &#123; //matched &quot;)&quot; before &quot;(&quot; return counter; &#125; else if(char === &apos;(&apos;) &#123; return ++counter; &#125; else if(char === &apos;)&apos;) &#123; return --counter; &#125; else &#123; //matched some other char return counter; &#125; &#125;, 0); //&lt;-- starting value of the counter&#125;isParensBalanced(&apos;(())&apos;) // 0 &lt;-- balancedisParensBalanced(&apos;(asdfds)&apos;) //0 &lt;-- balancedisParensBalanced(&apos;(()&apos;) // 1 &lt;-- not balancedisParensBalanced(&apos;)(&apos;) // -1 &lt;-- not balanced 使用 reduce 计算数组中的重复项如果你想计算数组中的每个值有多少重复值，reducer 也可以快速帮到你。下面的例子我们计算数组中每个值的重复数量，并输出一个对象来展示： 123456var cars = [&apos;BMW&apos;,&apos;Benz&apos;, &apos;Benz&apos;, &apos;Tesla&apos;, &apos;BMW&apos;, &apos;Toyota&apos;];var carsObj = cars.reduce(function (obj, name) &#123; obj[name] = obj[name] ? ++obj[name] : 1; return obj;&#125;, &#123;&#125;);carsObj; // =&gt; &#123; BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 &#125; 对象解构 移除对象的多余属性有时你可能希望移除一个对象中的某些属性，我们一般会通过迭代这个对象（如 for..in 循环）来移除那些我们不想要的属性。实际上我们可以通过对象解构的方法将不想要的属性提取出来，并将想留下来的变量保存在rest 参数中。在下面的这个例子中，我们从对象中移除_internal和tooBig这两个属性： 12let &#123;_internal, tooBig, ...cleanObject&#125; = &#123;el1: &apos;1&apos;, _internal:&quot;secret&quot;, tooBig:&#123;&#125;, el2: &apos;2&apos;, el3: &apos;3&apos;&#125;;console.log(cleanObject); // &#123;el1: &apos;1&apos;, el2: &apos;2&apos;, el3: &apos;3&apos;&#125; 嵌套对象解构下面的示例中，engine属性是对象car内的嵌套对象。我们可以通过对象解构快速的获取到engine中的属性，比如vin: 123456789101112var car = &#123; model: &apos;bmw 2018&apos;, engine: &#123; v6: true, turbo: true, vin: 12345 &#125;&#125;const modelAndVIN = (&#123;model, engine: &#123;vin&#125;&#125;) =&gt; &#123; console.log(`model: $&#123;model&#125; vin: $&#123;vin&#125;`);&#125;modelAndVIN(car); // =&gt; model: bmw 2018 vin: 12345 合并对象ES6 增加了展开运算符（也就是三个点），展开运算符常常用在处理数组解构上，在对象的解构上它也同样好用。下面的示例中我们合并两个对象，新对象中相同的属性会被放在后面的对象覆盖： 1234let object1 = &#123; a:1, b:2,c:3 &#125;let object2 = &#123; b:30, c:40, d:50&#125;let merged = &#123;...object1, ...object2&#125; //spread and re-add into mergedconsole.log(merged) // &#123;a:1, b:30, c:40, d:50&#125; 使用 Sets 数组去重使用 Sets 可以快速给数组去重，因为 Sets 中的值不可重复。 12let arr = [1, 1, 2, 2, 3, 3];let deduped = [...new Set(arr)] // [1, 2, 3] 数组解构 变换变量的值123456let param1 = 1;let param2 = 2;//swap and assign param1 &amp; param2 each others values[param1, param2] = [param2, param1];console.log(param1) // 2console.log(param2) // 1 从函数接受和分配多个值很多时候你的函数都会将多个数据放在数组内，以返回一个单一值（例如 Promise 函数，它的决议值只能是个单一值），我们可以使用数组解构简便的从返回结果中获取这些值。下面的这个例子中，我们使用 fetch 发送了两个请求，并使用 Promise.all() 将两个结果保存在数组中，函数的执行结果是返回这个数组。 12345678function getFullPost()&#123; return Promise.all([ fetch(&apos;/post&apos;), fetch(&apos;/comments&apos;) ]);&#125;// 在 async 函数中const [post, comments] = await getFullPost();","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Other-摘录前端业界大牛及业界平台","slug":"Other-摘录前端业界大牛及业界平台","date":"2018-07-03T12:52:52.000Z","updated":"2018-07-03T17:54:33.000Z","comments":true,"path":"2018/07/03/Other-摘录前端业界大牛及业界平台/","link":"","permalink":"http://yoursite.com/2018/07/03/Other-摘录前端业界大牛及业界平台/","excerpt":"导语 想要在“每天都有新事物冒出来”的前端世界中跟上步伐，眼下已经成为了一个艰巨的任务。 很多人都有这样的感觉：不需要几个月你的技术就会过时，全新的炒作、类库、框架总会让你迷失，面对这场比赛，你只能选择退出。","text":"导语 想要在“每天都有新事物冒出来”的前端世界中跟上步伐，眼下已经成为了一个艰巨的任务。 很多人都有这样的感觉：不需要几个月你的技术就会过时，全新的炒作、类库、框架总会让你迷失，面对这场比赛，你只能选择退出。 业界大牛不完全名单Addy OsmaniTodoMVC、Material-Design-Lite、Yeoman等项目作者，Google Chrome工程经理主页：https://addyosmani.com/github：https://github.com/addyosmanitwitter：https://twitter.com/addyosmani Lea Verou麻省理工学院HCI研究员， W3C-CSSWG成员，github多个项目作者主页：http://lea.verou.me/github：https://github.com/LeaVeroutwitter：https://twitter.com/leaverou Evan You 尤雨溪大名鼎鼎的Vue.js作者，前端布道者，业界大V主页：http://evanyou.me/github：https://github.com/yyx990803twitter：https://twitter.com/youyuxi Axel Rauschmayer2ality博主，写有《Speaking JavaScript》等著作，ES.next News刊物主编主页：http://2ality.com/github：twitter：https://twitter.com/rauschma Ben AlmanGruntJS作者，jQuery界大神，开发了jQuery BBQ等大量插件主页：http://benalman.com/github：https://github.com/cowboytwitter：https://twitter.com/cowboy Nicholas C. Zakas著名的《JavaScript高级程序设计》作者，JS布道者主页：https://www.nczonline.net/github：twitter：https://twitter.com/slicknet 好的资讯平台EchoJS地址：www.echojs.com/ DailyJS地址：medium.com/dailyjs/ Front-End Front地址：frontendfront.com/ ES.next News地址：esnextnews.com/ Web Design Weekly地址：web-design-weekly.com/","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/categories/杂谈/"}],"tags":[{"name":"Other","slug":"Other","permalink":"http://yoursite.com/tags/Other/"}]},{"title":"Vue-从头到尾撸官方文档系列(Vue基础篇)","slug":"Vue-从头到尾撸官方文档系列(基础篇)","date":"2018-06-20T14:52:00.000Z","updated":"2018-07-04T15:36:02.000Z","comments":true,"path":"2018/06/20/Vue-从头到尾撸官方文档系列(基础篇)/","link":"","permalink":"http://yoursite.com/2018/06/20/Vue-从头到尾撸官方文档系列(基础篇)/","excerpt":"导语 从2017年3月份开始接触到Vue，至今前前后后已经使用了1年多，一直希望有机会能从头开始认真地撸一遍官方文档，现在终于有充足的时间了。","text":"导语 从2017年3月份开始接触到Vue，至今前前后后已经使用了1年多，一直希望有机会能从头开始认真地撸一遍官方文档，现在终于有充足的时间了。 Vue实例创建一个Vue实例每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： 123var vm = new Vue(&#123; // 选项&#125;) 当创建一个 Vue 实例时，你可以传入一个选项对象。一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成。所有Vue组件都是Vue实例，并接受相同的选项对象，一些跟实例特有的选项除外。 数据与方法当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 12345678910111213141516171819// 我们的数据对象var data = &#123; a: 1 &#125;// 该对象被加入到一个 Vue 实例中var vm = new Vue(&#123; data: data&#125;)// 获得这个实例上的属性// 返回源数据中对应的字段vm.a == data.a // =&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // =&gt; 2// ……反之亦然data.a = 3vm.a // =&gt; 3 值得注意的是只有当实例被创建时data中存在的属性才是响应式的。 如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你仅需要设置一些初始值，如： 1234567data: &#123; newTodoText: &apos;&apos;, visitCount: 0, hideCompletedTodos: false, todos: [], error: null&#125; 还有一个例外是使用Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。 12345678910var obj = &#123; foo: &apos;bar&apos;&#125;Object.freeze(obj)new Vue(&#123; el: &apos;#app&apos;, data: obj&#125;) 12345&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;!-- 这里的 `foo` 不会更新！ --&gt; &lt;button v-on:click=&quot;foo = &apos;baz&apos;&quot;&gt;Change it&lt;/button&gt;&lt;/div&gt; 实例生命周期钩子每个Vue实例在被创建时都要经过一系列的初始化过程。在实例生命周期的不同阶段，可以调用一些钩子，如 mounted、updated 和 destroyed。 注：不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。 生命周期图示 模板语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。 插值文本数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。 原始HTML双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令： 12&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p &gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p &gt; 12Using mustaches: &lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;Using v-html directive: This should be red. 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。 特性Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令： 1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 使用JavaScript表达式对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt; 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date。你不应该在模板表达式中试图访问用户定义的全局变量。 指令指令特性的值预期是单个 JavaScript 表达式（除v-for），当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 1&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt; 这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 元素。 参数一些指令能够接收一个“参数”，在指令名称之后以冒号表示。v-bind 指令可以用于响应式地更新 HTML 特性： 1&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt; 另一个例子是 v-on 指令，它用于监听 DOM 事件： 1&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt; 修饰符修饰符 (Modifiers) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; 缩写Vue.js 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写： v-bind 缩写12345&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt; v-on缩写12345&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt; 计算属性和侦听器计算属性对于任何复杂逻辑，你都应当使用计算属性。 基础例子1234&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 12345结果：Original message: &quot;Hello&quot;Computed reversed message: &quot;olleH&quot; vm.reversedMessage 的值始终取决于 vm.message 的值。 计算属性缓存 vs 方法在表达式中调用方法可达到同样的效果： 1&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt; 123456// 在组件中methods: &#123; reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; 然而，最重要的是： 计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 计算属性 vs 侦听属性当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch。 然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。 1&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; 12345678910111213141516var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125;) 123456789101112var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos; &#125;, computed: &#123; fullName: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125; &#125;&#125;) 计算属性的setter计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ： 12345678910111213141516/ ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 侦听器 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 Class 与 Style 绑定操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。表达式结果的类型除了字符串之外，还可以是对象或数组。 绑定HTML Class对象语法我们可以传给 v-bind:class 一个对象，以动态地切换 class： 123&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt; 绑定的数据对象不必内联定义在模板里： 1&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; 123456data: &#123; classObject: &#123; active: true, &apos;text-danger&apos;: false &#125;&#125; 我们也可以在这里绑定一个返回对象的计算属性。这是一个常用且强大的模式： 1&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; 123456789101112data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos; &#125; &#125;&#125; 数组语法我们可以把一个数组传给 v-bind:class，以应用一个 class 列表： 1&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt; 1234data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; 如果你也想根据条件切换列表中的 class，可以用三元表达式： 1&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt; 当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法： 1&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt; 用在组件上当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。 1&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt; 对于带数据绑定 class 也同样适用： 1&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt; 绑定内联样式对象语法v-bind:style。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： 1&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt; 1234data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125; 直接绑定到一个样式对象通常更好，这会让模板更清晰： 1&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125; 同样的，对象语法常常结合返回对象的计算属性使用。 数组语法v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 自动添加前缀当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 多重值Vue.js 可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如： 1&lt;div :style=&quot;&#123; display: [&apos;-webkit-box&apos;, &apos;-ms-flexbox&apos;, &apos;flex&apos;] &#125;&quot;&gt;&lt;/div&gt; 条件渲染v-if在 Vue 中，我们使用 v-if 指令实现根据条件是否展示元素的功能： 1&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt; 也可以用 v-else 添加一个“else 块”： 12&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; 使用 &amp;&amp; v-if 条件渲染分组如果想切换多个元素，此时可以把一个 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 元素。 12345&lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p &gt; &lt;p&gt;Paragraph 2&lt;/p &gt;&lt;/template&gt; v-else使用 v-else 指令来表示 v-if 的“else 块”： 123456&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don&apos;t&lt;/div&gt; v-else-ifv-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 用 key 管理可复用的元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。 12345678&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot;&gt;&lt;/template&gt; 那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素， 不会被替换掉——仅仅是替换了它的 placeholder。 所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可： 12345678&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt; v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： 1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 v-if vs v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-if 与 v-for 一起使用当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-从头到尾撸官方文档系列(介绍篇)","slug":"Vue-从头到尾撸官方文档系列(介绍篇)","date":"2018-06-20T12:52:52.000Z","updated":"2018-06-28T16:13:53.000Z","comments":true,"path":"2018/06/20/Vue-从头到尾撸官方文档系列(介绍篇)/","link":"","permalink":"http://yoursite.com/2018/06/20/Vue-从头到尾撸官方文档系列(介绍篇)/","excerpt":"导语 从2017年3月份开始接触到Vue，至今前前后后已经使用了1年多，一直希望有机会能从头开始认真地撸一遍官方文档，现在终于有充足的时间了。","text":"导语 从2017年3月份开始接触到Vue，至今前前后后已经使用了1年多，一直希望有机会能从头开始认真地撸一遍官方文档，现在终于有充足的时间了。 介绍vue.js是什么Vue是一套用于构建用户界面的渐进式框架，其被设计为可以自底向上逐层应用。Vue的核心库只关心视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。——官网摘录~~~ 声明式渲染Vue.js的核心是一个允许采用简洁的模板语法来声明式将数据渲染进DOM的系统： 123&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Hello Vue!&apos; &#125;&#125;) 1Hello Vue! 除了文本插值，我们还可以像这样来绑定元素特性： 12345&lt;div id=&quot;app-2&quot;&gt; &lt;span v-bind:title=&quot;message&quot;&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: &apos;#app-2&apos;, data: &#123; message: &apos;页面加载于 &apos; + new Date().toLocaleString() &#125;&#125;) 1鼠标悬停几秒钟查看此处动态绑定的提示信息！ 条件与循环控制切换一个元素是否显示也相当简单： 123&lt;div id=&quot;app-3&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: &apos;#app-3&apos;, data: &#123; seen: true &#125;&#125;) 1现在你看到我了 还有其它很多指令，每个都有特殊的功能。例如，v-for 指令可以绑定数组的数据来渲染一个项目列表： 1234567&lt;div id=&quot;app-4&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: &apos;#app-4&apos;, data: &#123; todos: [ &#123; text: &apos;学习 JavaScript&apos; &#125;, &#123; text: &apos;学习 Vue&apos; &#125;, &#123; text: &apos;整个牛项目&apos; &#125; ] &#125;&#125;) 1231.学习 JavaScript2.学习Vue3.整个牛项目 处理用户输入为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法： 1234&lt;div id=&quot;app-5&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: &apos;#app-5&apos;, data: &#123; message: &apos;Hello Vue.js!&apos; &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。 1234&lt;div id=&quot;app-6&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: &apos;#app-6&apos;, data: &#123; message: &apos;Hello Vue!&apos; &#125;&#125;) 组件化应用构建组件系统是 Vue 的另一个重要概念，允许我们使用小型、独立和通常可复用的组件构建大型应用。几乎任意类型的应用界面都可以抽象为一个组件树： 在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单： 1234// 定义名为 todo-item 的新组件Vue.component(&apos;todo-item&apos;, &#123; template: &apos;&lt;li&gt;这是个待办项&lt;/li&gt;&apos;&#125;) 但是这样会为每个待办项渲染同样的文本，我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 prop： 1234567Vue.component(&apos;todo-item&apos;, &#123; // todo-item 组件现在接受一个 // &quot;prop&quot;，类似于一个自定义特性。 // 这个 prop 名为 todo。 props: [&apos;todo&apos;], template: &apos;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&apos;&#125;) 现在，我们可以使用 v-bind 指令将待办项传到循环输出的每个组件中： 123456789101112131415&lt;div id=&quot;app-7&quot;&gt; &lt;ol&gt; &lt;!-- 现在我们为每个 todo-item 提供 todo 对象 todo 对象是变量，即其内容可以是动态的。 我们也需要为每个组件提供一个“key”，稍后再 作详细解释。 --&gt; &lt;todo-item v-for=&quot;item in groceryList&quot; v-bind:todo=&quot;item&quot; v-bind:key=&quot;item.id&quot;&gt; &lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; 123456789101112131415Vue.component(&apos;todo-item&apos;, &#123; props: [&apos;todo&apos;], template: &apos;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&apos;&#125;)var app7 = new Vue(&#123; el: &apos;#app-7&apos;, data: &#123; groceryList: [ &#123; id: 0, text: &apos;蔬菜&apos; &#125;, &#123; id: 1, text: &apos;奶酪&apos; &#125;, &#123; id: 2, text: &apos;随便其它什么人吃的东西&apos; &#125; ] &#125;&#125;) 1231.蔬菜2.奶酪3.随便其它什么人吃的东西 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-Chrome插件开发实录[转]","slug":"Vue-Chrome 插件开发实录[转]","date":"2018-05-20T13:06:52.000Z","updated":"2018-06-25T17:05:41.000Z","comments":true,"path":"2018/05/20/Vue-Chrome 插件开发实录[转]/","link":"","permalink":"http://yoursite.com/2018/05/20/Vue-Chrome 插件开发实录[转]/","excerpt":"导语 开发一个Chrome插件就跟我们平时做web开发流程没多大的区别，就是先搭好基本的页面，然后使用js来写交互逻辑等功能。","text":"导语 开发一个Chrome插件就跟我们平时做web开发流程没多大的区别，就是先搭好基本的页面，然后使用js来写交互逻辑等功能。 Chrome插件开发基本知识在应用商店中下载下来的插件基本上都是以.crx为文件后缀，该文件其实就是一个压缩包，包括插件所需要的html、css、javascript、图片资源等等文件。 开发一个插件就跟我们平时做web开发流程没多大的区别，就是先搭好基本的页面，然后使用js来写交互逻辑等功能。 比如我这个插件的目录文件如下： manifest.json文件文件中需要注意一下的mainfest.json这个文件，这个json文件的作用是提供插件的各种信息，例如插件能够做的事情，以及插件的文件配置等等信息。下面是一个清单文件的示例： 12345678910111213&#123; &quot;manifest_version&quot;: 2, &quot;name&quot;: &quot;One-click Kittens&quot;, &quot;description&quot;: &quot;This extension demonstrates a browser action with kittens.&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;permissions&quot;: [ &quot;https://secure.flickr.com/&quot; ], &quot;browser_action&quot;: &#123; &quot;default_icon&quot;: &quot;icon.png&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; &#125;&#125; 第一行声明我们使用清单文件格式的版本 2，必须包含（版本 1 是旧的，已弃用，不建议使用）。 接下来的部分定义扩展程序的名称、描述与版本。这些都会在 Chrome 浏览器中使用，向用户显示已安装的扩展程序，同时在 Chrome 网上应用店中向潜在的新用户显示您的扩展程序。名称应该简练，描述不要比一句话左右还长（后面将会有更多的空间用于更详细的描述）。 最后一部分首先请求权限，用于访问 https://secure.flickr.com/ 上的数据，并声明该扩展程序实现了一个浏览器按钮，同时在这一过程中为它指定一个默认图标与弹出窗口。 定义浏览器按钮时指向了两个资源文件：icon.png 与 popup.html。这两个资源都必须在扩展程序包中存在，图片是扩展的显示，html是扩展具体运行的基础文件。 具体详细的开发教程可以看看官方的这个文档，非常简明的入门教程。 功能实现-Vuejs实践整个插件的核心交互功能非常简单，如文章开头的动图所示，用户选择对齐方式，代码区域显示对应的代码。这种简单数据交互使用vuejs再适合不过了，vuejs基础知识这里就不再细说了。 这里需要注意的一点是，chrome 扩展的运行环境有一些特殊要求，称为 Content Security Policy (CSP)，使得通常的 vue 不能被正常使用。如果用的是 vue 1.x，那么可以下载 csp 版本，在 这里。如果是 2.x 版本，请参考官网文档的这一段。 核心代码如下所示。 HTML： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- 引入样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;mystique.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 class=&quot;title-box&quot;&gt;flexbox对齐就是这么简单&lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;type-select&quot;&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;!-- &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt; --&gt; &lt;div class=&quot;resule-preview&quot;&gt; &lt;div v-bind:class=&quot;selected&quot; class=&quot;cols&quot;&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;resule-code&quot;&gt; &lt;pre class=&quot;code-display&quot;&gt; &lt;code class=&quot;code-lang&quot;&gt; &#123;&#123; cssMsg &#125;&#125; &lt;/code&gt; &lt;/pre&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 先引入 Vue --&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 引入样式 --&gt; CSS就不列出来了，可以在源代码中查看。 下面来使用vuejs来实现插件的功能。 功能实现使用 v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。 而下拉框（select）列表的渲染，就可以使用vue中的v-for方法来渲染下拉列表选项，下拉选项数据写在js中的data对象中的options中。用v-bind方法来绑定option的value值，代码如下所示： XHTML 12345&lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt; 在vuejs中可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。这里在select中使用v-model方法来监听选中的值。 为了能预览不同对齐的效果，先在CSS中写好和下拉框中值相同的对应的类名样式，这样当用户选中不同的值的时候能显示不同的效果。这里我们使用v-bind方法来实现这个功能，它主要用于属性绑定，我们可以给v-bind:class一个对象，以动态地切换class。 1234567891011&lt;div v-bind:class=&quot;selected&quot; class=&quot;cols&quot;&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col col-3&quot;&gt; &lt;p&gt;对齐&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 下拉框这块功能就这样，简简单单几行代码就实现了。想想要是用jquery或者是原生的js来实现同样的功能，不仅代码量要大而且写起来也没有vuejs这么舒服。 接下来是代码同步功能，即在代码区域显示对应flex对齐的CSS代码。 开始之前先讲讲vuejs中的computed属性方法，可计算属性 (computed properties) 就是不存在于原始数据中，而是在运行时实时计算出来的属性。 对应到我们这个实例，就是当用户选择flexbox不同的对齐方式的时候，及时同步对应的CSS代码到代码预览区域。简单起见，直接把几个不同的代码写到js中： 12345678910111213data: &#123; selected: &apos;cols-center&apos;, cssText: &#123; &apos;cols-center&apos; : &apos;nr-webkit-justify-content: center;nr-ms-flex-pack: center;nrjustify-content: center;&apos;, &apos;cols-space-between&apos; : &apos;nr-webkit-justify-content: space-between;nr-ms-flex-pack: justify;nrjustify-content: space-between;&apos;, &apos;cols-space-around&apos; : &apos;nr-webkit-justify-content: space-around;nr-ms-flex-pack: distribute;nrjustify-content: space-around;&apos; &#125;, options: [ &#123; text: &apos;居中对齐&apos;, value: &apos;cols-center&apos;&#125;, &#123; text: &apos;两端对齐&apos;, value: &apos;cols-space-between&apos;&#125;, &#123; text: &apos;间隔相等&apos;, value: &apos;cols-space-around&apos;&#125; ] &#125; 根据不同的名字对应不同的CSS代码。然后使用computed方法来根据用户选取的值实时取出对应的CSS代码： 123456computed:&#123; cssMsg:function()&#123; console.log(this) return this.cssText[this.selected]; &#125;&#125; 完整代码如下： 12345678910111213141516171819202122var typeSelect = new Vue(&#123; el: &apos;body&apos;, data: &#123; selected: &apos;cols-center&apos;, cssText:&#123; &apos;cols-center&apos; : &apos;nr-webkit-justify-content: center;nr-ms-flex-pack: center;nrjustify-content: center;&apos;, &apos;cols-space-between&apos; : &apos;nr-webkit-justify-content: space-between;nr-ms-flex-pack: justify;nrjustify-content: space-between;&apos;, &apos;cols-space-around&apos; : &apos;nr-webkit-justify-content: space-around;nr-ms-flex-pack: distribute;nrjustify-content: space-around;&apos; &#125;, options: [ &#123; text: &apos;居中对齐&apos;, value: &apos;cols-center&apos;&#125;, &#123; text: &apos;两端对齐&apos;, value: &apos;cols-space-between&apos;&#125;, &#123; text: &apos;间隔相等&apos;, value: &apos;cols-space-around&apos;&#125; ] &#125;, computed:&#123; cssMsg:function()&#123; console.log(this) return this.cssText[this.selected]; &#125; &#125;&#125;) 最后在html中绑定通过computed方法得到数据也就是CSS： 1234567&lt;div class=&quot;resule-code&quot;&gt; &lt;pre class=&quot;code-display&quot;&gt; &lt;code class=&quot;code-lang&quot;&gt; &#123;&#123; cssMsg &#125;&#125; &lt;/code&gt; &lt;/pre&gt;&lt;/div&gt; 插件代码下载（https://share.weiyun.com/d51b9e473e12f8c43e7eaafc9e2f11a7） 开发好之后，可以直接在chrome中运行来调试。打开扩展面板，勾选开发者模式，然后加载刚开发扩展所在的目录就可以直接运行了。 一个简单的插件就完成了，通过这一个简单的chrome插件就可以体验到vuejs在web开发中简单、优雅的魅力，还有什么理由不用起来呢。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"精心收集的48个JavaScript代码片段","slug":"JS-精心收集的48个JavaScript代码片段","date":"2018-04-14T13:06:52.000Z","updated":"2018-06-25T15:30:17.000Z","comments":true,"path":"2018/04/14/JS-精心收集的48个JavaScript代码片段/","link":"","permalink":"http://yoursite.com/2018/04/14/JS-精心收集的48个JavaScript代码片段/","excerpt":"导语 该文章摘自Github用户Chalarangelo，目前已在Github上获得了5K多个star，精心收集了多达48个有用的JavaScript代码片段。","text":"导语 该文章摘自Github用户Chalarangelo，目前已在Github上获得了5K多个star，精心收集了多达48个有用的JavaScript代码片段。 Anagrams of string(带有重复项)使用递归，对于给定字符串中的每个字母，为字母创建字谜。使用map()将字母与每部分字谜结合，然后使用reduce()将所有字谜组合到一个数据中，最基本情况是字符串长度等于2或1。 123456const anagrams = str =&gt; &#123; if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str]; return str.split(&apos;&apos;).reduce((acc, letter, i) =&gt; &#123; acc.concat(anagrams(str.slice(0, 1) + str.slice(i + 1)).map(val =&gt; letter + val))&#125;, []);&#125;;// anagrams(&apos;abc&apos;) -&gt; [&apos;abc&apos;,&apos;acb&apos;,&apos;bac&apos;,&apos;bca&apos;,&apos;cab&apos;,&apos;cba&apos;] 数组平均值使用reduce()将每个值添加到累加器，初始值为0，总和除以数组长度。 12const average = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;// avarage([1, 2, 3]) -&gt; 2 大写每个单词的首字母使用replace()匹配每个单词的第一个字符，并使用toUpperCase()来将其大写。 12const capitalizeEveryWord = str =&gt; str.replace(/\\b[a-z]/g, char =&gt; char.toUpperCase());// capitalizeEveryWord(&apos;hello world!&apos;) -&gt; &apos;Hello World!&apos; 首字母大写使用slice (0,1)和toUpperCase ()大写第一个字母，slice (1)获取字符串的其余部分。省略lowerRest参数以保持字符串的其余部分不变，或将其设置为true以转换为小写。(注：这和上一示例不是同一件事情) 1234const capitalize = (str, lowerRest = false) =&gt; &#123; str.slice(0, 1).toUpperCase() + (lowerRest ? str.slice(1).toLowerCase() : str.slice(1));&#125;// capitalize(&apos;myName&apos;, true) -&gt; &apos;Myname&apos; 检查回文将字符串转换为toLowerCase ()，并使用replace ()从中删除非字母的字符串。然后，将其转换为toLowerCase ()，将(‘’)拆分为单独字符，reverse ()，join (‘’)，与原始的非反转字符串进行比较，然后将其转换为toLowerCase ()。 12345const palindrome = str =&gt; &#123; const s = str.toLowerCase().replace(/[\\W_]/g, &apos;&apos;); return s === s.split(&apos;&apos;).reverse().join(&apos;&apos;);&#125;// palindrome(&apos;taco cat&apos;) -&gt; true 计算数组中值的出现次数每次遇到数组中的特别值时，使用reduce()来递增计数器。 12const countOccurrences = (arr, value) =&gt; arr.reduce((a, v) =&gt; v === value ? a + 1:a + 0, 0);// countOccurrences([1, 1, 2, 1, 2, 3], 1) -&gt; 3 当前URL使用windows.location.href来获取当前URL。 12const currentUrl = () =&gt; return window.location.href;// currentUrl() -&gt; &apos;https://google.com&apos; Curry使用递归。如果提供的参数(args)数量足够，则调用传递函数f，否则返回一个curried函数f。 12345const curry = (fn, arity = fn.length, ...args) =&gt; &#123; arity &lt;= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);&#125;// curry(Math.pow)(2)(10) -&gt; 1024// curry(Math.min, 3)(10)(50)(2) -&gt; 2 Deep flatten array使用递归，使用reduce()来获取所有不是数组的元素，flatten每个元素都是数组。 1234const deepFlatten = arr =&gt; &#123; arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? deepFlatten(v) : v), []);&#125;// deepFlatten([1, [2], [[3], 4], 5]) -&gt; [1, 2, 3, 4, 5] 数组之间的区别从b创建一个Set，然后在a上使用Array.filter()，只保留b中不包含的值。 12345const difference = (a, b) =&gt; &#123; const s = new Set(b); return a.filter(x =&gt; !s.has(x))&#125;// difference([1, 2, 3], [1, 2]) -&gt; [3] 两点之间的距离使用Math.hypot()计算两点之间的欧几里德距离。 12const distance = (x0, y0, x1, y1) =&gt; Math.hypot(x1 - x0, y1 - y0);// distance(1,1, 2,3) -&gt; 2.23606797749979 可以按数字整除使用模运算符(%)来检查余数是否等于0。 12const isDivisible = (dividend, divisor) =&gt; dividend % divisor === 0;// isDivisible(6, 3) -&gt; true 转义正则表达式使用replace()来转义特殊字符。 12const escapeRegExp = str =&gt; str.replace(/[.*+?^$&#123;&#125;()|[\\]\\\\]/g, &apos;\\\\$&amp;&apos;);// escapeRegExp(&apos;(test)&apos;) -&gt; \\\\(test\\\\) 偶数或奇数使用Math.abs()将逻辑扩展为负数，使用模(%)运算符进行检查。如果数字是偶数，则返回true；如果数字是奇数，则返回false。 12const isEven = num =&gt; Math.abs(num) % 2 === 0;// isEven(3) -&gt; false 阶乘使用递归。如果n小于或等于1，则返回1。否则返回n和n-1的阶乘的乘积。 12const factorial = n =&gt; n &lt;=1 ? 1 : n * factorial(n - 1);// factorial(6) -&gt; 720 斐波那契数组生成器创建一个特定长度的空数组，初始化前两个值(0和1)。使用Array.reduce()向数组中添加值，后面的一个数等于前面两个数相加之和(前两个除外)。 123const fibonacci = n =&gt; Array(n).fill(0).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []);// fibonacci(5) -&gt; [0,1,1,2,3] 过滤数组中的非唯一值将Array.filter() 用于仅包含唯一值得数组。 12const filterNonUnique = arr =&gt; arr.filter(i =&gt; arr.indexOf(i) === arr.lastIndexOf(i));// filterNonUnique([1, 2, 3, 2, 4, 4, 5]) -&gt; [1, 3, 5] Flatten数组使用reduce()来获取数组中的所有元素，并使用concat()来使它们flatten。 12const flatten = arr =&gt; arr.reduce((a, v) =&gt; a.concat(v), []);// flatten([1,[2],3,4]) -&gt; [1,2,3,4] 从数组中获取最大值用Math.max()与spread运算符(…)结合得到数组中的最大值。 12const arrayMax = arr =&gt; Math.max(...arr);// arrayMax([10, 1, 5]) -&gt; 10 从数组中获取最小值使用Math.min()与spread运算符(…)结合得到数组中的最小值。 12const arrayMin = arr =&gt; Math.min(...arr);// arrayMin([10, 1, 5]) -&gt; 1 获取滚动位置如果已定义，请使用pageXOffset和pageYOffset，否则使用scrollLeft和scrollTop，可以省略el来使用window的默认值。 1234const getScrollPos = (el = window) =&gt; (&#123;x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft, y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop&#125;);// getScrollPos() -&gt; &#123;x: 0, y: 200&#125; 最大公约数(GCD)使用递归。基本情况是当y等于0时。在这种情况下，返回x。否则，返回y的GCD和x / y的其余部分。 12const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y);// gcd (8, 36) -&gt; 4 Head of list返回ARR[0] 12const head = arr =&gt; arr[0];// head([1,2,3]) -&gt; 1 list初始化返回arr.slice(0，-1) 12const initial = arr =&gt; arr.slice(0, -1);// initial([1,2,3]) -&gt; [1,2] 用range初始化数组使用Array(end-start)创建所需长度的数组，使用map()来填充范围内的所需值 123const initializeArrayRange = (end, start = 0) =&gt; Array.apply(null, Array(end - start)).map((v, i) =&gt; i + start);// initializeArrayRange(5) -&gt; [0,1,2,3,4] 用值初始化数组使用Array(n)创建所需长度的数组，fill(v)以填充所需的值，可以忽略value使用默认值0。 12const initializeArray = (n, value = 0) =&gt; Array(n).fill(value);// initializeArray(5, 2) -&gt; [2,2,2,2,2] 列表的最后返回arr.slice(-1)[0] 12const last = arr =&gt; arr.slice(-1)[0];// last([1,2,3]) -&gt; 3 测试功能所花费的时间使用performance.now()获取函数的开始和结束时间，console.log()所花费的时间。第一个参数是函数名，随后的参数传递给函数。 12345678const timeTaken = callback =&gt; &#123; console.time(&apos;timeTaken&apos;); const r = callback(); console.timeEnd(&apos;timeTaken&apos;); return r;&#125;;// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024// (logged): timeTaken: 0.02099609375ms 来自键值对的对象使用Array.reduce()来创建和组合键值对。 12const objectFromPairs = arr.reduce((a, v) =&gt; (a[v[0]] =v[1], a), &#123;&#125;);// objectFromPairs([[&apos;a&apos;,1],[&apos;b&apos;,2]]) -&gt; &#123;a: 1, b: 2&#125; 管道使用Array.reduce()通过函数传递值。 12const pipe = (...funcs) =&gt; arg =&gt; funcs.reduce((acc, func) =&gt; func(acc), arg);// pipe(btoa, x =&gt; x.toUpperCase())(&quot;Test&quot;) -&gt; &quot;VGVZDA==&quot; Powerset使用reduce()与map()结合来遍历元素，并将其组合成包含所有组合的数组。 12const powerset = arr =&gt; arr.reduce((a, v) =&gt; a.concat(a.map(r =&gt; [v].concat(r))), [[]]);// powerset([1,2]) -&gt; [[], [1], [2], [2,1]] 范围内的随机整数使用Math.random()生成一个随机数并将其映射到所需的范围，使用Math.floor()使其成为一个整数。 12const randomIntegerInRange = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min;// randomIntegerInRange(0, 5) -&gt; 2 范围内的随机数使用Math.random()生成一个随机值，使用乘法将其映射到所需的范围。 12const randomInRange = (min, max) =&gt; Math.random() * (max - min) + min;// randomInRange(2,10) -&gt; 6.0211363285087005 随机化数组的顺序使用sort()重新排序元素，使用Math.random()来随机排序。 12const shuffle = arr =&gt; arr.sort(() =&gt; Math.random() - 0.5);// shuffle([1,2,3]) -&gt; [2,3,1] 重定向到URL使用window.location.href或window.location.replace()重定向到url。传递第二个参数来模拟链接点击(true-default)或HTTP重定向(false)。 12const redirect = (url, asLink = true) =&gt; asLink ? window.location.href = url : window.location.replace(url);// redirect(&apos;https://google.com&apos;) 反转一个字符串使用数组解构和Array.reverse()来颠倒字符串中的字符顺序。合并字符以使用join(‘’)获取字符串。 12const reverseString = str =&gt; [...str].reverse().join(&apos;&apos;);// reverseString(&apos;foobar&apos;) -&gt; &apos;raboof&apos; RGB到十六进制使用按位左移运算符(&lt;&lt;)和toString(16)，然后padStart(6，“0”)将给定的RGB参数转换为十六进制字符串以获得6位十六进制值。 12const rgbToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, &apos;0&apos;);// rgbToHex(255, 165, 1) -&gt; &apos;ffa501&apos; 滚动到顶部使用document.documentElement.scrollTop或document.body.scrollTop获取到顶部的距离。从顶部滚动一小部分距离。 使用window.requestAnimationFrame()来滚动。 12345678const scrollToTop = _ =&gt; &#123;const c = document.documentElement.scrollTop || document.body.scrollTop; if (c &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, c - c / 8); &#125;&#125;;// scrollToTop() 随机数组值使用Array.map()和Math.random()创建一个随机值的数组。使用Array.sort()根据随机值对原始数组的元素进行排序。 12345const shuffle = arr =&gt; &#123;let r = arr.map(Math.random);return arr.sort((a,b) =&gt; r[a] - r[b]);&#125;// shuffle([1, 2, 3]) -&gt; [2, 1, 3] 数组之间的相似性使用filter()移除不是values的一部分值，使用includes()确定。 12const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v));// similarity([1,2,3], [1,2,4]) -&gt; [1,2] 按字符串排序(按字母顺序排序)使用split(‘’)分割字符串，sort()使用localeCompare()，使用join(‘’)重新组合。 12const sortCharactersInString = str =&gt; str.split(&apos;&apos;).sort((a, b) =&gt; a.localeCompare(b)).join(&apos;&apos;);// sortCharactersInString(&apos;cabbage&apos;) -&gt; &apos;aabbceg&apos; 数组总和使用reduce()将每个值添加到累加器，初始化值为0。 12const sum = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0);// sum([1,2,3,4]) -&gt; 10 交换两个变量的值使用数组解构来交换两个变量之间的值。 12[varA, varB] = [varB, varA]// [x, y] = [y, x] 列表的tail返回arr.slice(1)。 123const tail = arr =&gt; arr.length &gt; 1 ? arr.slice(1) : arr;// tail([1,2,3]) -&gt; [2,3]// tail([1]) -&gt; [1] 数组唯一值使用ES6 Set和…rest操作符去掉所有重复值。 12const unique = arr =&gt; [...new Set(arr)];// unique([1, 2, 2, 3, 4, 4, 5]) -&gt; [1, 2, 3, 4, 5] URL参数使用match()与适当的正则表达式来获得所有键值对，适当的map()。使用Object.assign()和spread运算符(…)将所有键值对组合到一个对象中，将location.search()作为参数传递给当前url。 12const getUrlParameters = url =&gt; url.match(/([^?=&amp;]+)(=([^&amp;]*))/g).reduce((a, v) =&gt; (a[v.slice(0, v.indexOf(&apos;=&apos;))] = v.slice(v.indexOf(&apos;=&apos;) + 1), a), &#123;&#125;);// getUrlParameters(&apos;http://url.com/page?name=Adam&amp;surname=Smith&apos;) -&gt; &#123;name: &apos;Adam&apos;, surname: &apos;Smith&apos;&#125; UUID生成器使用crypto API生成符合RFC4122版本4的UUID。 12const uuid = _ =&gt; ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt; (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16));// uuid() -&gt; &apos;7982fcfe-5721-4632-bede-6000885be57d&apos; 验证数字使用！isNaN和parseFloat（）来检查参数是否是一个数字，使用isFinite（）来检查数字是否是有限的。 12const validateNumber = n =&gt; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n) &amp;&amp; Number(n) == n;// validateNumber(&apos;10&apos;) -&gt; true","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"手摸手，带你用Vue构建公路收费云 一（基础篇）","slug":"手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）","date":"2018-04-12T12:06:52.000Z","updated":"2018-06-15T12:20:54.000Z","comments":true,"path":"2018/04/12/手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）/","link":"","permalink":"http://yoursite.com/2018/04/12/手摸手，带你用Vue构建公路收费云平台 系列一（基础篇）/","excerpt":"导语 说好的总结终于来了，本篇文章主要来说说在开始写实际业务代码之前的一些准备工作，这里不会教你Webpack的基础配置，热更新原理等，有需求的请自行 Google。","text":"导语 说好的总结终于来了，本篇文章主要来说说在开始写实际业务代码之前的一些准备工作，这里不会教你Webpack的基础配置，热更新原理等，有需求的请自行 Google。 完整项目地址：公路收费云平台 系类文章一：手摸手，带你用Vue构建公路收费云平台 系列一（基础篇） 系类文章二：手摸手，带你用Vue构建公路收费云平台 系列二（登录权限篇） 系类文章三：手摸手，带你用Vue构建公路收费云平台 系列三（实战篇） 系类文章四：手摸手，带你用Vue构建公路收费云平台 系列四（挖坑填坑篇） 前端技术选型在三大框架中选择了VUE，因为自己对这个框架更为熟悉，同时，VUE在国内的生态环境已经相当成熟，各类组件库，插件库都比较丰富。搭配上vue-router和vuex组成vue全家桶，在UI框架上选择了专门针对pc端的ElementUI，ajax库选择了vue-resource，css预编译使用scss，js语言使用了支持 async function 的ES7，搭配babel编译成生产环境可运行的ES5。打包工具使用webpack。 前端框架： vue 路由管理： vue-router 状态管理： vuex、sessionStorage、localStorage UI框架： ElementUI Ajax库： vue-resource JS语言： ES6、ES7、babel CSS预编译语言： scss 打包工具： webpack 图表：echarts ESLint CSS 预处理： SASS 功能模块 目录结构1234567891011121314151617181920212223242526272829303132├── build // 构建相关 ├── config // 配置相关├── dist // 编译后静态文件├── documents // api ui等相关文档 ├── node_modules // 依赖相关├── src // 源代码│ ├── api // 所有请求│ ├── api-elk // elk所有请求│ ├── assets // 主题 字体等静态资源│ ├── components // 全局公用组件│ ├── directive // 全局指令│ ├── filtres // 全局 filter│ ├── http // 全局拦截器│ ├── mixin // mixin│ ├── pages // pages│ ├── router // 路由│ ├── storage // localStorage, sessionStorage│ ├── store // 全局 store管理│ ├── styles // 全局样式│ ├── svg // svg│ ├── config.js // appConfig│ ├── main.js // 入口 加载组件 初始化等│ ├── resources.js // api resources│ ├── utils.js // 全局公用方法├── static // 第三方不打包资源├── .babelrc // babel-loader 配置├── .editorconfig // 编辑器的配置文件├── .eslintrc.js // eslint 配置项├── .gitignore // git 忽略项├── index.html // html模板└── package.json // package.json└── package-lock.json // 锁定安装时的包的版本号 简单介绍一下src： api 和 pages随着业务的不断迭代，模块会越来越多，所以我们建议根据业务模块来划分pages和api，使之一一对应，从而方便维护。如下图： components这里的components放置的都是全局公用的一些组件，如自定义卡片组件，日期选择组件等。一些页面级的组件建议还是放在各自的pages文件夹下，方便管理。如图： router当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样写大大减少了初始页面 js 的大小并且能更好的利用游览器的缓存。 我们选择结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。 12345678&#123; path: &apos;/login&apos;, name: &apos;login&apos;, component: (resolve) =&gt; require([&apos;../../pages/Login.vue&apos;], resolve), meta: &#123; auth: false &#125;&#125; storage出于某些方面的考虑，我们在项目中用到了Window.sessionStorage和Window.localStorage，在这里关于其原理及相应语法不再进行介绍，有需求的请自行 Google。 stylesSass(Scss)号称是世界上最成熟、稳定和强大的专业级CSS扩展语言，通过Sass(Scss)来改变前端工程师，提高效率，降低成本。在这里，我们建议将颜色、屏幕分比率常用值等这些反复使用的css属性值定义成变量，与项目其它常规样式分开，便于维护。 svg项目中涉及到一些小图标，我们统一采用svg图形格式。在这里推荐vue-svg-icon—-一个 vue的可变彩色 svg 图标方案。 1&lt;icon name=&quot;chameleon&quot; :scale=&quot;20&quot;&gt;&lt;/icon&gt; store个人建议不要为了用 vuex 而用 vuex。就拿收费云来说，它虽然比较庞大，几十个业务模块，几十种权限，但业务之间的耦合度是很低的，所以没有必要使用 vuex 来存储data，每个页面里存放自己的 data 就行。当然有些数据还是需要用 vuex 来统一管理的，如登录token，用户信息等，还是用vuex管理更加的方便，具体当然还是要结合自己的业务场景的。总之还是那句话，不要为了用vuex而用vuex！ webpack这里是用vue-cli的webpack-template为基础模板构建的，如果你对这个有什么疑惑请自行Google，相关的配置介绍其他文章已经介绍地很详细了，这里将不再展开。 开发环境 生产环境 cors cors proxy nginx alias当项目逐渐变大之后，文件与文件之间的直接引用关系会很复杂，这时候就需要使用alias了。 1234567resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &#125;&#125; 12// 使用import dataPicker from &apos;@/components/base-date-picker&apos; ESLint不管是多人合作还是个人项目，代码规范是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性，简单介绍一下我们的.eslintrc。 123456789101112131415161718192021222324252627282930module.exports = &#123; root: true, // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style parserOptions: &#123; parser: &apos;babel-eslint&apos; &#125;, extends: [ // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules. &apos;plugin:vue/essential&apos;, // https://github.com/standard/standard/blob/master/docs/RULES-en.md &apos;standard&apos; ], env: &#123; browser: true, &#125;, plugins: [ &apos;vue&apos; ], rules: &#123; &apos;eol-last&apos;: 0, &apos;arrow-parens&apos;: 0, // allow debugger during development &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? 2 : 0, &quot;no-new&quot;: 0, &quot;no-useless-escape&quot;: 0, &quot;spaced-comment&quot;: [&quot;error&quot;, &quot;always&quot;, &#123; &quot;exceptions&quot;: [&quot;-&quot;] &#125;], &quot;space-before-function-paren&quot;: 0 &#125;&#125; 前后端交互在平时的开发中，交流占据了我们很大一部分时间。但如果前后端有一个好的协作方式的话能节省很多时间。我们的开发流程是前后端一起开会讨论项目，之后后端根据需求，首先定义数据格式和api，然后 mock api 生成好文档，我们前端才开始对接接口。 如果后端不肯来帮你mock数据的话，前端自己来mock也是很简单的。你可以了解下eoLinker，通过eoLinker的Mock API，随机生成虚拟数据接口，让前端在脱离后端的情况下独立进行测试，帮助你实现由文档驱动的敏捷开发。 跨域问题前后端交互不可避免的就会遇到跨域问题，在这里推荐两种跨域解决方案。 最推荐的常用方式就是cors全称为 Cross Origin Resource Sharing（跨域资源共享）。这玩意对应前端来说和平时发请求写法上没有任何区别，工作量基本都在后端这里。每一次请求浏览器必须先以 OPTIONS 请求方式发送一个预请求，从而获知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。推荐的原因是只要第一次配好了，之后不管有多少接口和项目复用就可以了，一劳永逸的解决了跨域问题，而且不管是开发环境还是测试环境都能方便的使用。 但总有后端觉得麻烦不想这么搞。那前端也是有解决方案的，在开发环境下可使用webpack 的 proxy，使用也是很方便的，看一下文档就会使用了。但这种方法在生成环境中是不适用的，在生产环境中需要使用Nginx反向代理。不管是 proxy 和 nginx 的原理都是一样的通过搭建一个中转服务器来转发请求规避跨域的问题。 封装HTTP请求在讨论与后端数据交互的选型中，我们选择了vue-resource，它是一个非常轻量的用于处理HTTP请求的插件，提供了两种方式来处理HTTP请求：使用Vue.http或this.$http 使用Vue.resource或this.$resource。 主要特点如下： 体积小：压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。 支持主流的浏览器：除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。 支持Promise API和URI Templates**：Promise对象用于异步计算。URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。 支持拦截器：拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import Vue from &apos;vue&apos;import &#123; HOST &#125; from &apos;../config&apos;import store from &apos;../store&apos;import router from &apos;../router&apos;import VueResource from &apos;vue-resource&apos;import &#123; Message &#125; from &apos;element-ui&apos;Vue.use(VueResource)// 设置全局 api ROOTVue.http.options.root = HOST// request 请求拦截Vue.http.interceptors.push((request, next) =&gt; &#123; // if logged in, add the token to the header if (store.state.token) &#123; // // 越权请求拦截 // if (store.state.permission) &#123; // let path = `$&#123;request.url&#125;`.replace(HOST, &apos;&apos;) // let perName = `$&#123;request.method&#125;,$&#123;path&#125;` // console.error(&apos;perName&apos;, perName) // if (store.state.permission.hasOwnProperty(perName)) &#123; // if (!store.state.permission[perName]) &#123; // this.$message(&#123; // message: &apos;无访问权限，请联系企业管理员&apos;, // type: &apos;warning&apos; // &#125;) // &#125; // &#125; // &#125; request.headers.set(&apos;Authorization&apos;, `JWT $&#123;store.state.token&#125;`) &#125; next()&#125;)// response 拦截Vue.http.interceptors.push((request, next) =&gt; &#123; next((response) =&gt; &#123; // don&apos;t handle for login page if (store.state.route.path === &apos;/login&apos;) &#123; return &#125; if (response.status === 403) &#123; store.commit(&apos;LOG_OUT&apos;) router.push(&#123;path: &apos;/login&apos;, query: &#123;redirect: store.state.route.fullPath&#125;&#125;) &#125; if (response.status === 401 ) &#123; store.commit(&apos;LOG_OUT&apos;) router.push(&#123;path: &apos;/login&apos;, query: &#123;redirect: store.state.route.fullPath&#125;&#125;) &#125; if (response.status === 500) &#123; Message.error(&#123; dangerouslyUseHTMLString: true, message: `服务器错误&lt;div&gt;$&#123;response.url&#125;&lt;/div&gt;` &#125;) &#125; &#125;)&#125;) 占坑 系类文章一：手摸手，带你用Vue构建公路收费云平台 系列一（基础篇） 系类文章二：手摸手，带你用Vue构建公路收费云平台 系列二（登录权限篇） 系类文章三：手摸手，带你用Vue构建公路收费云平台 系列三（实战篇） 系类文章四：手摸手，带你用Vue构建公路收费云平台 系列四（挖坑填坑篇）","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Babel-如何写好.babelrc?","slug":"Babel-如何写好.babelrc？","date":"2018-04-12T06:06:52.000Z","updated":"2018-06-10T14:17:42.000Z","comments":true,"path":"2018/04/12/Babel-如何写好.babelrc？/","link":"","permalink":"http://yoursite.com/2018/04/12/Babel-如何写好.babelrc？/","excerpt":"导语 Babel-The compiler for writing next generation Javascript. 下一代JavaScript 语法的编译器。","text":"导语 Babel-The compiler for writing next generation Javascript. 下一代JavaScript 语法的编译器。 什么是Babel？作为前端开发，由于浏览器的版本和兼容性等问题，很多JS的新的方法都不能使用，等到可以大胆使用的时候，可能已经过去很久。Babel就因此而生，它可以让你放心使用大部分的JS的新的标准的方法，然后编译成兼容绝大多数的主流浏览器的代码。 在升级到Babel6.X版本之后，所有的插件都是可插拔的，这也意味着你安装了Babel之后，是不能工作的，需要配置对应的.babelrc文件才能发挥完整的作用。 预设（presets）使用时需要安装对应的插件，对应babel-preset-xxx。例如下配置，需要npm i babel-preset-es2015。 123&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; env123&#123; &quot;presets&quot;: [&quot;env&quot;, options]&#125; 新增选项，有以下options选择。targets: {[string]: number}，默认{}需要支持的环境，可选例如：chrome，edge，firefox，safari等，甚至可以指定版本，如node：6.5。也使用node：current代表使用当前的版本。 browsers: array | string，默认[]浏览器列表，使用的是browserslist，可选例如：last 2 versions, &gt; 5%。 loose: boolean，默认false是否使用宽松模式，如果设置为true，plugins里的插件如果允许，都会采用宽松模式。 debug: boolean，默认false编译是否会去掉console.log。 whitelist: array，默认[]设置一直引入的plugins列表。es2015/es2016/es2017/latest 123&#123; &quot;presets&quot;: [&quot;es2015&quot;]&#125; es2015使用es2015，简单翻译如下，更多细节可以参看文档。 check-es2015-constants // 检验const常量是否被重新赋值。 transform-es2015-arrow-functions // 编译箭头函数。 transform-es2015-block-scoped-functions // 函数声明在作用域内。 transform-es2015-block-scoping // 编译const和let。 transform-es2015-classes // 编译class。 transform-es2015-computed-properties // 编译计算对象属性。 transform-es2015-destructuring // 编译解构赋值。 transform-es2015-duplicate-keys // 编译对象中重复的key，其实是转换成计算对象属性。 transform-es2015-for-of // 编译for…of。 transform-es2015-function-name // 将function.name语义应用于所有的function。 transform-es2015-literals // 编译整数(8进制/16进制)和unicode。 transform-es2015-modules-commonjs // 将modules编译成commonjs。 transform-es2015-object-super // 编译super。 transform-es2015-parameters // 编译参数，包括默认参数，不定参数和解构参数。 transform-es2015-shorthand-properties // 编译属性缩写。 transform-es2015-spread // 编译展开运算符。 transform-es2015-sticky-regex // 正则添加sticky属性。 transform-es2015-template-literals // 编译模版字符串。 transform-es2015-typeof-symbol // 编译Symbol类型。 transform-es2015-unicode-regex // 正则添加unicode模式。 transform-regenerator // 编译generator函数。 es2016使用es2016，更多细节可以参看文档。 transform-exponentiation-operator // 编译幂运算符 es2017使用es2017的相关插件，更多细节可以参看文档。 syntax-trailing-function-commas // function最后一个参数允许使用逗号。 transform-async-to-generator // 把async函数转化成generator函数。 latestlatest是一个特殊的presets，包括了es2015，es2016，es2017的插件（目前为止，以后有es2018也会包括进去）。 reactreact是一个比较特别的官方推荐的presets，大概是因为比较火吧。加入了flow，jsx等语法，具体可以看文档。 stage-x(stage-0/1/2/3/4)stage-x和上面的es2015等有些类似，但是它是按照JavaScript的提案阶段区分的，一共有5个阶段。而数字越小，阶段越靠后，存在依赖关系。也就是说stage-0是包括stage-1的，以此类推。 stage-4已完成的提案，与年度发布的release有关，包含2015年到明年正式发布的内容。例如，现在是2016年，stage-4应该是包括es2015，es2016，es2017。经过测试，babel-preset-stage-4这个npm包是不存在的，如果你单纯的需要stage-4的相关方法，需要引入es2015~es2017的presets。 stage-3除了stage-4的内容，还包括以下插件，更多细节请看文档。 transform-object-rest-spread // 编译对象的解构赋值和不定参数。 transform-async-generator-functions // 将async generator function和for await编译为es2015的generator。 stage-2除了stage-3的内容，还包括以下插件，更多细节请看文档。 transform-class-properties // 编译静态属性(es2015)和属性初始化语法声明的属性(es2016)。 stage-1除了stage-2的内容，还包括以下插件，更多细节请看文档。 transform-class-constructor-call // 编译class中的constructor，在Babel7中会被移除。 transform-export-extensions // 编译额外的export语法，如export * as ns from “mod”。 stage-0除了stage-1的内容，还包括以下插件，更多细节请看文档。 transform-do-expressions // 编译do表达式。 transform-function-bind // 编译bind运算符，也就是::。 插件(plugins)其实看了上面的应该也明白了，presets，也就是一堆plugins的预设，起到方便的作用。如果你不采用presets，完全可以单独引入某个功能，比如以下的设置就会引入编译箭头函数的功能。 123&#123; &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]&#125; 还有一些方法是presets中不提供的，这时候就需要单独引入了，介绍几个常见的插件。 transform-runtime123&#123; &quot;plugins&quot;: [&quot;transform-es2015-arrow-functions&quot;]&#125; 主要有以下options选择。 helpers: boolean // 默认为true，使用babel的helper函数。 polyfill: boolean // 默认为true，使用babel的polyfill，但不能完全取代bebel-polyfill。 regenerator: boolean // 默认为true，使用babel的regenerator。 noduleName: string // 默认babel-runtime，使用对应module处理。 options一般不用自己设置，使用默认的即可。这个插件的作用主要是： 解决编译中产生的重复的工具函数，减小代码体积 非实例方法的poly-fill，如Object.assign，但是实例方法不支持，如”foobar”.includes(“foo”)，这时候需要单独引入babel-polyfill。 更多细节参见文档。 transform-remove-console123&#123; &quot;plugins&quot;: [&quot;transform-remove-console&quot;]&#125; 使用这个插件，编译后的代码都会移除console.*，妈妈再也不用担心线上代码有多余的console.log了。当然很多时候，我们如果使用webpack，会在webpack中配置。 这也告诉我们，Babel不仅仅是编译代码的工具，还能对代码进行压缩，也许有一天，你不再需要代码压缩的插件了，因为你有了Babel！ 自定义预设或插件Babel支持自定义的预设(presets)或插件(plugins)。如果你的插件在npm上，可以直接采用这种方式”plugins”: [“babel-plugin-myPlugin”]，当然，你也可以缩写，它和”plugins”: [“myPlugin”]是等价的。此外，你还可以采用本地的相对路径引入插件，比如”plugins”: [“./node_modules/asdf/plugin”]。 presets同理。 plugins/presets排序也许你会问，plugins和presets编译，也许会有相同的功能，或者有联系的功能，按照怎么的顺序进行编译？答案是会按照一定的顺序。 具体而言，plugins优先于presets进行编译。 plugins按照数组的index增序(从数组第一个到最后一个)进行编译。 presets按照数组的index倒序(从数组最后一个到第一个)进行编译。因为作者认为大部分会把presets写成[“es2015”, “stage-0”]。具体细节可以看这个。 总结12345678910111213&#123; \"presets\": [ [\"env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125; &#125;], \"stage-2\" ], \"plugins\": [\"transform-runtime\", \"transform-vue-jsx\"], \"comments\": false&#125; 强烈推荐使用transform-runtime。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Vue-cli中Webpack配置基础文件详解","slug":"Vue-cli中Webpack配置基础文件详解","date":"2018-04-11T12:06:52.000Z","updated":"2018-06-15T17:04:24.000Z","comments":true,"path":"2018/04/11/Vue-cli中Webpack配置基础文件详解/","link":"","permalink":"http://yoursite.com/2018/04/11/Vue-cli中Webpack配置基础文件详解/","excerpt":"导语 Vue-cli是构建Vue单页应用的脚手架，输入一串指定的命令行从而自动生成Vue.js+Wepack的项目模板。","text":"导语 Vue-cli是构建Vue单页应用的脚手架，输入一串指定的命令行从而自动生成Vue.js+Wepack的项目模板。 前言通过Vue-cli生成的Vue.js+Webpack的项目模板，这其中webpack发挥了很大的作用，它使得我们的代码模块化，引入一些插件帮我们完善功能可以将文件打包压缩，图片转base64等。后期对项目的配置使得我们对于脚手架自动生成的代码的理解更为重要，接下来我们将基于webpack3.6.0版本结合文档将文件各个击破。 主体结构12345678910111213141516171819├─build├─config├─dist├─node_modules├─src│ ├─assets│ ├─components│ ├─router│ ├─App.vue│ ├─main.js├─static├─.babelrc├─.editorconfig├─.gitignore├─.postcssrc.js├─index.html├─package-lock.json├─package.json└─README.md package.json项目作为一个大家庭，每个文件都各司其职。package.json来制定名单，需要哪些npm包来参与到项目中来，npm install命令根据这个配置文件增减来管理本地的安装包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&#123; //从name到license都是package的配置信息，也就是我们在脚手架搭建中输入的项目描述 &quot;name&quot;: &quot;shou-fei-yun&quot;, // 项目名称 &quot;version&quot;: &quot;0.2.1&quot;, // 项目版本号 &quot;description&quot;: &quot;新疆公路收费&quot;, // 项目描述 &quot;author&quot;: &quot;ETVC &lt;etvcsoft.com&gt;&quot;, // 作者名字 &quot;license&quot;: &quot;MIT&quot;, // 许可证标识 // scripts中的子项即是我们在控制台运行的脚本的缩写 &quot;scripts&quot;: &#123; // webpack-dev-server启动了http服务器，实现实时编译 // inline模式会在webpack.config.js入口配置中新增webpack-dev-server/client?http://localhost:8080/的入口 // progress显示打包的进度 &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, // 与npm run dev相同 &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, // 使用node运行build文件 &quot;brwoser-sync&quot;: &quot;cd dist &amp;&amp; browser-sync start --server&quot; &#125;, // 项目依赖库：在安装时使用--save则写入到dependencies &quot;dependencies&quot;: &#123; &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;, &quot;babel-runtime&quot;: &quot;^5.8.0&quot;, &quot;countup.js&quot;: &quot;^1.8.1&quot;, &quot;echarts&quot;: &quot;^3.3.2&quot;, &quot;hideseek&quot;: &quot;^0.7.0&quot;, &quot;http-server&quot;: &quot;^0.9.0&quot;, &quot;jquery&quot;: &quot;^2.2.2&quot;, &quot;moment&quot;: &quot;^2.18.1&quot;, &quot;vue&quot;: &quot;^2.5.9&quot;, &quot;vue-date-picker&quot;: &quot;^1.0.2&quot;, &quot;vue-localstorage&quot;: &quot;^0.1.3&quot;, &quot;vue-prism&quot;: &quot;^1.0.5&quot;, &quot;vue-prism-component&quot;: &quot;^1.0.1&quot;, &quot;vue-resource&quot;: &quot;^1.3.4&quot;, &quot;vue-router&quot;: &quot;^2.8.1&quot;, &quot;vue-scrollTo&quot;: &quot;^2.3.2&quot;, &quot;vue-uweb&quot;: &quot;^0.1.0&quot;, &quot;vuex&quot;: &quot;^2.1.1&quot;, &quot;vuex-router-sync&quot;: &quot;^4.1.0&quot;, &quot;waypoints&quot;: &quot;^4.0.1&quot; &#125;, // 开发依赖库：在安装时使用--save-dev将写入到devDependencies &quot;devDependencies&quot;: &#123; &quot;@xkeshi/vue-qrcode&quot;: &quot;^0.3.0&quot;, &quot;autoprefixer&quot;: &quot;^7.1.2&quot;, // autoprefixer作为postcss插件用来解析css补充前缀，例如 display: flex会补充为display:-webkit-box;display: -webkit-flex等 // 以下几个babel开头的都是针对es6解析的插件，用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本 &quot;babel-core&quot;: &quot;^6.22.1&quot;, // babel的核心，把js代码分析成ast，方便各个插件分析语法进行相应的处理 &quot;babel-eslint&quot;: &quot;^8.2.1&quot;, &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;, // 预制babel-template函数，提供给vue，jsx等使用 &quot;babel-loader&quot;: &quot;^7.1.1&quot;, // 使项目运行使用babel和webpack来传输js文件，使用babel-core提供的api进行转译 &quot;babel-plugin-component&quot;: &quot;^0.9.1&quot;, &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;, // 支持jsx &quot;babel-plugin-transform-runtime&quot;: &quot;^6.0.0&quot;, // 避免编译输出中的重复，直接编译到build环境中 &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.4.2&quot;, // babel转译过程中使用到的插件，避免重复 &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;, // ES第二阶段的规范 &quot;babel-register&quot;: &quot;^6.0.0&quot;, &quot;chalk&quot;: &quot;^2.0.1&quot;, // 用来在命令行中输出不同颜色文字 &quot;clipboard&quot;: &quot;^1.7.1&quot;, &quot;compression&quot;: &quot;^1.7.1&quot;, &quot;connect-history-api-fallback&quot;: &quot;^1.5.0&quot;, &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;, // 拷贝资源和文件 &quot;cross-spawn&quot;: &quot;^5.0.1&quot;, &quot;css-loader&quot;: &quot;^0.28.0&quot;, // webpack先用css-loader加载器去解析后缀名为css的文件，在使用style-loader生成一个内容为最终解析完的css的style标签，放到head标签里 &quot;element-theme-chalk&quot;: &quot;^2.0.7&quot;, &quot;element-ui&quot;: &quot;^2.4.0&quot;, &quot;eslint&quot;: &quot;^3.7.1&quot;, &quot;eslint-config-standard&quot;: &quot;^10.2.1&quot;, &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;, &quot;eslint-loader&quot;: &quot;^1.7.1&quot;, &quot;eslint-plugin-html&quot;: &quot;^1.3.0&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.8.0&quot;, &quot;eslint-plugin-node&quot;: &quot;^5.2.1&quot;, &quot;eslint-plugin-promise&quot;: &quot;3.4.0&quot;, &quot;eslint-plugin-standard&quot;: &quot;^3.0.1&quot;, &quot;eslint-plugin-vue&quot;: &quot;^4.2.0&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;, // 将一个以上的包里面的文本提取到单独文件中 &quot;file-loader&quot;: &quot;^1.1.4&quot;, // 打包压缩文件，与url-loader用法类似 &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;, // 识别某些类别的webpack错误和清理，聚合和优先排序，以提供更好的开发体验 &quot;function-bind&quot;: &quot;^1.0.2&quot;, &quot;happypack&quot;: &quot;^4.0.0-beta.1&quot;, &quot;highlight.js&quot;: &quot;^9.12.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.28.0&quot;, // 简化了HTML文件的创建，引入了外部资源，创建html的入口文件，可通过此项进行多页面的配置 &quot;http-proxy-middleware&quot;: &quot;^0.17.4&quot;, &quot;imports-loader&quot;: &quot;^0.7.0&quot;, &quot;inject-loader&quot;: &quot;^3.0.0&quot;, &quot;isparta-loader&quot;: &quot;^2.0.0&quot;, &quot;json-loader&quot;: &quot;^0.5.4&quot;, &quot;lolex&quot;: &quot;^1.4.0&quot;, &quot;mavon-editor&quot;: &quot;^2.2.6&quot;, &quot;mocha&quot;: &quot;^3.1.0&quot;, &quot;node-notifier&quot;: &quot;^5.1.2&quot;, // 支持使用node发送跨平台的本地通知 &quot;node-sass&quot;: &quot;^4.7.2&quot;, &quot;opn&quot;: &quot;^4.0.2&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^1.3.0&quot;, // 压缩提取出的css，并解决ExtractTextPlugin分离出的js重复问题(多个文件引入同一css文件) &quot;ora&quot;: &quot;^0.3.0&quot;, // 加载的插件 &quot;portfinder&quot;: &quot;^1.0.13&quot;, // 查看进程端口 &quot;postcss-import&quot;: &quot;^11.0.0&quot;, // 可以消耗本地文件、节点模块或web_modules &quot;postcss-loader&quot;: &quot;^2.0.8&quot;, // 用来兼容css的插件 &quot;postcss-url&quot;: &quot;^7.2.1&quot;, // URL上重新定位、内联或复制 &quot;prismjs&quot;: &quot;^1.9.0&quot;, &quot;pug&quot;: &quot;^2.0.0-rc.4&quot;, &quot;rimraf&quot;: &quot;^2.6.0&quot;, // 节点的UNIX命令RM—RF,强制删除文件或者目录的命令 &quot;sass-loader&quot;: &quot;^4.1.0&quot;, &quot;semver&quot;: &quot;^5.3.0&quot;, // 用来对特定的版本号做判断的 &quot;shelljs&quot;: &quot;^0.7.6&quot;, // 使用它来消除shell脚本在UNIX上的依赖性，同时仍然保留其熟悉和强大的命令，即可执行Unix系统命令 &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.6&quot;, // 压缩js文件 &quot;url-loader&quot;: &quot;^0.5.8&quot;, // 压缩文件，可将图片转化为base64 &quot;vue-data-tables&quot;: &quot;^2.1.0&quot;, &quot;vue-easytable&quot;: &quot;^1.7.0&quot;, &quot;vue-loader&quot;: &quot;^13.3.0&quot;, // VUE单文件组件的WebPACK加载器 &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;, // 类似于样式加载程序，您可以在CSS加载器之后将其链接，以将CSS动态地注入到文档中作为样式标签 &quot;vue-svg-icon&quot;: &quot;^1.2.9&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.9&quot;, //这个包可以用来预编译VUE模板到渲染函数，以避免运行时编译开销和CSP限制 &quot;vue-waypoint&quot;: &quot;^2.1.0&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;, //可视化webpack输出文件的大小 &quot;webpack-dev-middleware&quot;: &quot;^1.12.1&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;, // 提供一个提供实时重载的开发服务器 &quot;webpack-hot-middleware&quot;: &quot;^2.18.0&quot;, &quot;webpack-merge&quot;: &quot;^4.1.0&quot; // 它将数组和合并对象创建一个新对象。如果遇到函数，它将执行它们，通过算法运行结果，然后再次将返回的值封装在函数中 &#125;, // engines是引擎，指定node和npm版本 &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;= 6.0.0&quot;, &quot;npm&quot;: &quot;&gt;= 3.0.0&quot; &#125;, // 限制了浏览器或者客户端需要什么版本才可运行 &quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot; ]&#125; devDependencies和dependencies的区别： devDependencies里面的插件只用于开发环境，不用于生产环境，即辅助作用，打包的时候需要，打包完成就不需要了。而dependencies是需要发布到生产环境的，自始至终都在。比如wepack等只是在开发中使用的包就写入到devDependencies，而像vue这种项目全程依赖的包要写入到devDependencies。 file-loader和url-loader的区别：以图片为例，file-loader可对图片进行压缩，但是还是通过文件路径进行引入，当http请求增多时会降低页面性能，而url-loader通过设定limit参数，小于limit字节的图片会被转成base64的文件，大于limit字节的将进行图片压缩的操作。总而言之，url-loader是file-loader的上层封装。 .babelrc该文件是es6解析的一个配置。 123456789101112131415&#123;// 制定转码的规则 &quot;presets&quot;: [ // env是使用babel-preset-env插件将js进行转码成es5，并且设置不转码的AMD,COMMONJS的模块文件，制定浏览器的兼容 [&quot;env&quot;, &#123; &quot;modules&quot;: false, &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;] &#125; &#125;], &quot;stage-2&quot; ], &quot;plugins&quot;: [&quot;transform-runtime&quot;, &quot;transform-vue-jsx&quot;], &quot;comments&quot;: false&#125; config1234├─config│ ├─dev.env.js│ ├─index.js│ ├─prod.env.js config/dev.env.jsconfig内的文件其实是服务于build的，大部分是定义一个变量export出去。 12345678&apos;use strict&apos; // 使用严格模式const merge = require(&apos;webpack-merge&apos;)const prodEnv = require(&apos;./prod.env&apos;)//webpack-merge提供了一个合并函数，它将数组和合并对象创建一个新对象。//如果遇到函数，它将执行它们，通过算法运行结果，然后再次将返回的值封装在函数中.这边将dev和prod进行合并module.exports = merge(prodEnv, &#123; NODE_ENV: &apos;&quot;development&quot;&apos;&#125;) config/prod.env.js当开发时调用dev.env.js的开发环境配置；当发布时调用prod.env.js的生产环境配置。 1234&apos;use strict&apos;module.exports = &#123; NODE_ENV: &apos;&quot;production&quot;&apos;&#125; config/index.js1234567891011121314151617181920212223242526272829303132333435&apos;use strict&apos;const path = require(&apos;path&apos;)module.exports = &#123; dev: &#123; // 开发环境下的配置 assetsSubDirectory: &apos;static&apos;, // 子目录，一般存放css，js，image等文件 assetsPublicPath: &apos;/&apos;, // 根目录 proxyTable: &#123;&#125;, // 可利用该属性解决跨域问题 host: &apos;localhost&apos;, // 地址 port: 8080, // 端口号 autoOpenBrowser: false, // 是否在编译后打开http://localhost:8080/ errorOverlay: true, // 浏览器错误提示 notifyOnErrors: true, // 跨平台错误提示 poll: false, // 使用文件系统(file system)获取文件改动的通知devServer.watchOptions useEslint: true, showEslintErrorsInOverlay: false, devtool: &apos;cheap-module-eval-source-map&apos;, // 增加调试，该属性为原始源代码（仅限行）不可在生产环境中使用 cacheBusting: true, // 使缓存失败 cssSourceMap: true // 代码压缩后进行调bug定位将非常困难，于是引入sourcemap记录压缩前后的位置信息记录，当产生错误时直接定位到未压缩前的位置，将大大的方便我们调试 &#125;, build: &#123; // 生产环境下的配置 index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // index编译后生成的位置和名字，根据需要改变后缀，比如index.php assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), // 编译后存放生成环境代码的位置 assetsSubDirectory: &apos;static&apos;, // js,css,images存放文件夹名 assetsPublicPath: &apos;/&apos;, // 发布的根目录，通常本地打包dist后打开文件会报错，此处修改为./。如果是上线的文件，可根据文件存放位置进行更改路径 productionSourceMap: true, devtool: &apos;#source-map&apos;, productionGzip: false, //unit的gzip命令用来压缩文件，gzip模式下需要压缩的文件的扩展名有js和css productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], bundleAnalyzerReport: process.env.npm_config_report &#125;&#125; build12345678├─build│ ├─build.js│ ├─check-versions.js│ ├─utils.js│ ├─vue-loader.conf.js│ ├─webpack.base.conf.js│ ├─webpack.dev.conf.js│ ├─webpack.prod.conf.js build/build.js该文件作用，即构建生产版本。package.json中的scripts的build就是node build/build.js，输入命令行npm run build对该文件进行编译生成生产环境的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243&apos;use strict&apos;require(&apos;./check-versions&apos;)() // 调用检查版本的文件process.env.NODE_ENV = &apos;production&apos; // 设置当前是生产环境// 下面定义常量引入插件const ora = require(&apos;ora&apos;) // 加载动画const rm = require(&apos;rimraf&apos;)// 删除文件const path = require(&apos;path&apos;)const chalk = require(&apos;chalk&apos;)// 对文案输出的一个彩色设置const webpack = require(&apos;webpack&apos;)const config = require(&apos;../config&apos;) // 默认读取下面的index.js文件const webpackConfig = require(&apos;./webpack.prod.conf&apos;)// 调用start的方法实现加载动画，优化用户体验const spinner = ora(&apos;building for production...&apos;)spinner.start()// 先删除dist文件再生成新文件，因为有时候会使用hash来命名，删除整个文件可避免冗余rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; if (err) throw err webpack(webpackConfig, (err, stats) =&gt; &#123; spinner.stop() if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build. chunks: false, chunkModules: false &#125;) + &apos;\\n\\n&apos;) if (stats.hasErrors()) &#123; console.log(chalk.red(&apos; Build failed with errors.\\n&apos;)) process.exit(1) &#125; console.log(chalk.cyan(&apos; Build complete.\\n&apos;)) console.log(chalk.yellow( &apos; Tip: built files are meant to be served over an HTTP server.\\n&apos; + &apos; Opening index.html over file:// won\\&apos;t work.\\n&apos; )) &#125;)&#125;) build/check-versions.js该文件用于检测node和npm版本，实现版本依赖。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&apos;use strict&apos;const chalk = require(&apos;chalk&apos;)const semver = require(&apos;semver&apos;) // 对版本进行检查const packageConfig = require(&apos;../package.json&apos;)const shell = require(&apos;shelljs&apos;)function exec (cmd) &#123;// 返回通过child_process模块的新建子进程，执行 Unix 系统命令后转成没有空格的字符串 return require(&apos;child_process&apos;).execSync(cmd).toString().trim()&#125;const versionRequirements = [ &#123; name: &apos;node&apos;, currentVersion: semver.clean(process.version), // 使用semver格式化版本 versionRequirement: packageConfig.engines.node // 获取package.json中设置的node版本 &#125;]if (shell.which(&apos;npm&apos;)) &#123; versionRequirements.push(&#123; name: &apos;npm&apos;, currentVersion: exec(&apos;npm --version&apos;), // 自动调用npm --version命令，并且把参数返回给exec函数，从而获取纯净的版本号 versionRequirement: packageConfig.engines.npm &#125;)&#125;module.exports = function () &#123; const warnings = [] for (let i = 0; i &lt; versionRequirements.length; i++) &#123; const mod = versionRequirements[i]// 如果版本号不符合package.json文件中指定的版本号，就执行下面错误提示的代码 if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + &apos;: &apos; + chalk.red(mod.currentVersion) + &apos; should be &apos; + chalk.green(mod.versionRequirement) ) &#125; &#125; if (warnings.length) &#123; console.log(&apos;&apos;) console.log(chalk.yellow(&apos;To use this template, you must update following to modules:&apos;)) console.log() for (let i = 0; i &lt; warnings.length; i++) &#123; const warning = warnings[i] console.log(&apos; &apos; + warning) &#125; console.log() process.exit(1) &#125;&#125; build/utils.jsutils是工具的意思，是一个用来处理css的文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&apos;use strict&apos;const path = require(&apos;path&apos;)const config = require(&apos;../config&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const packageConfig = require(&apos;../package.json&apos;)// 导出文件的位置，根据环境判断开发环境和生产环境，为config文件中index.js文件中定义的build.assetsSubDirectory或dev.assetsSubDirectoryexports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory return path.posix.join(assetsSubDirectory, _path)&#125;exports.cssLoaders = function (options) &#123; options = options || &#123;&#125;// 使用了css-loader和postcssLoader，通过options.usePostCSS属性来判断是否使用postcssLoader中压缩等方法 const cssLoader = &#123; loader: &apos;css-loader&apos;, options: &#123; sourceMap: options.sourceMap &#125; &#125; const postcssLoader = &#123; loader: &apos;postcss-loader&apos;, options: &#123; sourceMap: options.sourceMap &#125; &#125; function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] if (loader) &#123; loaders.push(&#123; loader: loader + &apos;-loader&apos;, options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125; if (options.extract) &#123; // ExtractTextPlugin可提取出文本，代表首先使用上面处理的loaders，当未能正确引入时使用vue-style-loader return ExtractTextPlugin.extract(&#123; use: loaders, fallback: &apos;vue-style-loader&apos; &#125;) &#125; else &#123; // 返回vue-style-loader连接loaders的最终值 return [&apos;vue-style-loader&apos;].concat(loaders) &#125; &#125; return &#123; css: generateLoaders(), // 需要css-loader和vue-style-loader postcss: generateLoaders(), // 需要css-loader和postcssLoader和 vue-style-loader less: generateLoaders(&apos;less&apos;), // 需要less-loader和vue-style-loader sass: generateLoaders(&apos;sass&apos;, &#123; indentedSyntax: true &#125;), // 需要sass-loader和vue-style-loader scss: generateLoaders(&apos;sass&apos;), // 需要sass-loader和vue-style-loader stylus: generateLoaders(&apos;stylus&apos;), // 需要stylus-loader和vue-style-loader styl: generateLoaders(&apos;stylus&apos;) // 需要sass-loader和vue-style-loader &#125;&#125;exports.styleLoaders = function (options) &#123; const output = [] const loaders = exports.cssLoaders(options) // 将各种css,less,sass等综合在一起得出结果输出output for (const extension in loaders) &#123; const loader = loaders[extension] output.push(&#123; test: new RegExp(&apos;\\\\.&apos; + extension + &apos;$&apos;), use: loader &#125;) &#125; return output&#125;exports.createNotifierCallback = () =&gt; &#123;// 发送跨平台通知系统 const notifier = require(&apos;node-notifier&apos;) return (severity, errors) =&gt; &#123; if (severity !== &apos;error&apos;) return// 当报错时输出错误信息的标题，错误信息详情，副标题以及图标 const error = errors[0] const filename = error.file &amp;&amp; error.file.split(&apos;!&apos;).pop() notifier.notify(&#123; title: packageConfig.name, message: severity + &apos;: &apos; + error.name, subtitle: filename || &apos;&apos;, icon: path.join(__dirname, &apos;logo.png&apos;) &#125;) &#125;&#125; path.posix：提供对路径方法的POSIX（可移植性操作系统接口）特定实现的访问，即可跨平台，区别于win32。 path.join：用于连接路径，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\\” build/vue-loader.conf.js该文件的主要作用就是处理.vue文件，解析这个文件中的每个语言块(template、script、style)，转换成可用的js模块。 1234567891011121314151617181920212223&apos;use strict&apos;const utils = require(&apos;./utils&apos;)const config = require(&apos;../config&apos;)const isProduction = process.env.NODE_ENV === &apos;production&apos;const sourceMapEnabled = isProduction ? config.build.productionSourceMap : config.dev.cssSourceMap// 处理项目中的css文件，生产环境和测试环境默认是打开sourceMap，而extract中的提取样式到单独文件只有在生产环境中才需要module.exports = &#123; loaders: utils.cssLoaders(&#123; sourceMap: sourceMapEnabled, extract: isProduction &#125;), cssSourceMap: sourceMapEnabled, cacheBusting: config.dev.cacheBusting, // 在模版编译过程中，编译器可以将某些属性，如 src 路径，转换为require调用，以便目标资源可以由 webpack 处理. transformToRequire: &#123; video: [&apos;src&apos;, &apos;poster&apos;], source: &apos;src&apos;, img: &apos;src&apos;, image: &apos;xlink:href&apos; &#125;&#125; build/webpack.base.conf.jswebpack.base.conf.js是开发和生产共同使用提出来的基础配置文件，主要实现配置入口，配置输出环境，配置模块resolve和插件等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&apos;use strict&apos;const path = require(&apos;path&apos;)const utils = require(&apos;./utils&apos;)const config = require(&apos;../config&apos;)const vueLoaderConfig = require(&apos;./vue-loader.conf&apos;)function resolve (dir) &#123;// 拼接出绝对路径 return path.join(__dirname, &apos;..&apos;, dir)&#125;const createLintingRule = () =&gt; (&#123; test: /\\.(js|vue)$/, loader: &apos;eslint-loader&apos;, enforce: &apos;pre&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)], options: &#123; formatter: require(&apos;eslint-friendly-formatter&apos;), emitWarning: !config.dev.showEslintErrorsInOverlay &#125;&#125;)module.exports = &#123;// path.join将路径片段进行拼接，而path.resolve将以/开始的路径片段作为根目录，在此之前的路径将会被丢弃 context: path.resolve(__dirname, &apos;../&apos;),// 配置入口，默认为单页面所以只有app一个入口 entry: &#123; app: &apos;./src/main.js&apos; &#125;, // 配置出口，默认是/dist作为目标文件夹的路径 output: &#123; path: config.build.assetsRoot, filename: &apos;[name].js&apos;, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath // 公共存放路径 &#125;, resolve: &#123; // 自动的扩展后缀，比如一个js文件，则引用时书写可不要写.js extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], // 创建路径的别名，比如增加&apos;components&apos;: resolve(&apos;src/components&apos;)等 alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &#125; &#125;, // 使用插件配置相应文件的处理方法 module: &#123; rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), // 使用vue-loader将vue文件转化成js的模块 &#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;, options: vueLoaderConfig &#125;, // js文件需要通过babel-loader进行编译成es5文件以及压缩等操作 &#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;)] &#125;, // 图片、音像、字体都使用url-loader进行处理，超过10000会编译成base64 &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;) &#125; &#125; ] &#125;, node: &#123; // 以下选项是Node.js全局变量或模块，这里主要是防止webpack注入一些Node.js的东西到vue中 dgram: &apos;empty&apos;, fs: &apos;empty&apos;, net: &apos;empty&apos;, tls: &apos;empty&apos;, child_process: &apos;empty&apos; &#125;&#125; build/webpack.dev.conf.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&apos;use strict&apos;const utils = require(&apos;./utils&apos;)const webpack = require(&apos;webpack&apos;)const config = require(&apos;../config&apos;)// 通过webpack-merge实现webpack.dev.conf.js对wepack.base.config.js的继承const merge = require(&apos;webpack-merge&apos;)const path = require(&apos;path&apos;)const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)// 美化webpack的错误信息和日志的插件const FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;)const portfinder = require(&apos;portfinder&apos;) // 查看空闲端口位置，默认情况下搜索8000这个端口const HOST = process.env.HOST // processs为node的一个全局对象获取当前程序的环境变量，即hostconst PORT = process.env.PORT &amp;&amp; Number(process.env.PORT)const devWebpackConfig = merge(baseWebpackConfig, &#123; module: &#123; // 规则是工具utils中处理出来的styleLoaders，生成了css，less,postcss等规则 rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, devtool: config.dev.devtool, // 增强调试，上文有提及 // 此处的配置都是在config的index.js中设定好了 devServer: &#123; clientLogLevel: &apos;warning&apos;, // 控制台显示的选项有none, error, warning或者info // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为index.html historyApiFallback: &#123; rewrites: [ &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, &apos;index.html&apos;) &#125;, ], &#125;, hot: true, // 热加载 contentBase: false, // since we use CopyWebpackPlugin. compress: true, // 压缩 host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, // 调试时自动打开浏览器 overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, // warning 和 error 都要显示 publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // 控制台是否禁止打印警告和错误,若用FriendlyErrorsPlugin 此处为 true watchOptions: &#123; poll: config.dev.poll, // 文件系统检测改动 &#125; &#125;, plugins: [ new webpack.DefinePlugin(&#123; &apos;process.env&apos;: require(&apos;../config/dev.env&apos;) &#125;), new webpack.HotModuleReplacementPlugin(), // 模块热替换插件，修改模块时不需要刷新页面 new webpack.NamedModulesPlugin(), // 显示文件的正确名字 new webpack.NoEmitOnErrorsPlugin(), // 当webpack编译错误的时候，来中断打包进程，防止错误代码打包到文件中 // 该插件可自动生成一个 html5 文件或使用模板文件将编译好的代码注入进去 new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos;, inject: true &#125;), // 复制插件 new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, &apos;../static&apos;), to: config.dev.assetsSubDirectory, ignore: [&apos;.*&apos;] &#125; ]) ]&#125;)module.exports = new Promise((resolve, reject) =&gt; &#123; portfinder.basePort = process.env.PORT || config.dev.port // 查找端口号 portfinder.getPort((err, port) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; // 端口被占用时就重新设置env和devServer的端口 process.env.PORT = port devWebpackConfig.devServer.port = port // Add FriendlyErrorsPlugin devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: [`Your application is running here: http://$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;`], &#125;, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined &#125;)) resolve(devWebpackConfig) &#125; &#125;)&#125;) build/webpack.prod.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&apos;use strict&apos;const path = require(&apos;path&apos;)const utils = require(&apos;./utils&apos;)const webpack = require(&apos;webpack&apos;)const config = require(&apos;../config&apos;)const merge = require(&apos;webpack-merge&apos;)const baseWebpackConfig = require(&apos;./webpack.base.conf&apos;)const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const OptimizeCSSPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)const env = require(&apos;../config/prod.env&apos;)const webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; // 调用utils.styleLoaders的方法 rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, // 开启调试的模式。默认为true extract: true, usePostCSS: true &#125;) &#125;, devtool: config.build.productionSourceMap ? config.build.devtool : false, output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;), chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;) &#125;, plugins: [ new webpack.DefinePlugin(&#123; &apos;process.env&apos;: env &#125;), new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; // 压缩 warnings: false, // 警告：true保留警告，false不保留 drop_console: true &#125; &#125;, sourceMap: config.build.productionSourceMap, parallel: true &#125;), // 抽取文本。比如打包之后的index页面有style插入，就是这个插件抽取出来的，减少请求 new ExtractTextPlugin(&#123; filename: utils.assetsPath(&apos;css/[name].[contenthash].css&apos;), allChunks: true, &#125;), // 优化css插件 new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), // html打包 new HtmlWebpackPlugin(&#123; filename: config.build.index, template: &apos;index.html&apos;, inject: true, minify: &#123; removeComments: true, // 删除注释 collapseWhitespace: true, // 删除空格 removeAttributeQuotes: true // 删除属性的引号 &#125;, chunksSortMode: &apos;dependency&apos; // 模块排序，按照我们需要的顺序排序 &#125;), new webpack.HashedModuleIdsPlugin(), new webpack.optimize.ModuleConcatenationPlugin(), new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks (module) &#123; return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &apos;../node_modules&apos;) ) === 0 ) &#125; &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos;, minChunks: Infinity &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;app&apos;, async: &apos;vendor-async&apos;, children: true, minChunks: 3 &#125;), // 复制，比如打包完之后需要把打包的文件复制到dist里面 new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, &apos;../static&apos;), to: config.build.assetsSubDirectory, ignore: [&apos;.*&apos;] &#125; ]), new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) ]&#125;)if (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;) webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: &apos;[path].gz[query]&apos;, algorithm: &apos;gzip&apos;, test: new RegExp( &apos;\\\\.(&apos; + config.build.productionGzipExtensions.join(&apos;|&apos;) + &apos;)$&apos; ), threshold: 10240, minRatio: 0.8 &#125;) )&#125;if (config.build.bundleAnalyzerReport) &#123; const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125;module.exports = webpackConfig 结语本文将vue本身自带的英文注释删除了，但英文注释非常有用可以仔细阅读，希望对大家学习vue和webpack都有所帮助。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"ES6-Airbnb JavaScript（ES6）代码规范","slug":"ES6-Airbnb JavaScript（ES6）代码规范","date":"2018-04-11T08:06:52.000Z","updated":"2018-06-15T17:02:16.000Z","comments":true,"path":"2018/04/11/ES6-Airbnb JavaScript（ES6）代码规范/","link":"","permalink":"http://yoursite.com/2018/04/11/ES6-Airbnb JavaScript（ES6）代码规范/","excerpt":"导语 本文摘自—Airbnb JavaScript（ES6）代码规范。","text":"导语 本文摘自—Airbnb JavaScript（ES6）代码规范。 声明变量的新姿势用let不用varES6之前我们使用var声明一个变量，但是它有很多弊病： 无块级作用域变量，很容易声明全局变量。 变量提升。 可重复声明。 12345678910var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10a[7](); // 10a[8](); // 10a[9](); // 10 所以，你有什么理由不用let? 某些场景，const比let更好const和let的唯一区别就是，const不可以被更改，所以当声明变量的时候，尤其是在声明容易被更改的全局变量的时候，尽量使用const。 更好的代码语义化，一眼看到就是常量。 另一个原因是因为JavaScript 编译器对const的优化要比let好，多使用const，有利于提高程序的运行效率。 所有的函数都应该设置为常量。 动态字符串不要使用“双引号”，一律用单引号或反引号。 12345678// lowconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// bestconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 解构赋值的骚操作变量赋值在用到数组成员对变量赋值时，尽量使用解构赋值。 12345678const arr = [1, 2, 3, 4];// lowconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数传对象函数的参数如果是对象的成员，优先使用解构赋值。 123456789// lowfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 1234567891011// lowfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 关于对象的细节逗号单行定义的对象结尾不要逗号： 12345// lowconst a = &#123; k1: v1, k2: v2, &#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;; 多行定义的对象要保留逗号：： 1234567891011// lowconst b = &#123; k1: v1, k2: v2&#125;;// goodconst b = &#123; k1: v1, k2: v2,&#125;; 一次性初始化完全不要声明之后又给对象添加新属性： 1234567// lowconst a = &#123;&#125;;a.x = 3;// goodconst a = &#123; x: null &#125;;a.x = 3; 如果一定非要加请使用Object.assign： 12const a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;); 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义： 12345678910111213/ lowconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,[getKey(&apos;enabled&apos;)]: true,&#125;; 在简洁一点1234567891011121314151617181920212223var ref = &apos;some value&apos;;// lowconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组扩展运算符…使用扩展运算符（…）拷贝数组： 1234567891011// 还在用for i 你就太low了const len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// cool !const itemsCopy = [...items]; Array.form（）用 Array.from 方法，将类似数组的对象转为数组： 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 函数箭头函数=&gt;立即执行函数可以写成箭头函数的形式： 123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 尽量写箭头函数使你的代码看起来简洁优雅： 1234567// low[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// cool ![1, 2, 3].map(x =&gt; x * x); 别再用arguments（类数组）了！使用 rest 运算符（…）代替，rest 运算符可以提供一个真正的数组。 12345678910// lowfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 传参时试试设置默认值123456789// lowfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Object？Map！简单的键值对优先Map如果只是简单的key: value结构，建议优先使用Map，因为Map提供方便的遍历机制。 12345678910111213let map = new Map(arr);// 遍历key值for (let key of map.keys()) &#123; console.log(key);&#125;// 遍历value值for (let value of map.values()) &#123; console.log(value);&#125;// 遍历key和value值for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; class语法123456789101112131415161718192021// lowfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 模块化引入模块使用import取代require，因为Module是Javascript模块的标准写法。 1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 输出模块使用export输出变量，拒绝module.exports: 123456789import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 输出单个值，使用export default。 输出多个值，使用export。 export default与普通的export不要同时使用。 编码规范模块输出一个函数，首字母应该小写： 1234function getData() &#123;&#125;export default getData;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Markdown-入门指南","slug":"markdown-入门指南","date":"2017-10-12T08:06:52.000Z","updated":"2018-06-15T17:02:36.000Z","comments":true,"path":"2017/10/12/markdown-入门指南/","link":"","permalink":"http://yoursite.com/2017/10/12/markdown-入门指南/","excerpt":"导语 Markdown 是一种轻量级的「标记语言」，语法十分简单，常用的标记符号不超过十个。","text":"导语 Markdown 是一种轻量级的「标记语言」，语法十分简单，常用的标记符号不超过十个。 Markdown 语法的简要规则标题在Markdown中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 1234567# 一级标题## 二级标题### 三级标题... 以此类推，总共六级标题，建议在 # 号后加空格。 列表列表分为有序列表和无序列表。在Markdown下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要与文字之间加上一个空格。 123456789#### 无序列表* 1* 2* 3#### 有序列表1. 12. 23. 3 引用如果你需要引用一小段别处的句子，那么就要用引用的格式 例如这样 只需要在文本前加入 &gt; 这种尖括号即可 1&gt; 例如这样 图片与链接插入链接与插入图片的语法很相似，区别在一个 ！号。 12图片为： ![]()链接为： []() 粗体与斜体Markdown 的粗体与斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的写法。 12*我是斜体***我是粗体** 表格语法为： 123| Table | Are | Cool || --- | --- | --- || col 3 is | right | $3000 | 效果为： Table Are Cool col 3 is right $3000 代码框如果你是个程序猿，需要在文章里优雅的引用代码框， 在Markdown下实现也非常简单，只需要用两个`把中间的代码包裹起来即可。 1`&lt;b&gt;Markdown&lt;/b&gt;` 使用 tab 键即可缩进。 分割线分割线的语法只需要三个 * 号。 1***","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"CD-前端常见跨域解决方案（全）","slug":"CD-前端常见跨域解决方案（全）","date":"2017-09-22T13:06:52.000Z","updated":"2018-06-25T17:40:15.000Z","comments":true,"path":"2017/09/22/CD-前端常见跨域解决方案（全）/","link":"","permalink":"http://yoursite.com/2017/09/22/CD-前端常见跨域解决方案（全）/","excerpt":"导语 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。","text":"导语 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 什么是跨域？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 资源跳转： A链接、重定向、表单提交 资源嵌入：、、、等dom标签，还有样式中background:url()、@font-face()等文件外链 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 什么是同源策略？同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 常见跨域场景123456789101112131415161718192021URL 说明 是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.jshttp://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 跨域解决方案通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 WebSocket协议跨域","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Cross-Domain","slug":"Cross-Domain","permalink":"http://yoursite.com/tags/Cross-Domain/"}]}]}