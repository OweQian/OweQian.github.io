{"meta":{"title":"W | 个人博客 | web前端","subtitle":null,"description":"前端","author":"wangxiaobai","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-04-11T08:28:54.000Z","updated":"2018-04-11T08:29:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-11T08:28:32.000Z","updated":"2018-04-11T08:28:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue-源码系列随读笔记之认识Flow","slug":"Vue-源码系列之认识Flow","date":"2019-03-01T09:02:00.000Z","updated":"2019-03-13T02:19:12.857Z","comments":true,"path":"2019/03/01/Vue-源码系列之认识Flow/","link":"","permalink":"http://yoursite.com/2019/03/01/Vue-源码系列之认识Flow/","excerpt":"导语 Flow是facebook出品的javascript静态类型检查工具。Vue.js源码利用了Flow做了静态类型检查。优先了解Flow有助于我们阅读源码。","text":"导语 Flow是facebook出品的javascript静态类型检查工具。Vue.js源码利用了Flow做了静态类型检查。优先了解Flow有助于我们阅读源码。 为什么要使用Flowjavascript是动态类型语言，它的灵活性有目共睹。但过于灵活的副作用就是容易写出非常隐蔽的隐患代码，在编译期看上去不会报错，但在运行阶段就可能出现各种奇怪的bug。 类型检查是当前动态类型语言的发展趋势。所谓类型检查，就是在编译期尽早发现bug，又不影响代码运行，使编写javascript具有和编写java等强类型语言相近的体验。 Flow的工作方式通常类型检查分为2中方式： 类型推断：通过变量使用的上下文来推断出变量类型，然后根据这些推断来检查类型。 类型注释：事先注释好我们期待的类型，Flow会基于这些注释来判断。 类型推断无需任何代码修改即可进行类型检查，最小化开发者的工作量。不会强制你改变开发习惯，因为它会自动推断出变量的类型。 1234567/*@flow*/function split(str) &#123; return str.split(&apos; &apos;)&#125;split(11) 类型注释在某些特定的场景下，添加类型注释可以提供更好更明确的检查依据。 考虑如下代码： 12345/*@flow*/function add(x, y) &#123; return x + y&#125;add(&apos;hello&apos;, 11) Flow检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 add() 的参数必须为数字。 在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以 : 开头，可以在函数参数、返回值、变量声明中使用。 如果我们在上段代码中添加类型注释，就会变成如下： 12345/*@flow*/function add(x: number, y: number) : number &#123; return x + y&#125;add(&apos;hello&apos;, 11) 现在Flow就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。 上面的例子是针对函数的类型注释。接下来我们来看看Flow能支持的一些常见的类型注释。 数组123/*@flow*/var arr: Array&lt;number&gt; = [1, 2, 3]arr.push(&apos;hello) 数组类型注释的格式为Array，T表示数组中每项的数据类型。在上述代码中，arr是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow就能检查出错误。 类和对象1234567891011121314151617181920/*@flow*/class Bar &#123; x: string y: string | number z: boolean constructor(x: string, y: string | number) &#123; this.x = x this.y = y this.z = z &#125;&#125;var bar: Bar = new Bar(&apos;hello&apos;, 11)var obj: &#123; a: string, b: number, c: Array&lt;string&gt;, d: Bar&#125; = &#123; a: &apos;hello&apos;, b: 11, c: [&apos;hello&apos;, &apos;world&apos;], d: new Bar(&apos;hello&apos;, 11)&#125; 类的类型注释可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。 对象的类型注释类似于类，需要指定对象属性的类型。 Null若想任意类型 T 可以为 null 或 undefined ，只需类似如下写成 ?T 的格式即可。 123/*@flow*/var foo ?string = null 此时，foo 可以为字符串，也可以为 null 。 Flow在Vue.js源码中的应用有时我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，检查时就会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者自定义类型。而 Vue.js 也利用了这一特性。 在 Vue.js 的主目录下有 .flowconfig 文件，它是 Flow 的配置文件。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。 这里的 [libs] 配置的是 flow ，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，就会发现文件如下： 123456789flow|-- compiler.js # 编译相关|-- component.js # 组件数据结构|-- global.api.js # Global API 结构|-- modules.js # 第三方库协议|-- options.js # 选项相关|-- ssr.js # 服务端渲染相关|-- vnode.js # 虚拟node相关|-- weex.js # weex相关 总结通过对Flow的认识，有助于阅读Vue源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Node-阿里云ECS部署","slug":"Node-阿里云ECS部署","date":"2018-11-27T04:19:00.000Z","updated":"2018-12-11T14:03:41.513Z","comments":true,"path":"2018/11/27/Node-阿里云ECS部署/","link":"","permalink":"http://yoursite.com/2018/11/27/Node-阿里云ECS部署/","excerpt":"导语 双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？","text":"导语 双11抢购了一台阿里云服务器，趁工作不忙，搞了一个简单的node项目。那么问题来了，如何将node项目部署到阿里云ECS？ 此教程仅供新手借鉴，多少有些缺陷，有问题还望各位大佬指正。 准备工作 一个域名 阿里云ECS(实例镜像：CentOS7.4) 如果使用Windows，推荐xshell。如果是Mac，推荐iTerm2 (注：因本人使用Mac，以下均已Mac为主) 终端连接服务器 打开iTerm2，输入连接命令ssh username@ip公网地址，回车，输入你在购买服务器时设置的密码。 密码输入正确，进入服务器。 cd / 进入根目录，创建一个空目录 mkdir soft，用来放我们的安装包。 安装Node下载node包。 1wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz 下载完成后，进行压缩包解压。 1tar -zxvf v8.9.4.tar.gz 进入解压好的目录并执行config配置命令。 1cd node-v8.9.4 &amp;&amp; ./configure 执行编译及安装命令。 1make &amp;&amp; make install 经过漫长的等待之后，一个node环境就安装好了。可以通过node -v 或者 npm -v来检查当前node/npm是否安装成功。 如果你需要升级node和npm版本，执行以下命令即可。 12npm i -g nn stable 安装nrm和pm2nrm是一个管理npm源的插件，方便切换国内外以及私人npm库。 pm2是node服务器的守护进程，方便管理当前服务器上的所有服务。 这里说一下cnpm，如果安装依赖包很慢或者根本没进度，输入命令 1npm install -g cnpm --registry=https://registry.npm.taobao.org 然后使用cnpm代替npm安装。 回到我们熟悉的soft目录。 nrm安装nrm。 1npm install -g nrm 常用命令： nrm add name address 添加新的源 nrm use name 切换到源 nrm ls 查看所有可用的源 pm2安装pm2。 1npm install -g pm2 常用命令： pm2 list 查看pm2守护服务 pm2 start index.js 启动一个pm2守护进程命令 pm2 restart id/name 重启一个pm2守护进程命令 pm2 delete id/name 删除一个正在使用的进程 pm2 delete all 删除所有正在使用的进程 pm2 monit 查看pm2的消耗 安装mysql卸载已有的mysql。 12rpm -qa|grep -i mysqlyum remove &apos;mysql&apos; 下载mysql源。 12// 5.7.24wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm 安装下载的源。 1rpm -ivh mysql57-community-release-el7-7.noarch.rpm 下载安装mysql。 123yum install mysql-serveryum install mysql-develyum install mysql 启动mysql。 1service mysqld start 常用命令： service mysqld status 查看mysql当前的状态 service mysqld stop 停止mysql service mysqld restart 重启mysql service mysqld start 启动mysql 如果遇到错误：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket /var/lib/mysql/mysql.sock’，请在tmp下创建一个软连接： 1ln -s /tmp/mysql.sock /var/lib/mysql 打开my.cnf并修改。 1vi /etc/my.cnf 重启数据库。 1service mysqld restart 登录(默认root是没有密码的)。 1mysql -u root 这时出现ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO)，登录root帐号需要密码，现在我们没有设置密码，哪来的密码。 于是我们开始忘记密码的操作 第一步，在/etc/my.cnf文件中添加skip-grant-tables第二步，重启mysql，service mysqld restart第三步，登录mysql，mysql -u root第四步，修改密码： 1234mysql&gt;use mysql;mysql&gt;update mysql.user set authentication_string=password(&apos;your password&apos;) where user=&apos;root&apos;;mysql&gt;flush privileges;mysql&gt;exit; 第五步，恢复/etc/my.cnf，将skip-grant-tables删除或者注释掉第六步，重启mysql，service mysqld restart 分配用户 host指定该用户在哪个主机上可以登陆，此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录;也可以指定某台机器可以远程登录。 12CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;CREATE USER &apos;test&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;; 给创建的用户权限 privileges 用户的操作权限,如SELECT，INSERT，UPDATE等.如果要授予所的权限则使用ALL databasename 数据库名 tablename 表名,如果要授予该用户对所有数据库和表的相应操作权限则可用表示, 如.*. 1GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; 安装RedisRedis是一个非常好用的数据仓库，既可以做nosql数据库，也可以做缓存数据库。 下载安装包。 1wget http://download.redis.io/releases/redis-4.0.6.tar.gz 解压并进入解压之后的文件夹。 1tar -zxvf redis-4.0.6.tar.gz &amp;&amp;cd redis-4.0.6 编译并安装。 1make &amp;&amp; make install 启动redis服务。 1redis-server redis.conf 此时我们发现，不能再输入任何命令，因为redis-server已经占用了这个命令行客户端。我们需要再打开一个命令行工具并连接服务器。 使用redis客户端连接Redis服务，执行Redis文件夹下的redis-cli文件redis-cli，输入几个命令测试一下简单的set/get： 关掉客户端，redis服务也会停止。这时，我们就需要修改redis.conf文件，将daemonizede的值改为yes。 再次运行Redis的启动命令redis-server redis.conf，这次就不会占用命令行了，可以继续操作其他的，Redis服务也不会停止。 nginxnginx在转发请求，负载均衡等方面非常有用。它可以将几个不同的服务集中在一个80端口下，根据域名或者请求路径来区分。 在安装nginx之前，先要安装几个依赖插件。 12yum install -y pcre pcre-develyum install -y zlib zlib-devel 安装openssl。 1yum install -y openssl openssl-devel 下载nginx包。 1wget https://nginx.org/download/nginx-1.15.6.tar.gz 解压并进入解压好的目录。 1tar -zxvf nginx-1.15.6.tar.gz &amp;&amp; cd nginx-1.15.6 执行配置命令。 1./configure 编译并安装。 1make &amp;&amp; make install 查看安装结果。 1whereis nginx 跳转到安装好的nginx目录下，进入sbin目录。 1cd /usr/local/nginx/sbin 启动nginx。 1./nginx 常用命令： ./nginx 启动nginx ./nginx -s stop 停止nginx ./nginx -s quit 退出nginx ./nginx -s reload 重启nginx 安装GitcentOS上没有安装git，有需要的话，我们可以自己手动安装一下。 12yum install gitgit --version 使用pm2启动项目在本地搭建并测试好node项目，上传到GitHub。然后git clone一下。 配置ECS安全组规则，暴露3000接口。 如果项目中使用数据库，运行之前要先建立好数据库，然后再运行项目，登录数据库执行create database dabasename; 1234git clone https://github.com/***cd ***cnpm ipm2 start index.js 注：项目监听3000端口，如果顺利的话，项目已经运行起来了。 可以使用pm2 list查看进程列表，使用pm2 log打印日志。","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"JS-深拷贝与浅拷贝","slug":"JS-深拷贝与浅拷贝","date":"2018-10-11T10:11:52.000Z","updated":"2018-12-11T14:03:41.509Z","comments":true,"path":"2018/10/11/JS-深拷贝与浅拷贝/","link":"","permalink":"http://yoursite.com/2018/10/11/JS-深拷贝与浅拷贝/","excerpt":"导语 当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。","text":"导语 当我们在JS中复制一个数据，在复制如string，number等基本数据类型时，看似没有出现问题。但是当复制如array，object类型时。出现了意想不到的结果。 实例🌰： 1234var a = &#123;x: 10, y: 10&#125;var b = ab.x = 100b.y = 100 打印一下a和b的值： 12console.log(a) // &#123;x: 100, y: 200&#125;console.log(b) // &#123;x: 100, y: 200&#125; 发现改变b的值，同时也改了a的值。 🌰： 123var a = 10var b = ab = 20 打印一下a和b的值： 12console.log(a) // 10console.log(b) // 20 ??? b的值改变并没有引起a的值改变。 值类型 vs 引用类型在JS中，变量传递方式分为值类型和引用类型。值类型包括String，Number，Null，Boolean，Undefined。引用类型包括Object类的所有，如Date，Array，Function。 在参数传递方式上，值类型是按值传递。引用类型是按共享传递(指向同一个内存地址，两者引用同一个值，当一者改变值，另一者也改变)。 JS这样设计的原因在于：按值传递的类型，复制一份存入栈内存，这类类型一般不会占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值，保证过大的对象等不会因为不停复制内容而造成内存的浪费。 深拷贝和浅拷贝最根本的区别在于是否真正获取了一个对象的拷贝实体，而不只是引用。 浅拷贝的实现方式直接赋值🌰： 123let obj = &#123;username: &apos;kobe&apos;, age: 39, sex: &#123;option1: &apos;男&apos;, option2: &apos;女&apos;&#125;&#125;let obj1 = objobj1.sex.option1 = &apos;不男不女&apos; // 修改复制的对象会影响原对象 打印obj1的值 1console.log(obj1) // &#123;username: &apos;kobe&apos;, age: 39, sex: &#123;option1: &apos;不男不女&apos;, option2: &apos;女&apos;&#125;&#125; Object.assign🌰： 12345let obj = &#123; username: &apos;kobe&apos;&#125;;let obj1 = Object.assign(obj)obj1.username = &apos;wang&apos; 打印obj的值 1console.log(obj) // &#123; username: &quot;wang&quot; &#125; Array.prototype.concat🌰： 12345let arr = [1, 3, &#123; username: &apos;kobe&apos;&#125;]let arr2=arr.concat()arr2[2].username = &apos;wang&apos; 打印arr的值 1console.log(arr) // [1, 3, &#123; username: &quot;wade&quot; &#125;] Array.prototype.slice🌰： 12345let arr = [1, 3, &#123; username: &apos;kobe&apos;&#125;]let arr2=arr.slice()arr2[2].username = &apos;wang&apos; 打印arr的值 1console.log(arr) // [1, 3, &#123; username: &quot;wade&quot; &#125;] Array.prototype.concat vs Array.prototype.slice关于Array的concat和slice补充说明：Array的concat和slice方法不改变原始数组，只是返回了一个浅复制原数组中的元素的一个新数组。 原数组中的元素会按照下述规则拷贝： 如果该元素是个引用类型，slice或者concat会拷贝这个引用到新的数组里，两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新数组和原数组中的这个元素都会发生改变。 如果该元素是个值类型，slice或者concat会复制一份这些值到新数组里。在别的数组里修改这些值，并不会影响另一个数组。 🌰： 123456let arr = [1, 3, &#123; username: &apos;kobe&apos;&#125;];let arr3 = arr.slice();arr3[1] = 2console.log(arr, arr3) 打印arr和arr3的值 1234console.log(arr, arr3)// ---result// [1, 3, &#123; username: &quot;kobe&quot; &#125;]// [1, 2, &#123; username: &quot;kobe&quot; &#125;] 深拷贝的实现方式Object.assignObject.assign可以进行一层深度拷贝 🌰： 12345678910var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = Object.assign(&#123;&#125;, obj1)obj1.age = 24console.log(obj, obj1) 打印obj和obj1的值 1234console.log(obj, obj1)// ----result// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; &#125;, age: 24 &#125; 然而。。。。。 🌰： 123456789var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = Object.assign(&#123;&#125;, obj1)obj1.test4.age = 24 打印obj和obj1的值 1234console.log(obj, obj1)// ----result// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; age: 24 &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; age: 24 &#125; &#125; JSON.parse(JSON.stringfy(obj))说到深拷贝，你肯定会想到JSON.parse(JSON.stringfy(obj))。 🌰： 12345678var obj = &#123; name: &apos;wang&apos;, test: &#123; name: &apos;test&apos; &#125; &#125;;var obj1 = JSON.parse(JSON.stringify(obj))obj1.test.name = 24 打印obj和obj1的值 1234console.log(obj, obj1)// ----result// &#123; name: &quot;wang&quot;, test: &#123; name: &quot;test&quot; &#125; &#125;// &#123; name: &quot;wang&quot;, test: &#123; name: 24 &#125; &#125; 然而。。。。 🌰： 12345678var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = JSON.parse(JSON.stringify(obj)) 打印obj和obj1的值 1234console.log(obj, obj1)// ---result// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123; &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test4: &#123; &#125; &#125; ???test2和test3不见了。。。。。 JSON.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个JSON字符串，不能接受函数。 手写递归方法1234567891011121314151617181920function deepClone(obj) &#123; let result let toString = Object.prototype.toString if (toString.call(obj) === &apos;[Object Array]&apos;) &#123; result = [] for (var i =0; i&lt;obj.length; i++) &#123; result[i] = deepClone(obj[i]) &#125; &#125; else if (toString.call(obj) === &apos;[Object Object]&apos;) &#123; result = &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; result[key] = deepClone(obj[key]) &#125; &#125; &#125; else &#123; return obj &#125; return result&#125; 🌰：调用函数并打印结果 1234567891011var obj = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj1 = deepClone(obj)console.log(obj, obj21)// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: Object &#123; &#125; &#125;// &#123; name: &quot;wang&quot;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: Object &#123; &#125; &#125; jQuery实现🌰： 12345678var obj1 = &#123; name: &apos;wang&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = $.extend(true, &#123;&#125;, obj1) lodash实现🌰： 12345678var obj1 = &#123; name: &apos;wclimb&apos;, test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = _.cloneDeep(obj1)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS-事件的防抖和节流","slug":"JS-事件的防抖和节流","date":"2018-10-10T10:11:52.000Z","updated":"2018-12-11T14:03:41.509Z","comments":true,"path":"2018/10/10/JS-事件的防抖和节流/","link":"","permalink":"http://yoursite.com/2018/10/10/JS-事件的防抖和节流/","excerpt":"导语 窗口的resize、scroll、mousemove、mouseover等事件被频繁触发时，其对应的回调函数也会被频繁触发而导致页面抖动甚至卡顿。","text":"导语 窗口的resize、scroll、mousemove、mouseover等事件被频繁触发时，其对应的回调函数也会被频繁触发而导致页面抖动甚至卡顿。 为了规避这种情况，我们需要一些手段来控制事件被触发的频率。此时，事件节流(throttle)和事件防抖(debounce)出现了。 “节流”与”防抖”的本质这两个东西都以闭包的形式存在。 它们通过对事件对应的回调函数进行包裹，以自由变量的形式缓存事件信息，然后用setTimeout来控制事件的触发频率。 Throttle：”节流”持续触发事件时，throttle会合并一定时间内的事件，并在该事件结束时真正去触发一次事件。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Webpack-webpack-dev-server","slug":"Webpack-webpack-dev-server","date":"2018-09-26T07:15:00.000Z","updated":"2018-12-11T14:03:41.515Z","comments":true,"path":"2018/09/26/Webpack-webpack-dev-server/","link":"","permalink":"http://yoursite.com/2018/09/26/Webpack-webpack-dev-server/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 webpack-dev-serverwebpack-dev-server为webpack提供的一个静态服务的工具，并能够实时重新加载。 基础使用安装： 1npm i webpack-dev-server -D package.json添加scripts配置： 123456&#123; // ... &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --mode development&quot; // 指定mode为development &#125;&#125; 1npm run dev 如果项目构建了HTML文件，直接访问http://localhost:8080/就可以看到index.html页面了。否则，就会看到一个静态资源列表列表的页面。 基础配置在webpack配置中，可以通过devServer字段来配置webpack-dev-server。 12345module.exports = &#123; devServer: &#123; // ... &#125;&#125; host：指定使用一个host，默认是localhost。 port：指定端口号，默认是8080。 publicPath: 构建好的静态文件在浏览器中以什么路径去访问，默认为’/‘。假设服务器运行在http://localhost:8080，并且output.filename被设置为bundle.js。完整的访问路径是 http://localhost:8080/bundle.js，如果你配置了 publicPath: ‘assets/‘，那么上述 bundle.js 的完整访问路径就是 http://localhost:8080/assets/bundle.js。 建议devServer.publicPath和output.publicPath一样。 proxy：配置代理 123456proxy: &#123; &apos;/api&apos;: &#123; target: &apos;http://localhost:3000&apos; // 将url中带有/api的请求代理到本地3000端口的服务器上 pathRewrite: &#123;&apos;^/api&apos;: &apos;&apos;&#125; // 把URL中path部分的api去掉 &#125;&#125; color：启用/jiny9ong控制台的彩色输出。 contentBase：提供未经webpack构建的额外静态文件内容的目录。 12345// 使用当前目录下的 publiccontentBase: path.join(__dirname, &quot;public&quot;)// 也可以使用数组提供多个路径contentBase: [path.join(__dirname, &quot;public&quot;), path.join(__dirname, &quot;assets&quot;)] publicePath的优先级高于constBase。 before：在服务内部的所有其他中间件之前， 提供执行自定义中间件的功能。 after：在服务内部的所有其他中间件之后， 提供执行自定义中间件的功能。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"Webpack-基础使用","slug":"Webpack-基础使用","date":"2018-09-25T07:15:00.000Z","updated":"2018-12-11T14:03:41.515Z","comments":true,"path":"2018/09/25/Webpack-基础使用/","link":"","permalink":"http://yoursite.com/2018/09/25/Webpack-基础使用/","excerpt":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。","text":"导语 webpack是一个现代JavaScript应用程序的静态模块打包器，在webpack处理应用程序时，它会在内部创建一个依赖图，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 安装使用npm或者yarn来安装webpack 全局安装12345$ npm i webpack webpack-cli -gor$ yarn -g add webpack webpack-cli 等待安装完毕，就可以全局执行webpack命令了。注：webpack-cli在4.x版本之后不再作为webpack的依赖了，我们使用时需要单独安装。 局部安装在项目中，我们更推荐将webpack作为项目的开发依赖来安装使用，这样可以指定项目中使用的webpack版本。 12345$ npm i webpack webpack-cli -Dor$ yarn add webpack webpack-cli -D 等待安装完毕，webpack会出现在项目的package.json文件中，我们添加一个npm scripts: 1234567&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --mode production&quot;&#125;,&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.1.1&quot;, &quot;webpack-cli&quot;: &quot;^2.0.12&quot;,&#125; 项目根目录新建./src/index.js，任意写JS代码，保存，执行npm run build或者yarn build命令，我们会发现项目根目录下新增了一个dist目录，里面存放了webpack构建好的main.js文件。 webpack4.x可以零配置就开始构建，但有时我们的项目需要更多的功能。 基本概念先放一张经典图： 入口如上图左上角的.js，这个.js就是多个代码模块的入口，也是webpack构建的入口。webpack会读取这个文件，并从它开始解析依赖，然后进行打包。 在我们的项目中，如果是单页应用，那么可能入口只有一个。如果是多页应用，那么经常是一个页面对应一个构建入口。 用法：entry 单个入口语法12345678910// 简写module.exports = &#123; entry: &apos;./src/index&apos;&#125;module.exports = &#123; entry: &#123; main: &apos;./src/index&apos; &#125;&#125; 多个入口语法123456module.exports = &#123; entry: &#123; foo: &apos;./src/foo&apos;, bar: &apos;./src/bar&apos; &#125;&#125; 输出输出即指webpack最终构建出来的静态文件，构建结果的文件名，路径等都是可以配置的。 用法：output 12345678910111213141516171819202122module.exports = &#123; output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125;// 多个入口生成不同的文件module.exports = &#123; output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].js&apos; &#125;&#125;// 路径中使用hash，每次构建都有一个不同的hash值，避免发布新版本使用浏览器缓存module.exports = &#123; output: &#123; path: path.resolve(__dirname, &apos;dist/[hash]&apos;), filename: &apos;[name].js&apos; &#125;&#125; loaderloader，我们可以理解为一个转换器，负责把某种文件格式的内容转换成webpack可以支持打包的模块。 默认情况下，webpack会默认把所有依赖打包成JS文件，如果入口文件依赖一个.pug模块文件或者.scss样式文件，那么我们就需要相应的loader来把不同格式的文件转换为JavaScript，以便打包后在浏览器运行。 用法：module.rules 12345678910111213module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.jsx?/, // 条件 include: [ path.resolve(__dirname, &apos;src&apos;) ], // 条件 use: &apos;babel-loader&apos; // 规则应用结果 &#125; // 一个Object即一条规则 ] &#125;&#125; loader匹配规则中最重要的两个因素：匹配条件和匹配规则后的应用。 规则条件配置匹配条件通常使用请求资源文件的绝对路径来进行匹配，官方文档成为resource。 上述代码中的test和include都用于匹配resource路径，是resource.test和resource.include的简写。你也可以这样写： 123456789101112131415module.exports = &#123; // ... rules: [ &#123; resource: &#123; // resource 的匹配条件 test: /\\.jsx?/, include: [ path.resolve(__dirname, &apos;src&apos;), ] &#125;, use: &apos;babel-loader&apos; &#125;, // ... ],&#125; webpack为loader提供了多种匹配条件的配置方式： test: … 匹配特定条件 include: … 匹配特定路径 exclude: … 排除特定路径 and: [] 必须匹配数组中的所有条件 or: [] 匹配数组中的任意一个条件 not: [] 排除匹配数组中的所有条件 条件值类型： 字符串：必须以提供的字符串开始（绝对路径） 正则表达式 数组：至少包含一个条件的数组 对象：匹配所有属性值的条件 函数：返回true表示匹配 规则应用配置匹配规则后的应用，我们可以使用use字段： 1234567891011121314151617181920rules: [ &#123; test: /\\.less/, use: [ &apos;style-loader&apos;, &#123; loader: &apos;css-loader&apos;, options: &#123; // ... &#125; &#125;, &#123; loader: &apos;less-loader&apos;, options: &#123; // ... &#125; &#125; ] &#125;] 使用options可以给对应的loader传递一些配置项。 对于上述的less规则应用配置，一个less模块文件可以经过多个loader的转换处理，执行顺序为从右到左。 如果多个rule匹配了同一个模块文件，loader的应用顺序应该如何处理？ 12345678910rules: [ &#123; test: /\\.js$/, loader: &quot;eslint-loader&quot;, &#125;, &#123; test: /\\.js$/, loader: &quot;babel-loader&quot;, &#125;] eslint-loader用于检查人工编写的代码，babel-loader用于转换代码。所以，eslint-loader应该在babel-loader之前执行，那么该如何保证执行顺序？ webpack为每一个匹配规则提供了enforce字段来配置当前rule得的loader类型。pre(前置) &gt; 行内 &gt; 普通 &gt; 后置(post)。 我们要确保eslint-loader在babel-loader之前执行，只需给rule规则项添加enforce字段，并设置其值为pre。 1234567891011rules: [ &#123; enforce: &apos;pre&apos;, test: /\\.js$/, loader: &quot;eslint-loader&quot;, &#125;, &#123; test: /\\.js$/, loader: &quot;babel-loader&quot;, &#125;] 常用rule配置项CSS123456789101112131415161718192021const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: &apos;css-loader&apos;, &#125;) &#125; ] &#125;, plugins: [ // 引入插件，配置文件名，这里同样可以使用 [hash] new ExtractTextPlugin(&apos;[name].css&apos;), ],&#125; css-loader：负责解析CSS代码，主要处理CSS中的依赖，🌰：@import、url()等。 style-loader：将css-loader解析的结果转变为JS代码，运行时动态插入style标签来让CSS生效。 预处理器12345678910111213141516171819module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.less/, // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [&apos;css-loader&apos;, &apos;less-loader&apos;], &#125;) &#125; ] &#125;, plugins: [ // 引入插件，配置文件名，这里同样可以使用 [hash] new ExtractTextPlugin(&apos;[name].css&apos;) ]&#125; 图片webpack无法处理图片格式，我们选择file-loader，它不仅可以处理图片格式，还可用于处理其它很多类型的文件。直接输出文件，将构建后的文件路径返回。 1234567891011module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: &apos;file-loader&apos; &#125; ] &#125;&#125; BabelBabel是一个让我们能够使用ES6、ES7等新标准来编写JS的编译工具。 1234567891011module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.jsx?/, loader: &apos;babel-loader&apos; &#125; ] &#125;&#125; plugin插件是webpack的支柱功能，在于解决loader无法实现的其他事情。 用法：plugin 12345const UglifyPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)module.exports = &#123; plugins: [new UglifyPlugin()]&#125; 常见webpack plugin使用HtmlWebpackPluginwebpack默认从作为入口的JS文件进行构建，但通常一个前端项目都是从一个页面(HTML)出发的。通常我们会创建一个HTML文件，使用script标签直接引入构建好的js文件。 1&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt; 然而，问题来了，如果我们的文件名或者路径变化，每次构建完成后，我们要手动去修改HTML文件中的js路径? 如果能将HTML引用路径和我们的webpack构建结果关联起来就好了。 html-webpack-plugin就可以帮我们解决这个问题。 12345npm i html-webpack-plugin -Doryarn add html-webpack-plugin -D 然后在webpack配置中，将html-webpack-plugin添加到plugins列表中： 12345678const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(), ],&#125; 配置好之后，构建时html-webpack-plugin会为我们创建一个HTML文件，其中会引用构建出来的JS文件。 我们还可以在html-webpack-plugin中传递我们自己写好的HTML模板： 1234567891011const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(&#123; filename: &quot;index.html&quot;, template: &quot;assets/index.html&quot; &#125;), ],&#125; DefinePluginDefinePlugin是webpack的内置插件，可以通过webpack.DefinePlugin直接引用。 主要用于创建一些在编译时可以配置的全局变量。 12345678910111213module.exports = &#123; // ... plugins: [ new webpack.DefinePlugin(&#123; VERSION: JSON.stringfy(&apos;v1.1.0&apos;), // const VERSION = &apos;v1.1.0&apos; TWO: &apos;1 + 1&apos;, // const TWO = 2 BROWSER_SUPPORT: true, // const BROWSER_SUPPORT = &apos;true&apos; CONSTANTS: &#123; APP_VERSION: JSON.stringfy(&apos;1.1.1&apos;) &#125; // const CONSTANTS = &#123; APP_VERSION: &apos;1.1.1&apos;&#125; &#125;) ]&#125; 配置好之后，我们就可以在应用代码中，访问配置好的变量了。 1console.log(VERSION) 有关配置的值，简述一下配置规则： 如果配置的值为字符串，那么整个字符串会被当做代码片段来执行，其结果将作为最终配置的值。 如果配置的值不是字符串，也不是对象字面量，那么该值会被转换为一个字符串。 如果配置的值是一个对象字面量，那么该对象的所有key会以同样的方式去定义。 CopyWebpackPlugin通常我们会把源码和资源文件放在项目的src目录下，构建完成后会有一个dist目录，我们会直接拿dist目录中的所有文件来发布。有些文件没有经过webpack处理，但是我们希望它们也能出现在dist目录下，这时，我们就可以使用CopyWebpackPlugin来处理。 12345678910const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)module.exports = &#123; // ... plugins: [ new CopyWebpackPlugin([ &#123; from: &apos;src/*.txt&apos;, to: &apos;dist/*.txt&apos; &#125; // from: 配置来源；to: 配置目标 ]) ]&#125; ExtractTextWebpackPlugin通常CSS经过相应的loader处理后，会转换为JS，和index.js一起打包。如果需要单独把CSS文件分离出来，就需要使用extract-text-webpack-plugin插件。 1234567891011121314151617181920const ExtractTextWebpackPlugin = require(&apos;extract-text-webpack-plugin&apos;)module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: &apos;css-loader&apos; &#125;) &#125; ] &#125;, plugins: [ // style.css 作为单独分离出来的文件名 new ExtractTextWebpackPlugin(&apos;style.css&apos;) ]&#125; 它还可以为每一个入口创建单独分离的文件，所以，最好这样配置： 123plugins: [ new ExtractTextPlugin(&apos;[name].css&apos;),] ProvidePluginProvidePlugin是webpack的内置插件，可以通过webpack.ProvidePlugin直接引用。 主要用于自动加载模块，不必到处import或require 1234567891011new webpack.ProvidePlugin(&#123; identifier: &apos;module&apos;, // ...&#125;)ornew webpack.ProvidePlugin(&#123; identifier: [&apos;module&apos;, &apos;property&apos;], // 即引用 module 下的 property，类似 import &#123; property &#125; from &apos;module&apos; // ...&#125;) 任何时候，当identifier被当作未赋值的变量时，module就会自动被加载，并且identifier会被这个module输出的内容所赋值。 注：如果是ES的default export，那么你需要指定模块的default属性：identifier: [‘module’, ‘default’]。 IgnorePluginIgnorePlugin是webpack的内置插件，可以通过webpack.IgnorePlugin直接引用。 主要用于忽略某些特定的模块，让webpack不把这些指定的模块打包进去。 配置参数：匹配引入模块路径的正则表达式，匹配模块的上下文。 123456module.exports = &#123; // ... plugins: [ new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) ]&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"Linux-常用命令","slug":"Linux-常用命令","date":"2017-10-03T08:41:00.000Z","updated":"2018-12-11T14:03:41.511Z","comments":true,"path":"2017/10/03/Linux-常用命令/","link":"","permalink":"http://yoursite.com/2017/10/03/Linux-常用命令/","excerpt":"导语 这篇文章主要是为了使用Linux系统服务器做开发，总结的一些常用命令。","text":"导语 这篇文章主要是为了使用Linux系统服务器做开发，总结的一些常用命令。 Linux常用操作指令列表 命令 说明 ssh username@ip 连接服务器 cd path 跳转到路径对应的目录下 rm filename 删除文件 rm -rf path 删除目录及目录下的所有文件 ls [-a] 查看当前目录下的文件和目录(-a：查看所有文件，包括隐藏文件) ll 查看当前目录下的文件详情(文件权限) pwd 查看当前路径的完整路径 which name 默认位置查找该名字 mkdir dirname 创建空目录 cat path 查看文件内容 cp origin target 复制一个文件到另一个地方 mv origin target 移动一个文件到另一个地方 ps -aux 显示当前进程 kill -9 processid 结束进程 tar -zxvf filename 解压文件 tar -zcvf filename 压缩文件 vi path 进入文件编辑模式 vi编辑文件，按下i进入编辑模式 vi退出文件，esc+:wq或esc+:x保存退出 vi退出文件，esc+:q或esc+:q!强制退出","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"小程序-全栈开发(mpvue+koa2+mysql)","slug":"小程序-全栈开发(mpvue+koa2+mysql)","date":"2017-09-02T08:06:52.000Z","updated":"2018-12-11T14:03:41.518Z","comments":true,"path":"2017/09/02/小程序-全栈开发(mpvue+koa2+mysql)/","link":"","permalink":"http://yoursite.com/2017/09/02/小程序-全栈开发(mpvue+koa2+mysql)/","excerpt":"导语 接触小程序并做了一些项目之后，又开始了Vue的旅程，受其核心思想的影响，对数据/状态管理、组件化、跨平台等都有较高的追求，mpvue 是一个使用 Vue.js开发小程序的前端框架，由此开始了mpvue踩坑之旅，想在提高代码可读性的同时，也增加一点Vue.js的开发体验。","text":"导语 接触小程序并做了一些项目之后，又开始了Vue的旅程，受其核心思想的影响，对数据/状态管理、组件化、跨平台等都有较高的追求，mpvue 是一个使用 Vue.js开发小程序的前端框架，由此开始了mpvue踩坑之旅，想在提高代码可读性的同时，也增加一点Vue.js的开发体验。 技术栈 前端： 微信小程序、mpvue、 eslint、sass、ES6、ES7后端：koa2、Koa-Router、Knex、腾讯云Wafer2数据库：Mysql数据库可视化工具：Navicate Premium 小程序介绍一个功能简单的小程序，包含了个人中心、图书列表、个人评论列表三个tab页，后端的数据定义、分类、和存取等，各有其色。 成果分享个人中心： 个人中心： 图书列表： 图书详情： 评论列表： 脑图 初始化项目*全局安装vue-cli $npm install –global vue-cli *创建基于mpvue-quickstart模板的新项目，一路回车。 $vue init mpvue/mpvue-quickstart koa-wx *安装依赖 $cd koa-wx $npm install $npm run dev 项目目录123456789101112131415161718192021222324252627282930313233343536373839404142├── build // 构建相关 ├── config // 配置相关├── dist // 编译后静态文件 ├── node_modules // 依赖相关├── server // 服务端源代码│ ├── controllers │ ├── middlewares │ ├── node_modules │ ├── routes │ ├── tools │ ├── .eslintrc.js │ ├── .eslintrc.json │ ├── app.js │ ├── config.js │ ├── nodemon.json │ ├── package.json │ ├── process.prod.json │ ├── qcloud.js │ ├── README.md │ ├── tools.md ├── src // 前端源代码│ ├── components │ ├── config │ ├── mock │ ├── pages │ ├── styles │ ├── utils │ ├── App.vue │ ├── main.js │ ├── store.js │ ├── weui.css ├── static ├── .babelrc ├── .editorconfig ├── .eslintignore ├── .eslintrc.js ├── .postcssrc.js ├── index.html └── package.json └── package-lock.json └── project.config.json └── README.md 搭建后端本地开发环境打开 server/config.js添加以下配置： 123456789101112const CONF = &#123; // 其他配置 ... serverHost: &apos;localhost&apos;, tunnelServerUrl: &apos;&apos;, tunnelSignatureKey: &apos;27fb7d1c161b7ca52d73cce0f1d833f9f5b5ec89&apos;, // 腾讯云相关配置可以查看云 API 秘钥控制台：https://console.cloud.tencent.com/capi qcloudAppId: &apos;您的腾讯云 AppID&apos;, qcloudSecretId: &apos;您的腾讯云 SecretId&apos;, qcloudSecretKey: &apos;您的腾讯云 SecretKey&apos;, wxMessageToken: &apos;weixinmsgtoken&apos;, networkTimeout: 30000&#125; 并修改 MySQL 相关的配置为本地的 MySQL 数据库。 12345678mysql: &#123; host: &apos;localhost&apos;, port: 3306, user: &apos;root&apos;, db: &apos;cAuth&apos;, pass: &apos;******&apos;, char: &apos;utf8mb4&apos; &#125;, *切换到服务端代码目录$cd server *安装依赖$npm install *安装全局依赖$npm install -g nodemon $npm run dev 初始化数据库 - 打开 terminal 输入如下命令： $node tools/initdb.js 进入Mysql选中刚才创建的数据库，输入 show tables; 可以看到初始化时创建了一个名叫 cSessionInfo 的表。说明本地环境已经搭建成功。 部署到腾讯云环境当本地本地开发出一版时，可以部署到腾讯云的开发环境，这样就可以在线上访问该项目。 首先修改项目根目录的 project.config.json 文件，添加： 1&quot;qcloudRoot&quot;: &quot;./server/&quot;, 然后将本地开发时添加到 server/config.js 的配置删除，在 mysql.pass 那里填上自己的 APPID。 接着进入小程序开发工具，点击右上角的 腾讯云，上传测试代码，弹出如图选项。第一次部署如下选择，之后再次上传选择 智能上传 即可。部署成功会有提示。 ###上传前端代码 在小程序开发工具右上角找到 上传 选项，填写版本信息，上传后进入开发者控制台，开发管理页面，将该小程序设置为体验版本。 然后在用户身份 ==&gt; 成员管理中，添加项目成员，配置权限，这样好友也可以体验该小程序了。 项目地址：https://github.com/wangqian2017/mpvue-koa2","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"Vue-移动端自动转换px为rem(postcss-pxtorem)","slug":"Vue-移动端自动转换px为rem(postcss-pxtorem)","date":"2017-08-25T09:41:00.000Z","updated":"2018-12-11T14:03:41.583Z","comments":true,"path":"2017/08/25/Vue-移动端自动转换px为rem(postcss-pxtorem)/","link":"","permalink":"http://yoursite.com/2017/08/25/Vue-移动端自动转换px为rem(postcss-pxtorem)/","excerpt":"导语 前端在开发移动端webapp还原设计稿的重要性母庸质疑，目前来说应用最多的应该是rem。然而很多前端开发依然选择要么自己去计算rem值，要么依靠编辑器安装插件转换。","text":"导语 前端在开发移动端webapp还原设计稿的重要性母庸质疑，目前来说应用最多的应该是rem。然而很多前端开发依然选择要么自己去计算rem值，要么依靠编辑器安装插件转换。 其实，通过一系列的配置后，我们在开发中可以直接使用设计图的尺寸，它为我们自动编译，转换成rem。 技术栈 vue-cli@3.0: 脚手架工具创建项目 postcss-pxtorem: 转换px为rem的依赖包 只需以下几步，就可以愉快地开发了😊。 创建rem.js文件123456789101112131415// 基准大小const baseSize = 32// 设置 rem 函数function setRem() &#123; // 当前页面宽度相对于 750 宽的缩放比例，可根据自己需要修改。 const scale = document.documentElement.clientWidth / 750 // 设置页面根节点字体大小 document.documentElement.style.fontSize = baseSize * Math.min(scale, 2) + &apos;px&apos;&#125;// 初始化setRem()// 改变窗口大小时重新设置 remwindow.onresize = function() &#123; setRem()&#125; main.js中引入rem.js1import &apos;./utils/rem&apos; 引入文件后，可以看到页面的html节点，被自动添加 font-size 安装并配置postcss-pxtoren安装postcss-pxtorem1$ npm install postcss-pxtorem -D 修改跟目录postcss.config.js12345678910111213141516171819202122module.exports = &#123; plugins: &#123; autoprefixer: &#123; browsers: [&apos;Android &gt;= 4.0&apos;, &apos;iOS &gt;= 7&apos;] &#125;, &apos;postcss-pxtorem&apos;: &#123; rootValue: 32, // The root element font size propList: [&apos;*&apos;], // The properties that can change from px to rem. minPixelValue: 20, // Set the minimum pixel value to replace. selectorBlackList: [ &apos;.weui-&apos;, &apos;.ig-&apos;, &apos;.vux-&apos;, &apos;.scroller-&apos;, &apos;.dp-&apos;, &apos;.mt-&apos;, &apos;.mint-&apos;, &apos;.range&apos; ] // The selectors to ignore and leave as px. &#125; &#125;&#125; 按上述完成配置后，即可在开发中直接使用px单位开发。 举个🌰： 123body &#123; width: 750px;&#125; 转换后： 123body &#123; width: 23.4375rem;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"Vue-小技巧总结[转]","slug":"Vue-小技巧总结","date":"2017-07-03T09:41:00.000Z","updated":"2018-12-11T14:03:41.514Z","comments":true,"path":"2017/07/03/Vue-小技巧总结/","link":"","permalink":"http://yoursite.com/2017/07/03/Vue-小技巧总结/","excerpt":"导语 这篇文章主要是为了将开发过程中知道的一些小技巧进行总结，帮助使用Vue开发的小伙伴们愉快地采坑。","text":"导语 这篇文章主要是为了将开发过程中知道的一些小技巧进行总结，帮助使用Vue开发的小伙伴们愉快地采坑。 组件实例style的scoped场景：在组件中用js动态创建的dom，添加样式不生效 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; let a = document.querySelector(&apos;test&apos;) let newDom = document.createElement(&apos;div&apos;) newDom.setAttribute(&apos;class&apos;, &apos;testAdd&apos;) a.appendChild(newDom)&lt;/script&gt;&lt;style scoped&gt; .test&#123; background:blue; height:100px; width:100px; &#125; .testAdd&#123; background:red; height:100px; width:100px; &#125;&lt;/style&gt; 结果： 1234567// test生效 testAdd 不生效&lt;div data-v-1b971ada class=&quot;test&quot;&gt;&lt;div class=&quot;testAdd&quot;&gt;&lt;/div&gt;&lt;/div&gt;.test[data-v-1b971ada] &#123; // 注意data-v-1b971ada background:blue; height:100px; width:100px;&#125; 原因: 当 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素。它会为组件中所有的标签和class样式添加一个scoped标识，就像上面结果中的data-v-1b971ada。所以原因就很清楚了：因为动态添加的dom没有scoped添加的标识，没有跟testAdd的样式匹配起来，导致样式失效。 解决方式： 去掉该组件的scoped 动态添加style 123newDom.style.height=&apos;100px&apos;;newDom.style.width=&apos;100px&apos;;newDom.style.background=&apos;red&apos;; Vue 数组/对象更新 视图不更新123456789101112131415161718data() &#123; // data数据 return &#123; arr: [1,2,3], obj:&#123; a: 1, b: 2 &#125; &#125;; &#125;, // 数据更新 数组视图不更新 this.arr[0] = &apos;OBKoro1&apos;; this.arr.length = 1; console.log(arr);// [&apos;OBKoro1&apos;]; // 数据更新 对象视图不更新 this.obj.c = &apos;OBKoro1&apos;; delete this.obj.a; console.log(obj); // &#123;b:2,c:&apos;OBKoro1&apos;&#125;&#125; 由于js的限制，Vue 不能检测以上数组的变动，以及对象的添加/删除，很多人会因为像上面这样操作，出现视图没有更新的问题。 解决方式： this.$set(array)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Node-npm常用操作指令","slug":"Node-npm常用操作指令","date":"2017-06-15T08:06:52.000Z","updated":"2018-12-11T14:03:41.512Z","comments":true,"path":"2017/06/15/Node-npm常用操作指令/","link":"","permalink":"http://yoursite.com/2017/06/15/Node-npm常用操作指令/","excerpt":"导语 NPM，全程Node Package Manager，即Node.js模块管理工具。","text":"导语 NPM，全程Node Package Manager，即Node.js模块管理工具。 NPM常用操作指令列表 命令 说明 npm install 安装模块 npm uninstall 卸载模块 npm update 更新模块 npm outdated 检查模块是否已经过时 npm ls 查看安装的模块 npm init 初始化项目的package.json npm help 查看命令的详细帮助 npm root 查看包的安装路径 npm config 查看npm的配置路径 npm cache 管理模块的缓存 npm start 启动模块 npm stop 停止模块 npm restart 重启模块 npm view 查看模块的注册信息 npm version 查看模块版本 npm test 测试模块 npm adduser 添加用户 npm publish 发布模块 npm access 在发布的包上设置访问级别","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"},{"name":"NPM","slug":"NPM","permalink":"http://yoursite.com/tags/NPM/"}]},{"title":"JS-精心收集的48个JavaScript代码片段","slug":"JS-精心收集的48个JavaScript代码片段","date":"2017-05-11T13:06:52.000Z","updated":"2018-12-11T14:03:41.511Z","comments":true,"path":"2017/05/11/JS-精心收集的48个JavaScript代码片段/","link":"","permalink":"http://yoursite.com/2017/05/11/JS-精心收集的48个JavaScript代码片段/","excerpt":"导语 该文章摘自Github用户Chalarangelo，目前已在Github上获得了5K多个star，精心收集了多达48个有用的JavaScript代码片段。","text":"导语 该文章摘自Github用户Chalarangelo，目前已在Github上获得了5K多个star，精心收集了多达48个有用的JavaScript代码片段。 Anagrams of string(带有重复项)使用递归，对于给定字符串中的每个字母，为字母创建字谜。使用map()将字母与每部分字谜结合，然后使用reduce()将所有字谜组合到一个数据中，最基本情况是字符串长度等于2或1。 123456const anagrams = str =&gt; &#123; if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str]; return str.split(&apos;&apos;).reduce((acc, letter, i) =&gt; &#123; acc.concat(anagrams(str.slice(0, 1) + str.slice(i + 1)).map(val =&gt; letter + val))&#125;, []);&#125;;// anagrams(&apos;abc&apos;) -&gt; [&apos;abc&apos;,&apos;acb&apos;,&apos;bac&apos;,&apos;bca&apos;,&apos;cab&apos;,&apos;cba&apos;] 数组平均值使用reduce()将每个值添加到累加器，初始值为0，总和除以数组长度。 12const average = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0) / arr.length;// avarage([1, 2, 3]) -&gt; 2 大写每个单词的首字母使用replace()匹配每个单词的第一个字符，并使用toUpperCase()来将其大写。 12const capitalizeEveryWord = str =&gt; str.replace(/\\b[a-z]/g, char =&gt; char.toUpperCase());// capitalizeEveryWord(&apos;hello world!&apos;) -&gt; &apos;Hello World!&apos; 首字母大写使用slice (0,1)和toUpperCase ()大写第一个字母，slice (1)获取字符串的其余部分。省略lowerRest参数以保持字符串的其余部分不变，或将其设置为true以转换为小写。(注：这和上一示例不是同一件事情) 1234const capitalize = (str, lowerRest = false) =&gt; &#123; str.slice(0, 1).toUpperCase() + (lowerRest ? str.slice(1).toLowerCase() : str.slice(1));&#125;// capitalize(&apos;myName&apos;, true) -&gt; &apos;Myname&apos; 检查回文将字符串转换为toLowerCase ()，并使用replace ()从中删除非字母的字符串。然后，将其转换为toLowerCase ()，将(‘’)拆分为单独字符，reverse ()，join (‘’)，与原始的非反转字符串进行比较，然后将其转换为toLowerCase ()。 12345const palindrome = str =&gt; &#123; const s = str.toLowerCase().replace(/[\\W_]/g, &apos;&apos;); return s === s.split(&apos;&apos;).reverse().join(&apos;&apos;);&#125;// palindrome(&apos;taco cat&apos;) -&gt; true 计算数组中值的出现次数每次遇到数组中的特别值时，使用reduce()来递增计数器。 12const countOccurrences = (arr, value) =&gt; arr.reduce((a, v) =&gt; v === value ? a + 1:a + 0, 0);// countOccurrences([1, 1, 2, 1, 2, 3], 1) -&gt; 3 当前URL使用windows.location.href来获取当前URL。 12const currentUrl = () =&gt; return window.location.href;// currentUrl() -&gt; &apos;https://google.com&apos; Curry使用递归。如果提供的参数(args)数量足够，则调用传递函数f，否则返回一个curried函数f。 12345const curry = (fn, arity = fn.length, ...args) =&gt; &#123; arity &lt;= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);&#125;// curry(Math.pow)(2)(10) -&gt; 1024// curry(Math.min, 3)(10)(50)(2) -&gt; 2 Deep flatten array使用递归，使用reduce()来获取所有不是数组的元素，flatten每个元素都是数组。 1234const deepFlatten = arr =&gt; &#123; arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? deepFlatten(v) : v), []);&#125;// deepFlatten([1, [2], [[3], 4], 5]) -&gt; [1, 2, 3, 4, 5] 数组之间的区别从b创建一个Set，然后在a上使用Array.filter()，只保留b中不包含的值。 12345const difference = (a, b) =&gt; &#123; const s = new Set(b); return a.filter(x =&gt; !s.has(x))&#125;// difference([1, 2, 3], [1, 2]) -&gt; [3] 两点之间的距离使用Math.hypot()计算两点之间的欧几里德距离。 12const distance = (x0, y0, x1, y1) =&gt; Math.hypot(x1 - x0, y1 - y0);// distance(1,1, 2,3) -&gt; 2.23606797749979 可以按数字整除使用模运算符(%)来检查余数是否等于0。 12const isDivisible = (dividend, divisor) =&gt; dividend % divisor === 0;// isDivisible(6, 3) -&gt; true 转义正则表达式使用replace()来转义特殊字符。 12const escapeRegExp = str =&gt; str.replace(/[.*+?^$&#123;&#125;()|[\\]\\\\]/g, &apos;\\\\$&amp;&apos;);// escapeRegExp(&apos;(test)&apos;) -&gt; \\\\(test\\\\) 偶数或奇数使用Math.abs()将逻辑扩展为负数，使用模(%)运算符进行检查。如果数字是偶数，则返回true；如果数字是奇数，则返回false。 12const isEven = num =&gt; Math.abs(num) % 2 === 0;// isEven(3) -&gt; false 阶乘使用递归。如果n小于或等于1，则返回1。否则返回n和n-1的阶乘的乘积。 12const factorial = n =&gt; n &lt;=1 ? 1 : n * factorial(n - 1);// factorial(6) -&gt; 720 斐波那契数组生成器创建一个特定长度的空数组，初始化前两个值(0和1)。使用Array.reduce()向数组中添加值，后面的一个数等于前面两个数相加之和(前两个除外)。 123const fibonacci = n =&gt; Array(n).fill(0).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []);// fibonacci(5) -&gt; [0,1,1,2,3] 过滤数组中的非唯一值将Array.filter() 用于仅包含唯一值得数组。 12const filterNonUnique = arr =&gt; arr.filter(i =&gt; arr.indexOf(i) === arr.lastIndexOf(i));// filterNonUnique([1, 2, 3, 2, 4, 4, 5]) -&gt; [1, 3, 5] Flatten数组使用reduce()来获取数组中的所有元素，并使用concat()来使它们flatten。 12const flatten = arr =&gt; arr.reduce((a, v) =&gt; a.concat(v), []);// flatten([1,[2],3,4]) -&gt; [1,2,3,4] 从数组中获取最大值用Math.max()与spread运算符(…)结合得到数组中的最大值。 12const arrayMax = arr =&gt; Math.max(...arr);// arrayMax([10, 1, 5]) -&gt; 10 从数组中获取最小值使用Math.min()与spread运算符(…)结合得到数组中的最小值。 12const arrayMin = arr =&gt; Math.min(...arr);// arrayMin([10, 1, 5]) -&gt; 1 获取滚动位置如果已定义，请使用pageXOffset和pageYOffset，否则使用scrollLeft和scrollTop，可以省略el来使用window的默认值。 1234const getScrollPos = (el = window) =&gt; (&#123;x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft, y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop&#125;);// getScrollPos() -&gt; &#123;x: 0, y: 200&#125; 最大公约数(GCD)使用递归。基本情况是当y等于0时。在这种情况下，返回x。否则，返回y的GCD和x / y的其余部分。 12const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y);// gcd (8, 36) -&gt; 4 Head of list返回ARR[0] 12const head = arr =&gt; arr[0];// head([1,2,3]) -&gt; 1 list初始化返回arr.slice(0，-1) 12const initial = arr =&gt; arr.slice(0, -1);// initial([1,2,3]) -&gt; [1,2] 用range初始化数组使用Array(end-start)创建所需长度的数组，使用map()来填充范围内的所需值 123const initializeArrayRange = (end, start = 0) =&gt; Array.apply(null, Array(end - start)).map((v, i) =&gt; i + start);// initializeArrayRange(5) -&gt; [0,1,2,3,4] 用值初始化数组使用Array(n)创建所需长度的数组，fill(v)以填充所需的值，可以忽略value使用默认值0。 12const initializeArray = (n, value = 0) =&gt; Array(n).fill(value);// initializeArray(5, 2) -&gt; [2,2,2,2,2] 列表的最后返回arr.slice(-1)[0] 12const last = arr =&gt; arr.slice(-1)[0];// last([1,2,3]) -&gt; 3 测试功能所花费的时间使用performance.now()获取函数的开始和结束时间，console.log()所花费的时间。第一个参数是函数名，随后的参数传递给函数。 12345678const timeTaken = callback =&gt; &#123; console.time(&apos;timeTaken&apos;); const r = callback(); console.timeEnd(&apos;timeTaken&apos;); return r;&#125;;// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024// (logged): timeTaken: 0.02099609375ms 来自键值对的对象使用Array.reduce()来创建和组合键值对。 12const objectFromPairs = arr.reduce((a, v) =&gt; (a[v[0]] =v[1], a), &#123;&#125;);// objectFromPairs([[&apos;a&apos;,1],[&apos;b&apos;,2]]) -&gt; &#123;a: 1, b: 2&#125; 管道使用Array.reduce()通过函数传递值。 12const pipe = (...funcs) =&gt; arg =&gt; funcs.reduce((acc, func) =&gt; func(acc), arg);// pipe(btoa, x =&gt; x.toUpperCase())(&quot;Test&quot;) -&gt; &quot;VGVZDA==&quot; Powerset使用reduce()与map()结合来遍历元素，并将其组合成包含所有组合的数组。 12const powerset = arr =&gt; arr.reduce((a, v) =&gt; a.concat(a.map(r =&gt; [v].concat(r))), [[]]);// powerset([1,2]) -&gt; [[], [1], [2], [2,1]] 范围内的随机整数使用Math.random()生成一个随机数并将其映射到所需的范围，使用Math.floor()使其成为一个整数。 12const randomIntegerInRange = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min;// randomIntegerInRange(0, 5) -&gt; 2 范围内的随机数使用Math.random()生成一个随机值，使用乘法将其映射到所需的范围。 12const randomInRange = (min, max) =&gt; Math.random() * (max - min) + min;// randomInRange(2,10) -&gt; 6.0211363285087005 随机化数组的顺序使用sort()重新排序元素，使用Math.random()来随机排序。 12const shuffle = arr =&gt; arr.sort(() =&gt; Math.random() - 0.5);// shuffle([1,2,3]) -&gt; [2,3,1] 重定向到URL使用window.location.href或window.location.replace()重定向到url。传递第二个参数来模拟链接点击(true-default)或HTTP重定向(false)。 12const redirect = (url, asLink = true) =&gt; asLink ? window.location.href = url : window.location.replace(url);// redirect(&apos;https://google.com&apos;) 反转一个字符串使用数组解构和Array.reverse()来颠倒字符串中的字符顺序。合并字符以使用join(‘’)获取字符串。 12const reverseString = str =&gt; [...str].reverse().join(&apos;&apos;);// reverseString(&apos;foobar&apos;) -&gt; &apos;raboof&apos; RGB到十六进制使用按位左移运算符(&lt;&lt;)和toString(16)，然后padStart(6，“0”)将给定的RGB参数转换为十六进制字符串以获得6位十六进制值。 12const rgbToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, &apos;0&apos;);// rgbToHex(255, 165, 1) -&gt; &apos;ffa501&apos; 滚动到顶部使用document.documentElement.scrollTop或document.body.scrollTop获取到顶部的距离。从顶部滚动一小部分距离。 使用window.requestAnimationFrame()来滚动。 12345678const scrollToTop = _ =&gt; &#123;const c = document.documentElement.scrollTop || document.body.scrollTop; if (c &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, c - c / 8); &#125;&#125;;// scrollToTop() 随机数组值使用Array.map()和Math.random()创建一个随机值的数组。使用Array.sort()根据随机值对原始数组的元素进行排序。 12345const shuffle = arr =&gt; &#123;let r = arr.map(Math.random);return arr.sort((a,b) =&gt; r[a] - r[b]);&#125;// shuffle([1, 2, 3]) -&gt; [2, 1, 3] 数组之间的相似性使用filter()移除不是values的一部分值，使用includes()确定。 12const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v));// similarity([1,2,3], [1,2,4]) -&gt; [1,2] 按字符串排序(按字母顺序排序)使用split(‘’)分割字符串，sort()使用localeCompare()，使用join(‘’)重新组合。 12const sortCharactersInString = str =&gt; str.split(&apos;&apos;).sort((a, b) =&gt; a.localeCompare(b)).join(&apos;&apos;);// sortCharactersInString(&apos;cabbage&apos;) -&gt; &apos;aabbceg&apos; 数组总和使用reduce()将每个值添加到累加器，初始化值为0。 12const sum = arr =&gt; arr.reduce((acc, val) =&gt; acc + val, 0);// sum([1,2,3,4]) -&gt; 10 交换两个变量的值使用数组解构来交换两个变量之间的值。 12[varA, varB] = [varB, varA]// [x, y] = [y, x] 列表的tail返回arr.slice(1)。 123const tail = arr =&gt; arr.length &gt; 1 ? arr.slice(1) : arr;// tail([1,2,3]) -&gt; [2,3]// tail([1]) -&gt; [1] 数组唯一值使用ES6 Set和…rest操作符去掉所有重复值。 12const unique = arr =&gt; [...new Set(arr)];// unique([1, 2, 2, 3, 4, 4, 5]) -&gt; [1, 2, 3, 4, 5] URL参数使用match()与适当的正则表达式来获得所有键值对，适当的map()。使用Object.assign()和spread运算符(…)将所有键值对组合到一个对象中，将location.search()作为参数传递给当前url。 12const getUrlParameters = url =&gt; url.match(/([^?=&amp;]+)(=([^&amp;]*))/g).reduce((a, v) =&gt; (a[v.slice(0, v.indexOf(&apos;=&apos;))] = v.slice(v.indexOf(&apos;=&apos;) + 1), a), &#123;&#125;);// getUrlParameters(&apos;http://url.com/page?name=Adam&amp;surname=Smith&apos;) -&gt; &#123;name: &apos;Adam&apos;, surname: &apos;Smith&apos;&#125; UUID生成器使用crypto API生成符合RFC4122版本4的UUID。 12const uuid = _ =&gt; ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt; (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16));// uuid() -&gt; &apos;7982fcfe-5721-4632-bede-6000885be57d&apos; 验证数字使用！isNaN和parseFloat（）来检查参数是否是一个数字，使用isFinite（）来检查数字是否是有限的。 12const validateNumber = n =&gt; !isNaN(parseFloat(n)) &amp;&amp; isFinite(n) &amp;&amp; Number(n) == n;// validateNumber(&apos;10&apos;) -&gt; true","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"ES6-Airbnb JavaScript（ES6）代码规范","slug":"ES6-Airbnb JavaScript（ES6）代码规范","date":"2017-03-12T08:06:52.000Z","updated":"2018-11-15T12:39:23.826Z","comments":true,"path":"2017/03/12/ES6-Airbnb JavaScript（ES6）代码规范/","link":"","permalink":"http://yoursite.com/2017/03/12/ES6-Airbnb JavaScript（ES6）代码规范/","excerpt":"导语 本文摘自—Airbnb JavaScript（ES6）代码规范。","text":"导语 本文摘自—Airbnb JavaScript（ES6）代码规范。 声明变量的新姿势用let不用varES6之前我们使用var声明一个变量，但是它有很多弊病： 无块级作用域变量，很容易声明全局变量。 变量提升。 可重复声明。 12345678910var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10a[7](); // 10a[8](); // 10a[9](); // 10 所以，你有什么理由不用let? 某些场景，const比let更好const和let的唯一区别就是，const不可以被更改，所以当声明变量的时候，尤其是在声明容易被更改的全局变量的时候，尽量使用const。 更好的代码语义化，一眼看到就是常量。 另一个原因是因为JavaScript 编译器对const的优化要比let好，多使用const，有利于提高程序的运行效率。 所有的函数都应该设置为常量。 动态字符串不要使用“双引号”，一律用单引号或反引号。 12345678// lowconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// bestconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 解构赋值的骚操作变量赋值在用到数组成员对变量赋值时，尽量使用解构赋值。 12345678const arr = [1, 2, 3, 4];// lowconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数传对象函数的参数如果是对象的成员，优先使用解构赋值。 123456789// lowfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 1234567891011// lowfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 关于对象的细节逗号单行定义的对象结尾不要逗号： 12345// lowconst a = &#123; k1: v1, k2: v2, &#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;; 多行定义的对象要保留逗号：： 1234567891011// lowconst b = &#123; k1: v1, k2: v2&#125;;// goodconst b = &#123; k1: v1, k2: v2,&#125;; 一次性初始化完全不要声明之后又给对象添加新属性： 1234567// lowconst a = &#123;&#125;;a.x = 3;// goodconst a = &#123; x: null &#125;;a.x = 3; 如果一定非要加请使用Object.assign： 12const a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;); 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义： 12345678910111213/ lowconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,[getKey(&apos;enabled&apos;)]: true,&#125;; 在简洁一点1234567891011121314151617181920212223var ref = &apos;some value&apos;;// lowconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组扩展运算符…使用扩展运算符（…）拷贝数组： 1234567891011// 还在用for i 你就太low了const len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// cool !const itemsCopy = [...items]; Array.form（）用 Array.from 方法，将类似数组的对象转为数组： 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 函数箭头函数=&gt;立即执行函数可以写成箭头函数的形式： 123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 尽量写箭头函数使你的代码看起来简洁优雅： 1234567// low[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// cool ![1, 2, 3].map(x =&gt; x * x); 别再用arguments（类数组）了！使用 rest 运算符（…）代替，rest 运算符可以提供一个真正的数组。 12345678910// lowfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 传参时试试设置默认值123456789// lowfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Object？Map！简单的键值对优先Map如果只是简单的key: value结构，建议优先使用Map，因为Map提供方便的遍历机制。 12345678910111213let map = new Map(arr);// 遍历key值for (let key of map.keys()) &#123; console.log(key);&#125;// 遍历value值for (let value of map.values()) &#123; console.log(value);&#125;// 遍历key和value值for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; class语法123456789101112131415161718192021// lowfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 模块化引入模块使用import取代require，因为Module是Javascript模块的标准写法。 1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 输出模块使用export输出变量，拒绝module.exports: 123456789import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 输出单个值，使用export default。 输出多个值，使用export。 export default与普通的export不要同时使用。 编码规范模块输出一个函数，首字母应该小写： 1234function getData() &#123;&#125;export default getData;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]}]}